#include "SampleSearch.h"#include "Globals.h"extern FSSpec theApplSpec;extern long GhostsDirID;#define SFSaveDisk 	0x00000214#define CurDirStore 0x00000398void volumeSnapshot(void){short itemHit;				/** for dialog enquiry **/DialogPtr	myDlg;			/** for dialog enquiry **/Handle	iHndl;				/** for dialog enquiry **/Rect	iRect;				/** for dialog enquiry **/short	iType;				/** for dialog enquiry **/short z;MenuHandle	hRsrc;short catIndexNo;HFileParam	pb;Str255 theNameStr;OSErr	iErr;long	theCount= 4L;long	theFInfoCount;short iRefNum;StringHandle	hString[16];HVolumeParam	Fpb;Str255	theName,theTempVol;short wdRefNum;FInfoArrayPtr = 0;	snapFileLen = 0L;gogetvolref();hRsrc = GetMenu(1010);hRsrc = (MenuHandle)GetResource('MENU',1010);for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{		makeStr255 (volName[z], theTempVol);		doTheSlashAnalysis(theTempVol);		AppendMenu(hRsrc,theTempVol);		iErr = ResError();	}	myDlg = GetNewDialog(6015,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	ShowWindow(myDlg);	ModalDialog(xAlertFilter,&itemHit);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	iCtlValue = GetCtlValue((ControlHandle)iHndl);  	DisposDialog (myDlg);	iErr = OpenWD(theApplSpec.vRefNum,GhostsDirID,0,&wdRefNum);	*(Ptr)SFSaveDisk = wdRefNum;	if (itemHit == 1)		{			StandardPutFile("\pEnter Location and Name for Snapshot",volName[iCtlValue],&snapReply);			if (snapReply.sfGood)			{									ParamText(volName[iCtlValue],0,0,0);				myDlg = GetNewDialog(1800,0L,(WindowPtr)-1);					SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);				ShowWindow(myDlg);				ModalDialog(xAlertFilter,&itemHit);				if (itemHit == 2)					{						DisposDialog (myDlg);						return;					}				watchcursor(true);					if (snapReply.sfReplacing)					iErr = FSpDelete(&snapReply.sfFile);				iErr = FSpCreate(&snapReply.sfFile,'MgAl','SFlf',snapReply.sfScript);					if (iErr !=0)				{					genError("\pCould not create new file");				}				iErr = FSpOpenDF(&snapReply.sfFile,fsCurPerm,&snapRefNum);				if (iErr !=0)				{					genError("\pCould not open new file");				}				iErr = FSWrite(snapRefNum,&theCount,&snapFileLen);				if (iErr !=0)				{					genError("\pCould not write to new file");				}				Fpb.ioCompletion = 0;				Fpb.ioVolIndex = 0;				*theName = 0;				Fpb.ioNamePtr = theName;				Fpb.ioVRefNum = volumes[iCtlValue];				iErr = PBHGetVInfo((union HParamBlockRec *)&Fpb,false);				if (iErr !=0)				{					genError("\pCould not get info about volume");				}				//SetHandleSize(theFInfo,(Fpb.ioVFilCnt+5) * sizeof(FInfo));				iErr = MemError();				if (iErr !=0)					{							color.red = 56797;						color.green = 56797;						color.blue = 56797;						RGBBackColor(&color);						dAlert(1900,0);						iErr = FSClose(snapRefNum);						return;					}								FindAll( 2L, volumes[iCtlValue]);	/* 2 is dirID of root */								iErr = FSWrite(snapRefNum,&theCount,&FInfoArrayPtr);	/** write FInfo len (not data length - * 16) **/				if (iErr !=0)				{					genError("\pCould not write to new file");				}				theFInfoCount = FInfoArrayPtr*sizeof(FInfo);			 				iErr = FSWrite(snapRefNum,&theFInfoCount,*theFInfo);	/** write FInfo data **/				if (iErr !=0)				{					genError("\pCould not write to new file");				}				iErr = SetFPos(snapRefNum,1,0L);						iErr = FSWrite(snapRefNum,&theCount,&snapFileLen);		/** write FSSPEC len **/				if (iErr !=0)				{					genError("\pCould not write to new file");				}				iErr = FSClose(snapRefNum);								gogetvolref();				iRefNum = CurResFile();					HCreateResFile(snapReply.sfFile.vRefNum,snapReply.sfFile.parID,snapReply.sfFile.name);				iErr = ResError();				if (iErr !=0)				{					genError("\pCould not create new res fork");				}				snapRefNum = HOpenResFile(snapReply.sfFile.vRefNum,snapReply.sfFile.parID,snapReply.sfFile.name,fsCurPerm);				if (snapRefNum == -1)					genError("\pCould not open new fork");				UseResFile(snapRefNum);				iErr = ResError();				if (iErr !=0)				{					genError("\pCould not use new res fork");				}				for (z=1;z<=volumearrayptr;z++)				{				//z = -(snapReply.sfFile.vRefNum);					hString[z] = (StringHandle)NewHandle(256);					HLock ((Handle)hString[z]);					BlockMove(volName[z],*hString[z],28L);					AddResource((Handle)hString[z],'oVOL',z,"\pVolume Name for list");					iErr = ResError();					if (iErr !=0)					{						genError("\pCould not add new oVOL resource");					}					HUnlock ((Handle)hString[z]);				}				CloseResFile(snapRefNum);				DisposDialog (myDlg);				UseResFile(iRefNum);				iErr = ResError();				if (iErr !=0)				{					genError("\pCould not use new old fork");				}				watchcursor(false);			}					}		else		{		}return;}void FindAll( long dirID, short passVol){/*	Recursive procedure: Examine each entry in directory dirID	If it is a directory, recurse; otherwise, call DoIt()	The dirName parm is the C-style accumulated full path; used for display only.*/	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	Str255	dirFullName;	long myDrDir;			fpb->ioVRefNum = passVol;		/* default volume */	fpb->ioNamePtr = zfilename;	/* buffer to receive name */	for( idx=1; TRUE; idx++) 	{	/* indexing loop */		fpb->ioDirID = dirID;		/* must set on each loop */		myDrDir = dirID;		fpb->ioFDirIndex = idx;			rc = PBGetCatInfo( &cipbr, FALSE );		if (rc) break;	/* exit when no more entries */		PtoCstr( zfilename );		/* make ASCIIZ for printf() */		if (fpb->ioFlAttrib & 16) 		{			/** i.e it is a folder **/			FindAll( dpb->ioDrDirID, passVol);/* recursive call */		}		else 		{			DoIt( (HFileInfo *)&cipbr,myDrDir );		}	}}void DoIt( HFileInfo	*pb, long myDrDir){	long	flen;	OSErr	iErr;	long	theCount = 70L;	FSSpec	tempSpec;	FInfo	*locInfo;			HLock((Handle)theFInfo);	locInfo = (*theFInfo) + FInfoArrayPtr;		/** now this I don't understand - something to do with the casting **/	iErr = FSMakeFSSpec(pb->ioVRefNum,myDrDir,CtoPstr((Ptr)pb->ioNamePtr),&tempSpec);	//iErr = GetFInfo(tempSpec.name,tempSpec.vRefNum,theFInfo[FInfoArrayPtr]);	iErr = HGetFInfo(tempSpec.vRefNum,tempSpec.parID,tempSpec.name,locInfo);	iErr = FSWrite(snapRefNum,&theCount,&tempSpec);	FInfoArrayPtr++;	snapFileLen += 70L;	HUnlock((Handle)theFInfo);}