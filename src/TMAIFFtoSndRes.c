typedef SignedByte SInt8;typedef Byte UInt8;#include <AIFF.h>#include <Sound.h>#include <SoundComponents.h>#include <SoundInput.h>#include <FixMath.h>#include <stdio.h>#include <math.h>//#include "fp.h"//#include <Sound.h>#include <Resources.h>#include <Types.h>SndChannelPtr CreateSndChannel(Boolean Stereo);typedef struct	{	FSSpec file;	SoundComponentData info;	unsigned long numFrames;	unsigned long dataOffset;	Ptr buffer;	} SoundFileInfo;typedef struct	{	FSSpec file;	SoundComponentData info;	unsigned long inputBufferFrames;	unsigned long inputBufferBytes;	unsigned long outputBytes;	Ptr buffer;	} SoundConvertInfo;	#define kSoundComplete 1 #define kWaitIfFull TRUE	// wait for room in queue#define kSoundComplete  1	// last command in channel;  Application definedextern Boolean autoSustain;extern long dblBufferSize;extern Boolean gCallBackPerformed;  long findCOMM2(short localRefNum, OSType);SndChannelPtr CreateSndChannel(Boolean Stereo);short isPressed(unsigned short k );OSErr InstallCallBack(SndChannelPtr);pascal void SampleCallBack(SndChannelPtr,SndCommand);Boolean pleaseStop(void);extern long theTXFERLong;extern 	SndChannelPtr mySndChan;void AIFFtoSnd(FSSpec mySpec,short playFreq);void AIFFtoSnd(FSSpec mySpec,short playFreq){	OSErr	iErr;	ExtSoundHeader      sound;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	double_t samplesPerSec;	float myFloat;	short refNum;		SCStatus theStatus;	long z;	SoundFileInfo xFileInfo;	long filePos;	Fixed f;	CommonChunk	myCommCnk;	long audiosize,AOffset,thePlaySize;	Fixed	sampleRate;	OSErr sndErr;	EventRecord theEvent;	long bytesRead = 0;	gCallBackPerformed = true;	useTwo = 0;	dblBufferSize = 32768L;	 autoSustain = true;		iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)	{		SysBeep(5);				return;	}	ParseAIFFHeader(refNum, &xFileInfo.info, &xFileInfo.numFrames, &xFileInfo.dataOffset);	iErr = SetFPos(refNum,1,0);/*********/	filePos = findCOMM2(refNum,'COMM');	if (!filePos)	{		//genError ("\pCan't find common chunk");		iErr = FSClose(refNum);		if (iErr!=0)		//genErrorN("\pError closing DF",iErr);		return;	}	inOutCount = sizeof (CommonChunk);	iErr = SetFPos(refNum,1,filePos);	iErr = FSRead(refNum,&inOutCount,&myCommCnk);	if (iErr!=0)	{		//genError ("\pCan't read comm chunk from file");		iErr = FSClose(refNum);		return;	}		iErr = SetFPos(refNum,1,0L);		filePos = findCOMM2(refNum,'SSND');	if (!filePos)	{		//genError ("\pCan't find SSND chunk");		iErr = FSClose(refNum);		return;	}		filePos += 4L;	inOutCount = 4L;	iErr = SetFPos(refNum,1,filePos);	iErr = FSRead(refNum,&inOutCount,&audiosize);	if (iErr!=0)	{		//genError ("\pCan't read audio size from file");		iErr = FSClose(refNum);		return;	}		iErr = FSRead(refNum,&inOutCount,&AOffset);	if (iErr!=0)	{		//genError ("\pCan't read AOffset from file");		iErr = FSClose(refNum);		return;	}		filePos += 4L;	iErr = SetFPos(refNum,1,filePos);	//	watchcursor(true);		stereo = (myCommCnk.numChannels == 2);	theWordSize = myCommCnk.sampleSize >> 3;		/*myFloat = (float)myCommCnk.sampleRate.man;	sampleRate = myLong;*/					f = xFileInfo.info.sampleRate & 0x80000000L;		/*if ( xFileInfo.info.numChannels >= 2 )				strcpy( stereoString, "stereo" );	else		strcpy( stereoString, "mono" );*/			samplesPerSec = Fix2X( xFileInfo.info.sampleRate & 0x7fffffffL );	/* unsigned Fixed value*/	if ( f )		samplesPerSec += 32768.0;				sampleRate = samplesPerSec;						thePlaySize = audiosize;/*********/		mySndH[0] = NewPtr(dblBufferSize);	if (!mySndH[0])	{		//genErrorN("\pError making new handle",0);		FSClose (refNum);		return;	}		mySndH[1] = NewPtr(dblBufferSize);	if (!mySndH[1])	{		//genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		FSClose (refNum);		return;	}				inOutCount = (thePlaySize > dblBufferSize) ? dblBufferSize : thePlaySize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	bytesRead += inOutCount;	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}		thePlaySize -= inOutCount;		if (theWordSize ==1)	{		for (z = (long)mySndH[useTwo]; z< (long)mySndH[useTwo]+inOutCount;z++)		{			*((Byte *)z) += 128;		}	}			mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = sampleRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = inOutCount >> (stereo) >> (theWordSize - 1);      /*samples, not bytes*/		sound.AIFFSampleRate = myCommCnk.sampleRate;	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    sndErr = SndDoImmediate(mySndChan,&cmd);	    		gCallBackPerformed = false;		sndErr = InstallCallBack (mySndChan);			if (iErr == eofErr || (inOutCount < dblBufferSize))	{		while (gCallBackPerformed == false)		{			if(pleaseStop()) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = (thePlaySize > dblBufferSize) ? dblBufferSize : thePlaySize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		bytesRead += inOutCount;		if  (iErr != eofErr && iErr)		{						iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}		thePlaySize -= inOutCount;		if (theWordSize ==1)		{			for (z = (long)mySndH[!useTwo]; z<(long)mySndH[!useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}	}	while (!stoppit)	{			//SetStatusPercentage( LoWord((long)bytesRead * 100L / (long)theBytes));		    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = sampleRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	   sound.AIFFSampleRate = myCommCnk.sampleRate;	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    sndErr = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			if(pleaseStop() ) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		gCallBackPerformed = false;		if (!stoppit)			sndErr = InstallCallBack (mySndChan);					if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = (thePlaySize > dblBufferSize) ? dblBufferSize : thePlaySize;				iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			bytesRead += inOutCount;			if  (iErr != eofErr && iErr)			{								iErr = SndDisposeChannel(mySndChan,true);				DisposPtr((Ptr)mySndChan);				DisposPtr(mySndH[0]);				DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}			thePlaySize -= inOutCount;			if (theWordSize ==1)			{				for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}			if ((iErr == eofErr) || (inOutCount < dblBufferSize))			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  				   if ((iErr != eofErr) && (inOutCount == dblBufferSize))	   {		   	cmd.cmd = flushCmd;		    cmd.param2 = 0;		    sndErr = SndDoImmediate(mySndChan,&cmd);		    cmd.cmd = quietCmd;		    cmd.param2 = 0;		    sndErr = SndDoImmediate(mySndChan,&cmd);	   }	   	   iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);		while (theStat.scChannelBusy && !(pleaseStop()))		{			iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);		}		iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);	/* maybe shut it up */	FSClose(refNum);	DisposPtr(mySndH[0]);	DisposPtr(mySndH[1]);		/*if (arrowPressed)	{		switch (arrowPressed)		{			case kUpArrowPressed:				PostEvent(keyDown,0x00027E1E);				PostEvent(keyDown,0x00023120);			break;			case kDownArrowPressed:				PostEvent(keyDown,0x00027D1F);				PostEvent(keyDown,0x00023120);			break;			case kLeftArrowPressed:				PostEvent(keyDown,0x00027B1C);				PostEvent(keyDown,0x00023120);			break;			case kRightArrowPressed:				PostEvent(keyDown,0x00027C1D);				PostEvent(keyDown,0x00023120);			break;		}	}*/	//GetNextEvent(everyEvent,&theEvent);	return;}long findCOMM2(short localRefNum, OSType	theType){	OSErr	iErr;	Handle	myTempStore;	long inOutCount;	long lOffset;	OSType	filpType = theType;	long	soFar = 0;	myTempStore = NewHandle(2000);	if (!myTempStore)	{		theTXFERLong = 0;		return 0;	}	iErr = SetFPos(localRefNum,1,0L);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}		inOutCount = 1900L;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			theTXFERLong = 0;			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			theTXFERLong = (soFar + lOffset);			return (soFar + lOffset);		}		iErr = SetFPos(localRefNum,2,-1900L);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}	iErr = GetFPos(localRefNum,&soFar);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}			inOutCount = 1900L;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			theTXFERLong = 0;			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			theTXFERLong = (soFar + lOffset);			return (soFar + lOffset);		}		iErr = SetFPos(localRefNum,1,1900L);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}			soFar =1900L;		while (iErr != eofErr)	{		inOutCount = 1900L;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			theTXFERLong = 0;				DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			theTXFERLong = (soFar + lOffset);			return (soFar + lOffset);		}		soFar +=1900L;	}	DisposHandle(myTempStore);	theTXFERLong = 0;	return 0;}