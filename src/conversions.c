typedef SignedByte SInt8;typedef Byte UInt8;#include "conversions.h"void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);//void Rotatecursor(short seting);OSErr fillInConvRec (ConversionRec * myCR, UnsignedFixed SRin, UnsignedFixed SRout, Boolean doSR, short BITSin, short BITSout, Boolean doBITS, short CHANSin, short CHANSout, Boolean doCHANS){		myCR->sourceComponent.sampleRate = SRin;	if (doSR)		myCR->destComponent.sampleRate = SRout;	else		myCR->destComponent.sampleRate = SRin;				myCR->sourceComponent.sampleSize = BITSin;	if (doBITS)		myCR->destComponent.sampleSize = BITSout;	else		myCR->destComponent.sampleSize = BITSin;					myCR->sourceComponent.numChannels = CHANSin;	if (doCHANS)		myCR->destComponent.numChannels = CHANSout;	else		myCR->destComponent.numChannels = CHANSin;			myCR->sourceComponent.flags = 0;	myCR->sourceComponent.format = 'twos';	myCR->sourceComponent.sampleCount = 0;	myCR->sourceComponent.reserved = 0;			myCR->destComponent.flags = 0;	myCR->destComponent.format = 'twos';	myCR->destComponent.sampleCount = 0; 	myCR->destComponent.reserved = 0;	return noErr;}Boolean SRgetStarted (UnsignedFixed SRin, UnsignedFixed SRout, Boolean doSR, short BITSin, short BITSout, Boolean doBITS, short CHANSin, short CHANSout, Boolean doCHANS);Boolean SRprocessBuffer(void);Boolean SRstopIt(void);extern Ptr splitBufferL, splitBufferR;OSErr prepareRawConversion (ConversionRec  * myCR){	OSErr iErr;		iErr = SoundConverterOpen( &myCR->sourceComponent, &myCR->destComponent, &myCR->theSC);	if (iErr)		return iErr;		iErr = SoundConverterGetBufferSizes(myCR->theSC,  MaxBlock() * 0.2 ,&myCR->inputBufferFrames,&myCR->inputBufferBytes,&myCR->outputBytes);	if (iErr)	{		SoundConverterClose(myCR->theSC);		return iErr;	}		myCR->sourceComponent.buffer = (unsigned char *)NewPtr(myCR->inputBufferBytes);	iErr = MemError();	if ( iErr )	{		SoundConverterClose(myCR->theSC);		return iErr;	}			myCR->destComponent.buffer = (unsigned char *)NewPtr(myCR->outputBytes);	iErr = MemError();	if ( iErr )	{		DisposPtr ((Ptr)myCR->sourceComponent.buffer);		SoundConverterClose(myCR->theSC);		return iErr;	}		if (myCR->outputBytes > myCR->inputBufferBytes)	{		splitBufferL = NewPtrClear(myCR->outputBytes >> 1);		iErr = MemError();		if ( iErr )		{			SoundConverterClose(myCR->theSC);			return iErr;		}				splitBufferR = NewPtrClear(myCR->outputBytes >> 1);		iErr = MemError();		if ( iErr )		{			SoundConverterClose(myCR->theSC);			return iErr;		}		}	else	{		splitBufferL = NewPtrClear(myCR->inputBufferBytes >> 1);		iErr = MemError();		if ( iErr )		{			SoundConverterClose(myCR->theSC);			return iErr;		}				splitBufferR = NewPtrClear(myCR->inputBufferBytes >> 1);		iErr = MemError();		if ( iErr )		{			SoundConverterClose(myCR->theSC);			return iErr;		}			}					return 0;}OSErr endRawConversion (ConversionRec * myCR){	DisposPtr ((Ptr)myCR->sourceComponent.buffer);	DisposPtr ((Ptr)myCR->destComponent.buffer);	DisposPtr ((Ptr)splitBufferL);	DisposPtr ((Ptr)splitBufferR);	SoundConverterClose(myCR->theSC);	return noErr;}OSErr convertBuffer (ConversionRec * myCR){	unsigned long additionalOutputFrames;	unsigned long additionalOutputSize;	OSErr iErr;		myCR->sourceComponent.sampleCount = myCR->sourceFrames;	myCR->destComponent.sampleCount = 0;		SoundConverterBeginConversion(myCR->theSC);	iErr = SoundConverterConvertBuffer(myCR->theSC,					myCR->sourceComponent.buffer,					myCR->sourceFrames,					myCR->destComponent.buffer,					&myCR->destFrames,					&myCR->destBytes);		iErr = SoundConverterEndConversion( myCR->theSC, myCR->destComponent.buffer,			&additionalOutputFrames, &additionalOutputSize );	//Rotatecursor(1);	myCR->destFrames += additionalOutputFrames;	myCR->destBytes+= additionalOutputSize;		return iErr;}ConversionRec  zCR;Ptr inBuffer;Ptr outBuffer;Ptr procBufferL;Ptr procBufferR;long inputSize, outSize;long sourceBytes;Boolean convStereo;Boolean sixteenBit;long srater;Boolean SRgetStarted (UnsignedFixed SRin, UnsignedFixed SRout, Boolean doSR, short BITSin, short BITSout, Boolean doBITS, short CHANSin, short CHANSout, Boolean doCHANS){	if (fillInConvRec (&zCR, SRin, SRout, doSR, BITSin, BITSout, doBITS, CHANSin, CHANSout, doCHANS))	{		return 1;	}	if (prepareRawConversion (&zCR))	{		return 1;	}	convStereo = (CHANSin == 2);	sixteenBit = (BITSin == 16);	srater = ((SRin >> 16) & 0x0000FFFF);		inBuffer = (char *)zCR.sourceComponent.buffer;	outBuffer = (char *)zCR.destComponent.buffer;	procBufferL = splitBufferL;	procBufferR = splitBufferR;		inputSize = zCR.inputBufferBytes;	outSize = 0L;		return 0;}Boolean SRprocessBuffer(void){	OSErr iErr;		zCR.sourceBytes = sourceBytes;	zCR.sourceFrames = sourceBytes >> convStereo >> sixteenBit;	zCR.sourceDataOffset = 0;	zCR.destDataOffset = 0;	zCR.convertError = 0;	iErr = convertBuffer(&zCR);	outSize = zCR.destBytes;		return iErr;}Boolean SRstopIt(void){	return (endRawConversion (&zCR));}