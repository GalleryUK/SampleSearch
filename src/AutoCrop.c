Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);Boolean GetFSSpecComment(FSSpec mySpec, StringPtr theComment);Boolean SetFSSpecComment(FSSpec mySpec, Str255 theComment);#include <stdio.h>#include <string.h>#include "SampleSearch.h"#include "Globals.h"#include <SoundInput.h>#include <Sound.h>#include <Folders.h>#define regionReturned		0#define SDIIFormat 1#define AIFFFormat 2#define wavFormat 3#include "prefs.h"extern newPrefsRec theNewPrefs;#include "structToRez.h"void getConvertDest(void);Boolean translateParentToChildFolder(FSSpec *mySpec);Boolean addFileToList(FSSpec mySpec);typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);Boolean GetFSComment(FSSpec mySpec, Str255 theComment);Boolean	YesNo (Str255	myText);Boolean SetFSComment (FSSpec mySpec, StringPtr theComment);typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;short theDivTime = 1;Boolean preserveRegions;long theSpace;RegionRec	currentRegion;short regionCounter = 0;Handle	regionsHandle;	Handle	tempBuff;		Handle hNew;			ddRLHeader myRegHeader;				unsigned long secs;short deleteAutoCropSetting(void);				FSSpec prefsSpex[50];	short numPrefsFiles = 0;OSErr getNewAutoCropSetName(StringPtr theName);		Boolean QCompositeSDIIDialog(void);Boolean QCompositeSDIIDialog(void){		Cell theCell;	short theindex;		short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 theSpaceStr;	StandardFileReply reply;	short refNum, sourceRef,iRefNum, destRef,index;	OSErr 	iErr,eErr,eErrNext;	long filePos;	Str255 rate,numBits,StereoMono,tempStr;	StringHandle h1,h2,h3;		myDlg = GetNewDialog(12312,0L,(WindowPtr)-1);	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)(ControlHandle)iHndl,true);	ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)(ControlHandle)iHndl));			break;						case 12:				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						default:						break;		}	}	if (itemHit == 2)	{		theNewPrefs.theCropSpec.compositeFiles = false;		DisposDialog(myDlg);		return false;	}	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	preserveRegions = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	GetIText(iHndl,theSpaceStr);	GetDItem(myDlg,12,&iType,&iHndl,&iRect);	theNewPrefs.theCropSpec.deleteCompCopies = GetCtlValue((ControlHandle)iHndl);	StringToNum(theSpaceStr,&theSpace);	theNewPrefs.theCropSpec.silencePeriod = theSpace;	/*9,10,11 stero, rate, bits*/		GetDItem(myDlg,9,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p1",StereoMono);			theNewPrefs.theCropSpec.theCompStereo = false;		break;				case 2:			makeStr255("\p2",StereoMono);			theDivTime = 2;			theNewPrefs.theCropSpec.theCompStereo = true;		break;	}	GetDItem(myDlg,10,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p44100.0000",rate);			theNewPrefs.theCropSpec.theCompRate = 44100L;		break;				case 2:			makeStr255("\p48000.0000",rate);			theNewPrefs.theCropSpec.theCompRate = 48000L;		break;				case 3:			makeStr255("\p32000.0000",rate);			theNewPrefs.theCropSpec.theCompRate = 32000L;		break;	}		GetDItem(myDlg,11,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p2",numBits);			theDivTime *= 2;			theNewPrefs.theCropSpec.theCompBits = 2;		break;				case 2:			makeStr255("\p1",numBits);			theNewPrefs.theCropSpec.theCompBits = 1;		break;	}		DisposDialog(myDlg);			return true;}extern Boolean autoCrop;Boolean CompositeSDIIDialog(void);extern FSSpec theConvertDestLoc;Boolean autoCropSDII(FSSpec mySpec, cropSpec theCropSpec);void autoCropMany(void);void autoCropMany(void){	Cell theCell;	cropSpec tempCropSpec;	short theindex;	OSErr	iErr;	FInfo fndrInfo;	short itemHit,iCtlVal,iCtlPart,iItemCnt,z;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 theText, tempStr;	long theTextConv;	Point localPt;	GrafPtr savePort;	long tempLong;	short TTnoiseFloor;	StandardFileReply myReply;	Str255 textStr;	short refNum, sourceRef,iRefNum, destRef,theItem;	MenuHandle prefsMenu,prefsPopMenu;	long inOutCount,theDivider;	CInfoPBRec		xCPB;	HFileInfo		*myxCPB = (HFileInfo *)&xCPB;	FSSpec settingsFolder,tempspec;	long createdDirID,foundDirID;	short foundVRefNum,index;		GetPort(&savePort);		iErr = FindFolder(kOnSystemDisk,'pref',true,&foundVRefNum,&foundDirID);	if (iErr)	{		genError("\pCant find prefs folder");	}		iErr = FSMakeFSSpec(foundVRefNum,foundDirID,"\pSSearch AutoCropª Settings",&settingsFolder);	if (iErr == -43)	{		iErr = DirCreate(foundVRefNum,foundDirID,"\pSSearch AutoCropª Settings",&createdDirID);		settingsFolder.parID = createdDirID;	}	else	{		translateParentToChildFolder(&settingsFolder);		createdDirID = settingsFolder.parID;	}		numPrefsFiles = 0;	//prefsPopMenu = GetMenu(156);	prefsMenu = GetMenu(2224);		//InsertMenu(prefsPopMenu, -1);	InsertMenu(prefsMenu, -1);	iErr = 0;	index = 1;	do	{		myxCPB->ioVRefNum = settingsFolder.vRefNum;		myxCPB->ioFDirIndex = index;			myxCPB->ioDirID = createdDirID;		*tempStr = 0;		myxCPB->ioNamePtr = tempStr;		iErr = PBGetCatInfo((CInfoPBPtr)myxCPB, false);				if(iErr == noErr) 		{			iErr = FSMakeFSSpec(myxCPB->ioVRefNum,createdDirID,myxCPB->ioNamePtr,&tempspec);			iErr = FSpGetFInfo(&tempspec,&fndrInfo);			if(fndrInfo.fdType == 'cRoP')			{				prefsSpex[numPrefsFiles] = tempspec;				++numPrefsFiles;				AppendMenu(prefsMenu,tempspec.name);			}		}		index += 1;	} while(iErr == noErr && numPrefsFiles < 49);	/* set up the next one ready */	iErr = FSMakeFSSpec(myxCPB->ioVRefNum,createdDirID,"\pX",&prefsSpex[numPrefsFiles]);		myDlg = GetNewDialog(1988,0L,(WindowPtr)-1);	if (!myDlg)	{		genError ("\pCouldn't get dialog");		return;	}	SetPort (myDlg);		/*******/		GetDItem(myDlg,7,&iType,&iHndl,&iRect);		NumToString((long)theNewPrefs.theCropSpec.noiseFloor,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,6,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,LoWord(theNewPrefs.theCropSpec.noiseFloor));			GetDItem(myDlg,32,&iType,&iHndl,&iRect);		NumToString((long)theNewPrefs.theCropSpec.noiseFloorOut,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,31,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,LoWord(theNewPrefs.theCropSpec.noiseFloorOut));	GetDItem(myDlg,9,&iType,&iHndl,&iRect);		NumToString ((long)theNewPrefs.theCropSpec.preRoll,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,8,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.doPre);		GetDItem(myDlg,12,&iType,&iHndl,&iRect);		NumToString ((long)theNewPrefs.theCropSpec.postRoll,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,11,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.doPost);			GetDItem(myDlg,21,&iType,&iHndl,&iRect);		NumToString ((long)theNewPrefs.theCropSpec.addSilenceStart,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,20,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.doAddSilenceStart);			GetDItem(myDlg,24,&iType,&iHndl,&iRect);		NumToString ((long)theNewPrefs.theCropSpec.addSilenceEnd,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,23,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.doAddSilenceEnd);		GetDItem(myDlg,15,&iType,&iHndl,&iRect);		NumToString ((long)theNewPrefs.theCropSpec.fadeInTime,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,14,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.doFadeStart);		GetDItem(myDlg,18,&iType,&iHndl,&iRect);		NumToString ((long)theNewPrefs.theCropSpec.fadeOutTime,theText);	SetIText(iHndl,theText);		GetDItem(myDlg,17,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.doFadeEnd);		GetDItem(myDlg,26,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.rewriteOriginal);	GetDItem(myDlg,27,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theCropSpec.compositeFiles);		/********/		color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		ShowWindow(myDlg);		itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 6: case 31:				GetMouse(&localPt);				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);				iCtlPart = TestControl((ControlHandle)iHndl,localPt);				switch (iCtlPart)				{					case inUpButton:						GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);						iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<0) ? 0 : iCtlVal;					break;										case inDownButton:						GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>100) ? 100 : iCtlVal;					break;										case inPageUp:						GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<0) ? 0 : iCtlVal;											break;										case inPageDown:						GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>100) ? 100 : iCtlVal;					break;										default:					break;				}				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);				iCtlVal = GetCtlValue((ControlHandle)iHndl);				NumToString((long)iCtlVal,theText);				GetDItem(myDlg,itemHit+1,&iType,&iHndl,&iRect);				SetIText(iHndl,theText);			break;						case 7:case 32:				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);				GetIText(iHndl,theText);				StringToNum(theText,&tempLong);				iCtlVal = LoWord(tempLong);				GetDItem(myDlg,itemHit-1,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,iCtlVal);			break;							case  8:case 11: case 14: case 17: case 20: case 23:				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case  26:				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case  27:				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));				if (!QCompositeSDIIDialog())				{					GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);						SetCtlValue((ControlHandle)iHndl,false);				}			break;									case 29:				GetDItem(myDlg,29,&iType,&iHndl,&iRect);					iCtlValue = GetCtlValue((ControlHandle)iHndl);								switch (iCtlValue)				{					case 1:						/* do nothing */					break;										case 2:						/* save setting */						GetDItem(myDlg,7,&iType,&iHndl,&iRect);							GetIText(iHndl,theText);						StringToNum(theText,&theTextConv);						tempCropSpec.noiseFloor = theTextConv;												GetDItem(myDlg,32,&iType,&iHndl,&iRect);							GetIText(iHndl,theText);						StringToNum(theText,&theTextConv);						tempCropSpec.noiseFloorOut = theTextConv;						GetDItem(myDlg,9,&iType,&iHndl,&iRect);							GetIText(iHndl,textStr);						StringToNum(textStr,&tempCropSpec.preRoll);												GetDItem(myDlg,12,&iType,&iHndl,&iRect);							GetIText(iHndl,textStr);						StringToNum(textStr,&tempCropSpec.postRoll);												GetDItem(myDlg,15,&iType,&iHndl,&iRect);							GetIText(iHndl,textStr);						StringToNum(textStr,&tempCropSpec.fadeInTime);								GetDItem(myDlg,18,&iType,&iHndl,&iRect);							GetIText(iHndl,textStr);						StringToNum(textStr,&tempCropSpec.fadeOutTime);												GetDItem(myDlg,21,&iType,&iHndl,&iRect);						GetIText(iHndl,textStr);							StringToNum(textStr,&tempCropSpec.addSilenceStart);												GetDItem(myDlg,24,&iType,&iHndl,&iRect);							GetIText(iHndl,textStr);						StringToNum(textStr,&tempCropSpec.addSilenceEnd);											GetDItem(myDlg,26,&iType,&iHndl,&iRect);							tempCropSpec.rewriteOriginal = GetCtlValue((ControlHandle)iHndl);												GetDItem(myDlg,8,&iType,&iHndl,&iRect);							tempCropSpec.doPre = GetCtlValue((ControlHandle)iHndl);												GetDItem(myDlg,11,&iType,&iHndl,&iRect);							tempCropSpec.doPost = GetCtlValue((ControlHandle)iHndl);												GetDItem(myDlg,20,&iType,&iHndl,&iRect);							tempCropSpec.doAddSilenceStart = GetCtlValue((ControlHandle)iHndl);												GetDItem(myDlg,23,&iType,&iHndl,&iRect);							tempCropSpec.doAddSilenceEnd = GetCtlValue((ControlHandle)iHndl);											GetDItem(myDlg,14,&iType,&iHndl,&iRect);							tempCropSpec.doFadeStart = GetCtlValue((ControlHandle)iHndl);												GetDItem(myDlg,17,&iType,&iHndl,&iRect);							tempCropSpec.doFadeEnd = GetCtlValue((ControlHandle)iHndl);										/* make the file */						iErr = FSMakeFSSpec(myxCPB->ioVRefNum,createdDirID,"\pX",&prefsSpex[numPrefsFiles]);						if (!getNewAutoCropSetName(prefsSpex[numPrefsFiles].name))						{							/* get the name */							saveStructureAsResource(prefsSpex[numPrefsFiles],(Ptr)&tempCropSpec,sizeof(cropSpec),'cRoP',1000, true,'cRoP');							AppendMenu(prefsMenu,prefsSpex[numPrefsFiles].name); 														GetDItem(myDlg,29,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,1);							numPrefsFiles++;							/* reset the menu to point to this one */						}					break;										case 3:						/* delete setting */						/* unmake the menu */												theItem = deleteAutoCropSetting();						if (theItem > 0)						{							//DelMenuItem(prefsMenu,theItem + 4);						}												iItemCnt = CountMItems(prefsMenu);						for (z=5;z<=iItemCnt;z++)						{							DelMenuItem(prefsMenu,5);						}												numPrefsFiles = 0;											iErr = 0;						index = 1;						do						{							myxCPB->ioVRefNum = settingsFolder.vRefNum;							myxCPB->ioFDirIndex = index;								myxCPB->ioDirID = createdDirID;							*tempStr = 0;							myxCPB->ioNamePtr = tempStr;							iErr = PBGetCatInfo((CInfoPBPtr)myxCPB, false);														if(iErr == noErr) 							{								iErr = FSMakeFSSpec(myxCPB->ioVRefNum,createdDirID,myxCPB->ioNamePtr,&tempspec);								iErr = FSpGetFInfo(&tempspec,&fndrInfo);								if(fndrInfo.fdType == 'cRoP')								{									prefsSpex[numPrefsFiles] = tempspec;									++numPrefsFiles;									AppendMenu(prefsMenu,tempspec.name);								}							}							index += 1;						} while(iErr == noErr && numPrefsFiles < 49);											/* set up the next one ready */						iErr = FSMakeFSSpec(myxCPB->ioVRefNum,createdDirID,"\pX",&prefsSpex[numPrefsFiles]);							GetDItem(myDlg,29,&iType,&iHndl,&iRect);						SetCtlValue((ControlHandle)iHndl,1);						/* remake it */										break;										default:						/* load setting */						if (loadStructureFromResource(prefsSpex[iCtlValue - 5],(Ptr)&tempCropSpec,sizeof(cropSpec),'cRoP',1000))						{							break;						}													GetDItem(myDlg,7,&iType,&iHndl,&iRect);							NumToString((long)tempCropSpec.noiseFloor,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,32,&iType,&iHndl,&iRect);							NumToString((long)tempCropSpec.noiseFloorOut,theText);						SetIText(iHndl,theText);						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,LoWord(tempCropSpec.noiseFloor));												GetDItem(myDlg,9,&iType,&iHndl,&iRect);							NumToString ((long)tempCropSpec.preRoll,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,8,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.doPre);												GetDItem(myDlg,12,&iType,&iHndl,&iRect);							NumToString ((long)tempCropSpec.postRoll,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,11,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.doPost);																		GetDItem(myDlg,21,&iType,&iHndl,&iRect);							NumToString ((long)tempCropSpec.addSilenceStart,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,20,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.doAddSilenceStart);																		GetDItem(myDlg,24,&iType,&iHndl,&iRect);							NumToString ((long)tempCropSpec.addSilenceEnd,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,23,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.doAddSilenceEnd);												GetDItem(myDlg,15,&iType,&iHndl,&iRect);							NumToString ((long)tempCropSpec.fadeInTime,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,14,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.doFadeStart);												GetDItem(myDlg,18,&iType,&iHndl,&iRect);							NumToString ((long)tempCropSpec.fadeOutTime,theText);						SetIText(iHndl,theText);												GetDItem(myDlg,17,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.doFadeEnd);												GetDItem(myDlg,26,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.rewriteOriginal);						GetDItem(myDlg,27,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,tempCropSpec.compositeFiles);					break;					}			break;									case 9: case 12: case 15: case 18: case 21: case 24:				GetDItem(myDlg,itemHit-1,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,true);			break;						case 1:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);					GetIText(iHndl,theText);				StringToNum(theText,&theTextConv);				theNewPrefs.theCropSpec.noiseFloor = theTextConv;								GetDItem(myDlg,32,&iType,&iHndl,&iRect);					GetIText(iHndl,theText);				StringToNum(theText,&theTextConv);				theNewPrefs.theCropSpec.noiseFloorOut = theTextConv;				GetDItem(myDlg,9,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);				GetDItem(myDlg,8,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					StringToNum(textStr,&theNewPrefs.theCropSpec.preRoll);				}				else				{					theNewPrefs.theCropSpec.preRoll = 0L;				}								GetDItem(myDlg,12,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);				GetDItem(myDlg,11,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					StringToNum(textStr,&theNewPrefs.theCropSpec.postRoll);				}								else				{					theNewPrefs.theCropSpec.postRoll = 0L;				}				GetDItem(myDlg,15,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);				GetDItem(myDlg,14,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					StringToNum(textStr,&theNewPrefs.theCropSpec.fadeInTime);				}				else				{					theNewPrefs.theCropSpec.fadeInTime = 0L;				}				GetDItem(myDlg,18,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);				GetDItem(myDlg,17,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					StringToNum(textStr,&theNewPrefs.theCropSpec.fadeOutTime);				}				else				{					theNewPrefs.theCropSpec.fadeOutTime = 0L;				}				GetDItem(myDlg,21,&iType,&iHndl,&iRect);				GetIText(iHndl,textStr);					GetDItem(myDlg,20,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					StringToNum(textStr,&theNewPrefs.theCropSpec.addSilenceStart);				}				else				{					theNewPrefs.theCropSpec.addSilenceStart = 0L;				}								GetDItem(myDlg,24,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);				GetDItem(myDlg,23,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					StringToNum(textStr,&theNewPrefs.theCropSpec.addSilenceEnd);				}				else				{					theNewPrefs.theCropSpec.addSilenceEnd = 0L;				}								GetDItem(myDlg,26,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.rewriteOriginal = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,8,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.doPre = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,11,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.doPost = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,20,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.doAddSilenceStart = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,23,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.doAddSilenceEnd = GetCtlValue((ControlHandle)iHndl);							GetDItem(myDlg,14,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.doFadeStart = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,17,&iType,&iHndl,&iRect);					theNewPrefs.theCropSpec.doFadeEnd = GetCtlValue((ControlHandle)iHndl);			break;		}	}		GetDItem(myDlg,27,&iType,&iHndl,&iRect);		if (GetCtlValue((ControlHandle)iHndl))	{		theNewPrefs.theCropSpec.compositeFiles = true;		StandardPutFile("\pEnter Name for Composite File","\pComposite File",&myReply);		if (!myReply.sfGood)			theNewPrefs.theCropSpec.compositeFiles = false;			else		{			BlockMove (&myReply.sfFile, &theNewPrefs.theCropSpec.theCompositeSpec,70L);		}	}	else	{		theNewPrefs.theCropSpec.compositeFiles = false;	}		DisposDialog(myDlg);		DeleteMenu(2224);//	DeleteMenu(156);	//	DisposeMenu(prefsPopMenu);	DisposeMenu(prefsMenu);		SetPort(savePort); 	if (itemHit == 2)		return;			SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	progressCreate("\pPerforming AutoCropª");		if (theNewPrefs.theCropSpec.compositeFiles)	{			/* create the file */		if (myReply.sfReplacing)		{			FSpDelete(&theNewPrefs.theCropSpec.theCompositeSpec);		}				iErr = FSpCreate(&theNewPrefs.theCropSpec.theCompositeSpec,'Sd2a','Sd2f',0);		if (iErr)		{			genError("\pUnexpected Error");			return ;		}		writeSDIIResources(theNewPrefs.theCropSpec.theCompositeSpec,theNewPrefs.theCropSpec.theCompRate,theNewPrefs.theCropSpec.theCompStereo,theNewPrefs.theCropSpec.theCompBits);		addFileToList(theNewPrefs.theCropSpec.theCompositeSpec);				tempBuff = NewHandle(32768L);		if (!tempBuff)		{			genError ("\pNot enough memory for that operation");			return ;			}				hNew = NewHandleClear(32768L);		if (!hNew)		{			genError ("\pNot enough memory for that operation");			DisposHandle(tempBuff);			return ;			}				if (preserveRegions)		{			regionsHandle = NewHandle(sizeof(ddRLHeader) + sizeof(RegionRec));			if (!regionsHandle)			{				genError ("\pNot enough memory for that operation");				DisposHandle(tempBuff);				DisposHandle(hNew);							return ;				}			myRegHeader.VersionNumber = 1;			myRegHeader.HeaderSize = 12L;			myRegHeader.RegionSize = 56L;			GetDateTime(&secs);			myRegHeader.ResourceDate = secs;			myRegHeader.NextID = 1;			BlockMove (&myRegHeader,*regionsHandle,sizeof(ddRLHeader));		}		}			while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		autoCrop = true;		if (progressDisp((theindex * 100) / totfindcounter))		{			return;		}		iErr = FSpGetFInfo(&(*therealResults)[theindex],&fndrInfo);		if (!iErr && fndrInfo.fdType == 'Sd2f')		{			autoCropSDII((*therealResults)[theindex],theNewPrefs.theCropSpec);		}			LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (theNewPrefs.theCropSpec.compositeFiles)	{		if (preserveRegions)		{			iRefNum = CurResFile();			refNum = FSpOpenResFile(&theNewPrefs.theCropSpec.theCompositeSpec,fsWrPerm);			if (refNum == -1)			{				genError ("\pCould not open res file");				//FSClose (destRef);				DisposHandle(tempBuff);				DisposHandle(hNew);				return ;			}			UseResFile(refNum);			SetHandleSize(regionsHandle,sizeof(ddRLHeader) + (sizeof(RegionRec) * (regionCounter)));			((ddRLHeader *)(*regionsHandle))->NextID = regionCounter+1;			AddResource(regionsHandle,'ddRL',1000,"\pRegion List");	 		CloseResFile(refNum);			UseResFile(iRefNum);		}		/* free up mem etc */		DisposHandle(regionsHandle);		DisposHandle(tempBuff);		DisposHandle(hNew);		}	watchcursor(false);		progressDispos();	return;}long MakeEven(long thelong);long MakeEven(long thelong){		if (thelong & 0x00000001)		thelong--;	return thelong;}Boolean autoCropSDII(FSSpec mySpec, cropSpec theCropSpec){	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	short sourceRefNum,tempShort;	short rfRefNum;	long sourcePtr,percentVolume;	long destPtr,tempLong;	Handle theAudioData;	long theStart,theEnd;	OSErr	iErr,eErrNext;	long fPos, filePos;	long inOutCount,startPos;	SignedByte theByte;	short theWord;	long savePos, theCountLeft;	OSErr	eErr;	Str255 theCopyStr = "\pFile Exists, replace ? : ",theasker;	long tempFloor;	long tempFloorOut;	RegionRec	myRegion;	FSSpec newSpec;	short noiseFloor, noiseFloorOut,iRefNum,xRefNum;	Handle dataH;	long preRoll;	long postRoll;	long addSilenceStart;	long addSilenceEnd;	long fadeInTime,presFadeInTime;	long fadeOutTime,presFadeOutTime,z;	Boolean rewriteOriginal;	Str255 theComment, theFinderComment;	short refNum, sourceRef, destRef;	HFileParam pb;	long creationDate,modificationDate;	getConvertDest();	if (getSDIIData (mySpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return false;	}	GetFSComment(mySpec, theComment);	GetFSSpecComment(mySpec, (StringPtr)theFinderComment);	pb.ioCompletion = 0;	pb.ioVRefNum = mySpec.vRefNum;	pb.ioFVersNum = 0;	pb.ioFDirIndex = 0;	pb.ioNamePtr = mySpec.name;	pb.ioDirID = mySpec.parID;	iErr = PBHGetFInfo((HParamBlockRec*)&pb,false);		creationDate = 	pb.ioFlCrDat;		modificationDate = 	pb.ioFlMdDat;		tempFloor = (long)theCropSpec.noiseFloor;	tempFloor = (tempFloor * (long)((theWordSize == 2) ? tempFloor : 1));			noiseFloor = LoWord(tempFloor);			tempFloorOut = (long)theCropSpec.noiseFloorOut;	tempFloorOut = (tempFloorOut * (long)((theWordSize == 2) ? tempFloorOut : 1));			noiseFloor = LoWord(tempFloor);	noiseFloorOut = LoWord(tempFloorOut);	/* convert params from mS to Bytes */		preRoll = MakeEven((theCropSpec.preRoll * theRate * (stereo+1) * theWordSize) / 1000L); 	postRoll =  MakeEven((theCropSpec.postRoll * theRate * (stereo+1) * theWordSize) / 1000L);	addSilenceStart = MakeEven((theCropSpec.addSilenceStart * theRate * (stereo+1) * theWordSize) / 1000L);	addSilenceEnd  = MakeEven((theCropSpec.addSilenceEnd * theRate * (stereo+1) * theWordSize) / 1000L);	presFadeInTime = fadeInTime = MakeEven((theCropSpec.fadeInTime * theRate * (stereo+1) * theWordSize) / 1000L);	presFadeOutTime = fadeOutTime = MakeEven((theCropSpec.fadeOutTime * theRate * (stereo+1) * theWordSize) / 1000L);	rewriteOriginal = theCropSpec.rewriteOriginal;		theAudioData = NewHandle(32768L);	if (!theAudioData)	{		return false;	}				iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRefNum);	if (iErr != 0)	{		return false;	}	theStart = 0L;	theEnd = theBytes;		eErr = 0;	while (!eErr)	{		iErr = GetFPos(sourceRefNum,&savePos);		inOutCount = 32000L;		eErr = FSRead(sourceRefNum,&inOutCount,*theAudioData);		if (eErr != 0 && eErr != eofErr)		{			FSClose (sourceRefNum);			DisposHandle(theAudioData);			return false;		}		for (fPos = 0L;fPos<inOutCount;fPos += (long)((stereo + 1)*theWordSize))		{				switch (theWordSize)			{				case 1:					theByte = *(Byte *)((*theAudioData) + fPos);					if (theByte >=0)					{						if (theByte > noiseFloor)						{							theStart = (fPos + savePos);							goto FireExit;						}					}					else					{						if ((-theByte) > noiseFloor)						{							theStart = (fPos + savePos);							goto FireExit;						}					}					if (stereo)					{						theByte = *(Byte *)((*theAudioData) + fPos + 1);						if (theByte >=0)						{							if (theByte > noiseFloor)							{								theStart = (fPos + savePos);								goto FireExit;							}						}						else						{							if ((-theByte) > noiseFloor)							{								theStart = (fPos + savePos);								goto FireExit;							}						}					}									/*	BlockMove ((*theAudioData) + fPos,&theByte,1L);					if (abs((short)theByte) > noiseFloor)					{						theStart = (fPos + savePos);						goto FireExit;					}					if (stereo)					{												BlockMove ((*theAudioData) + fPos+1L,&theByte,1L);						if (abs((short)theByte) > noiseFloor)						{							theStart = (fPos + savePos);							goto FireExit;						}					}*/									break;								case 2:					/* if (abs(*(short *)((*theAudioData) + fPos)) > noiseFloor) */													theWord = *(short *)((*theAudioData) + fPos);					if (theWord >=0)					{						if (theWord > noiseFloor)						{							theStart = (fPos + savePos);							goto FireExit;						}					}					else					{						if ((-theWord) > noiseFloor)						{							theStart = (fPos + savePos);							goto FireExit;						}					}					if (stereo)					{						theWord = *(short *)((*theAudioData) + fPos + 2L);						if (theWord >=0)						{							if (theWord > noiseFloor)							{								theStart = (fPos + savePos);								goto FireExit;							}						}						else						{							if ((-theWord) > noiseFloor)							{								theStart = (fPos + savePos);								goto FireExit;							}						}					}														/*	BlockMove ((*theAudioData) + fPos,&theWord,2L);					if (abs(theWord) > noiseFloor)					{						theStart = (fPos + savePos);						goto FireExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos + 2L,&theWord,2L);						if (abs(theWord) > noiseFloor)						{							theStart = (fPos + savePos);							goto FireExit;						}					}*/				break;				}		}	}FireExit:	iErr = SetFPos(sourceRefNum,2,0L);	eErr = SetFPos(sourceRefNum,3,-32000L);	if (eErr == posErr)	{		eErr = SetFPos(sourceRefNum,1,0L);		theCountLeft = theBytes;	}		else		theCountLeft = 32000L;	eErr = 0;	eErrNext = 0;		while (!eErr)	{		if (eErrNext)		{			eErr = eErrNext;		}					inOutCount = theCountLeft;		if (inOutCount < 32000L)			eErr = eofErr;					iErr = GetFPos(sourceRefNum,&savePos);				if (inOutCount > 0L && inOutCount <= 32000L)			iErr = FSRead(sourceRefNum,&inOutCount,*theAudioData);		else		{			eErr = eofErr;		}				if (iErr != 0 && iErr != eofErr)		{			FSClose (sourceRefNum);			DisposHandle(theAudioData);			return false;		}		for (fPos = inOutCount-(long)((stereo + 1)*theWordSize);fPos>=0L;fPos -= (long)((stereo + 1)*theWordSize))		{				switch (theWordSize)			{				case 1:					theByte = *(Byte *)((*theAudioData) + fPos);					if (theByte >=0)					{						if (theByte > noiseFloorOut)						{							theEnd = (fPos + savePos);							goto SecondExit;						}					}					else					{						if ((-theByte) > noiseFloorOut)						{							theEnd = (fPos + savePos);							goto SecondExit;						}					}					if (stereo)					{						theByte = *(Byte *)((*theAudioData) + fPos + 1L);						if (theByte >=0)						{							if (theByte > noiseFloorOut)							{								theEnd = (fPos + savePos);								goto SecondExit;							}						}						else						{							if ((-theByte) > noiseFloorOut)							{								theEnd = (fPos + savePos);								goto SecondExit;							}						}					}										/*BlockMove ((*theAudioData) + fPos,&theByte,1L);					if (abs((short)theByte) > noiseFloor)					{						theEnd = (fPos + savePos) ;						goto SecondExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos+1L,&theByte,1L);						if (abs((short)theByte) > noiseFloor)						{							theEnd = (fPos + savePos);							goto SecondExit;						}					}*/				break;								case 2:									theWord = *(short *)((*theAudioData) + fPos);					if (theWord >=0)					{						if (theWord > noiseFloorOut)						{							theEnd = (fPos + savePos);							goto SecondExit;						}					}					else					{						if ((-theWord) > noiseFloorOut)						{							theEnd = (fPos + savePos);							goto SecondExit;						}					}					if (stereo)					{						theWord = *(short *)((*theAudioData) + fPos + 2L);						if (theWord >=0)						{							if (theWord > noiseFloorOut)							{								theEnd = (fPos + savePos);								goto SecondExit;							}						}						else						{							if ((-theWord) > noiseFloorOut)							{								theEnd = (fPos + savePos);								goto SecondExit;							}						}					}  								/*	BlockMove ((*theAudioData) + fPos,&theWord,2L);					if (abs(theWord) > noiseFloor)					{						theEnd = (fPos + savePos);						goto SecondExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos + 2L,&theWord,2L);						if (abs(theWord) > noiseFloor)						{							theEnd = (fPos + savePos);							goto SecondExit;						}					}*/				break;			}		}		theCountLeft = 32000L;		iErr = GetFPos(sourceRefNum,&filePos);		if (filePos > (32000L + inOutCount))		{			iErr = SetFPos(sourceRefNum,3,-(32000L + inOutCount));			if (iErr)			{				eErrNext = eofErr;			}		}		else		{			iErr = SetFPos(sourceRefNum,1,0L);			theCountLeft = filePos;			eErrNext = eofErr;		}	}SecondExit:	FSClose (sourceRefNum);		DisposHandle(theAudioData);		if (theEnd < theStart)	{		return false;	}		BlockMove(&mySpec,&newSpec,70L);			if (rewriteOriginal)	{		concatStrings(newSpec.name,"\p~","\p");		iErr = FSpRename(&mySpec,newSpec.name);		BlockMove(&mySpec,&newSpec,70L);		concatStrings(mySpec.name,"\p~","\p");	}	else	{		newSpec.parID = theConvertDestLoc.parID;		newSpec.vRefNum = theConvertDestLoc.vRefNum;	}		iErr = FSpCreate(&newSpec,'Sd2a','Sd2f',0);	if (iErr == -48)	{		BlockMove (newSpec.name,theasker,64L);		concatStrings(theCopyStr,theasker,"\p ");		if (YesNo (theCopyStr))		{			if (newSpec.parID == mySpec.parID && newSpec.vRefNum == mySpec.vRefNum)			{					concatStrings(newSpec.name,"\p~","\p");				iErr = FSpRename(&mySpec,newSpec.name);				BlockMove(&mySpec,&newSpec,70L);				concatStrings(mySpec.name,"\p~","\p");				rewriteOriginal = true;			}			FSpDelete (&newSpec);			iErr = FSpCreate(&newSpec,'Sd2a','Sd2f',0);		}		else		{			return false;		}	}		//getSDIIData (mySpec,&theRate, &theWordSize,&stereo, &theBytes);		dataH = NewHandle(32768L); 	if (!dataH)	{		genError ("\pNot enough memory to perform this function");		return false;	}		iErr = FSpOpenDF(&newSpec,fsWrPerm,&fRefNum);	if (iErr != 0)	{		genError ("\pCan't open DF of destination file");		DisposHandle(dataH);		return false;	}	iErr = FSpOpenDF(&mySpec,fsCurPerm,&iRefNum);	if (iErr != 0)	{		genError ("\pCan't open DF of source file");		FSClose (fRefNum);		DisposHandle(dataH);		return false;	}		memset(*dataH,0,32000L);	inOutCount = addSilenceStart;		while (addSilenceStart > 0L)	{		inOutCount = addSilenceStart;		if (inOutCount > 32000L)			inOutCount = 32000L;		iErr = FSWrite (fRefNum,&inOutCount,*dataH);		addSilenceStart -= inOutCount;	}			iErr = SetFPos(iRefNum,1,theStart - preRoll);  /*check mS etc */	if (iErr != 0)	{		if (iErr == -40)		{			iErr = SetFPos(iRefNum,1,0L);		} 		else		{			genError ("\pCan't position in DF of source file");			FSClose (iRefNum);			FSClose (fRefNum);			DisposHandle(dataH);			//UseResFile(xRefNum);			return false;		}	}			iErr = GetFPos(iRefNum,&filePos);	/* do fade in after start, fade out before end */	percentVolume = 100L;	inOutCount = fadeInTime;	iErr = 0;	while (fadeInTime > 0L && iErr != eofErr)	{		inOutCount = fadeInTime;		if (inOutCount > 32000L)			inOutCount = 32000L;		iErr = FSRead(iRefNum,&inOutCount,*dataH);						for (z=0L;z<inOutCount;z+= (long)theWordSize)		{			percentVolume = ((presFadeInTime - fadeInTime) * 100L) / presFadeInTime;			switch (theWordSize)			{				case 1:					tempShort = (short)(*(Byte *)(*dataH + z)) * LoWord(percentVolume);					tempShort /= 100;					*(Byte *)(*dataH + z) = (Byte)tempShort;				break;				case 2:					tempLong = (long)(*(short *)(*dataH + z)) * percentVolume;					tempLong /= 100L;					*(short *)(*dataH + z) = LoWord(tempLong);				break;			}			fadeInTime -= (long)theWordSize;		}		eErr = FSWrite (fRefNum,&inOutCount,*dataH);		//fadeInTime -= inOutCount;	}		iErr = GetFPos(iRefNum,&filePos);	inOutCount = (theEnd - fadeOutTime + postRoll) - filePos;	iErr = 0;	while (iErr != eofErr && inOutCount > 0L)	{		if (inOutCount > 32000L)			inOutCount = 32000L;		iErr = FSRead (iRefNum,&inOutCount,*dataH);		eErr = FSWrite(fRefNum,&inOutCount,*dataH);		eErr = GetFPos(iRefNum,&filePos);		inOutCount = (theEnd - fadeOutTime + postRoll) - filePos;	}			iErr = GetFPos(iRefNum,&filePos);	/* do fade in after start, fade out before end */	percentVolume = 100L;	inOutCount = fadeOutTime;	iErr = 0;	while (fadeOutTime > 0L && iErr != eofErr)	{		inOutCount = fadeOutTime;		if (inOutCount > 32000L)			inOutCount = 32000L;		iErr = FSRead(iRefNum,&inOutCount,*dataH);						for (z=0L;z<inOutCount;z+= (long)theWordSize)		{			percentVolume = ((fadeOutTime * 100) / presFadeOutTime);			switch (theWordSize)			{				case 1:					tempShort = (short)(*(Byte *)(*dataH + z)) * LoWord(percentVolume);					tempShort /= 100;					*(Byte *)(*dataH + z) = (Byte)tempShort;				break;				case 2:					tempLong = (long)(*(short *)(*dataH + z)) * percentVolume;					tempLong /= 100L;					*(short *)(*dataH + z) = LoWord(tempLong);				break;			}			fadeOutTime -= (long)theWordSize;		}		eErr = FSWrite (fRefNum,&inOutCount,*dataH);			}		memset(*dataH,0,32000L);	inOutCount = addSilenceEnd;		while (addSilenceEnd > 0L)	{		inOutCount = addSilenceEnd;		if (inOutCount > 32000L)			inOutCount = 32000L;		iErr = FSWrite (fRefNum,&inOutCount,*dataH);		addSilenceEnd -= inOutCount;	}	FSClose(iRefNum);	FSClose(fRefNum);	writeSDIIResources( newSpec,theRate,stereo,theWordSize);	if (rewriteOriginal)	{		FSpDelete(&mySpec);	}	addFileToList(newSpec);	DisposHandle(dataH);	SetFSComment (newSpec, theComment);	SetFSSpecComment(newSpec, (StringPtr)theFinderComment);	pb.ioCompletion = 0;	pb.ioVRefNum = newSpec.vRefNum;	pb.ioFVersNum = 0;	pb.ioFDirIndex = 0;	pb.ioNamePtr = newSpec.name;	pb.ioDirID = newSpec.parID;	iErr = PBHGetFInfo((HParamBlockRec*)&pb,false);	pb.ioCompletion = 0;	pb.ioVRefNum = newSpec.vRefNum;	pb.ioFVersNum = 0;	pb.ioFDirIndex = 0;	pb.ioNamePtr = newSpec.name;	pb.ioDirID = newSpec.parID;	pb.ioFlCrDat = creationDate;	pb.ioFlMdDat = modificationDate;	iErr = PBHSetFInfo((HParamBlockRec*)&pb,false);		if (theCropSpec.compositeFiles)	{		iErr = FSpOpenDF(&theCropSpec.theCompositeSpec,fsWrPerm,&destRef);		if (iErr !=0)		{			//SysBeep(5);			return;		}				iErr = SetFPos(destRef,2,0);				iErr = FSpOpenDF(&newSpec,fsCurPerm,&sourceRef);		if (iErr !=0)		{			SysBeep(5);			return;		}				iErr = GetFPos(destRef,&filePos);		if (!theDivTime)			theDivTime = 1;		filePos = filePos / (long)theDivTime;				if (preserveRegions)		{			currentRegion.RegionID = regionCounter + 1;			currentRegion.StartFrame = filePos;			//currentRegion.StopFrame = 			currentRegion.SynchFrame = filePos;			currentRegion.TimeStampMS = secs;			currentRegion.TimeStampLS = secs;			BlockMove(newSpec.name,currentRegion.RegionName,32L); 					}		eErr = 0;		while (iErr != eofErr && !eErr)		{			if(progressDisp(0))			{				FSClose (sourceRef);				FSClose (destRef);				DisposHandle(tempBuff);				DisposHandle(hNew);						}			inOutCount = 32000L;			iErr = FSRead(sourceRef,&inOutCount,*tempBuff);			eErr = FSWrite(destRef,&inOutCount,*tempBuff);		}		FSClose (sourceRef);		if (theCropSpec.deleteCompCopies && !theCropSpec.rewriteOriginal)		{			iErr = FSpDelete(&newSpec);		}				iErr = GetFPos(destRef,&filePos);		if (!theDivTime)			theDivTime = 1;		filePos /= (long)theDivTime;				if (preserveRegions)		{			currentRegion.StopFrame = filePos;				//(RegionRec)((*regionsHandle) + sizeof(ddRLHeader) + ((sizeof(RegionRec) * regionCounter))) = currentRegion;			BlockMove(&currentRegion,((*regionsHandle) + sizeof(ddRLHeader) + ((sizeof(RegionRec) * regionCounter))),sizeof(RegionRec));			regionCounter ++;			SetHandleSize(regionsHandle,sizeof(ddRLHeader) + (sizeof(RegionRec) * (regionCounter+1)));			iErr = MemError();			if (iErr != 0)			{				FSClose (destRef);				DisposHandle(regionsHandle);				DisposHandle(tempBuff);				DisposHandle(hNew);				}		}				tempLong = (theCropSpec.silencePeriod * theCropSpec.theCompRate * (theCropSpec.theCompStereo + 1) * theCropSpec.theCompBits) / 1000L;		eErr = 0;		while (tempLong > 0L && !eErr)		{			if (tempLong >= 32000L)			{				inOutCount = 32000L;			}			else			{				inOutCount = tempLong;			}			tempLong -= inOutCount;			if(progressDisp(0))			{				FSClose (destRef);				DisposHandle(tempBuff);				DisposHandle(hNew);						}			eErr = FSWrite(destRef,&inOutCount,*hNew);		}				FSClose (destRef);		FSClose (sourceRef);	}			return true;}OSErr getNewAutoCropSetName(StringPtr theName){	OSErr		iErr;					FSSpec	mySpec;	FInfo	fndrInfo;	short z;	CInfoPBRec	pb;	StandardFileReply	reply;	short temprefNum;	Str255 newName;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	myDlg = GetNewDialog(6002,0L,(WindowPtr)-1);	SetPort (myDlg);		ShowWindow(myDlg);	ModalDialog(0,&itemHit);		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,theName);		DisposDialog(myDlg);		return (itemHit-1);}short deleteAutoCropSetting(void){	OSErr		iErr;					FSSpec	mySpec;	FInfo	fndrInfo;	short z;	CInfoPBRec	pb;	StandardFileReply	reply;	short temprefNum;	Str255 newName;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	CInfoPBRec		xCPB;	HFileInfo		*myxCPB = (HFileInfo *)&xCPB;	FSSpec settingsFolder,tempspec;	long createdDirID,foundDirID;	short foundVRefNum,index;	MenuHandle prefsPopMenu;	Str255 tempStr;				iErr = FindFolder(kOnSystemDisk,'pref',true,&foundVRefNum,&foundDirID);	if (iErr)	{		genError("\pCant find prefs folder");	}		iErr = FSMakeFSSpec(foundVRefNum,foundDirID,"\pSSearch AutoCropª Settings",&settingsFolder);	if (iErr == -43)	{		iErr = DirCreate(foundVRefNum,foundDirID,"\pSSearch AutoCropª Settings",&createdDirID);		settingsFolder.parID = createdDirID;	}	else	{		translateParentToChildFolder(&settingsFolder);		createdDirID = settingsFolder.parID;	}		numPrefsFiles = 0;		prefsPopMenu = GetMenu(156);		InsertMenu(prefsPopMenu, -1);	iErr = 0;	index = 1;	do	{		myxCPB->ioVRefNum = settingsFolder.vRefNum;		myxCPB->ioFDirIndex = index;			myxCPB->ioDirID = createdDirID;		*tempStr = 0;		myxCPB->ioNamePtr = tempStr;		iErr = PBGetCatInfo((CInfoPBPtr)myxCPB, false);				if(iErr == noErr) 		{			iErr = FSMakeFSSpec(myxCPB->ioVRefNum,createdDirID,myxCPB->ioNamePtr,&tempspec);			iErr = FSpGetFInfo(&tempspec,&fndrInfo);			if(fndrInfo.fdType == 'cRoP')			{				prefsSpex[numPrefsFiles] = tempspec;				++numPrefsFiles;				AppendMenu(prefsPopMenu,tempspec.name);			}		}		index += 1;	} while(iErr == noErr && numPrefsFiles < 49);	myDlg = GetNewDialog(6001,0L,(WindowPtr)-1);	SetPort (myDlg);		ShowWindow(myDlg);	ModalDialog(0,&itemHit);		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	iCtlValue = GetCtlValue((ControlHandle)iHndl);		DisposDialog(myDlg);		if (itemHit == 1)	{		FSpDelete (&prefsSpex[iCtlValue - 1]);	}	else	{		iCtlValue = -1;	}		DeleteMenu(156);		DisposeMenu(prefsPopMenu);		return (iCtlValue);}