#include "imaWAVADPCM.h"#define kBlockSize		0x200 	#define WAVE_FORMAT_IMA_ADPCM	0x0011 // Look for this in wFormatTag #define FlipShort(x) (((((unsigned short)(x))<<8)&0xFF00) | ((((unsigned short)(x))>>8)&0x00FF))	#define FlipLong(x) (((((unsigned long)(x))<<24)&0xFF000000)|((((unsigned long)(x))<<8)&0x00FF0000)|((((unsigned long)(x))>>8)&0x0000FF00) | ((((unsigned long)(x))>>24)&0x000000FF))	#define LOWORD(x) ((unsigned short)((x) & 0x0000FFFF))#define HIWORD(x) ((unsigned short)(((x)>>16) & 0x0000FFFF))		#define MAKELONG(x,y) (((unsigned long)((unsigned short)(x)))|((unsigned long)((unsigned short)(y)))<<16)#define min(x, y) ((x)>(y)?(y):(x))extern short destRefNum;Boolean progressDisp(short percentFull);/*******************************************************************************************	PROTOTYPES*******************************************************************************************/	short					refNum;	long 					RIFFPos;	long 					factPos;	long 					dataPos;	long 					blockSize;	short 					numTracks; /* stereo */	unsigned long 			sampleRate;	unsigned long			bytes;	short 					wordSize;		Ptr inputLeft;	Ptr inputRight;	Ptr encodedIMA;	/*******************************************************************************************	WriteWaveHeaderInfo		Write out the RIFF chunk headers and the IMAADPCMWAVEFORMAT chunk.  Leave file	positioned where the actual sound data will go.  Note that the unsigned long specifying	the length of the file and the unsigned long specifying the length of the sound data still	need to be filled in after the sound data is written.*******************************************************************************************/OSErr WriteWaveHeaderInfo(void){	IMAADPCMWAVEFORMAT		format;	OSErr					osErr;	long					bytesToWrite;	long					temp;	bytesToWrite = 4;	// RIFF file marker	temp = 'RIFF';	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	// Length of file placeholder.	GetFPos(destRefNum, &RIFFPos);	temp = 0;	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	// WAVE RIFF type	temp = 'WAVE';	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);		// 'fact' chunk.  This is REQUIRED for non-PCM format WAVE files.	temp = 'fact';	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	temp = 4;	temp = FlipLong(temp);	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	GetFPos(destRefNum, &factPos);	temp = 0; // Placeholder for # of samples.	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);		// IMAADPCMWAVEFORMAT chunk	temp = 'fmt ';	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	temp = sizeof(IMAADPCMWAVEFORMAT);	temp = FlipLong(temp);	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);		format.wFormatTag = WAVE_FORMAT_IMA_ADPCM;	format.wFormatTag = FlipShort(format.wFormatTag);	format.nChannels = (numTracks > 1) ? 2 : 1;	format.nChannels = FlipShort(format.nChannels);	format.nSamplesPerSec = sampleRate;	format.nSamplesPerSec = FlipLong(format.nSamplesPerSec);	format.nAvgBytesPerSec = ((unsigned long)sampleRate * (unsigned long)blockSize) / (((unsigned long)blockSize - 4)*2+1);	format.nAvgBytesPerSec = FlipLong(format.nAvgBytesPerSec);	format.nBlockAlign = blockSize;	format.nBlockAlign = FlipShort(format.nBlockAlign);	format.wBitsPerSample = 4;	format.wBitsPerSample = FlipShort(format.wBitsPerSample);	format.cbSize = 2;	format.cbSize = FlipShort(format.cbSize);	format.wSamplesPerBlock = (blockSize-4)*2 + 1; /* This is what Microsoft's codec writes, but...*//*	format.wSamplesPerBlock = (blockSize-8)*2 + 2;  this is what it SHOULD be for stereo.*/	format.wSamplesPerBlock = FlipShort(format.wSamplesPerBlock);		bytesToWrite = sizeof(IMAADPCMWAVEFORMAT);	osErr = FSWrite( destRefNum, &bytesToWrite, &format);		bytesToWrite = 4;	temp = 'data';	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	GetFPos(destRefNum, &dataPos);	temp = 0; // Placeholder for size of data chunk	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);		return noErr;}void  Expand8BitTo16Bit(void *sampleBuf, long numSamples);void  Expand8BitTo16Bit(void *sampleBuf, long numSamples){	short		x;	for (x = numSamples; x >= 0; x--)	{		*(((short*)sampleBuf)+x) = ((short)(*(((char*)sampleBuf)+x) - 128)) * 256;	}}/*******************************************************************************************	WriteWaveData		Write the wave data!*******************************************************************************************/OSErr WriteWaveData(long * totalBytesWritten, long * totalSamplesWritten){	OSErr		ourErr,iErr;	long			samplesLeft, samplesToDo;	OSErr			osErr;	short			samplesPerBlock;	long			bytesWritten;	long			bytesToWrite;	short			stepIndex, stepIndexR;	short			x;	long			totalSampleToWrite,inOutCount;	float theFloat;    short thePercent;    long multiplier = 32L;        	/* Figure out the number of samples per block per channel */	if (numTracks > 1)		samplesPerBlock = (((short)blockSize - 8) + 1);	else		samplesPerBlock = (((short)blockSize - 4)*2+1);	*totalBytesWritten = 0;	*totalSamplesWritten = 0;	stepIndex = 0;	stepIndexR = 0;	samplesLeft = 0;		samplesLeft = bytes >> (numTracks - 1) >> 1;		totalSampleToWrite = samplesLeft;	osErr = noErr;		/* Read the documents track data, compress it, and write it out! */	while (samplesLeft > 0 && osErr == noErr)	{		/* How many samples to do this pass.	 */				samplesToDo = samplesPerBlock * multiplier;		if (samplesToDo > samplesLeft)			samplesToDo = samplesLeft;		inOutCount = samplesToDo << (numTracks - 1) << (wordSize - 1); 				osErr = FSRead(refNum,&inOutCount,inputLeft);		if (osErr == eofErr)		{			samplesToDo  = inOutCount >> (numTracks - 1) >> (wordSize - 1); 		}						if (numTracks > 1)		{			deInterleaveAudio (inputLeft, inputRight, inOutCount,wordSize);		}		if (wordSize == 1)		{			Expand8BitTo16Bit(inputLeft, inOutCount);		}		/* Pad our buffers with 0's */		if (samplesToDo < samplesPerBlock * multiplier)		{			long i;			for (i = samplesToDo; i < samplesPerBlock * multiplier; i++)				((short*)inputLeft)[i] = 0;		} 						/* ------ Read second track ------*/			if (numTracks > 1)		{			/*  we already read and split the audio */			/* If the document data is 8 bit, we gotta expand it */			/* to 16 so the compressor routine can handle it. */			if (wordSize == 1)			{				Expand8BitTo16Bit(inputRight, samplesToDo);			}			/* Pad our buffers with 0's */			if (samplesToDo < samplesPerBlock * multiplier)			{				long i;				for (i = samplesToDo; i < samplesPerBlock * multiplier; i++)					((short*)inputRight)[i] = 0;			} 		}		/* Compress the samples and write.		We ALWAYS write a whole block, because Microsofts codec WON'T		read partial blocks....(!) */		if (numTracks > 1)		{			bytesWritten = EncodeStereo((unsigned char *)inputLeft, (unsigned char *)inputRight, samplesPerBlock * 2 * multiplier, (unsigned char *)encodedIMA, samplesPerBlock, &stepIndex, &stepIndexR);		}		else		{			bytesWritten = EncodeMono((unsigned char *)inputLeft, samplesPerBlock * 2 * multiplier,(unsigned char *) encodedIMA, samplesPerBlock, &stepIndex);		}			/*	bytesToWrite = blockSize; */		bytesToWrite = bytesWritten;		iErr = FSWrite(destRefNum, &bytesToWrite, encodedIMA);				samplesLeft -= samplesToDo;		*totalSamplesWritten += samplesToDo;		*totalBytesWritten += bytesToWrite;		theFloat = ((float)(*totalSamplesWritten) / (float)totalSampleToWrite) * (float)100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			return -99;				}				}	return noErr;}/*******************************************************************************************	FillInPlaceholders		Go back and write header data that currently just contains placeholders.*******************************************************************************************/OSErrFillInPlaceholders(long RIFFLen, long factLen, long dataLen){	long		temp;	long		bytesToWrite;	OSErr		osErr;		bytesToWrite = 4;		osErr = SetFPos(destRefNum, fsFromStart, RIFFPos);	temp = RIFFLen;	temp = FlipLong(temp);	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);		osErr = SetFPos(destRefNum, fsFromStart, factPos);	temp = factLen;	temp = FlipLong(temp);	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	osErr = SetFPos(destRefNum, fsFromStart, dataPos);	temp = dataLen;	temp = FlipLong(temp);	osErr = FSWrite( destRefNum, &bytesToWrite, &temp);	return noErr;}/*******************************************************************************************	MyXtraMain		Import IMA compressed audio tracks from WAVE file specified by theFile into	the document specified by pDocInfo.  This is the whole point of this Xtra.*******************************************************************************************//* OSErr MyXtraMain(SndXtraShell_IMoaSEExtension FAR * This , pMoaSEDocInfo pDocInfo, FSSpec * theFile){	short 			tempShort;	OSErr		ourErr;	HParamBlockRec	hPB;	long			dataBytesWritten, samplesWritten, bytesInFile;		if (pDocInfo->numTracks > 1)		This->pObj->blockSize = kBlockSize*2;	else		This->pObj->blockSize = kBlockSize;	// Make sure the document is of the type we can export.	if (!CheckDocFormats(This, pDocInfo))	{		return kMoaErr_FileNotFound;	}	// Get our memory.	ourErr = AllocateBuffers(This, pDocInfo);	if (ourErr != kMoaErr_NoErr)		return ourErr;	// create the file	hPB.fileParam.ioCompletion = NULL;	hPB.fileParam.ioNamePtr = theFile->name;	hPB.fileParam.ioVRefNum = theFile->vRefNum;	hPB.fileParam.ioDirID = theFile->parID;	tempShort = PBHCreateSync( &hPB );			// if this file already exists, delete, and overwrite data	if (tempShort == dupFNErr)	{		hPB.fileParam.ioCompletion = NULL;		hPB.fileParam.ioNamePtr = theFile->name;		hPB.fileParam.ioVRefNum = theFile->vRefNum;		hPB.fileParam.ioDirID = theFile->parID;		tempShort = PBHDeleteSync( &hPB );		if (tempShort == noErr)					// Try creating again.		{			hPB.fileParam.ioCompletion = NULL;			hPB.fileParam.ioNamePtr = theFile->name;			hPB.fileParam.ioVRefNum = theFile->vRefNum;			hPB.fileParam.ioDirID = theFile->parID;			tempShort = PBHCreateSync( &hPB );		}		else		{			goto FAIL;		}	}			if ( tempShort != noErr )		goto FAIL;			// Ok.  We've created the file.  Now get info on it.		hPB.fileParam.ioCompletion = NULL;	hPB.fileParam.ioNamePtr = theFile->name;	hPB.fileParam.ioVRefNum = theFile->vRefNum;	hPB.fileParam.ioFDirIndex = 0;	hPB.fileParam.ioDirID = theFile->parID;	tempShort = PBHGetFInfoSync( &hPB );		// Get all the file info.	if ( tempShort != noErr )		goto FAIL;		// Now set the type/creator for the file.	hPB.fileParam.ioCompletion = NULL;	hPB.fileParam.ioNamePtr = theFile->name;	hPB.fileParam.ioVRefNum = theFile->vRefNum;	hPB.fileParam.ioFDirIndex = 0;	hPB.fileParam.ioDirID = theFile->parID;	hPB.fileParam.ioFlFndrInfo.fdType = 'WAVE';	hPB.fileParam.ioFlFndrInfo.fdCreator = 'nQst';	tempShort = PBHSetFInfoSync( &hPB );	if ( tempShort != noErr )		goto FAIL;	// Open the data for for writing.	hPB.ioParam.ioCompletion = NULL;	hPB.ioParam.ioNamePtr = theFile->name;	hPB.ioParam.ioVRefNum = theFile->vRefNum;	hPB.fileParam.ioDirID = theFile->parID;	hPB.ioParam.ioPermssn = fsWrPerm;	tempShort = PBHOpenDFSync( &hPB );	if ( tempShort != noErr )		goto FAIL;	This->pObj->refNum = hPB.ioParam.ioRefNum;		// Start up the progress dialog	StartProgressDialog(This);	// Write the .WAV file header info	ourErr = WriteWaveHeaderInfo(This, pDocInfo);	if (ourErr != kMoaErr_NoErr)		goto FAIL;		// Remember how many bytes written so far.	GetFPos(This->pObj->refNum, &bytesInFile);	bytesInFile -= 8; // -8 because RIFF file header not included.	// Now the file is positioned to to point where	// the wave data is supposed to go, so...	ourErr = WriteWaveData(This, pDocInfo, &dataBytesWritten, &samplesWritten);	if (ourErr != kMoaErr_NoErr)		goto FAIL;	// Now go back and fill in header information...	bytesInFile += dataBytesWritten;  	ourErr = FillInPlaceholders(This, bytesInFile, samplesWritten, dataBytesWritten);	if (ourErr != kMoaErr_NoErr)		goto FAIL;	goto CLEANUP;	// Something bad happened.  Notify the user.	FAIL:	SysBeep(1); // Notify user	CLEANUP:	FinishProgressDialog(This);	if (This->pObj->refNum)		FSClose(This->pObj->refNum);		DeallocateBuffers(This);		// If export failed, delete the file.	if (ourErr != kMoaErr_NoErr)	{		FSpDelete(theFile);	}		return ourErr;} *//***************************************************************************************************************************************************************************************	ENCODING ROUTINES***************************************************************************************************************************************************************************************/extern const short next_step[16];extern const short step[89];/****************************************************************************	SampleEncode		Encode a single sample.****************************************************************************/short SampleEncode(short inputSample, short predictedSample, short stepSize);short SampleEncode(short inputSample, short predictedSample, short stepSize){    long	diff; 				// Could be more the 16 bit    short     encodedSample;    diff = inputSample - predictedSample;    encodedSample = 0;    if (diff < 0)    {        encodedSample = 8;        diff = -diff;    }    // Bit 2    if (diff >= stepSize)    {                encodedSample |= 4;        diff -= stepSize;    }	// Bit 1    stepSize >>= 1;    if (diff >= stepSize)    {                encodedSample |= 2;        diff -= stepSize;    }	// Bit 0    stepSize >>= 1;    if (diff >= stepSize)    {             encodedSample |= 1;    }    return encodedSample;}/****************************************************************************	EncodeMono		Encode the single buffer of 16 bit samples.****************************************************************************/unsigned long EncodeMono(Byte * src, unsigned long cbSrcLength, Byte* dst, unsigned short samplesPerBlock, short* savedStepIndex){    Byte*		dstStart;    unsigned long       srcSamples;    unsigned short        blockSamples;    short         sample;    short         stepSize;    short         encodedSample1;    short         encodedSample2;    short         predictedSample;    short         stepIndex;	long	diff;	short   stepSize2;    long	difference;    long	newSample;            dstStart = dst;    srcSamples = cbSrcLength / 2;  /* Figure the number of samples in the buffer */    /* Restore the step index */    stepIndex = (*savedStepIndex);    while (srcSamples > 0)    {   		/* Figure number of sample we will write in this block */        blockSamples = (unsigned short)min(srcSamples, samplesPerBlock);                /* and subtract from the total number of samples. */        srcSamples -= blockSamples;		/*Write out the block header*/        predictedSample = *(short *)src;        src += sizeof(short);        blockSamples--;                *(short *)dst = FlipShort((short)predictedSample);        dst += sizeof(short);        *(short *)dst = FlipShort((short)stepIndex);        dst += sizeof(short);                while (blockSamples > 0)        {									/* Get a sample and encode it. */            sample = *(short *)src;            src  += sizeof(short);            blockSamples--;            stepSize    = step[stepIndex];                  	//	encodedSample1  = SampleEncode(sample, predictedSample, stepSize);      					stepSize2 = stepSize;					    diff = sample - predictedSample;		    encodedSample1 = 0;		    if (diff < 0)		    {		        encodedSample1 = 8;		        diff = -diff;		    }				    // Bit 2		    if (diff >= stepSize2)		    {        		        encodedSample1 |= 4;		        diff -= stepSize2;		    }					// Bit 1		    stepSize2 >>= 1;		    if (diff >= stepSize2)		    {        		        encodedSample1 |= 2;		        diff -= stepSize2;		    }					// Bit 0		    stepSize2 >>= 1;		    if (diff >= stepSize2)		    {     		        encodedSample1 |= 1;		    }						          // predictedSample  = SampleDecode(encodedSample1, predictedSample, stepSize);		    difference = stepSize>>3;				    if (encodedSample1 & 4) 		        difference += (long)stepSize;				    if (encodedSample1 & 2) 		        difference += (long)(stepSize>>1);				    if (encodedSample1 & 1) 		        difference += (long)(stepSize>>2);				    if (encodedSample1 & 8)		        difference = -difference;				    newSample = (long)predictedSample + (long)difference;				    if ((long)(short)newSample == newSample)		    {		       predictedSample = (short)(newSample);		    }			else			{				// Clip the sample to 16 bits			    if (newSample < -32767L)			    {			        newSample = -32767L;			    }			    if (newSample > 32767L)			    {			        newSample = 32767L;			    }					 predictedSample = (short)(newSample);			}			/* inline extraction */ 				 stepIndex += next_step[encodedSample1];   				 if (stepIndex < 0)   				 {					stepIndex = 0;				 }  				 else   				 {  				 	if (stepIndex > 88)  				 	{        				stepIndex = 88;        			}        		 }        		/*************************/        			        			        			            /* Get a second sample and encode it             If there's not enough data, just write a 0. */            encodedSample2  = 0;             if (blockSamples > 0)            {				                sample = *(short *)src;                src  += sizeof(short);                blockSamples--;                stepSize = step[stepIndex];                               // encodedSample2  = SampleEncode(sample, predictedSample, stepSize);                                stepSize2 = stepSize;						    diff = sample - predictedSample;			    encodedSample2 = 0;			    if (diff < 0)			    {			        encodedSample2 = 8;			        diff = -diff;			    }						    // Bit 2			    if (diff >= stepSize2)			    {        			        encodedSample2 |= 4;			        diff -= stepSize2;			    }							// Bit 1			    stepSize2 >>= 1;			    if (diff >= stepSize2)			    {        			        encodedSample2 |= 2;			        diff -= stepSize2;			    }							// Bit 0			    stepSize2 >>= 1;			    if (diff >= stepSize2)			    {     			        encodedSample2 |= 1;			    }			    		                  //  predictedSample = SampleDecode(encodedSample2, predictedSample, stepSize);                               difference = stepSize>>3;					    if (encodedSample2 & 4) 			        difference += (long)(stepSize);						    if (encodedSample2 & 2) 			        difference += (long)(stepSize>>1);						    if (encodedSample2 & 1) 			        difference += (long)(stepSize>>2);						    if (encodedSample2 & 8)			        difference = -difference;						    newSample = predictedSample + difference;						    if ((long)(short)newSample == newSample)			    {			       predictedSample = (short)(newSample);			    }				else				{					// Clip the sample to 16 bits				    if (newSample < -32767L)				    {				        newSample = -32767L;				    }				    if (newSample > 32767L)				    {				        newSample = 32767L;				    }							  predictedSample = (short)(newSample);				}							                /* inline extraction */ 				 stepIndex += next_step[encodedSample2];   				 if (stepIndex < 0)   				 {					stepIndex = 0;				 }  				 else   				 {  				 	if (stepIndex > 88)  				 	{        				stepIndex = 88;        			}        		 }        		/*************************/        			        			            }			/* Pack the nibbles into a Byte and write it. */            *dst++ = (Byte)(encodedSample1 | (encodedSample2 << 4));        }    }    /*  Save the the step index */    (*savedStepIndex) = stepIndex;	/* Return the number of bytes written */    return (unsigned long)(dst - dstStart);}unsigned long EncodeStereo(Byte* srcLeft, Byte* srcRight, unsigned long cbSrcLength, Byte* dst, unsigned short samplesPerBlock, short* savedStepIndexL, short* savedStepIndexR){    short         i;    Byte*       dstStart;    unsigned long       srcSamples;    unsigned short        blockSamples;    short         stepSize,stepSize2;    short         sample;    unsigned long       dwLeft;    short         enclodedSampleL;    short         predictedSampleL;    short         stepIndexL;    unsigned long       dwRight;    short         enclodedSampleR;    short         predictedSampleR;    short         stepIndexR;	long	difference;    long	newSample;	long	diff; 				// Could be more the 16 bit	short     encodedSample;		    dstStart = dst;    srcSamples = cbSrcLength / 2; // Figure the number of samples in each buffer    // Restore the step index    stepIndexL = (*savedStepIndexL);    stepIndexR = (*savedStepIndexR);    while (srcSamples > 0)    {        blockSamples = samplesPerBlock;        srcSamples  -= blockSamples;		// Block Header for left channel        predictedSampleL = *(short *)srcLeft;        srcLeft += sizeof(short);        *(short *)dst = FlipShort((short)predictedSampleL);        dst += sizeof(short);        *(short *)dst = FlipShort((short)stepIndexL);        dst += sizeof(short);		// Block Header for right channel        predictedSampleR = *(short *)srcRight;        srcRight += sizeof(short);        *(short *)dst = FlipShort((short)predictedSampleR);        dst += sizeof(short);        *(short *)dst = FlipShort((short)stepIndexR);        dst += sizeof(short);        blockSamples--;		// Left and right channels get unsigned long interleaved        while (blockSamples > 0)        {            dwLeft  = 0;            dwRight = 0;            blockSamples -= 8;            for (i=0; i<8; i++)            {				// Encode a sample from the left channel                sample = *(short *)srcLeft;                srcLeft  += sizeof(short);                stepSize    = step[stepIndexL];                                              //  enclodedSampleL  = SampleEncode(sample, predictedSampleL, stepSize);                          		stepSize2 = stepSize;								    diff = sample - predictedSampleL;				    enclodedSampleL = 0;				    if (diff < 0)				    {				        enclodedSampleL = 8;				        diff = -diff;				    }								    // Bit 2				    if (diff >= stepSize2)				    {        				        enclodedSampleL |= 4;				        diff -= stepSize2;				    }									// Bit 1				    stepSize2 >>= 1;				    if (diff >= stepSize2)				    {        				        enclodedSampleL |= 2;				        diff -= stepSize2;				    }									// Bit 0				    stepSize2 >>= 1;				    if (diff >= stepSize2)				    {     				        enclodedSampleL |= 1;				    }	 /****************/			    difference = stepSize>>3;						    if (enclodedSampleL & 4) 			        difference += stepSize;						    if (enclodedSampleL & 2) 			        difference += stepSize>>1;						    if (enclodedSampleL & 1) 			        difference += stepSize>>2;						    if (enclodedSampleL & 8)			        difference = -difference;						    newSample = predictedSampleL + difference;						    if ((long)(short)newSample == newSample)			    {			       predictedSampleL = newSample;			    }				else				{					// Clip the sample to 16 bits				    if (newSample < -32768)				        newSample = -32768;				    if (newSample > 32767)				        newSample = 32767;									predictedSampleL = newSample;				}								/* inline extraction */ 				 stepIndexL += next_step[enclodedSampleL];   				 if (stepIndexL < 0)					stepIndexL = 0;  				 else if (stepIndexL > 88)        			stepIndexL = 88;        			/*************************/                dwLeft |= ((unsigned long)enclodedSampleL) << 4*i;								// Encode a sample from the right channel                sample = *(short *)srcRight;                srcRight  += sizeof(short);                stepSize    = step[stepIndexR];             //   enclodedSampleR  = SampleEncode(sample, predictedSampleR, stepSize);                   			 stepSize2 = stepSize;								    diff = sample - predictedSampleR;				    enclodedSampleR = 0;				    if (diff < 0)				    {				        enclodedSampleR = 8;				        diff = -diff;				    }								    // Bit 2				    if (diff >= stepSize2)				    {        				        enclodedSampleR |= 4;				        diff -= stepSize2;				    }									// Bit 1				    stepSize2 >>= 1;				    if (diff >= stepSize2)				    {        				        enclodedSampleR |= 2;				        diff -= stepSize2;				    }									// Bit 0				    stepSize2 >>= 1;				    if (diff >= stepSize2)				    {     				        enclodedSampleR |= 1;				    }/*********/				 difference = stepSize>>3;						    if (enclodedSampleR & 4) 			        difference += stepSize;						    if (enclodedSampleR & 2) 			        difference += stepSize>>1;						    if (enclodedSampleR & 1) 			        difference += stepSize>>2;						    if (enclodedSampleR & 8)			        difference = -difference;						    newSample = predictedSampleR + difference;						    if ((long)(short)newSample == newSample)			    {			       predictedSampleR = newSample;			    }				else				{					// Clip the sample to 16 bits				    if (newSample < -32768)				        newSample = -32768;				    if (newSample > 32767)				        newSample = 32767;									predictedSampleR = newSample;				}                                                	/* inline extraction */ 				 stepIndexR += next_step[enclodedSampleR];   				 if (stepIndexR < 0)					stepIndexR = 0;  				 else if (stepIndexR > 88)        			stepIndexR = 88;        			/*************************/        			                dwRight    |= ((unsigned long)enclodedSampleR) << 4*i;            }			// Write out the unsigned longS            *(unsigned long *)dst = FlipLong(dwLeft);            dst += sizeof(unsigned long);            *(unsigned long *)dst = FlipLong(dwRight);            dst += sizeof(unsigned long);        }    }    //  Save the the step index    (*savedStepIndexL) = stepIndexL;    (*savedStepIndexR) = stepIndexR;	// Return the number of bytes written    return (unsigned long)(dst - dstStart);}void deInterleaveAudio (Ptr sourcePtr,Ptr secondChannel, long dataLength,short wordSize){	long z;			if (wordSize == 1)	{		for (z=0;z<dataLength;z+=4L)		{				*(Byte *)(sourcePtr + (z>>2)) = *(Byte *)(sourcePtr + z);				*(Byte *)(secondChannel + (z>>2)) = *(Byte *)(sourcePtr + z + 1L);				*(Byte *)(sourcePtr + (z>>2) + 1L) = *(Byte *)(sourcePtr + z + 2L);				*(Byte *)(secondChannel + (z>>2) + 1L) = *(Byte *)(sourcePtr + z + 3L);		}	}	else	{		for (z=0;z<dataLength;z+=4L)		{			*(short *)(sourcePtr + (z>>1)) = *(short *)(sourcePtr + z);			*(short *)(secondChannel + (z>>1)) = *(short *)(sourcePtr + z + 2L);		}	}}