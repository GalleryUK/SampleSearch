#define lastItem 9#define numElements 24 #include "prefs.h"extern newPrefsRec theNewPrefs;#define kSelectedMiddle 1#define kUnSelectedMiddle 2#define kUnSelRightEnd 3#define kSelOverUnSel 4#define kUnSelUnderUnSel 5#define kUnSelUnderSel 6#define kSelLeftEnd 7#define kSelRightEnd 8#define kUnSelLeftEnd 9#define kUnSelDragHilite 10#define kSelDragHilite 11Boolean setUpTabs(void);Boolean calcDrawingArray(void);Boolean drawTabs(short top,short left);Boolean evenNum(short number);void	drawColourIconIII(short left,short top,short cicnResID);Boolean hiliteCell(short cellNumber, Boolean hilite,short top,short left);short mouseInside (Point thePoint, short top, short left);void tmain(void);extern WindowPtr	myWindow;void tmain(void){	WindowPtr theWin;	short j;	Point localPt;	short lastHilite = -1;	short cellSel;			setUpTabs();		calcDrawingArray();		drawTabs(10,10);		while (!Button())	{		GetMouse(&localPt);		cellSel = mouseInside (localPt, 10, 10);		if (cellSel == -1)		{			if (lastHilite >= 0)			{				hiliteCell(lastHilite, false,10,10);				lastHilite = -1;			}		}		else		{			if (lastHilite != cellSel)			{				if (lastHilite >= 0)				{					hiliteCell(lastHilite, false,10,10);					lastHilite = -1;				}				hiliteCell(cellSel, true,10,10);				lastHilite = cellSel;			}		}	}}Str31 tabItem[lastItem + 1];Boolean tabSelected[lastItem + 1];short drawtablist[numElements];Rect elementRect[numElements];RGBColor theSelBackColor,theUnSelBackColor,saveWhite;short lastElement;Boolean setUpTabs(void){	short j,z;	MenuHandle tabsMenu;	for (j=0;j<=lastItem;j++)	{		BlockMove(theNewPrefs.tabName[j],tabItem[j],*(theNewPrefs.tabName[j])+1);		/*NumToString((long)j,tabItem[j]);*/		tabSelected[j] = false;		/*theNewPrefs.tabLockedtabLocked[j] = false;*/		}		tabSelected[theNewPrefs.whichTab] = true;			theSelBackColor.red = 0xFFFF;	theSelBackColor.green = 0xFFFF;	theSelBackColor.blue = 0xFFFF;		theUnSelBackColor.red = 52224;	theUnSelBackColor.green = 52224;	theUnSelBackColor.blue = 65280;		saveWhite.red = 0xFFFF;	saveWhite.green = 0xFFFF;	saveWhite.blue = 0xFFFF;		tabsMenu = GetMHandle(139);	for (z=0;z<=9;z++)	{		SetItem(tabsMenu,z+1,theNewPrefs.tabName[z]);	}}Boolean calcDrawingArray(void){	short j;	short x,y, sequencex;	Rect pictRect;	PicHandle thePic;		lastElement = 0;		for (j=0;j<=lastItem;j++)	{		switch (j)		{		 	case 0:		 		switch (tabSelected[j])		 		{		 			case true:		 				drawtablist[lastElement] = kSelLeftEnd;		 				lastElement ++;		 				drawtablist[lastElement] = kSelectedMiddle;		 				lastElement ++;		 						 				if ((j + 1) < lastItem)		 				{			 				switch (tabSelected[j + 1])			 				{			 					case true:			 									 					break;			 									 					case false:			 						drawtablist[lastElement] = kSelOverUnSel;		 							lastElement ++;			 					break;			 				}		 				}		 				else		 				{		 					drawtablist[lastElement] = kSelRightEnd;		 					lastElement ++;		 				}		 						 			break;			 						 			case false:		 				drawtablist[lastElement] = kUnSelLeftEnd;		 				lastElement ++;		 				drawtablist[lastElement] = kUnSelectedMiddle;		 				lastElement ++;		 						 				if ((j + 1) < lastItem)		 				{			 				switch (tabSelected[j + 1])			 				{			 					case true:			 						drawtablist[lastElement] = kUnSelUnderSel;		 							lastElement ++;			 					break;			 									 					case false:			 						drawtablist[lastElement] = kUnSelUnderUnSel;		 							lastElement ++;			 					break;			 				}		 				}		 				else		 				{		 					drawtablist[lastElement] = kUnSelRightEnd;		 					lastElement ++;		 				}		 			break;		 		}		 	break;		 			 	case lastItem:		 		switch (tabSelected[j])		 		{		 			case true:		 				drawtablist[lastElement] = kSelectedMiddle;		 				lastElement ++;		 							 				drawtablist[lastElement] = kSelRightEnd;		 				lastElement ++;					 			break;			 						 			case false:		 				drawtablist[lastElement] = kUnSelectedMiddle;		 				lastElement ++;		 						 				drawtablist[lastElement] = kUnSelRightEnd;		 				lastElement ++;		 			break;		 		}		 	break;					default:				switch (tabSelected[j])		 		{		 			case true:		 				drawtablist[lastElement] = kSelectedMiddle;		 				lastElement ++;		 						 				switch (tabSelected[j + 1])		 				{		 					case true:		 									 					break;		 								 					case false:		 						drawtablist[lastElement] = kSelOverUnSel;	 							lastElement ++;		 					break;		 				}		 			break;			 						 			case false:		 				drawtablist[lastElement] = kUnSelectedMiddle;		 				lastElement ++;		 							 			switch (tabSelected[j + 1])		 				{		 					case true:		 						drawtablist[lastElement] = kUnSelUnderSel;	 							lastElement ++;		 					break;		 								 					case false:		 						drawtablist[lastElement] = kUnSelUnderUnSel;	 							lastElement ++;		 					break;		 				}		 			break;		 		}			break;		}	}			sequencex = 0;		for (j=0;j<lastElement;j++)	{		thePic = GetPicture(drawtablist[j]);		if (!thePic)		{			Debugger();		}		pictRect = (*thePic)->picFrame;		x = pictRect.left;		pictRect.left = 0;		pictRect.right -= x;		x = pictRect.right;				y = pictRect.top;		pictRect.top = 0;		pictRect.bottom -= y;		y = pictRect.bottom;				pictRect.left += sequencex;		pictRect.right += sequencex;				sequencex += x;		elementRect[j] = pictRect;	}}Boolean drawTabs(short top,short left){	short j,x,y, sequencex;	Rect pictRect;	PicHandle thePic;	RGBColor colorr;	GrafPtr savePort;		GetPort (&savePort);	SetPort (myWindow);	TextFont (geneva);	TextSize(9);	sequencex = left;		for (j=0;j<lastElement;j++)	{		thePic = GetPicture(drawtablist[j]);				pictRect = elementRect[j];				pictRect.top += top;		pictRect.bottom += top;				pictRect.left += left;		pictRect.right += left;				DrawPicture(thePic,&pictRect);				if (!evenNum(j))		{			InsetRect(&pictRect,4,5);			pictRect.top += 3;			pictRect.bottom += 3;			TextSize(9);						switch (tabSelected[j >> 1])			{				case true:					RGBBackColor(&theSelBackColor);				break;								case false:					RGBBackColor(&theUnSelBackColor);				break;			}							TextBox(tabItem[j >> 1] + 1,*tabItem[j >> 1],&pictRect,1);			RGBBackColor(&saveWhite);						if (theNewPrefs.tabLocked[j >> 1])				drawColourIconIII(pictRect.left-7,pictRect.top + 3,600);		}				pictRect = elementRect[j];		pictRect.top += top;		pictRect.bottom += top;		pictRect.left += left;		pictRect.right += left;		colorr.red = 0xFFFF;		colorr.green = 0xFFFF;		colorr.blue = 0xFFFF;		RGBForeColor(&colorr);					if (drawtablist[j] == kSelectedMiddle)		{			MoveTo(pictRect.left,pictRect.bottom);			LineTo(pictRect.right,pictRect.bottom);		}		if (drawtablist[j] == kSelOverUnSel)		{			MoveTo(pictRect.left,pictRect.bottom);			LineTo(pictRect.right-5,pictRect.bottom);				}		if (drawtablist[j] == kUnSelUnderSel)		{			MoveTo(pictRect.left+3,pictRect.bottom);			LineTo(pictRect.right,pictRect.bottom);		}		if (drawtablist[j] == kSelLeftEnd)		{			MoveTo(pictRect.left,pictRect.bottom);			LineTo(pictRect.right,pictRect.bottom);		}		if (drawtablist[j] == kSelRightEnd)		{			MoveTo(pictRect.left,pictRect.bottom);			LineTo(pictRect.right,pictRect.bottom);		}				colorr.red = 0;		colorr.green = 0;		colorr.blue = 0;		RGBForeColor(&colorr);			/*			if (tabSelected[j>>1] )		{			RGBColor colorr;						pictRect = elementRect[j];					pictRect.top += top;			pictRect.bottom += top;					pictRect.left += left;			pictRect.right += left;							colorr.red = 0xFFFF;			colorr.green = 0xFFFF;			colorr.blue = 0xFFFF;						RGBForeColor(&colorr);						MoveTo(pictRect.left,pictRect.bottom);			LineTo(pictRect.right,pictRect.bottom);						colorr.red = 0;			colorr.green = 0;			colorr.blue = 0;						RGBForeColor(&colorr);		}				if (tabSelected[(j>>1)-1] && evenNum(j))		{			RGBColor colorr;						pictRect = elementRect[j];					pictRect.top += top;			pictRect.bottom += top;					pictRect.left += left;			pictRect.right += left;							colorr.red = 0xFFFF;			colorr.green = 0xFFFF;			colorr.blue = 0xFFFF;						RGBForeColor(&colorr);						MoveTo(pictRect.left,pictRect.bottom);			LineTo(pictRect.right - 5,pictRect.bottom);						colorr.red = 0;			colorr.green = 0;			colorr.blue = 0;						RGBForeColor(&colorr);		}*/	}	//TextFont(0);	//TextSize(12);	SetPort (savePort);	return;}Boolean evenNum(short number){	return (((number >> 1) << 1) == number);}Boolean hiliteCell(short cellNumber, Boolean hilite,short top,short left){	PicHandle thePic;	Rect pictRect;			switch (hilite)	{		case true:			switch (tabSelected[cellNumber])			{				case true:					thePic = GetPicture(kSelDragHilite);				break;								case false:					thePic = GetPicture(kUnSelDragHilite);				break;			}		break;				case false:			switch (tabSelected[cellNumber])			{				case true:					thePic = GetPicture(kSelectedMiddle);				break;								case false:					thePic = GetPicture(kUnSelectedMiddle);				break;			}		break;	}		pictRect = 	elementRect[(cellNumber * 2) + 1];	pictRect.top += top;	pictRect.bottom += top;	pictRect.left += left;	pictRect.right += left;		DrawPicture(thePic,&pictRect);			InsetRect(&pictRect,4,5);	pictRect.top += 3;	pictRect.bottom += 3;	TextSize(9);		switch (tabSelected[cellNumber])	{		case true:			RGBBackColor(&theSelBackColor);		break;				case false:			RGBBackColor(&theUnSelBackColor);		break;	}			TextFont(geneva);	TextSize(9);	TextBox(tabItem[cellNumber] + 1,*tabItem[cellNumber],&pictRect,1);	//TextFont(0);	//TextSize(12);		RGBBackColor(&saveWhite);}extern short totfindcounter;	extern Boolean	reFound;extern Boolean folderSearch;extern Boolean SkipList;short mouseInside (Point thePoint, short top, short left){	short j;		thePoint.v -= top;	thePoint.h -= left;		for (j=0;j<=lastItem;j++)	{		if(PtInRect(thePoint,&elementRect[(j * 2) + 1])) 		{			return j;		}	}		return -1;}Boolean makefaveFile(short listIndex,FSSpec *theFaveFile, FSSpec *theFaveInfo);void makeFaveTabSpecs(short theOne);void eraseAllTabs(void);void eraseAllTabs(void){	short z,j;	FSSpec faveFile,myFaveInfo;	OSErr iErr;	for (z=0;z<=9;z++)	{		makefaveFile(z,&faveFile,&myFaveInfo);		iErr = FSpDelete(&faveFile);		if (iErr)		{			//genError("\pProblem deleting favefile");		}		iErr = FSpDelete(&myFaveInfo);		if (iErr)		{			//genError("\pProblem deleting favefile info");		}	}	for (j=0;j<=lastItem;j++)	{		makeFaveTabSpecs(j);		NumToString ((long)j,theNewPrefs.tabName[j]);			}	setUpTabs();	drawTabs(55,0);	totfindcounter = 0;  	reFound = true;  	SkipList = true;  	folderSearch = false;}