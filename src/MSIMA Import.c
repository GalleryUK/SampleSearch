#include "imaWAVADPCM.h"	#define kBufferSize	(1024 * 1)#define FlipShort(x) (((((unsigned short)(x))<<8)&0xFF00) | ((((unsigned short)(x))>>8)&0x00FF))	#define FlipLong(x) (((((unsigned long)(x))<<24)&0xFF000000)|((((unsigned long)(x))<<8)&0x00FF0000)|((((unsigned long)(x))>>8)&0x0000FF00) | ((((unsigned long)(x))>>24)&0x000000FF))	#define LOWORD(x) ((unsigned short)((x) & 0x0000FFFF))#define HIWORD(x) ((unsigned short)(((x)>>16) & 0x0000FFFF))		#define MAKELONG(x,y) (((unsigned long)((unsigned short)(x)))|((unsigned long)((unsigned short)(y)))<<16)#define min(x, y) ((x)>(y)?(y):(x))#define WAVE_FORMAT_IMA_ADPCM	0x0011#define IMAADPCM_HEADER_LENGTH      4    // In bytes, per channel.// Defines for the warning dialog.#define kReturnKey	13#define kEnterKey	 3#define kEscapeKey	27#define kAlertDlgID	128typedef struct SoundChunk {	long howMany;	long startWhere;	short trackNum; 	Ptr pBuffer;} SoundChunk;/*******************************************************************************************	DoImport		This does the work of reading the WAVE file, converting, and adding the	decompressed data to the document.*******************************************************************************************/OSErr DoImport(Ptr inPtr, Ptr out1Ptr, Ptr  out2Ptr, short fileRef, long numBytes, short firstTrack, short channels, long nBlockAlign){	OSErr			osErr;	long			bytesLeft = numBytes;	long			readSize;	unsigned long			bytesReturned;	SoundChunk 		ourSound;	long			curWritePos = 0;	OSErr			err;	long			bytesPerSample = 2;		while (bytesLeft > 0)	{		// Always decode blocks that are multiples of nBlockAlign		readSize = (kBufferSize / nBlockAlign) * nBlockAlign;				if (readSize > bytesLeft)			readSize = bytesLeft;		osErr = FSRead(fileRef, &readSize, inPtr);		if (osErr != noErr )			return osErr;		bytesLeft -= readSize;				if (channels == 1)				bytesReturned = DecodeMono16((Byte*)inPtr, readSize, (Byte*)out1Ptr, nBlockAlign);			else				bytesReturned = DecodeStereo16((Byte*)inPtr, readSize, (Byte*)out1Ptr, (Byte*)out2Ptr,nBlockAlign);		if (bytesReturned == 0)		{			 // An error has occured			break;		}						 /* write / play the data */ 		 		if (channels == 2)		{						 /* write / play the data */ 		 		}						// Update the progress dialog...			// ...and check for a user cancel.	}		return 0;	}/*******************************************************************************************	StartProgressDialog		Show the progress dialog.*******************************************************************************************//*******************************************************************************************	FinishProgressDialog		Terminate the progress dialog.*******************************************************************************************//*******************************************************************************************	SeekToChunk		Seek to beginning of chunk data.  Assumes file is positioned at the start of	a RIFF header.  Leaves file positioned at actual data, not the header.  Retruns	the length of the data if found, or 0 if not found.*******************************************************************************************/long SeekToChunk(short fileRef, long tag){	RIFFChunkHead	ch;	long			readSize;	OSErr			osErr;	long			initialPos;	readSize = sizeof(RIFFChunkHead);	osErr = GetFPos(fileRef, &initialPos);	if (osErr != noErr && osErr != eofErr)		return 0;	do {		// Read in chunk header			osErr = FSRead( fileRef, &readSize, &ch );		if (osErr != noErr && osErr != eofErr)			goto FAIL;		ch.ckDataSize = (long)FlipLong(ch.ckDataSize);				if (ch.ckID == tag)		{			// We found the chunk we were looking for			return ch.ckDataSize;		}		else		{			// skip to next chunk header			osErr = SetFPos(fileRef, fsFromMark, ch.ckDataSize);			if (osErr != noErr && osErr != eofErr)				goto FAIL;		}	} while (1);	FAIL:	SetFPos(fileRef, fsFromStart, initialPos);	return 0; }/*******************************************************************************************	ReadWaveHeader		Read in header info from file, and return TRUE if it's a valid Microsoft IMA	ADPCM compressed WAVE file.  Leaves file pointing at chunk header following the	WAVE header chunk (usually the WAVE data chunk).	*******************************************************************************************/IMAADPCMWAVEFORMAT 	format;		Boolean ReadWaveHeader(short fileRef){	RIFFChunkHead	ch;	long			readSize;	OSErr			osErr;	long			riffTypeTag;	long			chunkSize;			// Read and verify RIFF header	readSize = sizeof(RIFFChunkHead);	SetFPos(fileRef, fsFromStart, 0);	osErr = FSRead( fileRef, &readSize, &ch );	if (osErr != noErr && osErr != eofErr || ch.ckID != 'RIFF')		goto FAIL;	// Read and verify WAVE RIFF type	readSize = sizeof(long);	osErr = FSRead( fileRef, &readSize, &riffTypeTag );	if (osErr != noErr && osErr != eofErr || riffTypeTag != 'WAVE')		goto FAIL;	// Read the WAVE header		chunkSize = SeekToChunk(fileRef, 'fmt ');	if (chunkSize == 0 || chunkSize < sizeof(IMAADPCMWAVEFORMAT))		goto FAIL;	readSize = sizeof(IMAADPCMWAVEFORMAT);	osErr = FSRead( fileRef, &readSize, &format );	if (osErr != noErr && osErr != eofErr)		goto FAIL;	SetFPos(fileRef, fsFromMark, chunkSize - sizeof(IMAADPCMWAVEFORMAT)); // go to next header		// Fix up the Byte ordering in the header!	format.wFormatTag = FlipShort(format.wFormatTag);	format.nChannels = FlipShort(format.nChannels);	format.nSamplesPerSec = FlipLong(format.nSamplesPerSec);	format.nAvgBytesPerSec = FlipLong(format.nAvgBytesPerSec);	format.nBlockAlign = FlipShort(format.nBlockAlign);	format.wBitsPerSample = FlipShort(format.wBitsPerSample);	format.cbSize = FlipShort(format.cbSize);	format.wSamplesPerBlock = FlipShort(format.wSamplesPerBlock);		// Veryify the wave header	if (format.wFormatTag != WAVE_FORMAT_IMA_ADPCM)		goto FAIL;	// Can only handle stereo or mono.	if (format.nChannels > 2)		goto FAIL;		// Everything seems to be OK, so....	return TRUE;			FAIL:	return FALSE;	}/*	Decode routines */const short next_step[16] ={    -1, -1, -1, -1, 2, 4, 6, 8,    -1, -1, -1, -1, 2, 4, 6, 8};const short step[89] ={        7,     8,     9,    10,    11,    12,    13,       14,    16,    17,    19,    21,    23,    25,       28,    31,    34,    37,    41,    45,    50,       55,    60,    66,    73,    80,    88,    97,      107,   118,   130,   143,   157,   173,   190,      209,   230,   253,   279,   307,   337,   371,      408,   449,   494,   544,   598,   658,   724,      796,   876,   963,  1060,  1166,  1282,  1411,     1552,  1707,  1878,  2066,  2272,  2499,  2749,     3024,  3327,  3660,  4026,  4428,  4871,  5358,     5894,  6484,  7132,  7845,  8630,  9493, 10442,    11487, 12635, 13899, 15289, 16818, 18500, 20350,    22385, 24623, 27086, 29794, 32767};/****************************************************************************	SampleDecode		Decode a single sample.****************************************************************************/short SampleDecode(short encodedSample, short predictedSample, short stepSize){    long	difference;    long	newSample;    difference = stepSize>>3;    if (encodedSample & 4)         difference += stepSize;    if (encodedSample & 2)         difference += stepSize>>1;    if (encodedSample & 1)         difference += stepSize>>2;    if (encodedSample & 8)        difference = -difference;    newSample = predictedSample + difference;    if ((long)(short)newSample == newSample)    {        return (short)newSample;    }	// Clip the sample to 16 bits    if (newSample < -32768)        newSample = -32768;    if (newSample > 32767)        newSample = 32767;	return (short)newSample;}/****************************************************************************	NextStepIndex		Calculate step index to use for next encode.****************************************************************************/short NextStepIndex(short encodedSample, short stepIndex){    stepIndex += next_step[encodedSample];    if (stepIndex < 0)        stepIndex = 0;    else if (stepIndex > 88)        stepIndex = 88;    return (stepIndex);}/****************************************************************************	ValidStepIndex		Make sure an index is OK.****************************************************************************/Boolean ValidStepIndex(short stepIndex){    if (stepIndex >= 0 && stepIndex <= 88)        return TRUE;    else        return FALSE;}/****************************************************************************	DecodeMono8		Decode mono IMA ADPCM chunks into a 8 bit sample buffer.****************************************************************************//****************************************************************************	DecodeMono16		Decode mono IMA ADPCM chunks into a 16 bit sample buffer.****************************************************************************/unsigned long DecodeMono16(Byte* src, unsigned long srcLength, Byte* dst, unsigned short blockAlign){    Byte*	dstStart;    unsigned short    blockLength;    Byte    sample;    short     stepSize;    short     encodedSample;    short     predictedSample;    short     stepIndex;    long	difference;	long	newSample;			    			        dstStart = dst;    while (srcLength >= IMAADPCM_HEADER_LENGTH)    {        unsigned long	headerDWORD;        blockLength = (unsigned short)min(srcLength, blockAlign);        srcLength -= blockLength;        blockLength -= IMAADPCM_HEADER_LENGTH;		// Get the block header        headerDWORD = *(unsigned long *)src;        headerDWORD = FlipLong(headerDWORD);        src   += sizeof(unsigned long);        predictedSample = (short)LOWORD(headerDWORD);        stepIndex = (short)(Byte)HIWORD(headerDWORD);		// Make sure the step index is valid        if (!ValidStepIndex(stepIndex))            return 0;		// Write the first sample        *(short *)dst = (short)predictedSample;        dst += sizeof(short);        while (blockLength--)        {        	// Get a Byte from the source            sample = *src++;			// Decode the first sample in the Byte            encodedSample  = (sample & (Byte)0x0F);            stepSize   = step[stepIndex];                        /***   in line extraction   ******/  						    difference = stepSize>>3;						    if (encodedSample & 4) 			        difference += stepSize;						    if (encodedSample & 2) 			        difference += stepSize>>1;						    if (encodedSample & 1) 			        difference += stepSize>>2;						    if (encodedSample & 8)			        difference = -difference;						    newSample = predictedSample + difference;						    if ((long)(short)newSample == newSample)			    {			        predictedSample = newSample;			    }				else				{					// Clip the sample to 16 bits				    if (newSample < -32768)				        newSample = -32768;				    if (newSample > 32767)				        newSample = 32767;									predictedSample = newSample;				}						/******/                                  //  predictedSample = SampleDecode(encodedSample, predictedSample, stepSize);                     //   stepIndex  = NextStepIndex(encodedSample, stepIndex);			/****in line extraction */						stepIndex += next_step[encodedSample];						    if (stepIndex < 0)			        stepIndex = 0;			    else if (stepIndex > 88)			        stepIndex = 88;						/******/						            *(short *)dst = (short)predictedSample;            dst += sizeof(short);			// Decode the second sample in the Byte            encodedSample  = (sample >> 4);            stepSize   = step[stepIndex];                                 //   predictedSample = SampleDecode(encodedSample, predictedSample, stepSize);         //   stepIndex  = NextStepIndex(encodedSample, stepIndex);						/***   in line extraction   ******/  						    difference = stepSize>>3;						    if (encodedSample & 4) 			        difference += stepSize;						    if (encodedSample & 2) 			        difference += stepSize>>1;						    if (encodedSample & 1) 			        difference += stepSize>>2;						    if (encodedSample & 8)			        difference = -difference;						    newSample = predictedSample + difference;						    if ((long)(short)newSample == newSample)			    {			        predictedSample = newSample;			    }				else				{					// Clip the sample to 16 bits				    if (newSample < -32768)				        newSample = -32768;				    if (newSample > 32767)				        newSample = 32767;									predictedSample = newSample;				}						/******/                                  //  predictedSample = SampleDecode(encodedSample, predictedSample, stepSize);                     //   stepIndex  = NextStepIndex(encodedSample, stepIndex);			/****in line extraction */						stepIndex += next_step[encodedSample];						    if (stepIndex < 0)			        stepIndex = 0;			    else if (stepIndex > 88)			        stepIndex = 88;						/******/									             *(short *)dst = (short)predictedSample;            dst += sizeof(short);        }    }	// Return the number of bytes written    return (unsigned long)(dst - dstStart);}/****************************************************************************	DecodeStereo16		Decode stereo IMA ADPCM chunks into a two 16 bit sample buffers.****************************************************************************/unsigned long DecodeStereo16(Byte* src, unsigned long srcLength, Byte* dstLeft, Byte* dstRight, unsigned short blockAlign){    short     i;    Byte*	dstStart;    unsigned short    blockLength;    short     stepSize;    unsigned long   headerDWORD;    unsigned long   leftDWORD;    short     encodedSampleL;    short     predictedSampleL;    short     stepIndexL;    unsigned long   rightDWORD;    short     encodedSampleR;    short     predictedSampleR;    short     stepIndexR;    dstStart = dstLeft;        while (srcLength != 0)    {        blockLength = blockAlign;        srcLength -= blockLength;        blockLength -= IMAADPCM_HEADER_LENGTH * 2;		// Get the block header for the left channel        headerDWORD = *(unsigned long *)src;        headerDWORD = FlipLong(headerDWORD);        src += sizeof(unsigned long);        predictedSampleL = (short)LOWORD(headerDWORD);        stepIndexL = (short)(Byte)HIWORD(headerDWORD);		// Make sure the step index is valid        if (!ValidStepIndex(stepIndexL))            return 0;        		// Get the block header for the right channel        headerDWORD = *(unsigned long *)src;        headerDWORD = FlipLong(headerDWORD);        src += sizeof(unsigned long);        predictedSampleR = (short)LOWORD(headerDWORD);        stepIndexR = (short)(Byte)HIWORD(headerDWORD); 		// Make sure the step index is valid        if (!ValidStepIndex(stepIndexR))            return 0;        		// Write the first sample        *(short*)dstLeft = predictedSampleL;        *(short*)dstRight = predictedSampleR;        dstLeft += sizeof(short);        dstRight += sizeof(short);                // Decode the block.		// The left channel gets a unsigned long, then the right		// Channel gets a unsigned long, etc.        while (blockLength != 0)        {			// Do a unsigned long of left and right at the same time            leftDWORD = *(unsigned long *)src;            leftDWORD = FlipLong(leftDWORD);            src += sizeof(unsigned long);            rightDWORD = *(unsigned long *)src;            rightDWORD = FlipLong(rightDWORD);            src += sizeof(unsigned long);            for (i=0; i<8; i++)            {				// Decode a nibble of the left channel                encodedSampleL  = (unsigned short)(leftDWORD & 0x0F);                stepSize = step[stepIndexL];                predictedSampleL = SampleDecode(encodedSampleL, predictedSampleL, stepSize);                stepIndexL = NextStepIndex(encodedSampleL, stepIndexL);		        *(short*)dstLeft = (short)predictedSampleL;		        dstLeft += sizeof(short);                leftDWORD >>= 4; // shift for next nibble 				// Decode a nibble of the right channel                encodedSampleR  = (unsigned short)(rightDWORD & 0x0F);                stepSize = step[stepIndexR];                predictedSampleR = SampleDecode(encodedSampleR, predictedSampleR, stepSize);                stepIndexR = NextStepIndex(encodedSampleR, stepIndexR);		        *(short*)dstRight = (short)predictedSampleR;		        dstRight += sizeof(short);                rightDWORD >>= 4; // shift for next nibble            }            blockLength -= 8;        }    }    // Return the number of bytes in each buffer.  It is calculated for    // the left buffer, but both have the same number of bytes.    return (unsigned long)(dstLeft - dstStart);}