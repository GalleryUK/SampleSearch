#include "imaWAVADPCM.h"Byte * sourceIMA;short * decodedLeft[2];short * decodedRight[2];short * tempBuffer;#define kBufferSize	(1024 * 16)#define kBlockSize		0x200 extern IMAADPCMWAVEFORMAT 	format;extern FSSpec theConvertDestLoc;#include "SampleSearch.h"#include "Globals.h"#include "xSound.h"#include <Resources.h>#include <SoundInput.h>extern Boolean DialogPresent;extern Boolean plusMode;OSErr playIMAWAV (FSSpec mySpec);short destRefNum;Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);#define kWaitIfFull TRUE	// wait for room in queue#define kSoundComplete  1	// last command in channel;  Application definedextern long dblBufferSize;extern Boolean gCallBackPerformed;  extern Boolean autoSustain;void SDIIPlay(FSSpec,short playFreq);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);SndChannelPtr CreateSndChannel(Boolean Stereo);void CallSndPlay(Handle);OSErr InstallCallBack(SndChannelPtr);void pitchIt(void);short isPressed(unsigned short k );void genErrorN(Str255 myText,long Errno);OSErr AlterPitch(SndChannelPtr chan, Fixed theRatio);extern short keyAcrossTheTop[14];extern Fixed keyRatio[14];extern SndChannelPtr mySndChan;Boolean progressDisp(short percentFull);extern short  arrowPressed;extern short refNum;extern long 					blockSize;extern short 					numTracks; /* stereo */extern unsigned long 			sampleRate;extern unsigned long			bytes;extern short 					wordSize;extern Ptr inputLeft;extern Ptr inputRight;extern Ptr encodedIMA;short arrowKey (void);Boolean pleaseStop(void);#define kLeftArrowPressed 1#define kRightArrowPressed 2	#define kDownArrowPressed 3#define kUpArrowPressed 4void playIMAWAVMany(void){	Cell theCell;	short theindex;	short myshort;		SetPt( &theCell, 0,0 );		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));			playIMAWAV((*therealResults)[theindex]);				LNextCell( TRUE, TRUE, &theCell, myList ); 	}}void IMAWAV2SDIIMany(void){	Cell theCell;	short theindex;	short myshort;		Boolean memoryError = false;	getConvertDest();	SetPt( &theCell, 0,0 );		writeLogS((unsigned char *)"Began IMA WAV to SDII Convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (!IMAWAV2SDII((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}OSErr playIMAWAV (FSSpec mySpec){	OSErr			osErr;	long		numBytes;	long			bytesLeft;	long			readSize, curPos;	unsigned long	bytesReturned,bytesReturned2;	long			curWritePos = 0;	OSErr			err = 0,iErr;	long			bytesPerSample = 2;	FInfo 			fndrInfo;	short sourceRefNum;	Boolean secondBuffer;		ExtSoundHeader      sound;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent,myEvent;		long z;	gCallBackPerformed = false;	useTwo = 0;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'WAVE' && fndrInfo.fdType != '.WAV')	{		return -1;	}		iErr = FSpOpenDF(&mySpec,fsRdPerm,&sourceRefNum);	if (!ReadWaveHeader(sourceRefNum))	{		FSClose (sourceRefNum);		return -1;	}		theRate = format.nSamplesPerSec;	theWordSize = 2;	stereo = (format.nChannels == 2);					mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	osErr = allocateMemoryIMA();	if(osErr)	{		return osErr;	}	numBytes = SeekToChunk(sourceRefNum, 'data');	if (numBytes == 0)	{		err = -2;		SysBeep(5);		goto FINISHIT;	}			secondBuffer = false;						useTwo = 0;						bytesLeft = numBytes;			readSize = (kBufferSize / format.nBlockAlign) * format.nBlockAlign;				if (readSize > bytesLeft)			readSize = bytesLeft;		osErr = FSRead(sourceRefNum, &readSize, sourceIMA);			bytesLeft -= readSize;				if (format.nChannels == 1)				bytesReturned = DecodeMono16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[useTwo], format.nBlockAlign);			else				bytesReturned = DecodeStereo16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[useTwo], (Byte*)decodedRight[useTwo],format.nBlockAlign);		if (bytesReturned == 0)		{			 // An error has occured		}		if (stereo)		{			interleave16BitBuffers ((Ptr)decodedLeft[useTwo], (Ptr)decodedRight[useTwo], (Ptr)tempBuffer, bytesReturned);				BlockMove (tempBuffer,decodedLeft[useTwo],bytesReturned*2L);		}								if (bytesLeft > 0)		{						useTwo = !useTwo;						readSize = (kBufferSize / format.nBlockAlign) * format.nBlockAlign;						if (readSize > bytesLeft)				readSize = bytesLeft;				osErr = FSRead(sourceRefNum, &readSize, sourceIMA);						bytesLeft -= readSize;						if (format.nChannels == 1)					bytesReturned2 = DecodeMono16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[useTwo], format.nBlockAlign);				else					bytesReturned2 = DecodeStereo16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[useTwo], (Byte*)decodedRight[useTwo],format.nBlockAlign);				if (bytesReturned2 == 0)			{				 // An error has occured			}						secondBuffer = true;						if (stereo)			{				interleave16BitBuffers ((Ptr)decodedLeft[useTwo],(Ptr) decodedRight[useTwo], (Ptr)tempBuffer, bytesReturned2);					BlockMove (tempBuffer,decodedLeft[useTwo],bytesReturned2*2L);			}					useTwo = !useTwo;					}								sound.samplePtr =  (Ptr)decodedLeft[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = bytesReturned >> 1;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = 16;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/			cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd);	    	    gCallBackPerformed = false;		InstallCallBack (mySndChan);													if (secondBuffer)	{		useTwo = !useTwo;		sound.samplePtr =  (Ptr)decodedLeft[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = bytesReturned2 >> 1;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = 16;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/			cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	    	    gCallBackPerformed = false;		InstallCallBack (mySndChan);		useTwo = !useTwo;	}							while (bytesLeft > 0)	{		while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;				goto FINISHIT;			}		}				// Always decode blocks that are multiples of format.nBlockAlign		readSize = (kBufferSize / format.nBlockAlign) * format.nBlockAlign;				if (readSize > bytesLeft)			readSize = bytesLeft;		osErr = FSRead(sourceRefNum, &readSize, sourceIMA);		if (osErr != noErr && osErr != eofErr )		{			goto FINISHIT;		}		bytesLeft -= readSize;				if (format.nChannels == 1)				bytesReturned = DecodeMono16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[useTwo], format.nBlockAlign);			else				bytesReturned = DecodeStereo16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[useTwo], (Byte*)decodedRight[useTwo],format.nBlockAlign);		if (bytesReturned == 0)		{			 // An error has occured			break;		}		if (stereo)		{			interleave16BitBuffers ((Ptr)decodedLeft[useTwo], (Ptr)decodedRight[useTwo], (Ptr)tempBuffer, bytesReturned);				BlockMove (tempBuffer,decodedLeft[useTwo],bytesReturned * 2L);		}				sound.samplePtr =  (Ptr)decodedLeft[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = bytesReturned >> 1;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = 16;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/			cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	   err = SndDoCommand(mySndChan,&cmd,true);	    	    gCallBackPerformed = false;		InstallCallBack (mySndChan);				/* at this point the decompressed data is in decodedLeft & decodedRight in buffer's' of size bytesReturned */		/* write / play the data */ 		if (format.nChannels == 2)		{						 /* write / play the data */ 		}				useTwo = !useTwo;				// Update the progress dialog...			// ...and check for a user cancel.	}	iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	while (theStat.scChannelBusy && !Button()  && !(pleaseStop() ||  (arrowPressed = arrowKey ())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}		iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);FINISHIT:	iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);	FSClose (sourceRefNum);	deAllocateMemory();	return err;}OSErr IMAWAV2SDII (FSSpec mySpec){	OSErr			osErr;	long		numBytes;	long			bytesLeft;	long			readSize, curPos;	unsigned long	bytesReturned;	long			curWritePos = 0;	OSErr			err = 0,iErr;	long			bytesPerSample = 2;	FInfo 			fndrInfo;	short sourceRefNum;	FSSpec destSpec;			float theFloat;    short thePercent;	ExtSoundHeader      sound;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent,myEvent;		long z;	gCallBackPerformed = false;	useTwo = 0;	BlockMove (&mySpec,&destSpec,70L);	destSpec.parID = theConvertDestLoc.parID;	destSpec.vRefNum = theConvertDestLoc.vRefNum;					iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'WAVE' && fndrInfo.fdType != '.WAV')	{		return -1;	}		iErr = FSpCreate(&destSpec,'Sd2a','Sd2f',0);	{		if (iErr == -48)		{			if (YesNo ("\pFile Exists, overwrite ?"))			{				FSpDelete (&destSpec);				iErr = FSpCreate(&destSpec,'Sd2a','Sd2f',0);			}			else			{				return -48;			}		}		}		iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRefNum);				iErr = FSpOpenDF(&mySpec,fsRdPerm,&sourceRefNum);	if (!ReadWaveHeader(sourceRefNum))	{		FSClose (sourceRefNum);		return -1;	}		theRate = format.nSamplesPerSec;	theWordSize = 2;	stereo = (format.nChannels == 2);			osErr = allocateMemoryIMA();	if(osErr)	{		return osErr;	}	numBytes = SeekToChunk(sourceRefNum, 'data');	if (numBytes == 0)	{		err = -2;		SysBeep(5);		goto FINISHIT;	}		progressCreate("\pde-compressing IMA WAV File");		bytesLeft = numBytes;		while (bytesLeft > 0)	{		// Always decode blocks that are multiples of format.nBlockAlign		readSize = (kBufferSize / format.nBlockAlign) * format.nBlockAlign;				if (readSize > bytesLeft)			readSize = bytesLeft;		osErr = FSRead(sourceRefNum, &readSize, sourceIMA);		if (osErr != noErr )			return osErr;		bytesLeft -= readSize;				if (format.nChannels == 1)		{			bytesReturned = DecodeMono16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[0], format.nBlockAlign);		}		else		{			bytesReturned = DecodeStereo16((Byte*)sourceIMA, readSize, (Byte*)decodedLeft[0], (Byte*)decodedRight[0],format.nBlockAlign);		}				if (bytesReturned == 0)		{			 // An error has occured			break;		}		inOutCount = bytesReturned;		if (format.nChannels == 1)		{			iErr = FSWrite(destRefNum,&inOutCount,decodedLeft[0]);		}		else		{			if (bytesReturned > 65536L)			{				genError("\pBuffer size mismatch");				goto FINISHIT;							}			interleave16BitBuffers ((Ptr)decodedLeft[0], (Ptr)decodedRight[0], (Ptr)decodedLeft[1],bytesReturned);				inOutCount = bytesReturned * 2L;				iErr = FSWrite(destRefNum,&inOutCount,decodedLeft[1]);		}		/* at this point the decompressed data is in decodedLeft & decodedRight in buffer's' of size bytesReturned */		/* write / play the data */ 		if (format.nChannels == 2)		{						 /* write / play the data */ 		}				theFloat = (((float)numBytes - (float)bytesLeft) / (float)numBytes) * (float)100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			goto FINISHIT;				}					// Update the progress dialog...			// ...and check for a user cancel.	}	progressDispos();FINISHIT:	FSClose (sourceRefNum);	FSClose (destRefNum);	writeSDIIResources(destSpec,theRate,(format.nChannels == 2),2);	deAllocateMemory();		addFileToList(destSpec);		return 0;}OSErr allocateMemoryIMA(void){	sourceIMA = (Byte *)NewPtrClear(36000L);	if (!sourceIMA)	{		return -99;	}	decodedLeft[0] = (short *)NewPtrClear(67000L);	if (!decodedLeft[0])	{		DisposPtr ((Ptr)sourceIMA);		return -99;	}	decodedLeft[1] = (short *)NewPtrClear(67000L);	if (!decodedLeft[1])	{		DisposPtr ((Ptr)decodedLeft[0]);		DisposPtr ((Ptr)sourceIMA);		return -99;	}			decodedRight[0] = (short *)NewPtrClear(67000L);	if (!decodedRight[0])	{		DisposPtr ((Ptr)sourceIMA);		DisposPtr ((Ptr)decodedLeft[0]);		DisposPtr ((Ptr)decodedLeft[1]);		return -99;	}		decodedRight[1] = (short *)NewPtrClear(67000L);	if (!decodedRight[1])	{		DisposPtr ((Ptr)sourceIMA);		DisposPtr ((Ptr)decodedLeft[0]);		DisposPtr ((Ptr)decodedLeft[1]);		DisposPtr ((Ptr)decodedRight[0]);		return -99;	}		tempBuffer = (short *)NewPtrClear(67000L);	if (!tempBuffer)	{		DisposPtr ((Ptr)sourceIMA);		DisposPtr ((Ptr)decodedLeft[0]);		DisposPtr ((Ptr)decodedLeft[1]);		DisposPtr ((Ptr)decodedRight[0]);		DisposPtr ((Ptr)decodedRight[1]);		return -99;	}		return 0;}OSErr deAllocateMemory(void){	DisposPtr ((Ptr)sourceIMA);	DisposPtr ((Ptr)decodedLeft[0]);	DisposPtr ((Ptr)decodedRight[0]);	DisposPtr ((Ptr)decodedLeft[1]);	DisposPtr ((Ptr)decodedRight[1]);	DisposPtr ((Ptr)tempBuffer);}OSErr allocateMemoryCompressIMA(void){	encodedIMA = (Ptr)(Byte *)NewPtrClear(36000L);	if (!encodedIMA)	{		return -99;	}		inputLeft = (Ptr)(short *)NewPtrClear(67000L);	if (!inputLeft)	{		DisposPtr ((Ptr)encodedIMA);		return -99;	}		inputRight = (Ptr)(short *)NewPtrClear(67000L);	if (!inputRight)	{		DisposPtr ((Ptr)encodedIMA);		DisposPtr ((Ptr)inputLeft);		return -99;	}		return 0;}OSErr deAllocateCompressMemory(void){	DisposPtr ((Ptr)encodedIMA);	DisposPtr ((Ptr)inputLeft);	DisposPtr ((Ptr)inputRight);}void interleave16BitBuffers (Ptr leftBuffer, Ptr rightBuffer, Ptr stereoBuffer,long inOutCount){	unsigned long z;			for (z=0 ; z<inOutCount ; z+= 2)	{		*(short *)(stereoBuffer + (z * 2)) = *(short *)(leftBuffer + z);		*(short *)(stereoBuffer + (z * 2) + 2) = *(short *)(rightBuffer + z);	}}void SDII2IMAWAVMany(void){	Cell theCell;	short theindex;	short myshort;		Boolean memoryError = false;	getConvertDest();	SetPt( &theCell, 0,0 );		writeLogS((unsigned char *)"Began SDII to IMA WAV Convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (!SDII2IMAWAV((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}OSErr SDII2IMAWAV (FSSpec mySpec){	OSErr			osErr;	long		numBytes;	long			bytesLeft;	long			readSize, curPos,dataStart;	unsigned long	bytesReturned;	long			curWritePos = 0;	OSErr			err = 0,iErr;	long			bytesPerSample = 2;	FInfo 			fndrInfo;	short sourceRefNum;	FSSpec destSpec;	float theFloat;    short thePercent;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent,myEvent;	long ztotalBytesWritten, ztotalSamplesWritten;	long z;	gCallBackPerformed = false;	useTwo = 0;	BlockMove (&mySpec,&destSpec,70L);	destSpec.parID = theConvertDestLoc.parID;	destSpec.vRefNum = theConvertDestLoc.vRefNum;					if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes))	{		return -1;	}		if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	blockSize = kBlockSize;		numTracks = (stereo) ? 2 : 1;	sampleRate = theRate;	bytes = theBytes;	wordSize = theWordSize;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return -1;	}		iErr = FSpCreate(&destSpec,'MgAl','WAVE',0);	{		if (iErr == -48)		{			if (YesNo ("\pFile Exists, overwrite ?"))			{				FSpDelete (&destSpec);				iErr = FSpCreate(&destSpec,'MgAl','WAVE',0);			}			else			{				return -48;			}		}		}		iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRefNum);	if (iErr)	{		genError("\pCant open destination file");		return -48;	}		iErr = FSpOpenDF(&mySpec,fsRdPerm,&sourceRefNum);	if (iErr)	{		genError("\pCant open source file");		return -48;	}		/* write the wave header */		refNum = sourceRefNum;		WriteWaveHeaderInfo();	progressCreate("\pencoding IMA WAV File");		osErr = allocateMemoryCompressIMA();	if(osErr)	{		return osErr;	}	/* move the write file to the start of the data chunk */	SeekToChunk(destRefNum, 'data');		iErr = GetFPos(destRefNum,&dataStart);				bytesLeft = theBytes;			WriteWaveData(&ztotalBytesWritten, &ztotalSamplesWritten);	progressDispos();	iErr = FillInPlaceholders(ztotalBytesWritten + dataStart, ztotalSamplesWritten,ztotalBytesWritten);FINISHIT:	FSClose (sourceRefNum);	FSClose (destRefNum);	deAllocateCompressMemory();		addFileToList(destSpec);		return 0;}