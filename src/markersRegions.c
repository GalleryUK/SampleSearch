#include "SampleSearch.h"#include "Globals.h"#define outRegion 1#define inRegion 2Boolean markersRegionsMany(void);typedef struct markersHeader {short Version;long MarkerOffset;short NumMarkers;} markersHeader;typedef struct SD2marker {short MarkerType0;short MarkerType1;long Position;long Text;short CursorID;short MarkerID;long TextLength;} SD2marker;typedef struct myMarkers {long position;Str31 name;} myMarkers;typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;Boolean markersToRegions(FSSpec mySpec);Boolean regionsToMarkers(FSSpec mySpec);short markersPerRegion;void sortMarkers (myMarkers ** markersList,short NumMarkers);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);Boolean markersRegionsMany(void){	Cell theCell;	short theindex;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	ControlHandle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	short conversionType = 1;	markersPerRegion = 1;		/****************/	myDlg = GetNewDialog(11119,0L,(WindowPtr)-1);	//SetPort (myDlg);	GetDItem(myDlg,3,&iType,(Handle *)&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		GetDItem(myDlg,5,&iType,(Handle *)&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:				GetDItem(myDlg,3,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				markersPerRegion = 1;			break;						case 4:				GetDItem(myDlg,3,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				markersPerRegion = 2;			break;						case 5:				GetDItem(myDlg,5,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,6,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				conversionType = 1;			//	GetDItem(myDlg,3,&iType,(Handle *)&iHndl,&iRect);			//	SetCtlValue((ControlHandle)iHndl,true);				//HiliteControl((ControlHandle)iHndl,0);			//	GetDItem(myDlg,4,&iType,(Handle *)&iHndl,&iRect);			//	SetCtlValue((ControlHandle)iHndl,false);			break;						case 6:				GetDItem(myDlg,5,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,6,&iType,(Handle *)&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				conversionType = 2;			//	GetDItem(myDlg,3,&iType,(Handle *)&iHndl,&iRect);			//	SetCtlValue((ControlHandle)iHndl,false);				//HiliteControl((ControlHandle)iHndl,255);			//	GetDItem(myDlg,4,&iType,(Handle *)&iHndl,&iRect);			//	SetCtlValue((ControlHandle)iHndl,true);							break;					}	}while (itemHit != 1 && itemHit != 2);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;				SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		switch (conversionType)		{			case 1:				markersToRegions((*therealResults)[theindex]);			break;						case 2:				regionsToMarkers((*therealResults)[theindex]);			break;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}Boolean markersToRegions(FSSpec mySpec){	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	short iRefNum, refNum;	Handle theMarkers, theRegions;	short NumberOfMarkers;	short z;	markersHeader theMH;	ddRLHeader theRegH;	unsigned long secs;	RegionRec theRegion;	SD2marker theMarker;	long fileIndex = 0L;	Str255 theMarkerName;	long theLastMarker = 0L;	Boolean inOutRegion = outRegion;	myMarkers ** myMarkersList;	OSErr	iErr;	short numberOfRegions;	long theDestRecPos;	long fileEnd;			if(getSDIIData (mySpec, &theRate,&theWordSize, &stereo, &theBytes))	{		return false;	}		fileEnd = theBytes / (theWordSize * (stereo + 1));		iRefNum = CurResFile();		refNum = FSpOpenResFile(&mySpec,fsWrPerm);	iErr = ResError();	if (iErr)	{		return false;	}	UseResFile(refNum);		theMarkers = Get1Resource('ddRL',1000);	if (theMarkers)	{		RmveResource(theMarkers);		DisposHandle(theMarkers);	}		theMarkers = Get1Resource('sdML',1000);	if (!theMarkers)	{		CloseResFile(refNum);		UseResFile(iRefNum);		return false;	}		BlockMove(*theMarkers, &theMH, sizeof(markersHeader));	NumberOfMarkers = theMH.NumMarkers;	fileIndex += sizeof(markersHeader);	if (!NumberOfMarkers)	{		CloseResFile(refNum);		UseResFile(iRefNum);		return false;	}	myMarkersList = (myMarkers **)NewHandle((NumberOfMarkers + 1L)* sizeof(myMarkers));	if (!myMarkersList)	{		genError("\pOut of Memory");		CloseResFile(refNum);		UseResFile(iRefNum);		return false;	}		GetDateTime(&secs);		theRegH.VersionNumber = 1;	theRegH.HeaderSize = 12L;	theRegH.RegionSize = sizeof(RegionRec);	theRegH.ResourceDate = secs * 60L;	theRegH.NextID = (NumberOfMarkers / markersPerRegion) + 1;		//theRegions = NewHandle(sizeof(ddRLHeader) + (NumberOfMarkers*sizeof(RegionRec)));		for (z=0;z<NumberOfMarkers;z++)	{		BlockMove(*theMarkers + fileIndex,&theMarker, sizeof(SD2marker));		fileIndex += sizeof(SD2marker);		if (theMarker.MarkerType0 == 1)		{			NumToString((long)theMarker.MarkerID,theMarkerName);		}		else		{			BlockMove (*theMarkers + fileIndex, theMarkerName , theMarker.TextLength);			*(theMarkerName + theMarker.TextLength) = 0;			CtoPstr ((Ptr)theMarkerName);		}		fileIndex += theMarker.TextLength;				(*myMarkersList)[z].position = theMarker.Position;		if (theMarker.MarkerType0 == 1)		{			NumToString((long)theMarker.MarkerID,(*myMarkersList)[z].name);		}		else		{			BlockMove(theMarkerName,(*myMarkersList)[z].name,32L);		}	}	(*myMarkersList)[NumberOfMarkers].position = fileEnd;	sortMarkers (myMarkersList,NumberOfMarkers);	ReleaseResource(theMarkers);	numberOfRegions = 	(NumberOfMarkers / markersPerRegion);	theRegions = NewHandle (sizeof(ddRLHeader) + (numberOfRegions * sizeof (RegionRec)));	if (!theRegions)	{		DisposHandle((Handle)myMarkersList);		genError("\pOut of Memory");		CloseResFile(refNum);		UseResFile(iRefNum);		return false;	}			theDestRecPos = 0L;	BlockMove(&theRegH,*theRegions,sizeof(ddRLHeader));	theDestRecPos += sizeof(ddRLHeader);		z=0;		do {				theRegion.RegionID = (markersPerRegion  == 2) ? ((z>>1) + 1) : (z + 1);		theRegion.StartFrame = (*myMarkersList)[z].position;		theRegion.StopFrame = (*myMarkersList)[z+1].position;		if (z+1 >= (numberOfRegions * markersPerRegion))			theRegion.StopFrame = fileEnd;		theRegion.SynchFrame = theRegion.StartFrame;		theRegion.TimeStampMS = 0L;		theRegion.TimeStampLS = 0L;		BlockMove ( (*myMarkersList)[z].name , theRegion.RegionName , 32L);				BlockMove(&theRegion,(*theRegions) + theDestRecPos,sizeof(RegionRec));		theDestRecPos += sizeof(RegionRec);		z++;				if (markersPerRegion  == 2)			z++;					} while (z < (numberOfRegions * markersPerRegion));		AddResource(theRegions,'ddRL',1000,"\pRegions List");		CloseResFile(refNum);	DisposHandle ((Handle)myMarkersList);	DisposHandle (theRegions);	UseResFile(iRefNum);	return true;}Boolean regionsToMarkers(FSSpec mySpec){	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	short iRefNum, refNum;	Handle theMarkers, theRegions;	short NumberOfMarkers;	short NumberOfRegions;	short z;	markersHeader theMH;	ddRLHeader theRegH;	long secs;	RegionRec theRegion;	SD2marker theMarker;	long fileIndex = 0L;	Str255 theMarkerName;	long theLastMarker = 0L;	Boolean inOutRegion = outRegion;	myMarkers ** myMarkersList;	OSErr	iErr;	short numberOfRegions;	long theDestRecPos;	long fileEnd;			if(getSDIIData (mySpec, &theRate,&theWordSize, &stereo, &theBytes))	{		return false;	}		fileEnd = theBytes / (theWordSize * (stereo + 1));		iRefNum = CurResFile();		refNum = FSpOpenResFile(&mySpec,fsWrPerm);	iErr = ResError();	if (iErr)	{		return false;	}	UseResFile(refNum);		theMarkers = Get1Resource('sdML',1000);	if (theMarkers)	{		RmveResource(theMarkers);		DisposHandle(theMarkers);	}		theRegions = Get1Resource('ddRL',1000);	if (!theRegions)	{		CloseResFile(refNum);		UseResFile(iRefNum);		return false;	}		NumberOfRegions = (SizeResource(theRegions) -  sizeof(ddRLHeader)) /  sizeof(RegionRec);		theMarkers = NewHandle(sizeof(markersHeader) + ((long)markersPerRegion * NumberOfRegions * sizeof(SD2marker)) + (64L * NumberOfRegions));	if (!theMarkers)	{		CloseResFile(refNum);		UseResFile(iRefNum);		return false;	}		theMH.Version = 1;	theMH.MarkerOffset = 0;	theMH.NumMarkers = NumberOfRegions * markersPerRegion;		BlockMove (&theMH, *theMarkers, sizeof(markersHeader));	fileIndex += sizeof(markersHeader);		for (z=0;z<	NumberOfRegions;z++)	{		BlockMove (*theRegions + sizeof(ddRLHeader) + (z * sizeof(RegionRec)), &theRegion,sizeof(RegionRec));		theMarker.MarkerType0 = 2;		theMarker.MarkerType1 = 2;		theMarker.Position = theRegion.StartFrame;		theMarker.Text = 0;		theMarker.CursorID = 3012;		theMarker.MarkerID = z * 2;		theMarker.TextLength = *theRegion.RegionName;		if (((theMarker.TextLength / 2) * 2) != theMarker.TextLength)		{			theMarker.TextLength ++;		}		BlockMove (&theMarker, *theMarkers + fileIndex,sizeof(SD2marker));		fileIndex += sizeof(SD2marker);		if (!(((*theRegion.RegionName / 2) * 2) == *theRegion.RegionName))		{			*(theRegion.RegionName + (*theRegion.RegionName) + 1) = ' ';			BlockMove (theRegion.RegionName + 1L, *theMarkers + fileIndex,*theRegion.RegionName + 1);			fileIndex += *theRegion.RegionName + 1;		}		else		{			BlockMove (theRegion.RegionName + 1L, *theMarkers + fileIndex,*theRegion.RegionName);			fileIndex += *theRegion.RegionName;		}				if (markersPerRegion == 2)		{			theMarker.MarkerType0 = 2;			theMarker.MarkerType1 = 2;			theMarker.Position = theRegion.StopFrame;			theMarker.Text = 0;			theMarker.CursorID = 3012;			theMarker.MarkerID = z * 2;			theMarker.TextLength = *theRegion.RegionName;			if (((theMarker.TextLength / 2) * 2) != theMarker.TextLength)			{				theMarker.TextLength ++;			}			BlockMove (&theMarker, *theMarkers + fileIndex,sizeof(SD2marker));			fileIndex += sizeof(SD2marker);			BlockMove (theRegion.RegionName + 1L, *theMarkers + fileIndex,*theRegion.RegionName);			fileIndex += *theRegion.RegionName;			if (!(((*theRegion.RegionName / 2) * 2) == *theRegion.RegionName))			{				fileIndex ++;			}		}	}		SetResourceSize(theMarkers,fileIndex);	AddResource(theMarkers,'sdML',1000,"\pMarkers List");	iErr = ResError();	CloseResFile(refNum);	UseResFile(iRefNum);	return true;}void sortMarkers (myMarkers ** markersList,short NumMarkers){	Boolean didit = false;	short z;	long tempPos;	Str255 tempStr;	do {		didit = false;		for (z=0;z<NumMarkers;z++)		{			if  ((*markersList)[z].position > (*markersList)[z+1].position)			{				tempPos = (*markersList)[z].position;				 (*markersList)[z].position = (*markersList)[z+1].position;				 (*markersList)[z+1].position = tempPos;				 				 BlockMove ((*markersList)[z].name, tempStr,32L);				 BlockMove ((*markersList)[z+1].name,(*markersList)[z].name, 32L);				 BlockMove (tempStr,(*markersList)[z+1].name, 32L);				 didit = true;			}		}	}while (didit);return;}