#include "SampleSearch.h"#include "Globals.h"#include <Packages.h>extern short DispMode;#include "undoStuff.h"void paramSort(void);void saveForUndo (void);extern Boolean optionKeyHeld;int compareSize(const void *s1, const void *s2);int compareFileType(const void *s1, const void *s2);int compareCreatorType(const void *s1, const void *s2);int comparePath(const void *s1, const void *s2);int compareDate(const void *s1, const void *s2);int compareComment(const void *s1, const void *s2);int compareCategoryA(const void *s1, const void *s2);int compareCategoryB(const void *s1, const void *s2);void paramSort(void){	short z;	Size theCount;	FInfo ** theoldFInfo;	short * theTablePtr;	OSErr	iErr;	if (DispMode == 8)	{		genError ("\pCan't sort by Sample Info, sorry");		return;	}		watchcursor(true);		if 	(!FInfolistInMem)	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)				genError("\pCould not expand FInfo in alphasort");								checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));							for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}		theTablePtr = (short *)NewPtr((totfindcounter+5) * sizeof(short));	if (!theTablePtr)	{		genError("\pCould not assign memory");		return;	}	theCount = 70L*totfindcounter;		BlockMove((*therealResults),(*gTheResults),theCount);	/** make  copy **/			for (z=0;z<totfindcounter;z++)	{		((short *)theTablePtr)[z] = z;	}			switch (DispMode)		{			case 0:				qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareComment);			break;			case 1:				SysBeep(5);				//qsort (theTablePtr, (long)totfindcounter, sizeof(short), compare);			break;			case 2:				qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareFileType);			break;			case 3:				qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareCreatorType);			break;			case 4:				qsort (theTablePtr, (long)totfindcounter, sizeof(short), comparePath);			break;			case 5:				switch (optionKeyHeld)				{					case true:						qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareCategoryA);					break;										case false:						qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareCategoryB);					break;				}			break;						case 6:				qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareDate);			break;						case 7:				qsort (theTablePtr, (long)totfindcounter, sizeof(short), compareSize);			break;						case 8:				genError ("\pCan't sort by Sample Info, sorry");			break;		}			theoldFInfo = (FInfo **)NewHandle((totfindcounter+5L)*sizeof(FInfo));	if (!theoldFInfo)	{		genError("\pCouldn't assign memory");		DisposPtr((Ptr)theTablePtr);		return;	}		theCount = 16L * totfindcounter;		BlockMove((*theFInfo),(*theoldFInfo),theCount);	/** make a copy **/		theCount = 70L;	/* the alphasort prob is in here */	for (z=0;z<totfindcounter;z++)	{		BlockMove(&(((FInfo *)(*theoldFInfo))[((short*)(theTablePtr))[z]]),&((*theFInfo)[z]),16L);				BlockMove(&((*gTheResults)[((short *)theTablePtr)[z]]),&((*therealResults)[z]),theCount);	}	/*********************************/	DisposPtr((Ptr)theTablePtr);	iErr = MemError();	if (iErr!=0)		genError("\pCouldn't release theTablePtr");	DisposHandle((Handle)theoldFInfo);	iErr = MemError();	if (iErr!=0)		genError("\pCouldn't release theoldFInfo");	lCellCoords.h = 0;	lCellCoords.v = 0;			watchcursor(false);		return;}void makeStr255(Str255 theString, StringPtr thePtr);int compareFileType(const void *s1, const void *s2){	Str255 theTypeText,theTypeTextB;		short iResult;		switch ((*theFInfo)[*((short *)s1)].fdType)	{		case 'SCin':			makeStr255("\pSampleCell mono Instrument", theTypeText);		break;				case 'SCsi':			makeStr255("\pSampleCell stereo Instrument", theTypeText);		break;				case 'MixD':			makeStr255("\pSampleCell Bank", theTypeText);		break;				case 'SCss':			makeStr255("\pSampleCell thingy instrument", theTypeText);		break;				case 'SCsd':			makeStr255("\pSampleCell thingy 2 instrument", theTypeText);		break;				case 'Sd2f':			makeStr255("\pSound Designer II sample", theTypeText);		break;				case 'SFIL':			makeStr255("\pSound Designer I sample", theTypeText);		break;				case 'AIFF':			makeStr255("\pAIFF sample", theTypeText);		break;				case 'scSG':			makeStr255("\pCubase Audio Song", theTypeText);		break;				case 'WDBN':			makeStr255("\pMicrosoft Word File", theTypeText);		break;			default:			BlockMove(&(*theFInfo)[*((short *)s1)].fdType,theTypeText+1L,4L);			*theTypeText = 4;		break;	}		switch ((*theFInfo)[*((short *)s2)].fdType)	{		case 'SCin':			makeStr255("\pSampleCell mono Instrument", theTypeTextB);		break;				case 'SCsi':			makeStr255("\pSampleCell stereo Instrument", theTypeTextB);		break;				case 'MixD':			makeStr255("\pSampleCell Bank", theTypeTextB);		break;				case 'SCss':			makeStr255("\pSampleCell thingy instrument", theTypeTextB);		break;				case 'SCsd':			makeStr255("\pSampleCell thingy 2 instrument", theTypeTextB);		break;				case 'Sd2f':			makeStr255("\pSound Designer II sample", theTypeTextB);		break;				case 'SFIL':			makeStr255("\pSound Designer I sample", theTypeTextB);		break;				case 'AIFF':			makeStr255("\pAIFF sample", theTypeTextB);		break;				case 'scSG':			makeStr255("\pCubase Audio Song", theTypeTextB);		break;				case 'WDBN':			makeStr255("\pMicrosoft Word File", theTypeTextB);		break;			default:			BlockMove(&(*theFInfo)[*((short *)s2)].fdType,theTypeTextB+1L,4L);			*theTypeTextB = 4;		break;	}	iResult = RelString(theTypeText,theTypeTextB,false,false);		return	iResult;	}Boolean GetSizeDate (FSSpec mySpec, short index, long* theSize, long* theDate);int compareSize(const void *s1, const void *s2){	long theSize, theSizeB,theDate;	GetSizeDate (((*therealResults)[*((short *)s1)]),*((short *)s1), &theSize, &theDate);		GetSizeDate (((*therealResults)[*((short *)s2)]),*((short *)s2), &theSizeB, &theDate);	if (theSize == theSizeB)		return 0;		if (theSize > theSizeB)		return -1;			else		return 1;		}int compareCreatorType(const void *s1, const void *s2){	short iResult;	Str255 theTypeText,theTypeTextB;			switch ((*theFInfo)[*((short *)s1)].fdCreator)	{		default:			BlockMove(&(*theFInfo)[*((short *)s1)].fdCreator,theTypeText+1L,4L);			*theTypeText = 4;		break;	}		switch ((*theFInfo)[*((short *)s2)].fdCreator)	{		default:			BlockMove(&(*theFInfo)[*((short *)s2)].fdCreator,theTypeTextB+1L,4L);			*theTypeTextB = 4;		break;	}	iResult = RelString(theTypeText,theTypeTextB,false,false);		return	iResult;	}Boolean GetFSComment(FSSpec mySpec, Str255 theComment);int compareComment(const void *s1, const void *s2){	short iResult;	Str255 theComment1, theComment2;		GetFSComment((*therealResults)[*((short *)s1)], theComment1);	GetFSComment((*therealResults)[*((short *)s2)], theComment2);	iResult = RelString(theComment1,theComment2,false,false);		return	iResult;	}int compareDate(const void *s1, const void *s2){	short iResult;	long theSize,theDate, theDateB;		GetSizeDate (((*therealResults)[*((short *)s1)]),*((short *)s1), &theSize, &theDate);	GetSizeDate (((*therealResults)[*((short *)s2)]),*((short *)s2), &theSize, &theDateB);	if (theDate == theDateB)		return 0;		if (theDate > theDateB)		return -1;			else		return 1;}int comparePath(const void *s1, const void *s2){	short iResult;	Str255 theTypeText,theTypeTextB;	*theTypeText = 0;	PathNameFromDirID((*therealResults)[*((short *)s1)].parID, (*therealResults)[*((short *)s1)].vRefNum,(StringPtr)theTypeText);	*theTypeTextB = 0;	PathNameFromDirID((*therealResults)[*((short *)s2)].parID, (*therealResults)[*((short *)s2)].vRefNum,(StringPtr)theTypeTextB);	iResult = RelString(theTypeText,theTypeTextB,false,false);		return	iResult;	}int compareCategoryA(const void *s1, const void *s2){	short iResult;		if (((*theFInfo)[*((short *)s1)].fdFldr & 0x00FF) > ((*theFInfo)[*((short *)s2)].fdFldr  & 0x00FF) )		return 1;			if (((*theFInfo)[*((short *)s1)].fdFldr & 0x00FF)  < ((*theFInfo)[*((short *)s2)].fdFldr  & 0x00FF) )		return -1;		return 0;}int compareCategoryB(const void *s1, const void *s2){	short iResult;		if (((*theFInfo)[*((short *)s1)].fdFldr  & 0xFF00)  > ((*theFInfo)[*((short *)s2)].fdFldr  & 0xFF00) )		return 1;			if (((*theFInfo)[*((short *)s1)].fdFldr  & 0xFF00) < ((*theFInfo)[*((short *)s2)].fdFldr  & 0xFF00) )		return -1;		return 0;}