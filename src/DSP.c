#include "DSP.h"#include <stdlib.h>#include <math.h>#include "prefs.h"extern newPrefsRec theNewPrefs;Ptr theTempBuffer;short isPressed(unsigned short k );#define bufferLen 100long theLocalLPBuffer[200];long theLocalHPBuffer[200];float themultiplier[200];long bufferPtr;short keepY;OSErr testAlgorithm (Byte * theResults);void watchcursor(Boolean seting);OSErr updateScope (short scopeVal);short scope = 10;float correction = 0.9;Point lastMouse, thisMouse, origMouse;void resetFilter (void);Boolean runningTest;double DoFilter(double input, double freq, double res_in);short eventNow = 0;DialogPtr theDSPDlg;Boolean stopPlaying;Boolean byPass;float termMultipliers[8];long termPosition[8];float gainCorrection;OSErr interruptSoundProcessingProc (void);OSErr initDSP(void){	short z;	GrafPtr savePort;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	GetPort(&savePort);			for (z=0;z<bufferLen;z++)	{		theLocalLPBuffer[z] = 0;		theLocalHPBuffer[z] = 0;		themultiplier[z] = 0;	}	updateScope (scope);	keepY = 0;	GetMouse (&lastMouse);	GetMouse (&origMouse);		theDSPDlg = GetNewDialog(4500,0,(WindowPtr)-1);	SetPort (theDSPDlg);	ShowWindow(theDSPDlg);	stopPlaying = false;	byPass = false;	runningTest = false;	for (z=0;z<8;z++)	{		GetDItem(theDSPDlg,z+4,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.termEnabled[z]);					GetDItem(theDSPDlg,z+12,&iType,&iHndl,&iRect);		SetIText(iHndl,theNewPrefs.theDSPSettings.termMultiplier[z]);		*(theNewPrefs.theDSPSettings.termMultiplier[z] + (*theNewPrefs.theDSPSettings.termMultiplier[z] + 1)) = 0;		termMultipliers[z] = atof((const char *)theNewPrefs.theDSPSettings.termMultiplier[z] + 1);				GetDItem(theDSPDlg,z+20,&iType,&iHndl,&iRect);		SetIText(iHndl,theNewPrefs.theDSPSettings.termPosition[z]);		StringToNum (theNewPrefs.theDSPSettings.termPosition[z],&termPosition[z]);	}			GetDItem(theDSPDlg,30,&iType,&iHndl,&iRect);	SetIText(iHndl,theNewPrefs.theDSPSettings.gainCorrection);	*(theNewPrefs.theDSPSettings.gainCorrection + (*theNewPrefs.theDSPSettings.gainCorrection + 1)) = 0;	gainCorrection = atof((const char *)theNewPrefs.theDSPSettings.gainCorrection + 1);	 		GetDItem(theDSPDlg,29,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.invert);	watchcursor(0);	 eventNow = 0;	SetPort (savePort);}OSErr testAlgorithm (Byte * theResults){	Handle myTestTone;	short mySampleChunk[512];	long myTotalEnergy,lByteCnt;	long whichChunk = 0;	long numChunks,z;		myTestTone = GetResource('tone',128);	if (!myTestTone)	{		SysBeep(5);		return -25;	}	lByteCnt = SizeResource(myTestTone);		numChunks = lByteCnt/512L;	runningTest = true;	while (whichChunk<numChunks)	{		BlockMove (*myTestTone + (whichChunk * 512L), &mySampleChunk[0],1024L);		for (z=0;z<bufferLen;z++) /* clear calc buffers */		{			theLocalLPBuffer[z] = 0;			theLocalHPBuffer[z] = 0;			themultiplier[z] = 0;		}				processDSPBuffer(&mySampleChunk[0],1024L);		myTotalEnergy = 0L;		for (z=0;z<512;z++)		{			if (mySampleChunk[z] > 0)				myTotalEnergy += mySampleChunk[z];		}				myTotalEnergy = myTotalEnergy / 512L;		*(Byte *)(theResults + whichChunk) = (Byte)(myTotalEnergy >> 7);		whichChunk ++;	}	runningTest = false;	ReleaseResource(myTestTone);	return noErr;}OSErr updateScope (short scopeVal){	short z;	float myTot = 0;			for (z=scope;z>0;z--)	{		//themultiplier[scope - z] = 1; // if you widen the scope you introduce more phase effect. 		if (z & 0x0001)		{			themultiplier[scope - z] = -(float)z/(float)scope;		}		else		{			themultiplier[scope - z] = ((float)z/(float)scope);		}	}		for (z=0;z<scope;z++)	{		myTot += themultiplier[z];	}		correction = 1/myTot;		}OSErr exitDSP(void){	GrafPtr savePort;		GetPort(&savePort);	SetPort (theDSPDlg);	DisposDialog(theDSPDlg);	//FlashMenuBar(0);}float thisDifference,lastFilter = 0.5;OSErr mouseMoveHannprocessDSPBuffer(short * theAudio,long bufferSize);OSErr mainentryDlogprocessDSPBuffer(short * theAudio,long bufferSize);OSErr dynamictrackingbandpassprocessDSPBuffer(short * theAudio,long bufferSize);OSErr processDSPBuffer(short * theAudio,long bufferSize){	return dynamictrackingbandpassprocessDSPBuffer(theAudio,bufferSize);}OSErr mouseMoveHannprocessDSPBuffer(short * theAudio,long bufferSize){	long z,y;	long theLPSample;	float theHPSample;	long theBRSample;	long theBPSample;	float localMult;	float total = 0;	Point theMouse;	GrafPtr savePort;	short itemHit;	EventRecord theEvent;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	short ss;	Byte myResults[255];	long thisChunkAmp;			if (isPressed(0x39))	{		return noErr;	}			GetPort(&savePort);	SetPort (theDSPDlg);			/* HANDLE THE DIALOG */	if (!runningTest) /* dont process events when testing to avoid re-entrancy */	{		if(GetNextEvent(everyEvent,&theEvent)) 		{			if(IsDialogEvent(&theEvent)) 			{				if(DialogSelect(&theEvent,&theDSPDlg,&itemHit)) 				{					switch (itemHit)					{						case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.termEnabled[itemHit-4] = !GetCtlValue((ControlHandle)iHndl));						break;												case 28:							GetDItem(theDSPDlg,28,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,byPass = !GetCtlValue((ControlHandle)iHndl));						break;												case 29:							GetDItem(theDSPDlg,29,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.invert = !GetCtlValue((ControlHandle)iHndl));						break;											case 30:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.gainCorrection);							*(theNewPrefs.theDSPSettings.gainCorrection+ (*theNewPrefs.theDSPSettings.gainCorrection+ 1)) = 0;							gainCorrection = atof((const char *)theNewPrefs.theDSPSettings.gainCorrection+ 1);						break;												case 2: /* test */								if (!testAlgorithm (&myResults[0]))							{								GetDItem(theDSPDlg,32,&iType,&iHndl,&iRect);								EraseRect(&iRect);								for (ss=0;ss<169;ss++)								{									MoveTo(iRect.left+(ss*2),iRect.bottom);									LineTo(iRect.left+(ss*2),iRect.bottom - myResults[ss]);								}							}						break;												case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.termMultiplier[itemHit-12]);							*(theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + (*theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + 1)) = 0;							termMultipliers[itemHit-12] = atof((const char *)theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + 1);						break;													case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.termPosition[itemHit-20]);							StringToNum (theNewPrefs.theDSPSettings.termPosition[itemHit-20],&termPosition[itemHit-20]);						break;						case 1:							stopPlaying = true;						break;						}					if (!testAlgorithm (&myResults[0]))					{						GetDItem(theDSPDlg,32,&iType,&iHndl,&iRect);						EraseRect(&iRect);						MoveTo(iRect.left,iRect.bottom - myResults[0]);						for (ss=0;ss<169;ss++)						{						//	MoveTo(iRect.left+(ss*2),iRect.bottom);							LineTo(iRect.left+(ss*2),iRect.bottom - myResults[ss]);						}					}						}			}		}	}		/*GetMouse (&thisMouse);		if (thisMouse.h != lastMouse.h)	{		scope = abs(origMouse.h - thisMouse.h);		lastMouse.h = thisMouse.h;		if (scope == 0)		{			scope = 1;		}		if (scope >= bufferLen)		{			scope = bufferLen;			FlashMenuBar(0);		}		updateScope (scope);	}*/	/*	if (thisMouse.v != lastMouse.v)	{		scope = abs(origMouse.v - thisMouse.v);		lastMouse.v = thisMouse.v;		if (scope = 0)		{			scope = 1;		}		updateScope (scope);	}*/			/* DONT PROCESS IN BYPASS */	if (byPass)	{			SetPort(savePort);		return;	}					thisChunkAmp = 0;			/* INDEX THRU SAMPLES */	for (z=0;z<(bufferSize >> 1);z++)	{				theLocalHPBuffer[0] = (long)(*(short *)(theAudio + z));				if (theLocalHPBuffer[0] > 0)		{			thisChunkAmp += theLocalHPBuffer[0];		}	// 4th order non recursive difference 	theHPSample = (0.1 * (float)theLocalHPBuffer[0] - (0.3 * (float)theLocalHPBuffer[1]) 	//		+ (0.4 * (float)theLocalHPBuffer[2]) - (0.3 * (float)theLocalHPBuffer[3]) + (0.1 * (float)theLocalHPBuffer[4])) ;	//	theHPSample = (0.2 * (float)theLocalHPBuffer[0] - (0.2 * (float)theLocalHPBuffer[5]) + keepY) ;  /* low pass subtle */	//	theHPSample = ((float)theLocalHPBuffer[0] - (float)theLocalHPBuffer[1] + (0.42 * keepY)) ;			// this one creates noise ??	theHPSample = (0.2 * (float)(theLocalHPBuffer[0]*theLocalHPBuffer[0]) + 0.2 * (float)(theLocalHPBuffer[1]*theLocalHPBuffer[1]) + 0.2 * (float)(theLocalHPBuffer[2]*theLocalHPBuffer[2]) + 0.2 * (float)(theLocalHPBuffer[3]*theLocalHPBuffer[3]) + 0.2 * (float)(theLocalHPBuffer[4]*theLocalHPBuffer[4]) );	/*	total = 0;		for (y=0;y<scope;y++)		{			total += (themultiplier[y] * theLocalHPBuffer[y] * correction);			theHPSample = total;		}*/						/******* PROCESSING STAGE **********/		total = 0;						total =  DoFilter((double) theLocalHPBuffer[0],(double) termMultipliers[0], (double) termMultipliers[1]);		/*for (ss=0;ss<8;ss++)		{			if (theNewPrefs.theDSPSettings.termEnabled[ss])			{				if (termPosition[ss] < 0)				{					total += (termMultipliers[ss] * theLocalLPBuffer[-1-termPosition[ss]]);				}				else				{					total += (termMultipliers[ss] * theLocalHPBuffer[termPosition[ss]]);				}			}		}*/						/* CORRECT AMPLITUDE */		total = total * gainCorrection;				/* HISTORY SHUFFLE INCOMING ****/		for (y=scope;y>0;y--)		{				theLocalHPBuffer[y] = theLocalHPBuffer[y-1];			//BlockMove (&theLocalHPBuffer[0],&theLocalHPBuffer[1],(long)scope);		}				/* HISTORY SHUFFLE OUTGOING ****/		for (y=scope;y>0;y--)		{				theLocalLPBuffer[y] = theLocalLPBuffer[y-1];			//BlockMove (&theLocalHPBuffer[0],&theLocalHPBuffer[1],(long)scope);		}				/* THIS OUTPUT TERM */		theLocalLPBuffer[0] = (short)(total);				/****  WHAT WE HEAR ****/		if (theNewPrefs.theDSPSettings.invert)		{			*(theAudio + z) = (*(theAudio + z) - (short)(total));		}		else		{			*(theAudio + z) = (short)(total);		}			}			*(theNewPrefs.theDSPSettings.termMultiplier[0] + (*theNewPrefs.theDSPSettings.termMultiplier[0] + 1)) = 0;	termMultipliers[0] = atof((const char *)theNewPrefs.theDSPSettings.termMultiplier[0] + 1);	lastFilter = termMultipliers[0];		termMultipliers[0] = (double)(((float)thisChunkAmp / (float)bufferSize) / (float)32768) * termMultipliers[0];		/*	thisDifference = termMultipliers[0] - lastFilter;		if (thisDifference > 0)	{		if (thisDifference > 0.4)		{			termMultipliers[0] = lastFilter + 0.4;		}	}	else	{		if ((-thisDifference) > 0.4)		{			termMultipliers[0] = lastFilter - 0.4;		}			}		if (termMultipliers[0]<0.01)	{		termMultipliers[0] = 0.01;	}		if (termMultipliers[0]>0.9)	{		termMultipliers[0] = 0.9;	}		lastFilter = termMultipliers[0];*/		SetPort(savePort);	return noErr;}	OSErr mainentryDlogprocessDSPBuffer(short * theAudio,long bufferSize);OSErr mainentryDlogprocessDSPBuffer(short * theAudio,long bufferSize){	long z,y;	long theLPSample;	float theHPSample;	long theBRSample;	long theBPSample;	float localMult;	float total = 0;	Point theMouse;	GrafPtr savePort;	short itemHit;	EventRecord theEvent;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	short ss;	Byte myResults[255];	long thisChunkAmp;			if (isPressed(0x39))	{		return noErr;	}			GetPort(&savePort);	SetPort (theDSPDlg);			/* HANDLE THE DIALOG */	if (!runningTest) /* dont process events when testing to avoid re-entrancy */	{		if(GetNextEvent(everyEvent,&theEvent)) 		{			if(IsDialogEvent(&theEvent)) 			{				if(DialogSelect(&theEvent,&theDSPDlg,&itemHit)) 				{					switch (itemHit)					{						case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.termEnabled[itemHit-4] = !GetCtlValue((ControlHandle)iHndl));						break;												case 28:							GetDItem(theDSPDlg,28,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,byPass = !GetCtlValue((ControlHandle)iHndl));						break;												case 29:							GetDItem(theDSPDlg,29,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.invert = !GetCtlValue((ControlHandle)iHndl));						break;											case 30:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.gainCorrection);							*(theNewPrefs.theDSPSettings.gainCorrection+ (*theNewPrefs.theDSPSettings.gainCorrection+ 1)) = 0;							gainCorrection = atof((const char *)theNewPrefs.theDSPSettings.gainCorrection+ 1);						break;												case 2: /* test */								if (!testAlgorithm (&myResults[0]))							{								GetDItem(theDSPDlg,32,&iType,&iHndl,&iRect);								EraseRect(&iRect);								for (ss=0;ss<169;ss++)								{									MoveTo(iRect.left+(ss*2),iRect.bottom);									LineTo(iRect.left+(ss*2),iRect.bottom - myResults[ss]);								}							}						break;												case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.termMultiplier[itemHit-12]);							*(theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + (*theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + 1)) = 0;							termMultipliers[itemHit-12] = atof((const char *)theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + 1);						break;													case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.termPosition[itemHit-20]);							StringToNum (theNewPrefs.theDSPSettings.termPosition[itemHit-20],&termPosition[itemHit-20]);						break;						case 1:							stopPlaying = true;						break;						}					if (!testAlgorithm (&myResults[0]))					{						GetDItem(theDSPDlg,32,&iType,&iHndl,&iRect);						EraseRect(&iRect);						MoveTo(iRect.left,iRect.bottom - myResults[0]);						for (ss=0;ss<169;ss++)						{						//	MoveTo(iRect.left+(ss*2),iRect.bottom);							LineTo(iRect.left+(ss*2),iRect.bottom - myResults[ss]);						}					}						}			}		}	}		/* DONT PROCESS IN BYPASS */	if (byPass)	{			SetPort(savePort);		return;	}					thisChunkAmp = 0;			/* INDEX THRU SAMPLES */	for (z=0;z<(bufferSize >> 1);z++)	{				theLocalHPBuffer[0] = (long)(*(short *)(theAudio + z));				if (theLocalHPBuffer[0] > 0)		{			thisChunkAmp += theLocalHPBuffer[0];		}						/******* PROCESSING STAGE **********/		total = 0;				for (ss=0;ss<8;ss++)		{			if (theNewPrefs.theDSPSettings.termEnabled[ss])			{				if (termPosition[ss] < 0)				{					total += (termMultipliers[ss] * theLocalLPBuffer[-1-termPosition[ss]]);				}				else				{					total += (termMultipliers[ss] * theLocalHPBuffer[termPosition[ss]]);				}			}		}						/* CORRECT AMPLITUDE */		total = total * gainCorrection;				/* HISTORY SHUFFLE INCOMING ****/		for (y=scope;y>0;y--)		{				theLocalHPBuffer[y] = theLocalHPBuffer[y-1];			//BlockMove (&theLocalHPBuffer[0],&theLocalHPBuffer[1],(long)scope);		}				/* HISTORY SHUFFLE OUTGOING ****/		for (y=scope;y>0;y--)		{				theLocalLPBuffer[y] = theLocalLPBuffer[y-1];			//BlockMove (&theLocalHPBuffer[0],&theLocalHPBuffer[1],(long)scope);		}				/* THIS OUTPUT TERM */		theLocalLPBuffer[0] = (short)(total);				/****  WHAT WE HEAR ****/		if (theNewPrefs.theDSPSettings.invert)		{			*(theAudio + z) = (*(theAudio + z) - (short)(total));		}		else		{			*(theAudio + z) = (short)(total);		}			}				SetPort(savePort);	return noErr;}OSErr dynamictrackingbandpassprocessDSPBuffer(short * theAudio,long bufferSize) {	long z,y;	long theLPSample;	float theHPSample;	long theBRSample;	long theBPSample;	float localMult;	float total = 0;	Point theMouse;	GrafPtr savePort;	short itemHit;	EventRecord theEvent;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	short ss;	Byte myResults[255];	long thisChunkAmp;		eventNow ++;		if (isPressed(0x39))	{		return noErr;	}			GetPort(&savePort);	SetPort (theDSPDlg);			/* HANDLE THE DIALOG */	if (!runningTest) /* dont process events when testing to avoid re-entrancy */	{	if ((eventNow >>1 << 1) == eventNow)		if(GetNextEvent(everyEvent,&theEvent)) 		{			if(IsDialogEvent(&theEvent)) 			{				if(DialogSelect(&theEvent,&theDSPDlg,&itemHit)) 				{					switch (itemHit)					{						case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.termEnabled[itemHit-4] = !GetCtlValue((ControlHandle)iHndl));						break;												case 28:							GetDItem(theDSPDlg,28,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,byPass = !GetCtlValue((ControlHandle)iHndl));						break;												case 29:							GetDItem(theDSPDlg,29,&iType,&iHndl,&iRect);							SetCtlValue((ControlHandle)iHndl,theNewPrefs.theDSPSettings.invert = !GetCtlValue((ControlHandle)iHndl));						break;											case 30:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.gainCorrection);							*(theNewPrefs.theDSPSettings.gainCorrection+ (*theNewPrefs.theDSPSettings.gainCorrection+ 1)) = 0;							gainCorrection = atof((const char *)theNewPrefs.theDSPSettings.gainCorrection+ 1);						break;												case 2: /* test */								resetFilter();							/*if (!testAlgorithm (&myResults[0]))							{								GetDItem(theDSPDlg,32,&iType,&iHndl,&iRect);								EraseRect(&iRect);								for (ss=0;ss<169;ss++)								{									MoveTo(iRect.left+(ss*2),iRect.bottom);									LineTo(iRect.left+(ss*2),iRect.bottom - myResults[ss]);								}							}*/						break;												case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.termMultiplier[itemHit-12]);							*(theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + (*theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + 1)) = 0;							termMultipliers[itemHit-12] = atof((const char *)theNewPrefs.theDSPSettings.termMultiplier[itemHit-12] + 1);						break;													case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:							GetDItem(theDSPDlg,itemHit,&iType,&iHndl,&iRect);							GetIText(iHndl,theNewPrefs.theDSPSettings.termPosition[itemHit-20]);							StringToNum (theNewPrefs.theDSPSettings.termPosition[itemHit-20],&termPosition[itemHit-20]);						break;						case 1:							stopPlaying = true;						break;						}					 resetFilter ();					if (!testAlgorithm (&myResults[0]))					{						GetDItem(theDSPDlg,32,&iType,&iHndl,&iRect);						EraseRect(&iRect);						MoveTo(iRect.left,iRect.bottom - myResults[0]);						for (ss=0;ss<169;ss++)						{						//	MoveTo(iRect.left+(ss*2),iRect.bottom);							LineTo(iRect.left+(ss*2),iRect.bottom - myResults[ss]);						}					}					 resetFilter ();				}			}		}	}				/* DONT PROCESS IN BYPASS */	if (byPass)	{			SetPort(savePort);		return;	}					thisChunkAmp = 0;			/* INDEX THRU SAMPLES */	for (z=0;z<(bufferSize >> 1);z++)	{				theLocalHPBuffer[0] = (long)(*(short *)(theAudio + z));				if (theLocalHPBuffer[0] > 0)		{			if (theLocalHPBuffer[0] >= thisChunkAmp)			{				thisChunkAmp = theLocalHPBuffer[0];			}			else			{				thisChunkAmp -= termMultipliers[5];				if (theLocalHPBuffer[0] >= thisChunkAmp)				{					thisChunkAmp = theLocalHPBuffer[0];				}			}		}		else		{						}		/******* PROCESSING STAGE **********/		total = 0;						total =  DoFilter((double) theLocalHPBuffer[0],(double) termMultipliers[0] + ((theNewPrefs.theDSPSettings.invert) ? (-(double)termMultipliers[3]) : (+(double)termMultipliers[3])), (double) termMultipliers[1]);				/* CORRECT AMPLITUDE */		total = total * gainCorrection;				if ((z>>9<<9) == z)		{			*(theNewPrefs.theDSPSettings.termMultiplier[0] + (*theNewPrefs.theDSPSettings.termMultiplier[0] + 1)) = 0;			termMultipliers[0] = atof((const char *)theNewPrefs.theDSPSettings.termMultiplier[0] + 1);						if (theNewPrefs.theDSPSettings.invert)			{				termMultipliers[0] = ((double)((double)(termMultipliers[4] - (thisChunkAmp>>9)) / 32768.0) * termMultipliers[0]);			}			else			{				termMultipliers[0] = (double)((double)(thisChunkAmp>>9) / 32768.0) * termMultipliers[0];			}						thisDifference = termMultipliers[0] - lastFilter;						if (thisDifference > 0)			{				if (thisDifference > termMultipliers[2])				{					termMultipliers[0] = lastFilter +termMultipliers[2];				}			}			else			{				if ((-thisDifference) >termMultipliers[2])				{					termMultipliers[0] = lastFilter -termMultipliers[2];				}							}						if (termMultipliers[0]<0.01)			{				termMultipliers[0] = 0.01;			}						if (termMultipliers[0]>0.9)			{				termMultipliers[0] = 0.9;			}						lastFilter = termMultipliers[0];			thisChunkAmp = 0;		}				/* HISTORY SHUFFLE INCOMING ****/		for (y=scope;y>0;y--)		{				theLocalHPBuffer[y] = theLocalHPBuffer[y-1];			//BlockMove (&theLocalHPBuffer[0],&theLocalHPBuffer[1],(long)scope);		}				/* HISTORY SHUFFLE OUTGOING ****/		for (y=scope;y>0;y--)		{				theLocalLPBuffer[y] = theLocalLPBuffer[y-1];			//BlockMove (&theLocalHPBuffer[0],&theLocalHPBuffer[1],(long)scope);		}				/* THIS OUTPUT TERM */		theLocalLPBuffer[0] = (short)(total);				/****  WHAT WE HEAR ****//*		if (theNewPrefs.theDSPSettings.invert)		{			*(theAudio + z) = (*(theAudio + z) - (short)(total));		}		else		{			*(theAudio + z) = (short)(total);		}*/						/****  WHAT WE HEAR ****/		/* invert used for process, not output */		*(theAudio + z) = (short)(total);			}				SetPort(savePort);	return noErr;}/*   	LOW PASS  	--------	for (z=0;z<(bufferSize >> 1);z++)	{		theLocalBuffer[0] = *(theAudio + z);		*(theAudio + z) = (theLocalBuffer[0]+theLocalBuffer[1]+theLocalBuffer[2]+theLocalBuffer[3]+theLocalBuffer[4]) / 5;		theLocalBuffer[4] = theLocalBuffer[3];		theLocalBuffer[3] = theLocalBuffer[2];		theLocalBuffer[2] = theLocalBuffer[1];		theLocalBuffer[1] = theLocalBuffer[0];	}		y|	 |--------------	 |/////////////|	 |/////////////|	 |/////////////|	 |_____________|__________	               t				HIGH PASS  -  LOW PASS THEN SUBTRACT FROM ORIGINAL	---------	for (z=0;z<(bufferSize >> 1);z++)	{		theLocalBuffer[0] = *(theAudio + z);		theSample = (theLocalBuffer[0]+theLocalBuffer[1]+theLocalBuffer[2]+theLocalBuffer[3]+theLocalBuffer[4]) / 5;		theLocalBuffer[4] = theLocalBuffer[3];		theLocalBuffer[3] = theLocalBuffer[2];		theLocalBuffer[2] = theLocalBuffer[1];		theLocalBuffer[1] = theLocalBuffer[0];				*(theAudio + z) = *(theAudio + z) - theSample;	}		y|	 |			   --------------	 |             |/////////////	 |             |/////////////	 |             |/////////////	 |_____________|_____________	               t			BAND REJECT - LOW PASS MODERATE THEN SUBTRACT FROM ORIGINAL to FORM SEVERE HIGH PASS, THEN LOW PASS SEVERE. ADD SEVERE LOW PASS AND HIGH PASS	-----------	for (z=0;z<(bufferSize >> 1);z++)	{		USE ONLY THREE TERMS FOR MODERATE LOW PASS		theLocalLPBuffer[0] = *(theAudio + z);		theLPSample = (theLocalLPBuffer[0]+theLocalLPBuffer[1]+theLocalLPBuffer[2]) / 3;		theLocalLPBuffer[2] = theLocalLPBuffer[1];		theLocalLPBuffer[1] = theLocalLPBuffer[0];	y|	 |------------------	 |/////////////////|	 |/////////////////|	 |/////////////////|	 |_________________|____	                   t					SUBTRACT MODERATE LOW PASS TO FORM SEVERE HIGH PASS		theHPSample = *(theAudio + z) - theLPSample;			y|	 |		     	   ---------	 |                 |////////	 |                 |////////	 |                 |////////	 |_________________|________	                   t			USE FIVE TERMS FOR SEVERE LOW PASS		theLocalHPBuffer[0] = *(theAudio + z);		theLPSample = (theLocalHPBuffer[0]+theLocalHPBuffer[1]+theLocalHPBuffer[2]+theLocalHPBuffer[3]+theLocalHPBuffer[4]) / 5;		theLocalHPBuffer[4] = theLocalHPBuffer[3];		theLocalHPBuffer[3] = theLocalHPBuffer[2];		theLocalHPBuffer[2] = theLocalHPBuffer[1];		theLocalHPBuffer[1] = theLocalHPBuffer[0];				ADD SEVERE LOW AND HIGH TO FORM BAND REJECT		theBPSample = theLPSample + theHPSample;				*(theAudio + z) = theBPSample;			y|	 |--------------   -------	 |/////////////|   |/////	 |/////////////|   |/////	 |/////////////|   |/////	 |_____________|___|______	               t	SUBTRACT THIS FROM THE ORIGINAL AND YOU GET A BAND PASS FILTER		y|	 |			   -----	 |             |///|	 |             |///|	 |             |///|	 |_____________|___|________	               t	THIS MAY ALL BE OVERCOMPLEX AS IT COULD BE DONE WITH DIFFERENT TERMS AND MULTIPLIERS		Y = LOW PASS	X = X + (X-Y) GIVES HIGH BOOST}	*/double out0,out1,out2,out3,out4;double ap1,ap2,ap3,ap4;double in1,in2,in3,in4;void resetFilter (void){	out0=out1=out2=out3=out4=ap1=ap2=ap3=ap4=in1=in2=in3=in4 = 0;}double reso;// freq / res_in between 0 and 1/* this is our 'moog' filter with res */double DoFilter(double input, double freq, double res_in){        // kludge, read the paper instead...        reso = 1 - freq;        reso = 1 + 3.5 * reso * reso;        reso = reso * res_in;        freq = freq * 2.0 - 1.0;        reso = reso * out4;        // limit resonance (just simple clipping...)     /*   if (reso > 5.0) reso = 5.0;        else if (reso < -5.0) reso = -5.0;*/        out0 = input - reso; // feedback!        // lowpass 1        ap1  = (out0 - ap1) * freq + in1; // allpass section        in1  =  out0;        out1 = (out0 + ap1) * 0.5; // combine with input        // lowpass 2        ap2  = (out1 - ap2) * freq + in2;        in2  =  out1;        out2 = (out1 + ap2) * 0.5;        // lowpass 3        ap3  = (out2 - ap3) * freq + in3;        in3  =  out2;        out3 = (out2 + ap3) * 0.5;        // lowpass 4        ap4 = (out3 - ap4) * freq + in4;        in4 =  out3;        out4 = (out3 + ap4) * 0.5;        return out4;}OSErr interruptSoundProcessingProc (void){	/* access globals */					/* unaccess globals */}