/****************still to'exact match doesn't work for ghostsundo after purge causes bus errorrecording over same file crashes in recordcheck audio click on next record after edit after recordallow user to set rate etc - for AV macs.Check dawn resolve uses search and update ?check left and right region makingmake it easy to stop inst auditionburnsdata (update) should write type aswell so update in examine can write type changesdoes add items still fail on demo ?in add items. dbl click alias closes window (or selecting ?)??interactive edit crashes on fourth region when renamingcrash when closing recordmake it easier to quit auto region making, and turn off interactive, and edit settingswhen exporting regions, sd2s with deleted regions cause confusiondivert load, big dbl alpha sort crashoccasional crashes when divertloading or option dbl clickingallow interactive edit without autocrop suggestion.throw up error if examining etc SCI inst / bankorefs of ghosts are set to 0sc resolved files incorrect orefs and ovols.test full cd interactivitywhen you first turn autocrop on, ask for folder√√??FINISH noisefloor sampler for edit page, plus autocrop suggestion.make autocrop folder and use it.pre and post roll for autocropmake it popup after archive ?crashed after auditioning 20still auto sustain probs - keyboards ????make copy prot use scsi enq or floppy on vol ? still crashing on first divertload.show fldr thing SFDialog sometimes works - app specificaudition SCI instruments crashes ?text for categoriresget info on ghost crashes ??snapshot of appleshare bombedcreator type dialog still causes update color probs.caret color prob.graphics bug on progress while making auto region interactive edit.after alpha sort, pressing a letter doesn't work until you click.category text cross reference, with comment box.put default resorces into prefs not app.fix the number keys auditionpict view / moviesbatch process using plug insplay quickKeyscheck that method B respects stereo files properly change region maker sliders to 7-bit res for 16-bit sndcheck default regionmaker prefs√√√ AIFF to SDII sample rates ???make audition read async !!!!need to have more favourite lists. (d.murray)after achive with move, update entry in, listdon't ask for location in resolve to list.make wave form display more efficient - maybe sd2 overviewdo precord in RAM.????make it 7.0 compatcheck for nodisk space on crop and copy / move /archive / convert etc.in resolve all in examine, check whether file is resolved before searchingcancelling a method B region in interactive caused bus errordisplay old copyright ?apple E should go to crop if no regionsallow back up from tape of protools with auto look for resolve.find doubles on front page ???-db Display on record.keyboard on record AIFF to set original key8-bit normalisefade in / out of audio regions. (tag name with + sign then fades)AUTO BUILD APPS LIST FOR DISPLAYING FILE TYPE.finish output to file - dead items return garbage size.show SCII inst sizes in list under show info.maybe auto load into samplecell after recording.editing comment in get info does not update comment in list.make divert load work better.auto do not re-resolve under archive SCII if destination is desktape.Play and display PICTsput in custom sfdialog for archive if not making folder.Auto update of ghosts by date checking (update or renew - update can't delete)48 bytes per handle event.takes 3K from heap.start looking for resolve on same drive as parent - finds relevant one firstBank Size calc.pitch change on keys for non-dbl buffer.what happens if you option launch into  non-appleEvent applicationdon't write divert load app sig to application, probs with new versions.maybe put popup file type additions into prefs not rsrc.instrument sizes in list and get info.sort by submenu.if a sample is dragged and dropped, play it.crashes if log is left open when it tries to write (maybe use modal read log.)Desktape auto sense for grey area.allow sound to stop on non-dbl buffered play.pitch keys are offset, 5 should be normmatch creators to application names properlypage up/down in listshow  current item in divert load pop up under buttons - press it.do recent list to automatically add recently launched files.make all functions search for list selection not use ICellCoords. !!!!!!!after wheeling around with mousedown in lst, arrow key leaves last selection.option apple 1 = setup popups in menu, apple 1 to recall etc.make scroll bars in list for excludes work, check they work in examinealter every reference to fvolName(fvolumes) to use new antireference fvolumes list.mount appleshare volumes in check reference ?put key in root not system.make an alias of the volume to allow std remount operations for offlines / applesharescheck list manager size after merge.resolve macromind director files.(for external references)intelligently enable menus - eg search for aiff the merge list leaves audiotion enabled.having a / symbol or brackets () in drive name causes corruption******************BUGSWon't launch samples in examine.????? try resolving firstCMD clicking on an empty cell crashes.********************************/void cleanUpFVolumeGaps(void);void LoadFaves(void);Boolean makefaveFile(short listIndex,FSSpec *theFaveFile, FSSpec *theFaveInfo);void RetrievePrefs(void);#include "undoStuff.h"void SaveAsTabFave(short whichList);void initialiseUPPs (void);#include "tabs.h"//#include "Drag.h"#include <Gestalt.h>void getGhostsDirSpec(void);short findMaxVRefNum(void);void makeFaveSpecs(void);FSSpec AEvent (void);void openFSList(FSSpec mySpec);#include "SampleSearch.h"extern Boolean CopyProtect;void cleanUpRes(void);Boolean plusMode = true;void getAliasDirSpec(void);#include "prefs.h"extern newPrefsRec theNewPrefs;extern Boolean loseTheWindow;/********************************* global variables  **************************/FInfo	**theFInfo;long AliasesDirID;long GhostsDirID;long	FInfoArrayPtr;short snapRefNum;short applVRefNum;long applDirID;long	snapFileLen;StandardFileReply snapReply;Str255	zfilename, ztemp;Handle	volHdl;Str255	*volName;Ptr volPtr;extern Boolean stickyInfo;Boolean DisplayComments;short	DisplayedColumns;Boolean  GetStrOpen;Boolean typeRelevant;unsigned short fdFldrMask;short fdFldrVal;MenuHandle apMenu;Point	cSize;ListHandle	myList;CWindowPtr	myWindow;OSErr gErr;    RGBColor color; 					/** error variable **/HParamBlockRec gPb; 				/** parameter block for PBCatSearch **/FSSpec **gTheResults;CInfoPBRec gSpec1; 					/** search criteria, part 1 **/ CInfoPBRec gSpec2; 					/** search criteria, part 2 **/Ptr	gBuffer;Str255 gFileName;   				/** name of string to look for **/FSSpec **therealResults;short totfindcounter;					/** pointer to end of array of real results **/short volumes[100];					/** array of ioVRefNums (mounted vols) **/short volumearrayptr;					/** pointer to end of volumes[]  **/short iCtlValue;Boolean squashColumns;Cell	lCellCoords;Boolean textSearch;Boolean	reFound;short	fRefNum;Boolean FInfolistInMem;Boolean fChanged	=	false;void makeFaveTabSpecs(short theOne);MenuHandle	undoMenuH;FSSpec **theUndoResults;Boolean divertSamples;short oldFindCounter;short numTypesToSearch;short typeCounter;OSType	Fiyltype[10];Handle	fvolHdl;	Str31 fvolName[499];short fvolumes[1000];short fvolumesSource[1000];short filefvolumes[1000];short fvolumearrayptr;Boolean done;FSSpec	ghosts[199];short	ghostCounter = 0;short dSearcharrayptr;long snapSpecPtr;Boolean snapSpecFlushed;FSSpec divertSpec;short DispMode = 0;OSType divertDocCreator;Boolean DialogPresent = false;short DispMenuCheck = 0;Boolean SkipList;FSSpec	faveFSpec, faveISpec;FILE  *sessionLog;Boolean firstTime = true;Boolean MakeCompositeAE;Boolean AutoLaunchDivert;Boolean ExcludeDrives;Boolean PreservePopups;short maxVRef;Boolean undoFolderSearch;FSSpec theApplSpec;short presTop;	short presLeft;void saveNewPrefs (void);short presvertsize;short prestempor;Boolean freshSearch;Boolean discontigVolumes;Boolean dragAvailable;/********************************* main  ******************************************/Boolean DblBuffAudition = false;Boolean autoSustain = true;Boolean dontQuery = false;Boolean displayTypes = true;long theGreyColor;void RemoveVBL(void);void checkContig(void);pascal Boolean AlertFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit);void LoadTabFaves(short whichList);void setUpCurs(void);extern Boolean dontAdd;extern Boolean divertLoadBulk;ProcessSerialNumber PSNus;ModalFilterUPP xAlertFilter;#include "curs.h"extern Cell rememberCell;extern Boolean	rememberSelection;extern Boolean listOpen;extern  DragTrackingHandlerUPP xMyTrackingHandler;extern  DragReceiveHandlerUPP xMyReceiveDropHandler;void	startAppleScript( void );main(){	Boolean cancHit;	Str255	volName;	OSErr	iErr;	short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	StandardFileReply	mySFReply;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	Handle	hRsrc;	short  doWhat;	short fileCnt;	GDHandle	gdh;	long			gestaltResponse;	FSSpec theBackUpSpec;	PixMapHandle xx;	FSSpec theOpenDocSpec;	Boolean	dblClikOnDesk = false;	FSSpec	logSpec;	Str255 theStr;	Str255	logNameSpec = "\pSampleSearch™ Log";	Handle myhString;	Boolean skipsearch = false,firstTime;	divertLoadBulk = true;		InitStuff();				/** initialise Toolbox **/	MaxApplZone();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();		applVRefNum = 0;	iErr = HGetVol(theStr,&applVRefNum,&applDirID);	iErr = FSMakeFSSpec(applVRefNum,applDirID,theStr,&theApplSpec);	initialiseUPPs ();	GetCurrentProcess(&PSNus);	dontAdd = false;	iCtlValue = 1;				/** default popup menu position **/	reFound = false;	squashColumns = 1;	divertSamples = 0;	DisplayComments = 0;	DisplayedColumns = 4;	if ((Gestalt(gestaltDragMgrAttr, &gestaltResponse) != noErr) || (!(gestaltResponse & (1 << gestaltDragMgrPresent)))) 	{		dragAvailable = false;	}	else	{		dragAvailable = true;	}		gdh = GetMainDevice();	xx = ((**gdh).gdPMap);	if ((*xx)->pixelSize >1) /** if in color **/	{		theGreyColor = 52476;	}	else	{		theGreyColor = 65535;	}	cleanUpRes();	setUpCurs();	allocateHandles();	freshSearch = true;		theOpenDocSpec = AEvent ();	if (theOpenDocSpec.vRefNum != -999)	{		dblClikOnDesk = true;		openFSList(theOpenDocSpec);		checkList();		gogetvolref();		resolveOVols();	}	startAppleScript(  );	myhString = (Handle)GetString(998);	if (myhString)	{		BlockMove((*myhString)+1,&divertDocCreator,4L);	}	else	{		divertDocCreator = 'MACS';	}		GetStrOpen = 0;								/** was open pressed in initial dialog **/		DrawMenus();		/** main loop **/				/*iErr = FSMakeFSSpec(applVRefNum,applDirID,"\pSampleSearch™ Log",&logSpec);	if (iErr == -43)	{		iErr = FSpCreate(&logSpec,'ttxt','TEXT',0);	}		iErr = FSpOpenDF(&logSpec,fsCurPerm,&sessionLog);	if (iErr !=0)		genError ("\pCan't open Session log");*/			logSpec.vRefNum = theApplSpec.vRefNum;	logSpec.parID = theApplSpec.parID;	BlockMove (logNameSpec,logSpec.name,(*logNameSpec)+1L);	//logSpec.name = logNameSpec;			iErr = FSpDelete(&logSpec);			setUpTabs();	calcDrawingArray();	firstTime = true;	for (;;)	{		gogetvolref();		//fvolumearrayptr = volumearrayptr;		skipsearch = false;				if (theNewPrefs.noSearch && firstTime)		{			skipsearch = true;			SkipList = true;			dblClikOnDesk = true;			GetStrOpen = true;			firstTime = false;		}				if (!dblClikOnDesk)		{			cancHit = getsearchstring(false);/** ask user what string to search for **/						if (!cancHit)	/** exit program **/			{				/*totfindcounter = 0;				skipsearch = true;*/				DisposHandle((Handle)therealResults);				DisposHandle((Handle)gTheResults);				DisposPtr(gBuffer);					DisposHandle((Handle)theUndoResults);				HUnlock (volHdl);				DisposHandle ((Handle)volHdl);				FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempUndoFile",&theBackUpSpec);				FSpDelete(&theBackUpSpec);				FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);				FSpDelete(&theBackUpSpec);				cleanUpRes();				//RemoveVBL();				saveNewPrefs ();				ExitToShell();			}					if (!GetStrOpen) /** unless we pressed 'open' **/			{				searcher();					if (loseTheWindow)				{					SetPort ((GrafPtr)myWindow);					LDispose(myList);					listOpen = false;					rememberSelection = false;					myList = 0;		if (dragAvailable)		{			RemoveTrackingHandler(xMyTrackingHandler, (GrafPort *)myWindow);			RemoveReceiveHandler(xMyReceiveDropHandler, (GrafPort *)myWindow);		}					DisposeWindow((WindowPtr)myWindow);					loseTheWindow = false;				}			}						if (GetStrOpen)			{				if (!SkipList)				{									  		SFTypeList	myTypes;				  		StandardFileReply theReply;				  		myTypes[0] = 'SFlf';				  		StandardGetFile(0,1,myTypes,&theReply);				  		openFSList(theReply.sfFile);				  		checkList();						gogetvolref();						resolveOVols();				  						GetStrOpen = 0;				}				if (SkipList)				{										if (!stickyInfo)					{						DisplayComments = false;					}					CheckItem(GetMHandle(134), 2, DisplayComments);					DisplayedColumns = (3 * !DisplayComments )+ 1;										/* does it hilite the right tab */					LoadTabFaves(theNewPrefs.whichTab);										//LoadFaves();				}			}			}			dblClikOnDesk = false;						if (totfindcounter > 0 || SkipList)		{			SkipList = false;			do			{				DrawList();					/** display the list using the list manager  **/				handleEvents();				/** handle user interaction with list **/			} while (reFound);		}		else		{			SkipList = false;				color.red = 56797;				color.green = 56797;				color.blue = 56797;				RGBBackColor(&color);			dAlert(1090,nil);				/** nomatches were found **/		}	}	DisposHandle((Handle)therealResults);	DisposHandle((Handle)gTheResults);	DisposPtr(gBuffer);		DisposHandle((Handle)theUndoResults);	FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempUndoFile",&theBackUpSpec);	FSpDelete(&theBackUpSpec);	FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);	FSpDelete(&theBackUpSpec);	cleanUpRes();	//RemoveVBL();	saveNewPrefs ();	if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])			SaveAsTabFave(theNewPrefs.whichTab);	ExitToShell();		}/********************************* *********************  **************************/extern Boolean appearanceAvailable;void InitStuff(void){	SInt32			result;	OSErr err;	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	TEInit();	InitDialogs(nil);	InitCursor();	setUpCursors();	err = Gestalt( gestaltAppearanceAttr, &result ); /* check for appearance manager */	if ( err )	{		appearanceAvailable = false;	}	else	{	    appearanceAvailable = true;	}	}/********************************* *********************  **************************/void gogetvolref(void)		/** this function looks at the real mounted vols **/{	OSErr	iErr;	HVolumeParam	pb;	short x,y,z;	long freeBytes;	short	vRefNum;	Boolean missedOut;		volumearrayptr = 0;	x=1;		for (z=0;z<28;z++)	{		volumes[z] = 0;		*volName[z] = 0;	}	pb.ioCompletion = 0;	pb.ioNamePtr = nil;	pb.ioVRefNum = 0;	iErr = 0;	missedOut = false;	for (x = 1;x<28;x++)		/** index through volumes until error **/	{		pb.ioVolIndex = x; 				/* vary this to select volume **/		iErr = PBHGetVInfo((HParamBlockRec *)&pb,false);		if (iErr==0)		{			if (pb.ioVDRefNum < 0 && pb.ioVDrvInfo > 0)			{				volumes[-pb.ioVRefNum] = pb.ioVRefNum;		/** put ioVRefNum into array **/				iErr = GetVInfo(pb.ioVRefNum,volName[-pb.ioVRefNum],&vRefNum,&freeBytes);				if (iErr!=0)				{					genError("\pCannot GetVInfo in gogetvolrefs");				}			//	volumearrayptr++;				if (volumearrayptr < (-pb.ioVRefNum)) 					volumearrayptr = -pb.ioVRefNum;			}			else			{			/*iErr = PBUnmountVol((union ParamBlockRec *)&pb);			volumes[x] = 0;			*volName[x] = 0;*/			}			}			else		{	//	volumes[x] = 0;	//	*volName[x] = 0;		}						/** and increment pointer **/	}	dSearcharrayptr = volumearrayptr;	checkContig();	maxVRef = (-(findMaxVRefNum()));	discontigVolumes = false;	for (x=1;x<= volumearrayptr;x++)	{		if (-(volumes[x])>x)		{			discontigVolumes = true;			//Alert(1814,0);			return;		}	}}/*void gogetvolref(void)		{	OSErr	iErr;	HVolumeParam	pb;	short x,y;	long freeBytes;	short	vRefNum;	Boolean missedOut;		volumearrayptr = 0;	x=1;		pb.ioCompletion = 0;	pb.ioNamePtr = nil;	pb.ioVRefNum = 0;	iErr = 0;	missedOut = false;	for (x = 1;x<28;x++)			{		pb.ioVolIndex = x; 						iErr = PBHGetVInfo((HParamBlockRec *)&pb,false);		if (iErr==0)		{			if (pb.ioVDRefNum < 0 && pb.ioVDrvInfo > 0)			{				volumes[x] = pb.ioVRefNum;						iErr = GetVInfo(pb.ioVRefNum,volName[x],&vRefNum,&freeBytes);				if (iErr!=0)				{					genError("\pCannot GetVInfo in gogetvolrefs");				}				volumearrayptr++;				volumearrayptr = x;			}			else			{			iErr = PBUnmountVol((union ParamBlockRec *)&pb);			volumes[x] = 0;			*volName[x] = 0;			}			}			else		{		volumes[x] = 0;		*volName[x] = 0;		}							}	dSearcharrayptr = volumearrayptr;	checkContig();	maxVRef = (-(findMaxVRefNum()));	discontigVolumes = false;	for (x=1;x<= volumearrayptr;x++)	{		if (-(volumes[x])>x)		{			discontigVolumes = true;			//Alert(1814,0);			return;		}	}}*/Boolean isItOnLine(short myVRefNum);Boolean isItOnLine(short myVRefNum){	OSErr	iErr;	HVolumeParam	pb;		pb.ioCompletion = 0;	pb.ioNamePtr = nil;	pb.ioVRefNum = myVRefNum;			pb.ioVolIndex = 0; 				/* vary this to select volume **/				iErr = PBHGetVInfo((union HParamBlockRec *)&pb,false);		if (iErr==0)		{			if (pb.ioVDRefNum < 0 && pb.ioVDrvInfo > 0)			{				return true;			}			else			{				return false;			}		}			return false;}short findMaxVRefNum(void){	short z;	short maxvref=0;		for(z=1;z<=volumearrayptr;z++)	{		if (volumes[z]<maxvref)			maxvref = volumes[z];	}		return maxvref;}/********************************* *********************  **************************/CursHandle	cursH;void setUpCurs(void){		cursH = GetCursor( watchCursor );	/* constant in ToolboxUtil.h */		MoveHHi((Handle)cursH);		HLock ((Handle) cursH);	}void watchcursor(Boolean seting){	Cursor	textCrsr;			/* allocate a 68-byte struct */	if (seting)	{		textCrsr = **cursH;					/* copy the data */				SetCursor( &textCrsr );	}	else	{		SetCursor (&qd.arrow);	}}/********************************************************************************/short PopDialog(void){    Point where = {-1,-1};    									/**  set CustomGetfFile to auto centre dialog **/			    DialogPtr theDialog;										/**  Dialog pointer for CustomGetFile dialog  **/    StandardFileReply sfReply;									/**  details of returned file selection  */    Handle   hNew;												/** Handle to userdata which stores popup value **/        hNew = NewHandle(1L);										/** allocate 1 byte for popup result **/    MoveHHi(hNew);    HLock(hNew);												/** lock handle as we must pass a pointer **/    **hNew = 1;													/** set default value as top of popup menu **/                       HUnlock(hNew);												/** unlock handle **/	return 0;}/**************  xDlgHook callback for CustomGetFile - handles result of popup menu *****/pascal short xDlgHook(short item,DialogPtr theDlg,Ptr userData){	Handle iHandle;										/** recieves handle to popup menu **/	Rect iRect;												/** recieves RECT of popup menu **/	short iType;												/** recieves type of popup menu **/	short iCtlValue;											/** recieves SETTING of popup menu - this is what we want **/    if (item==10) 												/** if popup has been used - it is item 10 in the dialog **/    {			    GetDItem(theDlg,10,&iType,&iHandle,&iRect);  			/** get handle etc of popup **/	    iCtlValue = GetCtlValue((ControlHandle)iHandle);  						/** now get menu selected **/	    *userData = iCtlValue;									/** put menu item number into global userdata area to pass to FileFilter **/	    item = 101;												/** send pseudo item back to dialog box to invoke a redisplay of files **/    }    return item;												/** return redisplay request **/}/***********************************************************************/pascal void MyItemProc(WindowPtr theDlg,short theItem)		/** draws the line round the default dialog item **/{	Rect	iRect;	Handle	iHndl;	short	iType;		GetDItem (theDlg,1,&iType,&iHndl,&iRect);	PenSize(1,1);	InsetRect(&iRect,-1,-1);	FrameRect(&iRect);}/***********************************************************************//***********************************************************************/	void configPopup(void){		Handle hRsrc;			hRsrc = Get1Resource('MENU',150);	HLock(hRsrc);		HUnlock(hRsrc);}/***********************************************************************/voidident(void) {	short   alerresp;		color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	alerresp = dAlert(2000,0L); }	/***********************************************************************/void bringToDesk(FSSpec mySpec){	OSErr	iErr;	FInfo	fndrInfo;	short	fRefNum;	Point	where;	Ptr	pNew;	Str255 fgh;	short kj;		BlockMove(mySpec.name+1,fgh+1+*fgh,64L);	kj = *fgh;}/***********************************************************************/pascal short  cmp1stChar( Byte *cellPtr, Byte *testPtr, short cellLen,		short testLen ){Str255	strA  = "\p ";Str255	strB = "\p ";		BlockMove(cellPtr,strA+1,1L);	BlockMove(testPtr,strB+1,1L);	UprString(strA,true);	UprString(strB,true);		if (cellLen==0 || testLen==0) return(1);	if ( *(strA+1) >= *(strB+1) ) return(0);	/* Return 0 for a match */	else return(1);			/* Return 1 if no match */}short fVolmaxVRef = 0;void gogetoldrefs(FSSpec myFSSpec, Boolean appendList){	OSErr	iErr;	/** this function will create or append to the fvolumes list, OVols found in ghosts **/	short snapRefNum;	short iCnt,z;	Handle hRsrc, vRsrc;	short iRefNum;	short currentRef;	short oldmaxVRef = maxVRef;	Boolean missedOut;	short lastOne,q,myshort;	Byte myByte;	short lastarrayptr;	for (z=0;z<499;z++)	{		fvolumesSource[z] = 0;	}	gogetvolref(); /* fill up volumes - this was later */	fVolmaxVRef	= maxVRef;		if (!appendList)	{		fvolumearrayptr=volumearrayptr;	//	for (z=fvolumearrayptr+1;z<(198 - volumearrayptr);z++)	/** initialise globals **/		for (z=0;z<(499 - volumearrayptr);z++)					/** initialise globals **/		{			fvolumes[z] = 0;			*(fvolName[z]) = 0;		}		fVolmaxVRef = -fvolumearrayptr;	}	else	{		/* find the highest fvolume */		for (q=volumearrayptr;q<=fvolumearrayptr;q++)		{				if ((fvolumes[q] < (-fVolmaxVRef)) && fvolumes[q])			{				fVolmaxVRef = (-fvolumes[q]);			}				}	}		lastOne = 0; /* first one */		iRefNum = CurResFile();			/** preserve current resource file **/		snapRefNum = HOpenResFile(myFSSpec.vRefNum,myFSSpec.parID,myFSSpec.name,fsCurPerm);	/** open resource fork of specified ghost **/	iErr = ResError();	if (iErr!=0)	{		return;		genError("\pCouldn't open the current file in gogetoldrefs");	}	UseResFile(snapRefNum);	iErr = ResError();	if (iErr!=0)	{		genError("\pCould not UseResFile at start of gogetvolrefs");		}//	gogetvolref(); /* fill up volumes */	iCnt = CountResources('oVOL');	if (!iCnt)	{		genError("\pCouldn't find any oVol resources in gogetoldrefs");	}	if (!appendList)	{		fvolumearrayptr=volumearrayptr;	//	for (z=fvolumearrayptr+1;z<(199 -volumearrayptr);z++)					/** initialise globals **/		for (z=0;z<(499 -volumearrayptr);z++)					/** initialise globals **/		{			fvolumes[z] = 0;			*(fvolName[z]) = 0;		}	}	lastarrayptr = fvolumearrayptr;	oldmaxVRef = fvolumearrayptr;	//currentRef =maxVRef + 1;	for (z=1;z<=iCnt;z++)	{		short whichEntry;		SignedByte theByte;		vRsrc = Get1Resource ('oREF',z);		if  (!vRsrc)			genError ("\pMissing oREF");			myshort = ((unsigned short)**vRsrc);		theByte = myByte = (SignedByte)(myshort & 0x00FF);/* find out which fvolume array entry this will become */		whichEntry = (-theByte) + fvolumearrayptr;		fvolumesSource[whichEntry] = 0xFF00 | (short)(myByte);		fvolumes[whichEntry] = 0xFF00 | (short)(myByte - fvolumearrayptr);		hRsrc = Get1Resource('oVOL',z);		if (!hRsrc)		{			genError("\pCould not get one individual oVol in gogetoldrefs");		}		BlockMove(*hRsrc,fvolName[whichEntry],28L);/* maybe this should come at the end */		//fvolumearrayptr = (fvolumearrayptr > whichEntry) ? fvolumearrayptr	: whichEntry;				lastarrayptr = (lastarrayptr > whichEntry) ? lastarrayptr : whichEntry;			}		fvolumearrayptr = lastarrayptr;		//fvolumearrayptr = (fvolumearrayptr > whichEntry) ? fvolumearrayptr	: whichEntry;			CloseResFile(snapRefNum);	UseResFile(iRefNum);	iErr = ResError();	if (iErr!=0)	{		genError("\pCould not UseResFile at end of gogetvolrefs");		}	//resolveOVols(); /* need this ? */}void genError(Str255	myErrStr){	GrafPtr	savePort;	RGBColor theColor;		GetBackColor(&theColor);	GetPort (&savePort);	if (!DialogPresent)	{		color.red = 56797;		color.green = 56797;		color.blue = 56797;		RGBBackColor(&color);		ParamText(myErrStr,0,0,0);			dAlert	(2200,0);	}	SetPort (savePort);	RGBBackColor(&theColor);	if (isPressed(0x3A) && isPressed(0x3B) && isPressed(0x37))	{		Debugger();	}	return;}void cleanUpFVolumeGaps(void){	short z,y;	for (z=volumearrayptr+1;z<fvolumearrayptr;z++)	{			if (fvolumes[z] == 0 || (*fvolName[z] == 0))		{				for (y=0;y<totfindcounter;y++)			{				if ((*therealResults)[y].vRefNum == fvolumes[fvolumearrayptr])				{					(*therealResults)[y].vRefNum = -z;				}			}			fvolumes[z] = -z;			makeStr255(fvolName[fvolumearrayptr],fvolName[z]);			fvolumesSource[z] = fvolumesSource[fvolumearrayptr];						fvolumes[fvolumearrayptr] = 0;			fvolumesSource[fvolumearrayptr] = 0;			*fvolName[fvolumearrayptr] = 0;			while (fvolumearrayptr > volumearrayptr && !fvolumes[fvolumearrayptr])			{				fvolumearrayptr --;			}		}	}}void resolveOVols(void){	short zu;	short xu;	short yu;	short wu;	Boolean needToSkip;	for (xu=fvolumearrayptr;xu>volumearrayptr;xu--)			/** max ghosts to max mounted **/	{		if (fvolumes[xu] && *fvolName[xu]) /* this entry active */		{			needToSkip = false;			for (wu= 1;wu<=volumearrayptr;wu++)					/** min mounted to max mounted **/			{				if (EqualString(fvolName[xu],volName[wu],true,true)) 				{					for (yu=0;yu<totfindcounter;yu++)					{						if ((*therealResults)[yu].vRefNum == fvolumes[xu])						{							(*therealResults)[yu].vRefNum = volumes[wu];		/** set vRefNums to point to mounted volume **/						}					}					removefvolume(xu);					needToSkip = true;					break;				}			}			if (!needToSkip)			{				for (zu=volumearrayptr+1;zu<xu;zu++)				{					if (EqualString(fvolName[xu],fvolName[zu],true,true)) 					{						for (yu=0;yu<totfindcounter;yu++)						{							if ((*therealResults)[yu].vRefNum == fvolumes[xu])							{								(*therealResults)[yu].vRefNum = fvolumes[zu];							}							}								removefvolume(xu);  /** bubble through fvol list, updating FSSpec list data **/						break;					}							}			}		}				}					} 					/******************************************************/void removefvolume(short thefVol){	short a,b;	Boolean isAboveEntryInFvolumeTable;		if (thefVol == fvolumearrayptr)	{			fvolumes[fvolumearrayptr] = 0;		fvolumesSource[fvolumearrayptr] = 0;		*fvolName[fvolumearrayptr] = 0;		while (fvolumearrayptr > volumearrayptr && !fvolumes[fvolumearrayptr])		{			fvolumearrayptr --;		}		return;	}		fvolumes[thefVol] = 0;	*fvolName[thefVol] = 0;	fvolumesSource[thefVol] = 0;	cleanUpFVolumeGaps();/*	for (b = 0;b<totfindcounter;b++)	{		isAboveEntryInFvolumeTable = false;		a=thefVol+1		while (a<=fvolumearrayptr)		{			if ((*therealResults)[b].vRefNum == fvolumes[a]) 			{				(*therealResults)[b].vRefNum = fvolumes[a-1];			}			a++;			while (a<=fvolumearrayptr) && !fvolumes[a])			{				a++;			}		}	}		for (a=thefVol;a<fvolumearrayptr;a++)	{		BlockMove(fvolName[a+1],fvolName[a],28L);		fvolumesSource[a] = fvolumesSource[a+1];		//fvolumes[a] = fvolumes[a+1];	}	fvolumes[fvolumearrayptr] = 0;	fvolumesSource[fvolumearrayptr] = 0;	*fvolName[fvolumearrayptr] = 0;	while (fvolumearrayptr > volumearrayptr && !fvolumes[fvolumearrayptr])	{		fvolumearrayptr --;	}*/	return;}/******************************************************/	/****************************************************************/void allocateHandles(void){	OSErr iErr;	Handle hString;	short myDSrefNum;	short j;	/** allocate memory for pointers - change all this to handles **/		gTheResults = (FSSpec **)NewHandle((kMaxMatches+71L) * sizeof(FSSpec));	iErr = MemError();	if (iErr!=0)	{		genError("\pCannot allocate memory for gTheResults");		ExitToShell();	}	MoveHHi((Handle)gTheResults);	therealResults = (FSSpec **)NewHandle((kMaxMatches+71L) * sizeof(FSSpec));	iErr = MemError();	if (iErr!=0)	{		genError("\pCannot allocate memory for (*therealResults)");		ExitToShell();	}	MoveHHi((Handle)therealResults);	theUndoResults = (FSSpec **)NewHandle(10 * sizeof(FSSpec));	/** try and allocate mem for undo **/	iErr = MemError();	if (iErr!=0)	{		genError("\pCannot allocate memory for (*theUndoResults)");		ExitToShell();	}	//MoveHHi(theUndoResults);	/****************************************************************/		theFInfo = (FInfo **)NewHandle((kMaxMatches+71L) * sizeof(FInfo));	if (!theFInfo)	{		genError("\pCannot allocate memory for FInfo array");		ExitToShell();	}	MoveHHi((Handle)theFInfo);		/****************************************************************/		gBuffer = NewPtr(kOptBufferSize);			/** search cache  **/	iErr = MemError();	if (iErr!=0)	{		genError("\pCannot allocate memory for gBuffer");		ExitToShell();	}	myDSrefNum = openPrefFile();	if (!myDSrefNum)	{		genError ("\pProblem making prefs");	}	FSClose(myDSrefNum);	divertSpec = getDivertAppSpec();		if (divertSpec.vRefNum == -999)	{	  genError ("\pProblem getting divert spec");	} 	hString = (Handle)GetString(998);	if (hString)	{		BlockMove((*hString)+1,&divertDocCreator,4L);	}	DialogPresent = 0;			RetrievePrefs();	 readNewPrefs ();	/*****/	/*DispMode = DispMenuCheck;		DisplayComments = true;	CheckItem(GetMHandle(134), 2, DisplayComments);	DisplayedColumns = (3 * !DisplayComments )+ 1;	updateOptions();*/	/*****/		volHdl = NewHandle(256*60);	if (!volHdl)		genError ("\pNot enough memory to assign array");	MoveHHi(volHdl);	HLock (volHdl);	//volPtr = *volHdl;	volName = (Str255*)(*volHdl);//	fvolName = 	(Str31*)NewPtrClear(32*199);	/*	fvolHdl = NewHandle(32*199);	if (!fvolHdl)		genError ("\pNot enough memory to assign array");	MoveHHi(fvolHdl);	HLock (fvolHdl);	//volPtr = *volHdl;	fvolName = (Str31*)(*fvolHdl);*/	getAliasDirSpec();	getGhostsDirSpec();	makeFaveSpecs();	for (j=0;j<=lastItem;j++)		makeFaveTabSpecs(j);}void makeFaveTabSpecs(short theOne){	OSErr	error;	Str255 volName;	short	errCode;	SysEnvRec	ser;	short	myVRef;	short j;	short refNum;	short	myfRefNum;	long inOutCount;	long tempLong;	FSSpec	nullSpec,FaveInfo,FaveFile;	FInfo	nullFInfo;	OSErr	iErr;			j=theOne;if (true){	makefaveFile(j,&FaveFile, &FaveInfo);	iErr = FSpOpenDF(&FaveFile,fsRdPerm,&refNum);	if (!iErr)		FSClose(refNum);			if (iErr)	{		if (iErr)		{			error = FSpCreate(&FaveFile,'MgAl','SFfl',0);			if (error !=0)				genError ("\pCan't create New Fave spec file");			if(!error)			{				error = FSpOpenDF(&FaveFile,fsCurPerm,&refNum);				if (error !=0)					genError ("\pCan't Open New Fave spec file");				if (!error)				{					inOutCount = 4L;					tempLong = 0L;					nullSpec.vRefNum = 0;					nullSpec.parID = 0;					*(nullSpec.name) = 0;					error = FSWrite(refNum,&inOutCount,&tempLong);					if (error !=0)						genError ("\pCan't write to New Fave spec file");					inOutCount = 70L;					error = FSWrite(refNum,&inOutCount,&nullSpec);					if (error !=0)						genError ("\pCan't write to New Fave spec file");					FSClose(refNum);				}			}					}		else		{			genError ("\pProblem with favourite file : SSFaveList_FSSpec");						// put default vals into new list				}	}		iErr = FSpOpenDF(&FaveInfo,fsRdPerm,&refNum);	if (!iErr)		FSClose(refNum);			if (iErr)	{		if (iErr)		{			error = FSpCreate(&FaveInfo,'MgAl','SFfl',0);			if (error !=0)				genError ("\pCan't create New Fave FInfo file");			if(!error)			{				error = FSpOpenDF(&FaveInfo,fsCurPerm,&refNum);				if (error !=0)					genError ("\pCan't Open New Fave FInfo file");				if (!error)				{					inOutCount = 4L;					tempLong = 0L;					error = FSWrite(refNum,&inOutCount,&tempLong);					if (error !=0)						genError ("\pCan't write to New Fave FInfo file");					inOutCount = 16L;					error = FSWrite(refNum,&inOutCount,&nullFInfo);					if (error !=0)						genError ("\pCan't write to New Fave FInfo file");					FSClose(refNum);				}			}			}		else		{			genError ("\pProblem with favourite file : SSFaveList_FInfo");		}	}}	return;}void makeFaveSpecs(void){	OSErr	error;	Str255 volName;	short	errCode;	SysEnvRec	ser;	short	myVRef;	short	myfRefNum;	short refNum;	long inOutCount;	long tempLong;	FSSpec	nullSpec;	FInfo	nullFInfo;	errCode = SysEnvirons( curSysEnvVers, &ser );		myVRef = ser.sysVRefNum;		error = FSMakeFSSpec(myVRef,0,"\pSSFaveList_FSSpec",&faveFSpec);		if (error !=0)	{		if (error == -43)		{			error = FSpCreate(&faveFSpec,'MgAl','SFfl',0);			if (error !=0)				genError ("\pCan't create New Fave spec file");			if(!error)			{				error = FSpOpenDF(&faveFSpec,fsCurPerm,&refNum);				if (error !=0)					genError ("\pCan't Open New Fave spec file");				if (!error)				{					inOutCount = 4L;					tempLong = 0L;					nullSpec.vRefNum = 0;					nullSpec.parID = 0;					*(nullSpec.name) = 0;					error = FSWrite(refNum,&inOutCount,&tempLong);					if (error !=0)						genError ("\pCan't write to New Fave spec file");					inOutCount = 70L;					error = FSWrite(refNum,&inOutCount,&nullSpec);					if (error !=0)						genError ("\pCan't write to New Fave spec file");					FSClose(refNum);				}			}					}		else		{			genError ("\pProblem with favourite file : SSFaveList_FSSpec");						// put default vals into new list				}	}	error = FSMakeFSSpec(myVRef,0,"\pSSFaveList_FInfo",&faveISpec);	if (error !=0)	{		if (error == -43)		{			error = FSpCreate(&faveISpec,'MgAl','SFfl',0);			if (error !=0)				genError ("\pCan't create New Fave FInfo file");			if(!error)			{				error = FSpOpenDF(&faveISpec,fsCurPerm,&refNum);				if (error !=0)					genError ("\pCan't Open New Fave FInfo file");				if (!error)				{					inOutCount = 4L;					tempLong = 0L;					error = FSWrite(refNum,&inOutCount,&tempLong);					if (error !=0)						genError ("\pCan't write to New Fave FInfo file");					inOutCount = 16L;					error = FSWrite(refNum,&inOutCount,&nullFInfo);					if (error !=0)						genError ("\pCan't write to New Fave FInfo file");					FSClose(refNum);				}			}			}		else		{			genError ("\pProblem with favourite file : SSFaveList_FInfo");		}	}	return;}Boolean	YesNo (Str255	myText){	short ItemHit;	RGBColor theold;		GetBackColor(&theold);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	ParamText(myText,0,0,0);	ItemHit = dAlert (1066,0);	RGBBackColor(&theold);	return (ItemHit == 2);}void getAliasDirSpec(void){		CInfoPBRec	cipbr;				/* local pb */	//HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	Str255	dirFullName,zfilename;	long myDrDir;	long dirID, createdDirID;	OSErr	iErr;			makeStr255("\pSampleSearch™ Divert Aliases",zfilename); 	dpb->ioVRefNum = theApplSpec.vRefNum;		/* default volume */		dpb->ioNamePtr = zfilename;		dpb->ioDrDirID = theApplSpec.parID;	dpb->ioDrParID = theApplSpec.parID;	dpb->ioFDirIndex = 0;			rc = PBGetCatInfo( &cipbr, FALSE );	if (rc | !dpb->ioFlAttrib & 16) 	{		iErr = DirCreate(dpb->ioVRefNum,theApplSpec.parID,"\pSampleSearch™ Divert Aliases",&AliasesDirID);		if (iErr!=0)		{			genError ("\pCan't create aliases directory");		}	}	else	{		AliasesDirID = dpb->ioDrDirID;	}	return;}void getGhostsDirSpecInsideGhosts(Str255 folderName);void getGhostsDirSpecInsideGhosts(Str255 folderName){	CInfoPBRec	cipbr;				/* local pb */	//HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	Str255	dirFullName,zfilename;	long myDrDir;	long dirID, createdDirID;	OSErr	iErr;			makeStr255(folderName,zfilename); 	dpb->ioVRefNum = theApplSpec.vRefNum;		/* default volume */		dpb->ioNamePtr = zfilename;		dpb->ioDrDirID = GhostsDirID;	dpb->ioDrParID = GhostsDirID;	dpb->ioFDirIndex = 0;			rc = PBGetCatInfo( &cipbr, FALSE );	if (rc | !dpb->ioFlAttrib & 16) 	{	}	else	{		GhostsDirID = dpb->ioDrDirID;	}	return;}void getGhostsDirSpec(void){		CInfoPBRec	cipbr;				/* local pb */	//HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	Str255	dirFullName,zfilename;	long myDrDir;	long dirID, createdDirID;	OSErr	iErr;			makeStr255("\pSampleSearch™ Ghost Snapshots",zfilename); 	dpb->ioVRefNum = theApplSpec.vRefNum;		/* default volume */		dpb->ioNamePtr = zfilename;		dpb->ioDrDirID = theApplSpec.parID;	dpb->ioDrParID = theApplSpec.parID;	dpb->ioFDirIndex = 0;			rc = PBGetCatInfo( &cipbr, FALSE );	if (rc | !dpb->ioFlAttrib & 16) 	{		iErr = DirCreate(dpb->ioVRefNum,theApplSpec.parID,"\pSampleSearch™ Ghost Snapshots",&GhostsDirID);		if (iErr!=0)		{			genError ("\pCan't create ghosts directory");		}	}	else	{		GhostsDirID = dpb->ioDrDirID;	}	return;}short dAlert(short dnum,Ptr theFilt){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	GrafPtr	savePort;	GetPort(&savePort);	myDlg = GetNewDialog(dnum,0L,(WindowPtr)-1);	if (!myDlg)		return 0;	SetPort(myDlg);	color.red = 56797;	color.green = 56797;	color.blue =56797;	RGBBackColor(&color);			GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		ShowWindow(myDlg);	ModalDialog(xAlertFilter,&itemHit);	DisposDialog(myDlg);	SetPort(savePort);	return itemHit;	}pascal Boolean AlertFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit){	OSErr	iErr;	char theChar;		switch (theEvent->what) 	{		case keyDown:			// if key was pressed, handle return key			theChar = (theEvent->message) & charCodeMask;			if ( (theChar == 0x0d) || (theChar == 0x03)) 			{					*itemHit = 1;					return TRUE;			}					return FALSE;		break;					default :			return FALSE;		break;	}}void cleanUpRes(void){	Handle myH;	myH = GetResource('snd ',2000);	if (myH)	{		RmveResource(myH);		DisposHandle((Handle)myH);	}	myH = GetResource('snd ',2001);	if (myH)	{		RmveResource(myH);		DisposHandle((Handle)myH);	}	UpdateResFile(CurResFile());} void checkContig(void) { 	OSErr	iErr; 	short z; 	Str255 theString; 	short theRefNum; 	  } 