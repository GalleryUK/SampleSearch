/* play region s as it makes the,m *//* indicate inregion / out region *//* beeps *//* alter the settings as you go along *//* pop up each region as you go along */Boolean makeMaxAudio (Handle theAudio, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel);Boolean makeMeanAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel);Boolean progressDispN(short percentFull, short theValue);#include "SampleSearch.h"#include "Globals.h"#include <stdlib.h>//pascal OSErr	GetStdFilterProc(ProcPtr *theProc) = {0x303C, 0x0203,0xAA68};#define lookForQuiet 1#define lookForInPoint 2extern Handle theAudio;Boolean EndPtatStart;Boolean editRegionCancelled;Boolean interactiveEditing;short threshMethod;//pascal OSErr GetStdFilterProc(ProcPtr *theProc) = {0x303C, 0x0203, 0xAA68};typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;typedef struct RegionMakerPrefs {Boolean	copyOldRgns;Boolean	interactiveEdit;Boolean	methodA;Boolean  methodB;Boolean	endAtStartPt;short 	startThresh;short 	endThresh;long	minRgnLength;long preRoll;long postRoll;long methodABlockLength;long methodBQuietLength;} RegionMakerPrefs, *RegionMakerPrefsPtr;typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;Boolean editRegion(FSSpec mySpec,RegionRec** myRgnHdl);long theQuietSoFar;long audioScan (Handle theAudio, long theBytes, Boolean stereo, short wordSize, short scanMode);pascal Boolean myDFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);Boolean makeMeanAudio (Handle theAudio, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel);Boolean threshProcess (FSSpec mySpec,unsigned short zthreshold, Boolean cropStart, Boolean cropEnd, Boolean makeRegions,Boolean keepOldRegions);long theMillis, preRoll, postRoll;unsigned short threshold, Outthreshold;long theMinRegionLength,theQuietLength;Boolean threshProcessMany(void);Boolean threshProcessMany(void){	Cell theCell;	short theindex;		SetPt( &theCell, 0,0 );		/* start at top of list  */	LGetSelect( TRUE, &theCell, myList);		if (theCell.h == 1 && DisplayedColumns == 1)	{		LNextCell( TRUE, TRUE, &theCell, myList );		LGetSelect( TRUE, &theCell, myList) ;	}		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		threshProcess ((*therealResults)[theindex], threshold, false, false, true, false);	return true;}Boolean threshProcess (FSSpec mySpec, unsigned short zthreshold, Boolean cropStart, Boolean cropEnd, Boolean makeRegions, Boolean keepOldRegions){	RegionRec **	theRegionData;	RegionRec	theNewRegions[10];	long theRate;	short theWordSize;	long scanResult;	Boolean stereo;	long theBytes;	Boolean failed;	long theChunkLength;	long z;	Handle theAudioData;	OSErr	iErr;	short refNum,rfRefNum;	long inOutCount;	Boolean inRegion = false;	Handle theOldResources;	long lByteCnt;	short regionCount;	short regionIDCount = 0L;	short regionRecIndex = 0;	unsigned long secs;	long leftLevel;	long rightLevel;	Str255 regionTempText = "\pRegion";	Str255 sourceB, sourceA;	long theFPos;	Handle theddRL;	ddRLHeader theddRLHeader;	short curRefNum;	RegionRec** myRgnHdl;	long thePresFPos;	FInfo fndrInfo;	RegionMakerPrefs myPrefs;	Handle myPrefsH;	ModalFilterUPP xmyDFilter = NewModalFilterProc (myDFilter);	/************/	short itemHit, oldRefNum, newRefNum;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr;	Cell theCell;	short theindex;	Point localPt;	short  iCtlPart;	Str255 milliStr;	long theAverVal, theAveBytes;	GrafPtr saveXPort;	threshMethod = 1;		theQuietSoFar = 0L;	iErr = FSpGetFInfo(&mySpec,&fndrInfo);			if (fndrInfo.fdType != 'Sd2f')	{		genError ("\pNot a Sound Designer II file");		return false;	}	failed = getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes);	if (failed)	{		genError ("\pCan't get SDII information");	//	DisposHandle((Handle)theRegionData);		return false;	}		if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	GetPort(&saveXPort);	myDlg = GetNewDialog(1557,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);		/***********/	myPrefsH = Get1Resource('RMpf',1000);	if (myPrefsH)	{		BlockMove (*myPrefsH, &myPrefs, sizeof(RegionMakerPrefs));		ReleaseResource(myPrefsH);	}	else	{		myPrefs.copyOldRgns = false;		myPrefs.interactiveEdit = false;		myPrefs.methodA = false;		myPrefs.methodB = true;		myPrefs.endAtStartPt = true;		myPrefs.startThresh = 10L;		myPrefs.endThresh = 10L;		myPrefs.minRgnLength = 100L;		myPrefs.preRoll = 0L;		myPrefs.postRoll = 0L;		myPrefs.methodABlockLength = 50L;		myPrefs.methodBQuietLength = 75L;				myPrefsH = NewHandle(sizeof(RegionMakerPrefs));		if (!myPrefsH)		{				genError ("\pNot enough memory");			return false;		}		BlockMove (&myPrefs, *myPrefsH, sizeof(RegionMakerPrefs));		AddResource(myPrefsH,'RMpf',1000,"\pRegion Maker prefs");		WriteResource(myPrefsH);		ReleaseResource(myPrefsH);	}	/**************/		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		theAverVal = myPrefs.startThresh;	NumToString(theAverVal,textStr);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);		SetIText(iHndl,textStr);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theAverVal);		theAverVal = myPrefs.endThresh;	NumToString(theAverVal,textStr);	GetDItem(myDlg,24,&iType,&iHndl,&iRect);		SetIText(iHndl,textStr);	GetDItem(myDlg,23,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,theAverVal);		/*	theAverVal = (theWordSize == 2) ? 1000L : 10L;	NumToString(theAverVal,textStr);	GetDItem(myDlg,30,&iType,&iHndl,&iRect);		SetIText(iHndl,textStr);*/		GetDItem(myDlg,17,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,myPrefs.methodB);		GetDItem(myDlg,14,&iType,&iHndl,&iRect);	 	SetCtlValue((ControlHandle)iHndl,myPrefs.methodA);		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	 	SetCtlValue((ControlHandle)iHndl,myPrefs.copyOldRgns);	GetDItem(myDlg,8,&iType,&iHndl,&iRect);		NumToString(myPrefs.methodABlockLength,textStr);	SetIText(iHndl,textStr);	GetDItem(myDlg,11,&iType,&iHndl,&iRect);		NumToString(myPrefs.minRgnLength,textStr);	SetIText(iHndl,textStr);		GetDItem(myDlg,18,&iType,&iHndl,&iRect);		NumToString(myPrefs.methodBQuietLength,textStr);	SetIText(iHndl,textStr);		GetDItem(myDlg,28,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,myPrefs.interactiveEdit);		GetDItem(myDlg,31,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,myPrefs.endAtStartPt);		GetDItem(myDlg,32,&iType,&iHndl,&iRect);		NumToString(myPrefs.preRoll,textStr);	SetIText(iHndl,textStr);	GetDItem(myDlg,33,&iType,&iHndl,&iRect);		NumToString(myPrefs.postRoll,textStr);	SetIText(iHndl,textStr);	ShowWindow(myDlg);	 	SetPort(myDlg); 	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xmyDFilter,&itemHit);		switch (itemHit)		{			case 5:				GetMouse(&localPt);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				iCtlPart = TestControl((ControlHandle)iHndl,localPt);				/*iCtlPart = FindControl(localPt,myDlg,&iHndl);*/				switch (iCtlPart)				{					case inDownButton:						GetDItem(myDlg,5,&iType,&iHndl,&iRect);							threshold = GetCtlValue((ControlHandle)(ControlHandle)iHndl);						threshold += 1;						SetCtlValue((ControlHandle)iHndl,threshold);						threshold = (threshold>127) ? 127 : threshold;					break;										case inUpButton:						GetDItem(myDlg,5,&iType,&iHndl,&iRect);							threshold = GetCtlValue((ControlHandle)iHndl);						threshold -= 1;						SetCtlValue((ControlHandle)iHndl,threshold);						threshold = (threshold<0) ? 0 : threshold;					break;										case inPageDown:						GetDItem(myDlg,5,&iType,&iHndl,&iRect);							threshold = GetCtlValue((ControlHandle)iHndl);						threshold += 10;						SetCtlValue((ControlHandle)iHndl,threshold);						threshold = (threshold>127) ? 127 : threshold;					break;										case inPageUp:						GetDItem(myDlg,5,&iType,&iHndl,&iRect);							threshold = GetCtlValue((ControlHandle)iHndl);						threshold -= 10;						SetCtlValue((ControlHandle)iHndl,threshold);						threshold = (threshold<0) ? 0 : threshold;					break;										default:					break;				}								GetDItem(myDlg,5,&iType,&iHndl,&iRect);					threshold = GetCtlValue((ControlHandle)iHndl);				NumToString((long)threshold,textStr);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);					SetIText(iHndl,textStr);			break;						case 23:				GetMouse(&localPt);				GetDItem(myDlg,23,&iType,&iHndl,&iRect);				iCtlPart = TestControl((ControlHandle)iHndl,localPt);				/*iCtlPart = FindControl(localPt,myDlg,&iHndl);*/				switch (iCtlPart)				{					case inDownButton:						GetDItem(myDlg,23,&iType,&iHndl,&iRect);							Outthreshold = GetCtlValue((ControlHandle)iHndl);						Outthreshold += 1;						SetCtlValue((ControlHandle)iHndl,Outthreshold);						Outthreshold = (Outthreshold>127) ? 127 : Outthreshold;					break;										case inUpButton:						GetDItem(myDlg,23,&iType,&iHndl,&iRect);							Outthreshold = GetCtlValue((ControlHandle)iHndl);						Outthreshold -= 1;						SetCtlValue((ControlHandle)iHndl,Outthreshold);						Outthreshold = (Outthreshold<0) ? 0 : Outthreshold;											break;										case inPageDown:						GetDItem(myDlg,23,&iType,&iHndl,&iRect);							Outthreshold = GetCtlValue((ControlHandle)iHndl);						Outthreshold += 10;						SetCtlValue((ControlHandle)iHndl,Outthreshold);						Outthreshold = (Outthreshold>127) ? 127 : Outthreshold;					break;										case inPageUp:						GetDItem(myDlg,23,&iType,&iHndl,&iRect);							Outthreshold = GetCtlValue((ControlHandle)iHndl);						Outthreshold -= 10;						SetCtlValue((ControlHandle)iHndl,Outthreshold);						Outthreshold = (Outthreshold<0) ? 0 : Outthreshold;					break;										default:					break;				}				GetDItem(myDlg,23,&iType,&iHndl,&iRect);					Outthreshold = GetCtlValue((ControlHandle)iHndl);				NumToString((long)Outthreshold,textStr);				GetDItem(myDlg,24,&iType,&iHndl,&iRect);					SetIText(iHndl,textStr);			break;						case 7:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 31:				GetDItem(myDlg,31,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 17:				GetDItem(myDlg,17,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,14,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,false);			break;						case 14:				GetDItem(myDlg,14,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,17,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,false);			break;						case 1:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);					threshold = GetCtlValue((ControlHandle)iHndl); 				myPrefs.startThresh = (long)threshold;								GetDItem(myDlg,23,&iType,&iHndl,&iRect);					Outthreshold = GetCtlValue((ControlHandle)iHndl);				myPrefs.endThresh = (long)Outthreshold;				GetDItem(myDlg,28,&iType,&iHndl,&iRect);					myPrefs.interactiveEdit = interactiveEditing = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,7,&iType,&iHndl,&iRect);					myPrefs.copyOldRgns = keepOldRegions = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,17,&iType,&iHndl,&iRect);					threshMethod = (GetCtlValue((ControlHandle)iHndl))+1;				myPrefs.methodB = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,14,&iType,&iHndl,&iRect);					myPrefs.methodA = GetCtlValue((ControlHandle)iHndl);								GetDItem(myDlg,31,&iType,&iHndl,&iRect);					myPrefs.endAtStartPt = EndPtatStart = (GetCtlValue((ControlHandle)iHndl));								GetDItem(myDlg,8,&iType,&iHndl,&iRect);					GetIText(iHndl,milliStr);				StringToNum (milliStr, &theMillis);				if (theMillis <= 0L)					theMillis = 2L;				myPrefs.methodABlockLength = theMillis;								/*	GetDItem(myDlg,30,&iType,&iHndl,&iRect);					GetIText(iHndl,milliStr);				StringToNum (milliStr, &theAverVal);				if (theWordSize == 2)					theAverVal /= 255;				if (theAverVal <= 0L)					theAverVal = 2L;*/									GetDItem(myDlg,32,&iType,&iHndl,&iRect);					GetIText(iHndl,milliStr);				StringToNum (milliStr, &preRoll);				if (preRoll <= 0L)					preRoll = 0L;				myPrefs.preRoll = preRoll;									GetDItem(myDlg,33,&iType,&iHndl,&iRect);					GetIText(iHndl,milliStr);				StringToNum (milliStr, &postRoll);				if (postRoll <= 0L)					postRoll = 0L;				myPrefs.postRoll = postRoll;								GetDItem(myDlg,11,&iType,&iHndl,&iRect);					GetIText(iHndl,milliStr);				StringToNum (milliStr, &theMinRegionLength);				if  (!theMinRegionLength)					theMinRegionLength = 2L;				myPrefs.minRgnLength = theMinRegionLength;									GetDItem(myDlg,18,&iType,&iHndl,&iRect);					GetIText(iHndl,milliStr);				StringToNum (milliStr, &theQuietLength);				if  (!theQuietLength)					theQuietLength = 2L;					myPrefs.methodBQuietLength = 	theQuietLength;			break;						case 28:				GetDItem(myDlg,28,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;								}	}	DisposDialog(myDlg);		SetPort(saveXPort);		if (itemHit == 2)		return false;		/************/	/*threshMethod = 1;*/	/* correct this */		myPrefsH = Get1Resource('RMpf',1000);	if (myPrefsH)	{		BlockMove (&myPrefs, *myPrefsH, sizeof(RegionMakerPrefs));		ChangedResource(myPrefsH);		WriteResource(myPrefsH);		ReleaseResource(myPrefsH);	}		myRgnHdl = (RegionRec **)NewHandle(sizeof(RegionRec));	if (!myRgnHdl)	{		SysBeep(5);		return false;	}		theRegionData = (RegionRec**)NewHandle(1000 * sizeof(RegionRec));	if (!theRegionData)	{		genError ("\pNot enough memory for that operation");		return false;	}	/* ((RegionRecPtr)(*theRegionData))[1].RegionID */	failed = getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes);	if (failed)	{		genError ("\pCan't get SDII information");		DisposHandle((Handle)theRegionData);		return false;	}	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	/* more level 1 bodges */	/*if (theWordSize == 2)	{		threshold *= 256;		if (threshold == 256)			threshold == 1;	}		if (theWordSize == 2)	{		Outthreshold *= 256;		if (Outthreshold == 256)			Outthreshold == 1;	}*/			if (theWordSize == 2)	{		threshold *= threshold;	}		if (theWordSize == 2)	{		Outthreshold *= Outthreshold;	}				theChunkLength = ((long)theRate * (long)theWordSize * ((long)stereo + 1L)) / ((1000L / (long)theMillis)+1L);		theChunkLength = (theChunkLength >> 1) << 1;		theMinRegionLength =  ((theMinRegionLength * theRate) / 1000L); //(theRate * theWordSize * (stereo + 1)) / ((1000L / theMinRegionLength)+1L);	theQuietLength = ((theQuietLength * theRate) / 1000L);		if (stereo)	{		theMinRegionLength *= 2;		theQuietLength *= 2;	}	//	theQuietLength = (theRate * theWordSize * (stereo + 1)) / ((1000L / theQuietLength)+1L); 		if (preRoll)		preRoll = ((preRoll * theRate) / 1000L); //(theRate * theWordSize * (stereo + 1)) / ((1000L / preRoll)+1L); 	if (postRoll)		postRoll = ((postRoll * theRate) / 1000L);  //(theRate * theWordSize * (stereo + 1)) / ((1000L / postRoll)+1L); 			curRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	UseResFile(rfRefNum);	if (rfRefNum == -1)	{		genError ("\pCan't open SDII resource fork");		DisposHandle((Handle)theRegionData);		return false;	}		theOldResources = Get1Resource('ddRL',1000);	DetachResource(theOldResources);	iErr = ResError();	CloseResFile(rfRefNum);	UseResFile(curRefNum);		if (theOldResources && keepOldRegions)	{		lByteCnt = GetHandleSize(theOldResources);		//lByteCnt = SizeResource(theOldResources);		if (lByteCnt <= 18L)		{			SysBeep(5);			DisposHandle((Handle)theRegionData);			return false;		}				BlockMove (*theOldResources, &theddRLHeader, 18L);		regionIDCount = theddRLHeader.NextID; 		regionCount = (lByteCnt - 18L) / 56L;		for (z=0 ;z< regionCount;z++)		{					BlockMove (*theOldResources + 18L + (z*56L), &(((RegionRecPtr)(*theRegionData))[regionRecIndex]), 56L);			regionRecIndex ++;		}	}	else	{		/*((RegionRecPtr)(*theRegionData))[0].RegionID = 0L;		((RegionRecPtr)(*theRegionData))[0].StartFrame = 0L;		((RegionRecPtr)(*theRegionData))[0].StopFrame = 0L;		((RegionRecPtr)(*theRegionData))[0].SynchFrame = 0L;		GetDateTime(&secs);		((RegionRecPtr)(*theRegionData))[0].TimeStampMS = secs;		((RegionRecPtr)(*theRegionData))[0].TimeStampLS = secs;		BlockMove (mySpec.name,((RegionRecPtr)(*theRegionData))[0].RegionName,32L);		regionRecIndex ++;*/	}		theAudioData = NewHandle(theChunkLength);	if (!theAudioData)	{		genError ("\pNot enough memory for that operation");		DisposHandle((Handle)theRegionData);		return false;	}	HLock(theAudioData);		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr != 0)	{		genError ("\pCan't open SDII data fork");		DisposHandle((Handle)theRegionData);		HUnlock(theAudioData);		DisposHandle((Handle)theAudioData);		return false;	}		progressCreate("\pCreating Regions");	if (!theBytes)		theBytes += 2;	for (z=0L;z <= theBytes; z+= theChunkLength)	{		if (progressDispN(z*100/theBytes, regionRecIndex))		{				HUnlock(theAudioData);			DisposHandle((Handle)theAudioData);			FSClose (refNum);			DisposHandle((Handle)theRegionData);			return false;		}				inOutCount = theChunkLength;		if (iErr != 0)		{			genError ("\pCan't read SDII data fork");				HUnlock(theAudioData);			DisposHandle((Handle)theAudioData);			FSClose (refNum);			DisposHandle((Handle)theRegionData);			progressDispos();			return false;		}		iErr = GetFPos(refNum,&theFPos);		iErr = FSRead(refNum,&inOutCount,*theAudioData);		switch (threshMethod)		{			case 1:				makeMeanAudio (theAudioData, inOutCount, stereo, theWordSize, &leftLevel, &rightLevel);				if (inRegion)				{					if (leftLevel < Outthreshold && rightLevel < Outthreshold)					{						/* do the end region thing */						iErr = GetFPos(refNum,&theFPos);						((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame = (theFPos / (long)(theWordSize * (stereo+1))) + postRoll;						if ((((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame - ((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame) > theMinRegionLength)						{							regionRecIndex ++;							if (interactiveEditing)							{								BlockMove (&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),*myRgnHdl,sizeof(RegionRec));																iErr = GetFPos(refNum,&thePresFPos);								FSClose(refNum);								editRegion(mySpec,myRgnHdl);								iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);								iErr = SetFPos(refNum,1,thePresFPos);								if (editRegionCancelled)								{									regionRecIndex --;								}								else								{									BlockMove (*myRgnHdl,&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),sizeof(RegionRec));															}							}						}						inRegion = false;					}				}				else				{					if (leftLevel >= threshold || rightLevel >= threshold)					{						/* do the start region thing */						inRegion = true;						((RegionRecPtr)(*theRegionData))[regionRecIndex].RegionID = regionIDCount + 1;						regionIDCount ++;						((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame = (theFPos / (long)(theWordSize * (stereo+1)))-preRoll;						if (((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame < 0L)						((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame = 0L;						((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame = (theFPos / (long)(theWordSize * (stereo+1)))-preRoll;						if (((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame < 0L)						((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame = 0L;						GetDateTime(&secs);						((RegionRecPtr)(*theRegionData))[regionRecIndex].TimeStampMS = secs;						((RegionRecPtr)(*theRegionData))[regionRecIndex].TimeStampLS = secs;						NumToString((long)regionRecIndex,sourceB);						if (*sourceB == 1)						{							*sourceB = 2;							*(sourceB+2) = *(sourceB+1);							*(sourceB+1) = '0';						}						BlockMove (regionTempText,sourceA,256L);						concatStrings(sourceA,sourceB,"\p ");						BlockMove (sourceA,((RegionRecPtr)(*theRegionData))[regionRecIndex].RegionName,32L);					}				}			break;						case 2:				if (inRegion)				{					scanResult = audioScan (theAudioData, inOutCount, stereo, theWordSize, lookForQuiet);					if (scanResult < 0L)					{						break;					}					else					{						((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame = (((theFPos / (long)(theWordSize * (stereo+1)))+scanResult)+postRoll)-((long)EndPtatStart * theQuietLength);						if ((((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame - ((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame) > theMinRegionLength)						{							/****/							iErr = GetFPos(refNum,&thePresFPos);								/****/								regionRecIndex ++;								if (interactiveEditing)								{									BlockMove (&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),*myRgnHdl,sizeof(RegionRec));																		iErr = GetFPos(refNum,&thePresFPos);									FSClose(refNum);									editRegion(mySpec,myRgnHdl);									iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);									iErr = SetFPos(refNum,1,thePresFPos);									if (editRegionCancelled)									{										regionRecIndex --;									}									else									{										BlockMove (*myRgnHdl,&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),sizeof(RegionRec));																}								}														inRegion = false;						}											}				}				else				{					scanResult = audioScan (theAudioData, inOutCount, stereo, theWordSize, lookForInPoint);					if (scanResult < 0L)					{						break;					}					else					{						inRegion = true;						((RegionRecPtr)(*theRegionData))[regionRecIndex].RegionID = regionIDCount + 1;						regionIDCount ++;						((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame = ((theFPos / (long)(theWordSize * (stereo+1)))+scanResult)-preRoll;						if (((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame < 0L)							((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame = 0L;						((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame = ((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame;						if (((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame < 0L)							((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame = 0L;						GetDateTime(&secs);						((RegionRecPtr)(*theRegionData))[regionRecIndex].TimeStampMS = secs;						((RegionRecPtr)(*theRegionData))[regionRecIndex].TimeStampLS = secs;						NumToString((long)regionRecIndex,sourceB);						if (*sourceB == 1)						{							*sourceB = 2;							*(sourceB+2) = *(sourceB+1);							*(sourceB+1) = '0';						}						BlockMove (regionTempText,sourceA, 256L);						concatStrings(sourceA,sourceB,"\p ");						BlockMove (sourceA,((RegionRecPtr)(*theRegionData))[regionRecIndex].RegionName,32L);					}				}			break;						case 3:				makeMaxAudio (theAudioData, inOutCount, stereo, theWordSize, &leftLevel, &rightLevel);				if (inRegion)				{					if (leftLevel < Outthreshold && rightLevel < Outthreshold)					{						/* do the end region thing */						iErr = GetFPos(refNum,&theFPos);						((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame = (theFPos / (long)(theWordSize * (stereo+1))) + postRoll;						if ((((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame - ((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame) > theMinRegionLength)						{							regionRecIndex ++;							if (interactiveEditing)							{								BlockMove (&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),*myRgnHdl,sizeof(RegionRec));																iErr = GetFPos(refNum,&thePresFPos);								FSClose(refNum);								editRegion(mySpec,myRgnHdl);								iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);								iErr = SetFPos(refNum,1,thePresFPos);								if (editRegionCancelled)								{									regionRecIndex --;								}								else								{									BlockMove (*myRgnHdl,&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),sizeof(RegionRec));															}							}						}						inRegion = false;					}				}				else				{					if (leftLevel >= threshold || rightLevel >= threshold)					{						/* do the start region thing */						inRegion = true;						((RegionRecPtr)(*theRegionData))[regionRecIndex].RegionID = regionIDCount + 1;						regionIDCount ++;						((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame = (theFPos / (long)(theWordSize * (stereo+1)))-preRoll;						if (((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame<0L)							((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame  = 0L;						((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame = (theFPos / (long)(theWordSize * (stereo+1)))-preRoll;						if (((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame<0L)							((RegionRecPtr)(*theRegionData))[regionRecIndex].SynchFrame  = 0L;						GetDateTime(&secs);						((RegionRecPtr)(*theRegionData))[regionRecIndex].TimeStampMS = secs;						((RegionRecPtr)(*theRegionData))[regionRecIndex].TimeStampLS = secs;						NumToString((long)regionRecIndex,sourceB);						BlockMove (regionTempText,sourceA, 256L);						concatStrings(sourceA,sourceB,"\p ");						BlockMove (sourceA,((RegionRecPtr)(*theRegionData))[regionRecIndex].RegionName,32L);					}				}			break;		}						if (regionRecIndex > 999)			z = theBytes + 2;				/*z = (z >> 1) << 1;*/	}		if (inRegion)	{		iErr = GetFPos(refNum,&theFPos);		((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame = theFPos / (long)(theWordSize * (stereo+1));		if ((((RegionRecPtr)(*theRegionData))[regionRecIndex].StopFrame - ((RegionRecPtr)(*theRegionData))[regionRecIndex].StartFrame) > theMinRegionLength)		{			regionRecIndex ++;			if (interactiveEditing)			{				BlockMove (&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),*myRgnHdl,sizeof(RegionRec));								iErr = GetFPos(refNum,&thePresFPos);				FSClose(refNum);				//oldRefNum = CurResFile();				editRegion(mySpec,myRgnHdl);				//UseResFile(newRefNum);				iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);				iErr = SetFPos(refNum,1,thePresFPos);				if (editRegionCancelled)				{					regionRecIndex --;				}				else				{					BlockMove (*myRgnHdl,&(((RegionRecPtr)(*theRegionData))[regionRecIndex-1]),sizeof(RegionRec));											}			}		}				inRegion = false;	}		HUnlock(theAudioData);	DisposHandle((Handle)theAudioData);	FSClose (refNum);	progressDispos();	theddRL = NewHandle((regionRecIndex * 56L) + 18L);		theddRLHeader.VersionNumber = 1;	theddRLHeader.HeaderSize = 12L;	theddRLHeader.RegionSize = 56L;	GetDateTime(&secs);	theddRLHeader.ResourceDate = secs;	theddRLHeader.NextID = (long)regionIDCount + 1;	BlockMove (&theddRLHeader, *theddRL, 18L);		BlockMove (((RegionRecPtr)(*theRegionData)),(*theddRL) +18L, regionRecIndex * 56L); 		if (theOldResources)		DisposHandle((Handle)theOldResources);		curRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	UseResFile(rfRefNum);	if (rfRefNum == -1)	{		genError ("\pCan't open SDII resource fork");		return false;	}		theOldResources = Get1Resource('ddRL',1000);	RmveResource(theOldResources);		iErr = ResError();	AddResource(theddRL,'ddRL',1000,"\pRegion List");	iErr = ResError();	CloseResFile(rfRefNum);	iErr = ResError();	UseResFile(curRefNum);	iErr = ResError();	DisposHandle((Handle)theRegionData);	return true;/* at EOF, close file and write structs to RF delete old res if it exists */}Boolean makeMeanAudio (Handle theAudio, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel){	long theCount[2];	long z,y;	SignedByte	theByte;	short theWord;		theCount[0] = 0L;	theCount[1] = 0L;		for (z=0;z< theBytes;z += (wordSize * (stereo + 1)))	{		y=0;		do		{			if (wordSize == 1)			{				BlockMove ((*theAudio) + z + y,&theByte,1L);				theCount[y / wordSize] += (long)(abs ((short)theByte));			}			if (wordSize == 2)			{				BlockMove ((*theAudio) + z + y,&theWord,2L);				theCount[y / wordSize] += (long)(abs(theWord));			}			y += wordSize;		}while (y <= (stereo * wordSize));	}	theCount[0] /= (z/(wordSize * (stereo + 1)));	theCount[1] /= (z/(wordSize * (stereo + 1)));		*leftLevel = theCount[0];	*rightLevel = theCount[1];}Boolean makeMaxAudio (Handle theAudio, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel){	long theCount[2];	long z,y;	SignedByte	theByte;	short theWord;	short theMax[1];		theCount[0] = 0L;	theCount[1] = 0L;	theMax[0] = 0L;	theMax[1] = 0L;		for (z=0;z< theBytes;z += (wordSize * (stereo + 1)))	{		y=0;		do		{			if (wordSize == 1)			{				BlockMove ((*theAudio) + z + y,&theByte,1L);				if (abs ((short)theByte)>theMax[y / wordSize])				{					theMax[y / wordSize] = abs ((short)theByte);				}			}			if (wordSize == 2)			{				BlockMove ((*theAudio) + z + y,&theWord,2L);				if (abs (abs(theWord))>theMax[y / wordSize])				{					theMax[y / wordSize] = abs(theWord);				}			}			y += wordSize;		}while (y <= (stereo * wordSize));	}	*leftLevel = theMax[0];	*rightLevel = theMax[1];}short GetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes){	short iRefNum,fRefNum;	OSErr	iErr;	long theDuration;	StringHandle h1,h2,h3;	long xwordsize;	Str255 the1, the2, the3;	long chans;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	Str255 zfilename;	FInfo fndrInfo;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType == '.WAV')	{		return GetWAVInfo (mySpec,theRate, theWordSize, &theDuration, stereo, theBytes);	}			iRefNum = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (fRefNum == -1)	{		return true;	}	UseResFile(fRefNum);	h1 = GetString(1000);	if (!h1)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return true;	}	h2 = GetString(1001);	if (!h2)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return true;	}	h3 = GetString(1002);	if (!h3)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return true;	}		**(Byte**)h2 = 5;	BlockMove (*h1,the1,2L);	BlockMove (*h2,the2,6L);	BlockMove (*h3,the3,2L);	StringToNum(the3,&chans);	StringToNum(the2,theRate);	StringToNum(the1,&xwordsize);	CloseResFile(fRefNum);	UseResFile(iRefNum);		*theWordSize = LoWord(xwordsize);	*stereo = (chans == 2L);			BlockMove(mySpec.name,zfilename,64L);	fpb->ioVRefNum = mySpec.vRefNum;		/* default volume */	fpb->ioNamePtr = zfilename;	/* buffer to receive name */	fpb->ioDirID = mySpec.parID;	fpb->ioFDirIndex = 0;		iErr = PBGetCatInfo(&cipbr,false);		*theBytes = fpb->ioFlLgLen;	return false;}pascal Boolean myDFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	OSErr	myErr;	Boolean	returnVal = FALSE;	WindowPtr	temp;	ModalFilterUPP	standardProc;	Point thePoint;	Cell XlCellCoords;	short iType;	Handle iHndl;	Rect iRect;	Point p;	Rect	arrowRect;	GrafPtr savePort;		if(theEventIn->what==updateEvt &&				(WindowPtr) theEventIn->message!=currentDialog)	{		/* if the update is for the dialog box, ignore it since the regular			ModalDialog function will redraw it as necessary.		*/				returnVal = false; //MyDrawProc((WindowPtr) theEventIn->message);	}	else	{		/* it wasn't an update, pass it on to the system filter */		//GetPort(&temp);/* save the current port, set to the dialog */		//SetPort(currentDialog);						/* necessary to track the edit cursor changes */		#ifdef powerc				myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = CallUniversalProc(standardProc,uppModalFilterProcInfo,currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#else	myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = ((ModalFilterProcPtr)standardProc)				(currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#endif		/*if (theEventIn->what==mouseDown)		{			GetPort(&savePort);			SetPort(currentDialog);			thePoint = theEventIn->where;			GlobalToLocal(&thePoint);			SetPort(savePort);			GetDItem(currentDialog,5,&iType,&iHndl,&iRect);				if(PtInRect(thePoint,&iRect)) 			{							GetDItem(currentDialog,5,&iType,&iHndl,&iRect);					BlockMove (&iRect,&arrowRect,8L);	 			arrowRect.left = arrowRect.right - 16;				if(PtInRect(thePoint,&arrowRect)) 				{						GetDItem(currentDialog,5,&iType,&iHndl,&iRect);						threshold = GetCtlValue((ControlHandle)iHndl);					threshold ++;					threshold = (threshold>255) ? 255 : threshold;					SetCtlValue((ControlHandle)iHndl,threshold);				}				GetDItem(currentDialog,5,&iType,&iHndl,&iRect);					BlockMove (&iRect,&arrowRect,8L);	 			arrowRect.right = arrowRect.left + 16;				if(PtInRect(thePoint,&arrowRect)) 				{						GetDItem(currentDialog,5,&iType,&iHndl,&iRect);						threshold = GetCtlValue((ControlHandle)iHndl);					threshold --;					threshold = (threshold<0) ? 0 : threshold;					SetCtlValue((ControlHandle)iHndl,threshold);				}				}		}	*/		return returnVal;	}}long audioScan (Handle theAudio, long theBytes, Boolean stereo, short wordSize, short scanMode){	unsigned long z,y;	SignedByte	theByte;	short theWord;	long theStartOfRegion = 0L;	long thePositionToReturn = -1L;	if (!wordSize)	{		wordSize = 1;		//SysBeep(5);	}				switch (wordSize)	{		case 1:			for (z=0;z< theBytes;z ++)			{					BlockMove ((*theAudio) + z,&theByte,1L);				switch (scanMode)				{					case lookForInPoint:						if (abs((short)theByte) > threshold)						{							return  (long)(z) / (long)((stereo+1) * wordSize);						}					break;										case lookForQuiet:						if (abs((short)theByte) <= Outthreshold)						{							theQuietSoFar ++;							if (theQuietSoFar == 1L)							{								theStartOfRegion =   (long)(z) / (long)((stereo+1) * wordSize);							}						}						else						{							theQuietSoFar = 0L;						}						if (theQuietSoFar >= theQuietLength)						{								return  (long)(z) / (long)((stereo+1) * wordSize);						}					break;				}			}		break;						case 10:			for (z=0;z< theBytes;z += 2L)			{				//BlockMove ((*theAudio) + z,&theWord,2L);								theWord = *((short *)(*theAudio) + (z>>1));				switch (scanMode)				{					case lookForInPoint:						//if (abs(theWord) > threshold)						if (((short)theWord >= 0x8000) ? (0xFFFF - (short)theWord + 1) : ((short)theWord) > threshold)						{							return  (long)(z) / (long)((stereo+1) * wordSize);						}					break;										case lookForQuiet:					//	if (      (theWord) <= Outthreshold)						if (((short)theWord >= 0x8000) ? (0xFFFF - (short)theWord + 1) : ((short)theWord)  <= Outthreshold)						{							theQuietSoFar ++;						}						else						{							theQuietSoFar = 0L;						}						if (theQuietSoFar >= theQuietLength)						{								return  (long)(z) / (long)((stereo+1) * wordSize);						}					break;				}			}		break;						case 2:			for (z=0;z< theBytes;z += 2L)			{								theWord = *((short *)(*theAudio) + (z>>1));				switch (scanMode)				{					case lookForInPoint:						if (abs(theWord) > threshold)						/*if (((unsigned short)theWord >= 0x8000) ? (0xFFFF - (unsigned short)theWord + 1) : ((unsigned short)theWord) > threshold)*/						{							return  (long)(z) / (long)((stereo+1) * wordSize);						}					break;										case lookForQuiet:						if (      (theWord) <= Outthreshold)						/*if (((unsigned short)theWord >= 0x8000) ? (0xFFFF - (unsigned short)theWord + 1) : ((unsigned short)theWord)  <= Outthreshold)*/						{							theQuietSoFar ++;						}						else						{							theQuietSoFar = 0L;						}						if (theQuietSoFar >= theQuietLength)						{								return  (long)(z) / (long)((stereo+1) * wordSize);						}					break;				}			}		break;	}	return -1L;}