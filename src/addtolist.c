#include "SampleSearch.h"#include "Globals.h"#include "prefs.h"extern newPrefsRec theNewPrefs;Boolean addFolderContents(FSSpec mySpec);Boolean addFileToList(FSSpec mySpec);pascal short mySFDlgHook(short item, DialogPtr theDialog, short *whichConverter);Boolean isFolder;Boolean isPlay;extern Boolean goingToFind;void SFAddToList(void);void SFAddToList(void){		short activeList = 0;	StandardFileReply reply;	short convertItem;	Point where = {-1,-1};	isFolder = false;	CustomGetFile(0,-1,0,&reply,2122,where,NewDlgHookYDProc(mySFDlgHook),0,&activeList,0, (void *)&convertItem);	if (reply.sfGood)	{		if (isFolder)		{			addFolderContents(reply.sfFile);		}		else		{			addFileToList(reply.sfFile);		}	}}pascal short mySFDlgHook(short item, DialogPtr theDialog, short *whichConverter){	short kind;	Handle h;	Rect r;	if (GetWRefCon(theDialog) != sfMainDialogRefCon)		return item;			isPlay = false;		switch (item)	{		/*case 15:			isFolder = false;			isPlay = true;			*whichConverter = 999L;			return 1;		break;*/		case 13:			isFolder = true;			*whichConverter = 999L;			return 1;		break;		default:			*whichConverter = 0L;		break;	}	return item;}Boolean addFolderContents(FSSpec mySpec){	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	OSErr	iErr;	Str255 zfilename;	long	dirID,myDrDir;	short Fcounter = 0;	FSSpec	tempSpec;					dpb->ioVRefNum = mySpec.vRefNum;		/* default volume */		dpb->ioNamePtr = mySpec.name;	/* buffer to receive name */		dpb->ioFDirIndex = 0;		dpb->ioDrDirID = mySpec.parID;		rc = PBGetCatInfo( &cipbr, FALSE );				dirID = dpb->ioDrDirID;				fpb->ioVRefNum = mySpec.vRefNum;		/* default volume */		fpb->ioNamePtr = zfilename;	/* buffer to receive name */				for( idx=1; TRUE; idx++) 		{	/* indexing loop */			fpb->ioDirID = dirID;		/* must set on each loop */			myDrDir = dirID;			fpb->ioFDirIndex = idx;					rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) 				break;	/* exit when no more entries */				if (!(fpb->ioFlAttrib & 16)) 			{			/** i.e it is a file **/					iErr = FSMakeFSSpec(fpb->ioVRefNum,myDrDir,fpb->ioNamePtr,&tempSpec);				/*	if (iErr!= 0 )						SysBeep(5);*/					addFileToList(tempSpec);				}		} // end of for idx		FInfolistInMem = false;		reFound = true;	}Boolean dontAdd;void setCursor(short setting);#define kWristWatch 99#define kRightCursor 1#define kLeftCursor 2#define kArrowCursor 0OSErr addSDIIFilesInside (FSSpec theParentObject, Boolean folderSearch);OSErr allocateRamForFilesList (void);extern FSSpec * theFoundFiles;Boolean addFileToList(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	if (theNewPrefs.dontAddToList)	{		return;	}		if (totfindcounter >= (2474L))	{		return;		}			BlockMove (&mySpec, &((*therealResults)[totfindcounter]),70L);		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		//genError("\pCant get info for file in add file to list");		//	SysBeep(5);		return false;	}		//SetHandleSize(theFInfo,(totfindcounter + 2) * sizeof(FInfo));	iErr = MemError();	if (iErr!=0)	{		//genError ("\pmemory problem in add file to list");	//	SysBeep(5);		return false;	}	BlockMove (&fndrInfo, &((*theFInfo)[totfindcounter]),16L);	totfindcounter ++;	reFound = true;	goingToFind = false;	return true;}