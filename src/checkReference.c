#include "SampleSearch.h"#include "Globals.h"#include <Aliases.h>Boolean nameFromVolume(short theVolume, StringPtr theString);Boolean numFromVolume(short thevRefNum, short *therealVolNum);extern Boolean volumeMounted;Boolean UnMount(StringPtr tempstrB);void RefreshMemA(void);void RefreshMemB(void);void dismountOfflines(void);void checkList(void);Boolean FSpCheckReferencec(FSSpec theSpec/*, Str255 volumeName*/);OSErr copyVolsListToFVolsList(void);Boolean checkReference(short	indexToSpec){		FSSpec	mySpec;	short z;	short driveAvailable;	Boolean cancHit = false;	short itemHit = 0;			/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	StandardFileReply	myReply;	short therealVolNum;	Str255 theNameWeWant;	short theNum;		copyVolsListToFVolsList();	if (numFromVolume((*therealResults)[indexToSpec].vRefNum, &theNum))	{		BlockMove (fvolName[theNum], theNameWeWant,28L);	}	volumeMounted = false;	gogetvolref();	if (-((*therealResults)[indexToSpec].vRefNum)<=maxVRef)	{		return true;	}	do{		gogetvolref();		driveAvailable = 0;		if (!numFromVolume((*therealResults)[indexToSpec].vRefNum, &therealVolNum))		{			genError ("\pCan't find vRefNum in volumes list");			return false;		}		for (z=1;z<=volumearrayptr;z++)			{					if (EqualString(volName[z],theNameWeWant,false,false)) 					{						driveAvailable = z;					}			}		if (driveAvailable == 0)			{			//	RefreshMemA();				//ParamText(theNameWeWant,0,0,0);				if (!UnMount(theNameWeWant))				cancHit = true;				dismountOfflines();			//	checkList();				//xParamText(theNameWeWant,0,0,0);			}	}while (driveAvailable == 0 && cancHit == false);		/*if (!cancHit)	{		RefreshMemB();		(*therealResults)[indexToSpec].vRefNum = -driveAvailable;		volumeMounted = true;	}*/		return !cancHit;}Boolean FSpCheckReferencec(FSSpec theSpec/*, Str255 volumeName*/){		FSSpec	mySpec;	short z;	short driveAvailable;	Boolean cancHit = false;	short itemHit = 0;			/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	StandardFileReply	myReply;	short therealVolNum;	Str255 theNameWeWant;	short theNum;		copyVolsListToFVolsList();	if (numFromVolume(theSpec.vRefNum, &theNum))	{		BlockMove (fvolName[theNum], theNameWeWant,28L);	}	volumeMounted = false;	gogetvolref();	if (-(theSpec.vRefNum)<=maxVRef)	{		return true;	}	do{		gogetvolref();		driveAvailable = 0;		if (!numFromVolume(theSpec.vRefNum, &therealVolNum))		{			genError ("\pCan't find vRefNum in volumes list");			return false;		}		for (z=1;z<=volumearrayptr;z++)			{					if (EqualString(volName[z],theNameWeWant,false,false)) 					{						driveAvailable = z;					}			}		if (driveAvailable == 0)			{			//	RefreshMemA();				//ParamText(theNameWeWant,0,0,0);				if (!UnMount(theNameWeWant))				cancHit = true;				dismountOfflines();			//	checkList();				//xParamText(theNameWeWant,0,0,0);			}	}while (driveAvailable == 0 && cancHit == false);		/*if (!cancHit)	{		RefreshMemB();		(*therealResults)[indexToSpec].vRefNum = -driveAvailable;		volumeMounted = true;	}*/		return !cancHit;}Boolean zcheckReference(short	indexToSpec);Boolean zcheckReference(short	indexToSpec){	FSSpec	mySpec;		short z;	short driveAvailable;	Boolean cancHit = false;	short itemHit = 0;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	StandardFileReply	myReply;	AliasHandle	theDriveAlias;	char theDriveName[99];	Str255	volumeName;	Boolean wasChanged;	OSErr	iErr;	short therealVolNum;		gogetvolref();	if (-((*therealResults)[indexToSpec].vRefNum)<=maxVRef)	{		return true;	}	do{		driveAvailable = 0;				if (!numFromVolume((*therealResults)[indexToSpec].vRefNum, &therealVolNum))		{			genError ("\pCan't find vRefNum in volumes list");			return false;		}						for (z=1;z<=volumearrayptr;z++)			{					if (EqualString(volName[z],fvolName[therealVolNum],false,false)) 					{						driveAvailable = z;					}			}		if (driveAvailable == 0)			{								if (nameFromVolume((*therealResults)[indexToSpec].vRefNum, (StringPtr)volumeName))				{					BlockMove(volumeName+1,&theDriveName[0],28);					theDriveName[*volumeName] = ':';					*volumeName = (*volumeName) +1;										iErr = NewAliasMinimalFromFullPath(*volumeName,&theDriveName[0],"\p","\p",&theDriveAlias);					if (iErr !=0)					{						genError ("\pProblem making drive alias");						return false;					}					iErr = ResolveAlias(0,theDriveAlias,&mySpec,&wasChanged);						if (iErr !=0 )					{												return false;					}					cancHit = 1;				}				else				{									return false;				}			}	}while (driveAvailable == 0 && cancHit == false);	if (!cancHit)		(*therealResults)[indexToSpec].vRefNum = -driveAvailable;	return !cancHit;}Boolean nameFromVolume(short theVolume, StringPtr theString){	short z;		for (z=0;z<=fvolumearrayptr;z++)	{		if (fvolumes[z] == theVolume)		{			BlockMove (fvolName[z],theString,28);			return true;		}	}	return false;}Boolean numFromVolume(short thevRefNum, short *therealVolNum){	short z;		copyVolsListToFVolsList();	for (z=1;z<=fvolumearrayptr;z++)	{		if (fvolumes[z] == thevRefNum)		{			*therealVolNum = z;			return true;		}	}	return false;}void dismountOfflines(void)		/** this function looks at the real mounted vols **/{	OSErr	iErr;	HVolumeParam	pb;	short x;	short	vRefNum;		volumearrayptr = 0;	x=1;	pb.ioCompletion = 0;	pb.ioNamePtr = nil;	pb.ioVRefNum = 0;	iErr = 0;	for (x = 1;x<28;x++)		/** index through volumes until error **/	{		pb.ioVolIndex = x; 				/* vary this to select volume **/		iErr = PBHGetVInfo((union HParamBlockRec *)&pb,false);		if (iErr==0)		{			if (pb.ioVDRefNum < 0 && pb.ioVDrvInfo > 0)			{			}			else			{			iErr = PBUnmountVol((union ParamBlockRec *)&pb);			}			}			else		{		}						/** and increment pointer **/	}}void checkList(void){	short z,y;		gogetvolref();		for (z=1;z<=volumearrayptr;z++)	{		if (!EqualString(volName[z],fvolName[z],false,false)) 		{			BlockMove(fvolName[z], fvolName[fvolumearrayptr + 1],28L);			fvolumes[fvolumearrayptr + 1] = fvolumes [z];			fvolumearrayptr ++;			for (y=0;y<kMaxMatches;y++)			{				if ((*therealResults)[y].vRefNum == fvolumes[z])				{					(*therealResults)[y].vRefNum = fvolumes[fvolumearrayptr];				}			}			BlockMove(volName[z], fvolName[z],28);			fvolumes[z] = volumes [z];		}	}}