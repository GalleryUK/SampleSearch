#include "SampleSearch.h"#include "Globals.h"#include "prefs.h"Boolean GetFSComment(FSSpec mySpec, Str255 theComment);Boolean GetFSSpecComment(FSSpec mySpec, Str255 theComment);Boolean SetFSComment(FSSpec mySpec, Str255 theComment);Boolean SetFSSpecComment(FSSpec mySpec, Str255 theComment);FSSpec theBackUpAudioFile;Boolean backUpAudioValid;FSSpec whatTheBUAudioIsOf;Boolean lastOperation;#include "undoStuff.h"Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);void drawSDIIToolBar(FSSpec mySpec);void playMoviesMain(FSSpec mySpec, float startRatio);void SDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;extern Boolean autoSustain;void showCommentinWin(short mode, Cell theCell);Boolean mousePlay = false;Boolean createSDIIOverview(FSSpec mySpec, long decimation);Boolean playingFromWaveform = false;void AddToFaveTab(FSSpec	mySpec, short index,short whichList);void SDIIRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect);void SDIIPlayScrub(FSSpec mySpec, Rect displayRect, short startHoriz);extern short theCurrentSDIIRegion;extern Boolean regionSelected;void fadeRegion (FSSpec theFile, RegionRec theRgn, Boolean fadeIn);void silenceRegion (FSSpec theFile, RegionRec theRgn);#include "waveFormPlay.h"void AIFFRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect);Boolean recreateSDIIOverviewRegion(FSSpec mySpec, long decimation,RegionRec theRgn);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);short playAudioInWaveForm (FSSpec theFile,Rect DisplayRect,short startHoriz){	long fileStart;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	Boolean presSustain;	FInfo fndrInfo;	short chans;	OSErr iErr;	iErr = FSpGetFInfo(&theFile,&fndrInfo);	if (iErr!=0)	{		return;	}	switch (fndrInfo.fdType)	{		case 'Sd2f':			if (getSDIIData (theFile, &theRate, &theWordSize, &stereo, &theBytes)) 			{				return -99; /* its not an SDII file */		 	}		break;		case 'AIFF':			if (getAIFFDataII (theFile, &theRate, &theWordSize, &chans, &theBytes)) 			{				return -99; /* its not an AIFF file */		 	}			stereo = (chans == 2);		break;		default:			theRatio = ((float)startHoriz / (float)DisplayRect.right);			playMoviesMain(theFile,theRatio);			return 0;		break;	}  meStart:	 	 	theRatio = ((float)startHoriz / (float)DisplayRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */	if (fileStart < 0)	{		fileStart = 0;	}	presSustain = autoSustain;	autoSustain = false;	playingFromWaveform = true;			SDIIRegionPlayCursor(theFile, 0x3C, fileStart, theBytes,DisplayRect);	if (isPressed(0x3B))	{		Point localPt;		GetMouse(&localPt);		SDIIPlayScrub(theFile, DisplayRect, localPt.h);	}			playingFromWaveform = false;	autoSustain = presSustain;	if (isPressed(0x37))	{		Point theMouse;				if (mousePlay && Button())		{			GetMouse(&theMouse);			startHoriz = theMouse.h;			goto meStart;		}	}			return true;	}short playRegionFromSelection(FSSpec theFile,short playFreq,Rect DisplayRect,short startHoriz, short endHoriz){	long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	if (getSDIIData (theFile, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return -99; /* its not an SDII file */ 	} 	 	theRatio = ((float)startHoriz / (float)DisplayRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)endHoriz / (float)DisplayRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */		if (fileStart < 0)	{		fileStart = 0;	}		if (fileEnd > theBytes)	{		fileEnd = theBytes;	}		if (DisplayRect.top+DisplayRect.bottom+DisplayRect.left+DisplayRect.right == 0)	{		fileStart = 0;		fileEnd = theBytes;	}	while (Button())	{		}		SDIIRegionPlayCursor(theFile, playFreq, fileStart, fileEnd,DisplayRect);	if (isPressed(0x3B))	{		Point localPt;		GetMouse(&localPt);		SDIIPlayScrub(theFile, DisplayRect, localPt.h);	}					return true;}short AIFFplayRegionFromSelection(FSSpec theFile,short playFreq,Rect DisplayRect,short startHoriz, short endHoriz);short AIFFplayRegionFromSelection(FSSpec theFile,short playFreq,Rect DisplayRect,short startHoriz, short endHoriz){	long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	short chans;	short refNum;	unsigned long curPos;	SoundComponentData sndInfo;	OSErr iErr;	iErr = FSpOpenDF(&theFile,fsRdPerm,&refNum);	if (iErr)		return;			iErr = ParseAIFFHeader(refNum, &sndInfo, (unsigned long*)&theBytes,  (unsigned long*)&curPos);	theWordSize = sndInfo.sampleSize >> 3;	theRate = (sndInfo.sampleRate >> 16) & 0x0000FFFF;	chans = sndInfo.numChannels;	stereo = (chans == 2);		theBytes = (theBytes << (chans - 1) << (theWordSize - 1));	FSClose (refNum); 	theRatio = ((float)startHoriz / (float)DisplayRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)endHoriz / (float)DisplayRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */		if (fileStart < 0)	{		fileStart = 0;	}		if (fileEnd > theBytes)	{		fileEnd = theBytes;	}		if (DisplayRect.top+DisplayRect.bottom+DisplayRect.left+DisplayRect.right == 0)	{		fileStart = 0;		fileEnd = theBytes;	}	while (Button())	{		}		AIFFRegionPlayCursor(theFile, playFreq, fileStart, fileEnd,DisplayRect);/*	if (isPressed(0x3B))	{		Point localPt;		GetMouse(&localPt);		SDIIPlayScrub(theFile, DisplayRect, localPt.h);	}	 */				return true;}extern FSSpec theConvertDestLoc;extern FSSpec theDisplayedFile;Boolean exportRegion (FSSpec source, FSSpec destination, RegionRec	myRgn);extern Boolean waveFormSelected;extern Rect selectRect, zRect;void cutRegion(FSSpec theFile, RegionRec theRgn){	short refNum;	Ptr theSilence;	long inOutCount;	OSErr iErr;	long bytesToGo;	long filePos;	long theRate;	short theWordSize;	Boolean stereo; 	long theBytes;	long endByte;	FSSpec theNewFile;	FInfo fndrInfo;	Boolean cropEnd = false;	long startByte,bytesWritten;	short destrefNum;		if (getSDIIData (theFile, &theRate, &theWordSize, &stereo,&theBytes))	{		/* not an SDII file */		return;	}			endByte = (theRgn.StopFrame << stereo << (theWordSize - 1));	if (endByte > theBytes)	{		endByte = theBytes;	}		if (endByte == theBytes)	{		cropEnd = true;	}		startByte = theRgn.StartFrame << stereo << (theWordSize - 1);	if (startByte < 0)	{		startByte = 0;	}			if (!cropEnd)	{		BlockMove(&theFile,&theNewFile,70L);		concatStrings(theNewFile.name,"\ptemp","\p-");				if (FSpGetFInfo(&theFile,&fndrInfo))		{			SysBeep(5);			return;		}				if (FSpCreate(&theNewFile,fndrInfo.fdCreator,'Sd2f',0))		{			genError("\pCant create new file");			return;		}			iErr = FSpOpenDF(&theFile,fsRdPerm,&refNum);		if (iErr)		{			return;		}					iErr = FSpOpenDF(&theNewFile,fsWrPerm,&destrefNum);		if (iErr)		{			return;		}							iErr = 0;				theSilence = NewPtrClear(131072L);		if (!theSilence)		{			FSClose (refNum);			genError("\pNot Enough memory");			FSpDelete(&theNewFile);			return;		}				bytesWritten = 0;				while (bytesWritten < startByte && !iErr) 		{			inOutCount = 131072L;			if (inOutCount > (startByte - bytesWritten))			{				inOutCount = (startByte - bytesWritten);			}						iErr = FSRead(refNum,&inOutCount,theSilence);			iErr = FSWrite(destrefNum,&inOutCount,theSilence);			bytesWritten += inOutCount;		}						bytesWritten = endByte;		iErr = SetFPos(refNum,1,endByte);		if (!iErr)		{			while (bytesWritten < theBytes && !iErr) 			{				inOutCount = 131072L;				if (inOutCount > (theBytes - bytesWritten))				{					inOutCount = (theBytes - bytesWritten);				}								iErr = FSRead(refNum,&inOutCount,theSilence);				iErr = FSWrite(destrefNum,&inOutCount,theSilence);				bytesWritten += inOutCount;			}			}			FSClose (refNum);		FSClose (destrefNum);		writeSDIIResources(theNewFile,theRate,stereo,theWordSize);		DisposPtr (theSilence);		createSDIIOverview(theNewFile, 0x00000100);				iErr = FSpDelete(&theFile);		iErr = FSpRename(&theNewFile,theFile.name);				showCommentinWin(kFirstSelected,nullCell);	}	else	{		iErr = FSpOpenDF(&theFile,fsWrPerm,&refNum);		if (iErr)		{			return;		}			iErr = SetEOF(refNum,theBytes - (endByte - startByte));				FSClose (refNum);		createSDIIOverview(theFile, 0x00000100);		showCommentinWin(kFirstSelected,nullCell);		/*chop the end off */	}		watchcursor(false);	return;}Boolean exportRegionFromAIFF (FSSpec source, FSSpec destination, RegionRec	myRgn);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);void captureSelectionToFile(Boolean writeTemp){	StandardFileReply theReply;	RegionRec	myRgn;		long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	FSSpec presConDest;	Str255 theComment;	Str255 theFinderComment;	short chans;	FInfo fndrInfo;	OSErr iErr;	SoundComponentData sndInfo;	unsigned long curPos;	short refNum;	if (!waveFormSelected)	{		SysBeep(5);		return;	}		iErr = FSpGetFInfo(&theDisplayedFile,&fndrInfo);	if (iErr)	{		return;	}	switch (fndrInfo.fdType)	{		case 'AIFF':			iErr = FSpOpenDF(&theDisplayedFile,fsRdPerm,&refNum);			if (iErr)				return;							iErr = ParseAIFFHeader(refNum, &sndInfo, (unsigned long*)theBytes,  (unsigned long*)&curPos);			if (iErr)			{				FSClose (refNum);				return;			}			else			{				theWordSize = sndInfo.sampleSize >> 3;				theRate = (sndInfo.sampleRate >> 16) & 0x0000FFFF;				chans = sndInfo.numChannels;								theBytes = (theBytes << (chans - 1) << (theWordSize - 1));			}			stereo = (chans == 2);			FSClose (refNum);		break;			case 'Sd2f':			if (getSDIIData (theDisplayedFile, &theRate, &theWordSize, &stereo, &theBytes)) 			{				return; /* its not an SDII file */		 	} 			curPos = 0;		break;		default:			return;		break;	}	GetFSComment(theDisplayedFile, theComment);	GetFSSpecComment(theDisplayedFile, (StringPtr)theFinderComment); 	theRatio = ((float)selectRect.left / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)selectRect.right / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */			if (fileStart < 0)	{		fileStart = 0;	}	if (fileEnd > theBytes)	{		fileEnd = theBytes;	}				if (!writeTemp)	{		StandardPutFile("\pEnter Name for captured selection","\pUntitled",&theReply);		if (theReply.sfGood)		{			if (theReply.sfReplacing)			{				FSpDelete(&theReply.sfFile);					}			if (!theWordSize)			{				theWordSize = 1;			}			myRgn.StartFrame = (fileStart >> stereo) / ((!theWordSize) ? 1 : theWordSize);			myRgn.StopFrame = (fileEnd >> stereo) / ((!theWordSize) ? 1 : theWordSize);						presConDest = theConvertDestLoc;			theConvertDestLoc = theReply.sfFile;			exportRegion (theDisplayedFile, theReply.sfFile,myRgn);			theConvertDestLoc = presConDest;			addFileToList(theReply.sfFile);			SetFSComment (theReply.sfFile, theComment);			SetFSSpecComment(theReply.sfFile, (StringPtr)theFinderComment);		}	}	else	{		FSSpec tempFile = theDisplayedFile;		makeStr255 ("\pUntitled Region",tempFile.name);				myRgn.StartFrame = (fileStart >> stereo) / ((!theWordSize) ? 1 : theWordSize);		myRgn.StopFrame = (fileEnd >> stereo)  / ((!theWordSize) ? 1 : theWordSize);				presConDest = theConvertDestLoc;		theConvertDestLoc = tempFile;		switch (fndrInfo.fdType)		{				case 'Sd2f':					exportRegion (theDisplayedFile, tempFile,myRgn);				break;				case 'AIFF':					exportRegionFromAIFF (theDisplayedFile, tempFile,myRgn);				break;				default:				break;		}		theConvertDestLoc = presConDest;		FSpRename(&theDisplayedFile,"\pgoing away now");		createSDIIOverview(tempFile, 0x00000100);		FSpRename(&tempFile,theDisplayedFile.name);		makeStr255 (theDisplayedFile.name,tempFile.name);		makeStr255 ("\pgoing away now",theDisplayedFile.name);		FSpDelete(&theDisplayedFile);				theDisplayedFile = tempFile;				theCurrentSDIIRegion = -99;		regionSelected = false;		waveFormSelected = false;																						showCommentinWin(kFirstSelected,nullCell);		SetFSComment (tempFile, theComment);		SetFSSpecComment(tempFile, (StringPtr)theFinderComment);		/* build overview */		/* display */	}	return;}void fadeSelection(Boolean fadeIn){	RegionRec	myRgn;	long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	FSSpec presConDest;		if (!waveFormSelected)	{		SysBeep(5);		return;	}		if (getSDIIData (theDisplayedFile, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return; /* its not an SDII file */ 	} 	 	theRatio = ((float)selectRect.left / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)selectRect.right / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */					if (fileStart < 0)	{		fileStart = 0;	}	if (fileEnd > theBytes)	{		fileEnd = theBytes;	}					myRgn.StartFrame = (fileStart >> stereo) / ((!theWordSize) ? 1 : theWordSize);	myRgn.StopFrame = (fileEnd >> stereo) / ((!theWordSize) ? 1 : theWordSize);		fadeRegion (theDisplayedFile, myRgn, fadeIn);		return;}void silenceSelection(void){	RegionRec	myRgn;	long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	FSSpec presConDest;		if (!waveFormSelected)	{		SysBeep(5);		return;	}		if (getSDIIData (theDisplayedFile, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return; /* its not an SDII file */ 	} 	 	theRatio = ((float)selectRect.left / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)selectRect.right / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */					if (fileStart < 0)	{		fileStart = 0;	}	if (fileEnd > theBytes)	{		fileEnd = theBytes;	}					myRgn.StartFrame = (fileStart >> stereo)  / ((!theWordSize) ? 1 : theWordSize);	myRgn.StopFrame = (fileEnd >> stereo)  / ((!theWordSize) ? 1 : theWordSize);		silenceRegion (theDisplayedFile, myRgn);		return;}void cutWaveformSelection(void){	RegionRec	myRgn;	long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	FSSpec presConDest;	Str255 theComment,theFinderComment;	if (!waveFormSelected)	{		SysBeep(5);		return;	}		GetFSComment(theDisplayedFile, theComment);	GetFSSpecComment(theDisplayedFile, (StringPtr)theFinderComment);		if (getSDIIData (theDisplayedFile, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return; /* its not an SDII file */ 	} 	 	theRatio = ((float)selectRect.left / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)selectRect.right / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */			if (fileStart < 0)	{		fileStart = 0;	}	if (fileEnd > theBytes)	{		fileEnd = theBytes;	}		myRgn.StartFrame = (fileStart >> stereo)  / ((!theWordSize) ? 1 : theWordSize);	myRgn.StopFrame = (fileEnd >> stereo)  / ((!theWordSize) ? 1 : theWordSize);		cutRegion (theDisplayedFile, myRgn);		/* get rid of selection */		theCurrentSDIIRegion = -99;	regionSelected = false;	waveFormSelected = false;	drawSDIIToolBar(theDisplayedFile);		selectRect.left = 0;	selectRect.right = 0;	SetFSComment (theDisplayedFile, theComment);	SetFSSpecComment(theDisplayedFile, (StringPtr)theFinderComment);	showCommentinWin(kFirstSelected,nullCell);	return;}void captureSelectionToFileTAB(short theTab){	StandardFileReply theReply;	RegionRec	myRgn;		long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	FSSpec presConDest;		if (!waveFormSelected)	{		SysBeep(5);		return;	}		if (getSDIIData (theDisplayedFile, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return; /* its not an SDII file */ 	} 	 	theRatio = ((float)selectRect.left / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)selectRect.right / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */				if (fileStart < 0)	{		fileStart = 0;	}	if (fileEnd > theBytes)	{		fileEnd = theBytes;	}				StandardPutFile("\pEnter Name for captured selection","\pUntitled",&theReply);	if (theReply.sfGood)	{		if (theReply.sfReplacing)		{			FSpDelete(&theReply.sfFile);				}		myRgn.StartFrame = (fileStart >> stereo)  / ((!theWordSize) ? 1 : theWordSize);		myRgn.StopFrame = (fileEnd >> stereo)  / ((!theWordSize) ? 1 : theWordSize);				presConDest = theConvertDestLoc;		theConvertDestLoc = theReply.sfFile;		exportRegion (theDisplayedFile, theReply.sfFile,myRgn);		theConvertDestLoc = presConDest;		AddToFaveTab(theReply.sfFile, 0,theTab);	}		return;}void fadeRegion (FSSpec theFile, RegionRec theRgn, Boolean fadeIn){	short refNum;	Ptr theSilence;	long inOutCount;	OSErr iErr;	long bytesToGo;	long filePos;	long theRate;	short theWordSize;	Boolean stereo; 	long theBytes;	long endByte;	float thefadeLevel;	Byte theSampleByte;	short theSampleShort;	long fadelength;	float theNewSample;	long bytesSoFar;	float theSampleIncrement;		if (getSDIIData (theFile, &theRate, &theWordSize, &stereo,&theBytes))	{		/* not an SDII file */		return;	}		endByte = (theRgn.StopFrame << stereo / ((!theWordSize) ? 1 : theWordSize));	if (endByte > theBytes)	{		endByte = theBytes;	}			iErr = FSpOpenDF(&theFile,fsWrPerm,&refNum);	if (iErr)	{		return;	}			filePos = theRgn.StartFrame << stereo / ((!theWordSize) ? 1 : theWordSize);	iErr = SetFPos(refNum,1,filePos);	if (iErr)	{		FSClose (refNum);		return;	}		if (fadeIn)	{		thefadeLevel = 0;	}	else	{		thefadeLevel = 1;	}		fadelength = bytesToGo = endByte - filePos;		if (bytesToGo > 0)	{		theSilence = NewPtrClear(65536L);		if (!theSilence)		{			FSClose (refNum);			return;		}				}	iErr = 0;		bytesSoFar = bytesToGo;		theSampleIncrement = 1/ (float)bytesToGo;	watchcursor(true);	while (bytesToGo > 0 && !iErr)	{		long z;				inOutCount = (bytesToGo > 65536L) ? 65536L : bytesToGo;		iErr = FSRead(refNum,&inOutCount,theSilence);		switch (theWordSize)		{			case 1:				for (z=0;z<inOutCount;z++)				{					theSampleByte = *(Byte *)(theSilence + z);					bytesSoFar --;					theNewSample = (float)theSampleByte * thefadeLevel;					theSampleByte = (Byte)theNewSample;					*(Byte *)(theSilence + z) = theSampleByte;					if (fadeIn)					{						thefadeLevel += theSampleIncrement;						if (thefadeLevel > 1)						{							thefadeLevel = 1;						}						}					else					{						thefadeLevel -= theSampleIncrement;						if (thefadeLevel < 0)						{							thefadeLevel = 0;						}					}					//thefadeLevel = (fadeIn) ? (1-(bytesSoFar / fadelength)) : (bytesSoFar / fadelength);				}			break;					case 2:				for (z=0;z<inOutCount;z+=2L)				{					theSampleShort = *(short *)(theSilence + z);					bytesSoFar -= 2L;					theNewSample = (float)theSampleShort * thefadeLevel;					theSampleShort = (short)theNewSample;					*(short *)(theSilence + z) = theSampleShort;					if (fadeIn)					{						thefadeLevel += (2 * theSampleIncrement);						if (thefadeLevel > 1)						{							thefadeLevel = 1;						}						}					else					{						thefadeLevel -= (2 * theSampleIncrement);						if (thefadeLevel < 0)						{							thefadeLevel = 0;						}					}					//thefadeLevel = (fadeIn) ? (1-((float)bytesSoFar / (float)fadelength)) : ((float)bytesSoFar / (float)fadelength);				}			break;		}		iErr = SetFPos(refNum,3,-inOutCount);		iErr = FSWrite(refNum,&inOutCount,theSilence);		bytesToGo -= inOutCount;	}		FSClose (refNum);	DisposPtr (theSilence);	/* rebuild OV */		//recreateSDIIOverviewRegion(theFile, 0x00000100,theRgn); /* fix it later */		createSDIIOverview(theFile, 0x00000100);			showCommentinWin(kFirstSelected,nullCell);	/* re - display with Selection */	watchcursor(false);	return;}void silenceRegion (FSSpec theFile, RegionRec theRgn){	short refNum;	Ptr theSilence;	long inOutCount;	OSErr iErr;	long bytesToGo;	long filePos;	long theRate;	short theWordSize;	Boolean stereo; 	long theBytes;	long endByte;			if (getSDIIData (theFile, &theRate, &theWordSize, &stereo,&theBytes))	{		/* not an SDII file */		return;	}		endByte = (theRgn.StopFrame << stereo / ((!theWordSize) ? 1 : theWordSize));	if (endByte > theBytes)	{		endByte = theBytes;	}			iErr = FSpOpenDF(&theFile,fsWrPerm,&refNum);	if (iErr)	{		return;	}			filePos = theRgn.StartFrame << stereo / ((!theWordSize) ? 1 : theWordSize);	iErr = SetFPos(refNum,1,filePos);	if (iErr)	{		FSClose (refNum);		return;	}		bytesToGo = endByte - filePos;		if (bytesToGo > 0)	{		theSilence = NewPtrClear(65536L);		if (!theSilence)		{			FSClose (refNum);			return;		}				if (theWordSize == 1) /* need twos comp ??? */		{			memset(theSilence,0x80,65536L);		}	}	iErr = 0;	watchcursor(true);	while (bytesToGo > 0 && !iErr)	{		inOutCount = (bytesToGo > 65536L) ? 65536L : bytesToGo;		iErr = FSWrite(refNum,&inOutCount,theSilence);		bytesToGo -= inOutCount;	}		FSClose (refNum);	DisposPtr (theSilence);	/* rebuild OV */	createSDIIOverview(theFile, 0x00000100);	showCommentinWin(kFirstSelected,nullCell);	watchcursor(false);	/* re - display with Selection */	return;}Boolean normaliseFile(FSSpec mySpec,Boolean justRegion, long startPoint, long endPoint);extern short normaliseMaximum;extern Boolean rewriteOrig;void normaliseSelection (void){	RegionRec	myRgn;	long fileStart,fileEnd;	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	float theRatio, theSt;	FSSpec presConDest;		if (!waveFormSelected)	{		SysBeep(5);		return;	}		if (getSDIIData (theDisplayedFile, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return; /* its not an SDII file */ 	} 	 	theRatio = ((float)selectRect.left / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileStart = theSt;	fileStart = fileStart & 0xFFFFFFFC; /* lose the bottom 2 bits */		theRatio = ((float)selectRect.right / (float)zRect.right); 	theSt = theRatio * theBytes; 		fileEnd = theSt;	fileEnd = fileEnd & 0xFFFFFFFC; /* lose the bottom 2 bits */			if (fileStart < 0)	{		fileStart = 0;	}	if (fileEnd > theBytes)	{		fileEnd = theBytes;	}				myRgn.StartFrame = ((fileStart >> stereo))  / ((!theWordSize) ? 1 : theWordSize);	myRgn.StopFrame = ((fileEnd >> stereo))  / ((!theWordSize) ? 1 : theWordSize);		normaliseMaximum = 128;	rewriteOrig = true;	normaliseFile(theDisplayedFile,true, myRgn.StartFrame, myRgn.StopFrame);		/* rebuild OV */	createSDIIOverview(theDisplayedFile, 0x00000100);	showCommentinWin(kFirstSelected,nullCell);	/* re - display with Selection */	return;}	