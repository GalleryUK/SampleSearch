#include "SampleSearch.h"#include "Globals.h"#include <AIFF.h>#include <SoundInput.h>#include <Sound.h>extern long dblBufferSize;extern Boolean gCallBackPerformed;  SndChannelPtr CreateSndChannel(Boolean Stereo);#define kWaitIfFull TRUE	// wait for room in queue#define kSoundComplete  1	// last command in channel;  Application definedextern Boolean autoSustain;typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;Boolean SoundManagerPlaySD2 (FSSpec mySpec, short playFreq, RegionRec theRegion, Boolean playAll);Boolean SoundManagerPlaySD2 (FSSpec mySpec, short playFreq, RegionRec theRegion, Boolean playAll){	Handle	mySndH[2];	short	fRefNum;	short	thecurfile;	Str255	sampsize;	OSErr	iErr;	SndChannelPtr mySndChan;	// pointer to a sound channel tunnel	OSErr myErr;	Str255	samprate;	Boolean	whichBuff;	Str255	chans;	char	mysampsize;	long	mysamprate,xx,inOutCount;	char	mychans;	Handle 	hRsrc;	long z;	Fixed	sampleRate;	short 	numChans;	short		numBits;	short	refNum,tempchans;	Boolean fileEnded,Endedfile;	SCStatus theStatus;	EventRecord theEvent;	short headerLen;	Ptr mySndPtr;	unsigned char km[16];	short keycounter;	long filePos;	Boolean autoStop;	SndCommand	myCommand;	ExtSoundHeader	myHeader;	 	mySndH[0] = NewHandle(dblBufferSize+800L);	if (!mySndH[0])		genErrorN("\pError making new handle",0);	mySndH[1] = NewHandle(dblBufferSize+800L);	if (!mySndH[1])		genErrorN("\pError making new handle",0);	thecurfile = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError opening res file",iErr);			UseResFile(fRefNum);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError using res file",iErr);		hRsrc = Get1Resource('STR ',1000);	if (hRsrc == 0)		genErrorN("\pError getting ID1000",0);	mysampsize =*(*hRsrc+1);	*sampsize = 1;	*(sampsize+1) = mysampsize;	StringToNum(sampsize,&xx);	numBits = LoWord(xx);		hRsrc = Get1Resource('STR ',1001);	if (hRsrc == 0)		genErrorN("\pError getting ID1001",0);	BlockMove (*hRsrc,samprate,28L);	if (*(samprate + 5L) == '.')				*samprate = 4;			else				*samprate = 5;	StringToNum(samprate,&sampleRate);	//sampleRate = (sampleRate * (Fixed)playFreq) /(Fixed)0x3C;	sampleRate = sampleRate << 8; // ?????????		hRsrc = Get1Resource('STR ',1002);	if (hRsrc == 0)		genErrorN("\pError getting ID1002",0);	mychans =*(*hRsrc+1);	*chans = 1;	*(chans+1) = mychans;	StringToNum(chans,&xx);	numChans = LoWord(xx);	CloseResFile(fRefNum);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError closing res file",iErr);	UseResFile(thecurfile);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError using old res file",iErr);	iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,0xAC440000,numBits*8,'NONE',0x3C,0,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 1",iErr);	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)		genErrorN("\pError opening data fork",iErr);	/*********fill buffer************/	HLock(mySndH[0]);	/*iErr = SetFPos(refNum,1,theRegion.startFrame);	if (iErr !=0 )	{		SysBeep (5);	}*/	mySndPtr = (*mySndH[0])+headerLen;	/*if (dblBufferSize>= theRegion.stopFrame - theRegion.startFrame)	{		inOutCount = (theRegion.stopFrame - theRegion.startFrame);		autoStop = true;	}	else*/	{		inOutCount = dblBufferSize;		autoStop = false;	}	watchcursor(TRUE);	iErr = FSRead(refNum,&inOutCount,mySndPtr);	Endedfile = (iErr == eofErr || autoStop);	if (iErr!=0 && iErr!=-39)		genErrorN("\pError reading data fork",iErr);		iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,0xAC440000,numBits*8,'NONE',0x00,inOutCount,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 2",iErr);	//HUnlock(mySndH[0]);				/** process twos's complement **/	if (numBits ==1)	{		for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)		{			*((Ptr)z) += 128;		}	}	/****************************/	/*********fill buffer************/	HLock(mySndH[1]);	/*iErr = SetFPos(refNum,1,theRegion.startFrame);	if (iErr !=0 )	{		SysBeep (5);	}*/	mySndPtr = (*mySndH[1])+headerLen;	/*if (dblBufferSize>= theRegion.stopFrame - theRegion.startFrame)	{		inOutCount = (theRegion.stopFrame - theRegion.startFrame);		autoStop = true;	}	else*/	{		inOutCount = dblBufferSize;		autoStop = false;	}	watchcursor(TRUE);	iErr = FSRead(refNum,&inOutCount,mySndPtr);	Endedfile = (iErr == eofErr || autoStop);	if (iErr!=0 && iErr!=-39)		genErrorN("\pError reading data fork",iErr);	iErr = SetupSndHeader((SndListResource **)mySndH[1],numChans,sampleRate,numBits*8,'NONE',0x00,inOutCount,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 2",iErr);	//HUnlock(mySndH[1]);				/** process twos's complement **/	if (numBits ==1)	{		for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)		{			*((Ptr)z) += 128;		}	}	/****************************/		myHeader.samplePtr = mySndPtr;	myHeader.numChannels = 2L;	myHeader.sampleRate = 0xAC440000;	myHeader.baseFrequency = 0x3C;	myHeader.numFrames = 96000L;	myHeader.sampleSize = 16;		mySndChan = CreateSndChannel(numChans == 2);			if (mySndH[0] != nil)	{		/***********send commands*********/		myCommand.cmd = bufferCmd;		myCommand.param2 = (long)*(mySndH[0]);		iErr = SndDoCommand(mySndChan,&myCommand,true);		myCommand.cmd = callBackCmd;	// install the callback command		myCommand.param1 = kSoundComplete;	// last command for this channel		myCommand.param2 = SetCurrentA5();	// pass the callback the A5		/*return */ SndDoCommand (mySndChan, &myCommand, kWaitIfFull);		/******************************/	}	if (mySndH[1] != nil)	{		/***********send commands*********/		myCommand.cmd = bufferCmd;		myCommand.param2 = (long)*(mySndH[1]);		iErr = SndDoCommand(mySndChan,&myCommand,true);		myCommand.cmd = callBackCmd;	// install the callback command		myCommand.param1 = kSoundComplete;	// last command for this channel		myCommand.param2 = SetCurrentA5();	// pass the callback the A5		/*return */SndDoCommand (mySndChan, &myCommand, kWaitIfFull);		/******************************/	}				whichBuff = 0;	fileEnded = autoStop;	gCallBackPerformed = false;	do	{		Endedfile = fileEnded;				/**********wait**********/		while (!gCallBackPerformed)		{			keycounter = 0;			GetKeys(( long*)km);			for (z=0;z<=15;z++)				keycounter += (km[z] * ((z+1)*16));							if (autoSustain && EventAvail(everyEvent & ~mUpMask & ~keyUpMask,&theEvent))			{				Endedfile = true;				GetNextEvent(everyEvent,&theEvent);				gCallBackPerformed = true;				break;			}			if (!autoSustain && (keycounter == 0 || keycounter == 256))			{				Endedfile = true;				//GetNextEvent(everyEvent,&theEvent);				gCallBackPerformed = true;				break;			}		}		gCallBackPerformed = false;		/***************************/			/**********fill buffer*********/		HLock(mySndH[whichBuff]);		mySndPtr = (*mySndH[whichBuff])+headerLen;			iErr = GetFPos(refNum,&filePos);		/*if (filePos +dblBufferSize >= theRegion.stopFrame)		{			inOutCount = (theRegion.stopFrame - filePos);			if (inOutCount < 0)				inOutCount = 0;			autoStop = true;		}		else*/		{			inOutCount = dblBufferSize;			autoStop = false;		}		iErr = FSRead(refNum,&inOutCount,mySndPtr);		fileEnded = (iErr == eofErr || autoStop);		if (iErr!=0 && iErr!=-39)			genErrorN("\pError reading data fork",iErr);		iErr = SetupSndHeader((SndListResource **) mySndH[whichBuff],numChans,sampleRate,numBits*8,'NONE',0x3C,inOutCount,&headerLen);		if (iErr!=0)			genErrorN("\pError setting up snd header 2",iErr);		HUnlock(mySndH[whichBuff]);		if (numBits ==1)		{			for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)			{				*((Ptr)z) += 128;			}		}		/***************************/				/***********send commands*********/		myCommand.cmd = bufferCmd;		myCommand.param2 = (long)*(mySndH[whichBuff]);		iErr = SndDoCommand(mySndChan,&myCommand,true);		myCommand.cmd = callBackCmd;	// install the callback command		myCommand.param1 = kSoundComplete;	// last command for this channel		myCommand.param2 = SetCurrentA5();	// pass the callback the A5		return SndDoCommand (mySndChan, &myCommand, kWaitIfFull);		/******************************/		whichBuff = !whichBuff;			/** swap double buffers **/			}while (!Endedfile);		iErr = SndDisposeChannel(mySndChan,false);DisposPtr((Ptr)mySndChan);			DisposHandle(mySndH[0]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle",myErr);	DisposHandle(mySndH[1]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle",myErr);	iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);	watchcursor(false);}