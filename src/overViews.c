#include "overViews.h"#include "SampleSearch.h"#include "Globals.h"void writeLog(Ptr theLogTextPtr);void genError(Str255 theString);short isPressed(unsigned short k );void writeLogS(Str255 theLogText);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);extern ListHandle myList;typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;#define doBackGround true#define kBgRate 500Boolean createAIFFOverview(FSSpec mySpec, long decimation);/* DONT FORGET THE HEADERS!!!!!!!!!! */Boolean bail = false;OSErr convertBuffer24To16 (Ptr theSoundData, long *sourceLength);void createSDIIOverviewMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	short myshort; 			bail = false;			watchcursor(true);	writeLogS((unsigned char *)"Starting SDII overview building");	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) && !bail) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				if (createSDIIOverview((*therealResults)[theindex],0x00000100))		{			writeLog((Ptr)(*therealResults)[theindex].name);		}		else		{			writeLogS((unsigned char *)"Failed to create overview :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		watchcursor(false);	if (memoryError)		genError("\pSome files could not be processed, consult the SampleSearchª Log for details");	return;}Boolean recreateSDIIOverviewRegion(FSSpec mySpec, long decimation,RegionRec theRgn);Boolean recreateSDIIOverviewRegion(FSSpec mySpec, long decimation,RegionRec theRgn){	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	short refNum;	long inOutCount;	long resPtr;	short rfRefNum, dfRefNum,iRefNum;	Handle resHandle;	long dataForkPtr,theReadChunkSize,OVBytes;	char * theOverView;	short iCnt;	OSErr iErr,err;	overViewHeader theOVHeader;	/***/		Ptr theSilence;	long bytesToGo;	long filePos;	long startByte, endByte;			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo,&theBytes))	{		/* not an SDII file */		return false;	}		endByte = (theRgn.StopFrame << stereo << (theWordSize - 1));	startByte = (theRgn.StartFrame << stereo << (theWordSize - 1));			endByte = ((endByte / decimation) * decimation) & 0xFFFFFFFE; /* maybe times wordsize ??? */	startByte = ((startByte / decimation) * decimation) & 0xFFFFFFFE; /* maybe times wordsize ??? */			/****/			if (theWordSize != 2) /* only currently support 16 bit OV's !!! */	{		return false;	}	/* check whether the overview already exists */			/* init indexes */		dataForkPtr = 0;	resPtr = 14;	theOverView = (char *)NewPtrClear (140000L);	if (!theOverView)	{		genError ("\pNot enough memory to build overview");				return false;		}		iErr = FSpOpenDF(&mySpec,fsRdPerm,&dfRefNum);	if (iErr)	{		DisposPtr(theOverView);				return false;		}	theOVHeader.VersionNumber = 1;	theOVHeader.Headersize = 14;	theOVHeader.Decimation = decimation;	theOVHeader.FileLength = 0;	/* prepare the resource file */	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (!rfRefNum)	{		FSClose (dfRefNum);		DisposPtr(theOverView);				return false;		}	UseResFile(rfRefNum);	iCnt = Count1Resources('ddOV');	if (!iCnt) /* there never was an overview */	{		FSClose (dfRefNum);		CloseResFile (rfRefNum);		UseResFile(iRefNum);		DisposPtr(theOverView);		return createSDIIOverview(mySpec, decimation);	}	else	{		/*resHandle = Get1Resource('ddOV',1000);		BlockMove(&theOVHeader,*resHandle,14L);			WriteResource(resHandle);		ReleaseResource(resHandle);*/	}	UpdateResFile(rfRefNum);			SetResLoad(false);	resHandle = Get1Resource('ddOV',1000);	/* quantize to decimation  - done */	iErr = SetFPos(dfRefNum,1,startByte);	/* set the source file start point */			/* set the resource start point  resPtr  plus 14 header  */		resPtr += ((startByte / decimation));	resPtr = resPtr & 0xFFFFFFFE;		while (dataForkPtr < endByte) /* whilst we dont hit the end of the file */	{		if (!decimation) /* check for divide by zero */		{			SysBeep(5);			decimation = 0x00000100;				}				theReadChunkSize = 65536L * (decimation * theWordSize); /* the audio bytes are (resbuffer bytes / 2) * decimation */				if ((theReadChunkSize + dataForkPtr) > endByte)		{			theReadChunkSize = (endByte - dataForkPtr);			theReadChunkSize = theReadChunkSize & 0xFFFFFE00; /*hardwired bodge for 0x00000100 */		}				OVBytes = theReadChunkSize / (decimation);				switch (theWordSize)		{		/*	case 3:				if(calcPartialOverview24Bit (dfRefNum, dataForkPtr, theReadChunkSize, theOverView, 0, theWordSize, stereo, true, decimation ))				{					long totalSize = SizeResource(resHandle);					if (totalSize < (resPtr + OVBytes))					{						SetResourceSize(resHandle,(resPtr + OVBytes));						err = ResError();					}										WritePartialResource(resHandle,resPtr,theOverView,OVBytes);					err = ResError();					if (err && (err != -189))					{						SysBeep(5);					}						resPtr += OVBytes;				}				else				{											}				dataForkPtr += theReadChunkSize;								if ((theBytes - dataForkPtr) < ((decimation * theWordSize)))				{					dataForkPtr = endByte;				}			break;*/			default:				if(calcPartialOverview (dfRefNum, dataForkPtr, theReadChunkSize, theOverView, 0, theWordSize,stereo, true, decimation))				{					long totalSize = SizeResource(resHandle);					if (totalSize < (resPtr + OVBytes))					{						SetResourceSize(resHandle,(resPtr + OVBytes));						err = ResError();					}										WritePartialResource(resHandle,resPtr,theOverView,OVBytes);					err = ResError();					if (err && (err != -189))					{						SysBeep(5);					}						resPtr += OVBytes;				}				else				{											}				dataForkPtr += theReadChunkSize;								if ((theBytes - dataForkPtr) < ((decimation * theWordSize)))				{					dataForkPtr = endByte;				}			break;		}	}			theSize = (theBytes >> 8) + 14; /* bodge coded for 0x00000100 */		theSize = theSize & 0xFFFFFFFE;		//theSize = ((theBytes * ((theWordSize == 2) ? 1 : 2)) / decimation);	/*if ((theSize *  decimation) < (theBytes * ((theWordSize == 2) ? 1 : 2)))	{		theSize += 2;	}*/		if (((theSize - 14) << 8)  < theBytes)	{		theSize += 2;	}		/*if (theSize & 0x00000001)	{		theSize++;	}*/		SetResLoad(true);	SetResourceSize(resHandle,theSize);	FSClose (dfRefNum);	CloseResFile (rfRefNum);		/* close the res fork */		UseResFile(iRefNum);			DisposPtr(theOverView);	return true;}Boolean checkSDIIOverview(FSSpec mySpec){	short rfRefNum;	short iRefNum;	OSErr iErr;	short iCnt;		iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&mySpec,fsRdPerm);	if (rfRefNum == -1)	{		return kNoOverview;	}	UseResFile(rfRefNum);		iCnt = Count1Resources('ddOV');		CloseResFile(rfRefNum);	UseResFile(iRefNum);		if (iCnt)	{		return kOverViewPresent;	}	else	{		return kNoOverview;	}}Boolean createSDIIOverviewOther(FSSpec mySpec, long decimation);Boolean createSDIIOverviewOther(FSSpec mySpec, long decimation){	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize; 	short refNum;	long inOutCount;	long resPtr;	short rfRefNum, dfRefNum,iRefNum;	Handle resHandle;	long dataForkPtr,theReadChunkSize,OVBytes;	short iCnt;	OSErr iErr,err;	overViewHeader theOVHeader;	short thePart;	WindowPtr whichWindow;	EventRecord theEvent;	short theQuay;	char *theOverView;	FInfo fndrInfo;		if (checkSDIIOverview(mySpec) == kOverViewPresent)	/* check whether the overview already exists */	{		if (!isPressed(0x3B))		{			return true;		}	}		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr)	{		return false;	}	switch (fndrInfo.fdType)	{		case 'AIFF':			return createAIFFOverview(mySpec, decimation);		break;			default:			return false;		break;	}	return true;}Boolean createSDIIOverview(FSSpec mySpec, long decimation){	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	short refNum;	long inOutCount;	long resPtr;	short rfRefNum, dfRefNum,iRefNum;	Handle resHandle;	long dataForkPtr,theReadChunkSize,OVBytes;	char * theOverView;	short iCnt;	OSErr iErr,err;	overViewHeader theOVHeader;	short thePart;	WindowPtr whichWindow;	EventRecord theEvent;	short theQuay;	long theRealBytes;	FInfo fndrInfo;	iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr)	{		return false;	}	switch (fndrInfo.fdType)	{		case 'Sd2f':		break;			default:			return createSDIIOverviewOther( mySpec,  decimation);		break;	}		if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return false; /* its not an SDII file */ 	}		if (checkSDIIOverview(mySpec) == kOverViewPresent)	/* check whether the overview already exists */	{		if (!isPressed(0x3B))		{			return true;		}	}		/* init indexes */	dataForkPtr = 0;	resPtr = 14;	theOverView = (char *)NewPtrClear (140000L);	if (!theOverView)	{		genError ("\pNot enough memory to build overview");				return false;		}		iErr = FSpOpenDF(&mySpec,fsRdPerm,&dfRefNum);	if (iErr)	{		DisposPtr(theOverView);				return false;		}	theOVHeader.VersionNumber = 1;	theOVHeader.Headersize = 14;	theOVHeader.Decimation = decimation;	theOVHeader.FileLength = 0;	/* prepare the resource file */	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (!rfRefNum)	{		FSClose (dfRefNum);		DisposPtr(theOverView);				return false;		}	UseResFile(rfRefNum);	iCnt = Count1Resources('ddOV');	if (!iCnt)	{		resHandle = NewHandle(14L); /* add a new ddOV */		BlockMove(&theOVHeader,*resHandle,14L);			AddResource(resHandle,'ddOV',1000,"\pOverview");		WriteResource(resHandle);		ReleaseResource(resHandle);	}	else	{		resHandle = Get1Resource('ddOV',1000);		BlockMove(&theOVHeader,*resHandle,14L);			WriteResource(resHandle);		ReleaseResource(resHandle);	}	UpdateResFile(rfRefNum);			SetResLoad(false);	resHandle = Get1Resource('ddOV',1000);	watchcursor(true);	theRealBytes = theBytes;	if (theWordSize == 3)		{		theRealBytes = ((float)theBytes / 1.5);	}	while (dataForkPtr < theBytes) /* whilst we dont hit the end of the file */	{		if (!decimation) /* check for divide by zero */		{			SysBeep(5);			decimation = 0x00000100;				}		theReadChunkSize = 512L * (decimation * ((theWordSize == 3) ? 2 : theWordSize)); /* the audio bytes are (resbuffer bytes / 2) * decimation */				if ((theReadChunkSize + dataForkPtr) > theBytes)		{			theReadChunkSize = (theBytes - dataForkPtr);			theReadChunkSize = theReadChunkSize & 0xFFFFFE00; /*hardwired bodge for 0x00000100 */		}				if (theWordSize == 3)	{			OVBytes = ((theReadChunkSize << 1) / 3) / (decimation);		}		else		{			OVBytes = theReadChunkSize / (decimation);		}		if(calcPartialOverview (dfRefNum, dataForkPtr, theReadChunkSize, theOverView, 0, theWordSize, stereo, true, decimation ))		{			long totalSize = SizeResource(resHandle);			if (totalSize < (resPtr + OVBytes))			{				SetResourceSize(resHandle,(resPtr + OVBytes));				err = ResError();			}						WritePartialResource(resHandle,resPtr,theOverView,OVBytes);			err = ResError();			if (err && (err != -189))			{				SysBeep(5);			}				resPtr += OVBytes;		}		else		{							}		dataForkPtr += theReadChunkSize;				if ((theBytes - dataForkPtr) < ((decimation * ((theWordSize == 3) ? 2 : theWordSize))))		{			dataForkPtr = theBytes;			/* forced abort */		}						if(WaitNextEvent(everyEvent,&theEvent,0,0)) 		{			if (theEvent.what == keyDown)			{				theQuay = (theEvent.message) & keyCodeMask;				if ((theQuay == 0x2F00) && (theEvent.modifiers & cmdKey)) 				{					bail = true;					break;				}			}			if (theEvent.what == mouseDown)			{				thePart = FindWindow (theEvent.where,&whichWindow);				switch (thePart)				{					case inSysWindow: 		    			SystemClick (&theEvent, whichWindow);		    		break;		    	}			}		}		/* progress display */	}		watchcursor(false);		switch (theWordSize)	{		long the16Bytes = (theBytes << 1) / 3;	/*	case 3:			theSize = (the16Bytes >> 8) + 14; 						theSize = theSize & 0xFFFFFFFE;					if (((theSize - 14) << 8)  < the16Bytes)			{				theSize += 2;			}		break;*/		default:			theSize = (theRealBytes >> 8) + 14; /* bodge coded for 0x00000100 */						theSize = theSize & 0xFFFFFFFE;						//theSize = ((theBytes * ((theWordSize == 2) ? 1 : 2)) / decimation);			/*if ((theSize *  decimation) < (theBytes * ((theWordSize == 2) ? 1 : 2)))			{				theSize += 2;			}*/						if (((theSize - 14) << 8)  < theRealBytes)			{				theSize += 2;			}						/*if (theSize & 0x00000001)			{				theSize++;			}*/		break;	}				SetResourceSize(resHandle,theSize);	FSClose (dfRefNum);			/* close the res fork */	SetResLoad(true);	CloseResFile (rfRefNum);	UseResFile(iRefNum);			DisposPtr(theOverView);	return true;}Boolean createAIFFOverview(FSSpec mySpec, long decimation){	Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	short refNum;	long inOutCount;	long resPtr;	short rfRefNum, dfRefNum,iRefNum;	Handle resHandle;	long dataForkPtr,theReadChunkSize,OVBytes;	char * theOverView;	short iCnt;	OSErr iErr,err;	overViewHeader theOVHeader;	short thePart;	WindowPtr whichWindow;	EventRecord theEvent;	short theQuay;	long theRealBytes;	short chans;			SoundComponentData sndInfo;	unsigned long curPos;	iErr = FSpOpenDF(&mySpec,fsRdPerm,&dfRefNum);	if (iErr)		return 1;			iErr = ParseAIFFHeader(dfRefNum, &sndInfo, (unsigned long*)&theBytes,  (unsigned long*)&curPos);	theWordSize = sndInfo.sampleSize >> 3;	theRate = (sndInfo.sampleRate >> 16) & 0x0000FFFF;	chans = sndInfo.numChannels;			theBytes = (theBytes << (chans - 1) << (theWordSize - 1));//	FSClose (dfRefNum);	iErr = SetFPos(dfRefNum,fsFromStart,curPos);  /* goto start of sound data */	dataForkPtr = 0;	resPtr = 14;	theOverView = (char *)NewPtrClear (140000L);	if (!theOverView)	{		genError ("\pNot enough memory to build overview");				return false;		}		theOVHeader.VersionNumber = 1;	theOVHeader.Headersize = 14;	theOVHeader.Decimation = decimation;	theOVHeader.FileLength = 0;	/* prepare the resource file */	iRefNum = CurResFile();	FSpCreateResFile(&mySpec,'Sd2a','AIFF',0);	rfRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (!rfRefNum)	{		FSClose (dfRefNum);		DisposPtr(theOverView);				return false;		}	UseResFile(rfRefNum);	iCnt = Count1Resources('ddOV');	if (!iCnt)	{		resHandle = NewHandle(14L); /* add a new ddOV */		BlockMove(&theOVHeader,*resHandle,14L);			AddResource(resHandle,'ddOV',1000,"\pOverview");		WriteResource(resHandle);		ReleaseResource(resHandle);	}	else	{		resHandle = Get1Resource('ddOV',1000);		BlockMove(&theOVHeader,*resHandle,14L);			WriteResource(resHandle);		ReleaseResource(resHandle);	}	UpdateResFile(rfRefNum);			SetResLoad(false);	resHandle = Get1Resource('ddOV',1000);	watchcursor(true);	theRealBytes = theBytes;	if (theWordSize == 3)		{		theRealBytes = ((float)theBytes / 1.5);	}	while (dataForkPtr < theBytes) /* whilst we dont hit the end of the file */	{		if (!decimation) /* check for divide by zero */		{			SysBeep(5);			decimation = 0x00000100;				}		theReadChunkSize = 512L * (decimation * ((theWordSize == 3) ? 2 : theWordSize)); /* the audio bytes are (resbuffer bytes / 2) * decimation */				if ((theReadChunkSize + dataForkPtr) > theBytes)		{			theReadChunkSize = (theBytes - dataForkPtr);			theReadChunkSize = theReadChunkSize & 0xFFFFFE00; /*hardwired bodge for 0x00000100 */		}				if (theWordSize == 3)	{			OVBytes = ((theReadChunkSize << 1) / 3) / (decimation);		}		else		{			OVBytes = theReadChunkSize / (decimation);		}		if(calcPartialOverview (dfRefNum, dataForkPtr, theReadChunkSize, theOverView, 0, theWordSize, stereo, true, decimation ))		{			long totalSize = SizeResource(resHandle);			if (totalSize < (resPtr + OVBytes))			{				SetResourceSize(resHandle,(resPtr + OVBytes));				err = ResError();			}						WritePartialResource(resHandle,resPtr,theOverView,OVBytes);			err = ResError();			if (err && (err != -189))			{				SysBeep(5);			}				resPtr += OVBytes;		}		else		{							}		dataForkPtr += theReadChunkSize;				if ((theBytes - dataForkPtr) < ((decimation * ((theWordSize == 3) ? 2 : theWordSize))))		{			dataForkPtr = theBytes;			/* forced abort */		}						if(WaitNextEvent(everyEvent,&theEvent,0,0)) 		{			if (theEvent.what == keyDown)			{				theQuay = (theEvent.message) & keyCodeMask;				if ((theQuay == 0x2F00) && (theEvent.modifiers & cmdKey)) 				{					bail = true;					break;				}			}			if (theEvent.what == mouseDown)			{				thePart = FindWindow (theEvent.where,&whichWindow);				switch (thePart)				{					case inSysWindow: 		    			SystemClick (&theEvent, whichWindow);		    		break;		    	}			}		}		/* progress display */	}		watchcursor(false);		switch (theWordSize)	{		long the16Bytes = (theBytes << 1) / 3;	/*	case 3:			theSize = (the16Bytes >> 8) + 14; 						theSize = theSize & 0xFFFFFFFE;					if (((theSize - 14) << 8)  < the16Bytes)			{				theSize += 2;			}		break;*/		default:			theSize = (theRealBytes >> 8) + 14; /* bodge coded for 0x00000100 */						theSize = theSize & 0xFFFFFFFE;						//theSize = ((theBytes * ((theWordSize == 2) ? 1 : 2)) / decimation);			/*if ((theSize *  decimation) < (theBytes * ((theWordSize == 2) ? 1 : 2)))			{				theSize += 2;			}*/						if (((theSize - 14) << 8)  < theRealBytes)			{				theSize += 2;			}						/*if (theSize & 0x00000001)			{				theSize++;			}*/		break;	}				SetResourceSize(resHandle,theSize);	FSClose (dfRefNum);			/* close the res fork */	SetResLoad(true);	CloseResFile (rfRefNum);	UseResFile(iRefNum);			DisposPtr(theOverView);	return true;}Boolean calcPartialOverview (short RefNum, long startPoint, long duration, char * theLOverView, char * theROverView, short wordSize, Boolean stereo, Boolean mixStereo, long decimation){	long filePtr;	long inOutCount;	Ptr myData;	long theTempSample;	short theSample, theLSample,theRSample;	char theByte;	OSErr iErr, err;	long leftOVPtr, rightOVPtr;	long z;	short maxPlus, maxMinus;	Ptr bufferPtr,my24Data;	long soFarInBuffer,tempCount;	char ovPlus;	char ovMinus;		leftOVPtr = 0;	rightOVPtr = 0;		filePtr = startPoint;		if (wordSize == 3)	{		long myStartPos = startPoint;		myStartPos = ((float)startPoint);		myStartPos = (myStartPos / 3) * 3;		iErr = SetFPos(RefNum,fsFromStart,myStartPos);		if (iErr)		{			return false;		}	}	else	{		iErr = SetFPos(RefNum,fsFromStart,startPoint);		if (iErr)		{			return false;		}	}/*	if (wordSize == 3)	{		my24Data = NewPtrClear (262144L * 1.6);		if (!my24Data)		{			genError ("\pNot enough memory to build overviews");			return false;		}		} */	myData = NewPtrClear (419430); /* enough for 24 bit */	if (!myData)	{		genError ("\pNot enough memory to build overviews");		return false;	}		while (!iErr && filePtr < (duration + startPoint))	{		inOutCount = (wordSize == 3) ? 393216L : 262144L;				if (inOutCount + filePtr > (duration + startPoint))		{			inOutCount = (duration + startPoint) - filePtr;		}				if (wordSize == 3)		{			long myInOut = ((float)inOutCount * 1.5);		//	myInOut = (myInOut / 3) * 3;			iErr = FSRead(RefNum,&inOutCount,myData);				filePtr += inOutCount;			convertBuffer24To16 (myData, &inOutCount);			//inOutCount = myInOut;		}		else		{			iErr = FSRead(RefNum,&inOutCount,myData);			filePtr += inOutCount;			}		soFarInBuffer = 0;		bufferPtr = myData;				if (!iErr || iErr == eofErr)		{			if (stereo && !mixStereo)			{				if (wordSize == 2 || wordSize == 3) /* 16 bit stereo interleaved creating 2 overviews */				{																				}				else /* 8 bit stereo interleaved creating 2 overviews */				{																				}			}			else			{				if (wordSize == 2 || wordSize == 3)				{					if (mixStereo && stereo) /* 16 bit stereo interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = ((decimation * ((wordSize == 3) ? 2 : wordSize))); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=4L) /* index through the chunk */							{								theLSample = *(short *)(bufferPtr + z);								theRSample = *(short *)(bufferPtr + z + 2L);								theTempSample = (theLSample + theRSample) >> 1;								/*theSample = *(short *)(bufferPtr + z);*/ /* read the next sample */								theSample = LoWord(theTempSample);																if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																				//	ovPlus = ((maxPlus & 0x7F80) >> 7) /* + 128*/;  /* turn it into a byte */						//	maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */						//	ovMinus = ((maxPlus & 0x7F80) >> 7);  /* turn it into a byte */						//	ovMinus = -ovMinus; /* now swap it back */						//	*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */						//	*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */														ovPlus = ((maxPlus & 0xFF00) >> 8) ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = ((maxMinus & 0xFF00) >> 8);  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}					else /* 16 bit mono interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = ((decimation * ((wordSize == 3) ? 2 : wordSize))); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=2L) /* index through the chunk */							{								theSample = *(short *)(bufferPtr + z); /* read the next sample */								if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																				//	ovPlus = ((maxPlus & 0x7F80) >> 7) /* + 128*/;  /* turn it into a byte */						//	maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */						//	ovMinus = ((maxPlus & 0x7F80) >> 7);  /* turn it into a byte */						//	ovMinus = -ovMinus; /* now swap it back */						//	*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */						//	*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */														ovPlus = ((maxPlus & 0xFF00) >> 8) ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = ((maxMinus & 0xFF00) >> 8);  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}				}				else				{					if (mixStereo && stereo)  /* 8 bit stereo interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = ((decimation * ((wordSize == 3) ? 2 : wordSize))); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=2L) /* index through the chunk */							{								theLSample = *(Byte *)(bufferPtr + z);								theRSample = *(Byte *)(bufferPtr + z + 1L);								theTempSample = (theLSample + theRSample) >> 1;								/*theSample = *(short *)(bufferPtr + z);*/ /* read the next sample */								theSample = LoWord(theTempSample);																if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																										ovPlus = maxPlus ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = maxMinus;  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}					else /* 8 bit mono interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = ((decimation * ((wordSize == 3) ? 2 : wordSize))); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=1L) /* index through the chunk */							{								theSample = *(Byte *)(bufferPtr + z); /* read the next sample */								if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																						ovPlus = maxPlus ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = maxMinus;  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}				}			}		}	}		DisposPtr (myData);	return true;}Boolean calcPartialOverview24Bit (short RefNum, long startPoint, long duration, char * theLOverView, char * theROverView, Boolean stereo, Boolean mixStereo, long decimation){	long filePtr;	long inOutCount;	Ptr myData;	long theTempSample;	short theSample, theLSample,theRSample;	char theByte;	OSErr iErr, err;	long leftOVPtr, rightOVPtr;	long z;	short maxPlus, maxMinus;	Ptr bufferPtr,my24Data;	long soFarInBuffer,tempCount;	char ovPlus;	char ovMinus;	long myStartPos = startPoint;	leftOVPtr = 0;	rightOVPtr = 0;			myStartPos = startPoint;	myStartPos = (myStartPos / 3) * 3;	filePtr = myStartPos;	iErr = SetFPos(RefNum,fsFromStart,myStartPos);	if (iErr)	{		return false;	}	myData = NewPtrClear (419430); /* enough for 24 bit */	if (!myData)	{		genError ("\pNot enough memory to build overviews");		return false;	}		while (!iErr && (filePtr+2) < (duration + startPoint))	{		inOutCount = 393216L;				if (inOutCount + filePtr > (duration + startPoint))		{			inOutCount = (duration + startPoint) - filePtr;		}					inOutCount = (inOutCount / 3) * 3;			iErr = FSRead(RefNum,&inOutCount,myData);		filePtr += inOutCount;			convertBuffer24To16 (myData, &inOutCount);		soFarInBuffer = 0;		bufferPtr = myData;				if (!iErr || iErr == eofErr)		{			if (stereo && !mixStereo)			{																			}			else			{				if (true)				{					if (mixStereo && stereo) /* 16 bit stereo interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = (decimation * 2); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=4L) /* index through the chunk */							{								theLSample = *(short *)(bufferPtr + z);								theRSample = *(short *)(bufferPtr + z + 2L);								theTempSample = (theLSample + theRSample) >> 1;								/*theSample = *(short *)(bufferPtr + z);*/ /* read the next sample */								theSample = LoWord(theTempSample);																if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																				//	ovPlus = ((maxPlus & 0x7F80) >> 7) /* + 128*/;  /* turn it into a byte */						//	maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */						//	ovMinus = ((maxPlus & 0x7F80) >> 7);  /* turn it into a byte */						//	ovMinus = -ovMinus; /* now swap it back */						//	*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */						//	*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */														ovPlus = ((maxPlus & 0xFF00) >> 8) ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = ((maxMinus & 0xFF00) >> 8);  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}					else /* 16 bit mono interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = (decimation * 2); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=2L) /* index through the chunk */							{								theSample = *(short *)(bufferPtr + z); /* read the next sample */								if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																				//	ovPlus = ((maxPlus & 0x7F80) >> 7) /* + 128*/;  /* turn it into a byte */						//	maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */						//	ovMinus = ((maxPlus & 0x7F80) >> 7);  /* turn it into a byte */						//	ovMinus = -ovMinus; /* now swap it back */						//	*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */						//	*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */						//	leftOVPtr++; /* increment the OV Buffer ptr */														ovPlus = ((maxPlus & 0xFF00) >> 8) ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = ((maxMinus & 0xFF00) >> 8);  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}				}				else				{					if (mixStereo && stereo)  /* 8 bit stereo interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = (decimation * 2); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=2L) /* index through the chunk */							{								theLSample = *(Byte *)(bufferPtr + z);								theRSample = *(Byte *)(bufferPtr + z + 1L);								theTempSample = (theLSample + theRSample) >> 1;								/*theSample = *(short *)(bufferPtr + z);*/ /* read the next sample */								theSample = LoWord(theTempSample);																if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																										ovPlus = maxPlus ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = maxMinus;  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}					else /* 8 bit mono interleaved creating 1 overview */					{						long bgLooper = 0;						soFarInBuffer = 0; /* within the big read we are at the start */												while (bufferPtr < (myData+inOutCount)) /* until we get to the end of the big read */						{							tempCount = (decimation *2); /* process little decimation chunks */														if ((bufferPtr + tempCount) > (myData+inOutCount)) /* check this chunk doesnt go over the end of the buffer */							{								tempCount = ((long)myData + inOutCount) - (long)bufferPtr; /* if it does, chop it */							}							maxPlus = 0; /* init the OVs */							maxMinus = 0;													if (doBackGround && (bgLooper >= kBgRate))							{								//FlashMenuBar(0);								if (!dealWithUpdate ())								{									DisposPtr (myData);									return false;								}								bgLooper = 0;							}							bgLooper ++;														for (z=0;z<tempCount;z+=1L) /* index through the chunk */							{								theSample = *(Byte *)(bufferPtr + z); /* read the next sample */								if (theSample < 0) /* if it is minus */								{									if (theSample < maxMinus) /* check if it is the lowest */									{										maxMinus = theSample; /* if so assign it */									}								}								else								{									if (theSample > maxPlus) /* check if it is the highest */									{										maxPlus = theSample; /* if so assign it */									}								} 							}																						ovPlus = maxPlus ;  /* turn it into a byte */							maxMinus = -maxMinus; /* swap the minus to avoid bit shift sign confusion */							ovMinus = maxMinus;  /* turn it into a byte */							ovMinus = -ovMinus; /* now swap it back */							*(char *)(theLOverView + leftOVPtr) = ovPlus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */							*(char *)(theLOverView + leftOVPtr) = ovMinus; /* write it into the OV buffer */							leftOVPtr++; /* increment the OV Buffer ptr */																			bufferPtr += tempCount;						}					}				}			}		}	}		DisposPtr (myData);	return true;}Boolean dealWithUpdate (void){	EventRecord theEvent;	WindowPtr whichWindow;	short thePart;	short theQuay;		//SystemTask();	if(WaitNextEvent(everyEvent,&theEvent,0,0)) 	{		if (theEvent.what == mouseDown)		{			thePart = FindWindow (theEvent.where,&whichWindow);			switch (thePart)			{				case inSysWindow: 	    			SystemClick (&theEvent, whichWindow);	    		break;	    	}			    		}		if (theEvent.what == keyDown)		{			theQuay = (theEvent.message) & keyCodeMask;			if ((theQuay == 0x2F00) && (theEvent.modifiers & cmdKey)) 			{				return false;			}		}	}/*	if (isPressed(0x3A) && isPressed(0x2F))	{		return false;	}*/	return true;}