#include "SampleSearch.h"#include "Globals.h"extern Boolean plusMode;/*typedef struct cropSpec {	short noiseFloor;	long preRoll;	long postRoll;	long addSilenceStart;	long addSilenceEnd;	long fadeInTime;	long fadeOutTime;	Boolean rewriteOriginal;	Boolean compositeFiles;	long silencePeriod;	FSSpec theCompositeSpec;	long theCompRate;	short theCompBits;	Boolean theCompStereo;	Boolean deleteCompCopies;} cropSpec, *cropSpecPtr;*/typedef struct cropSpec {	short noiseFloor; /* in */	long preRoll;	long postRoll;	long addSilenceStart;	long addSilenceEnd;	long fadeInTime;	long fadeOutTime;	Boolean rewriteOriginal;	Boolean compositeFiles;	long silencePeriod;	FSSpec theCompositeSpec;	long theCompRate;	short theCompBits;	Boolean theCompStereo;	Boolean deleteCompCopies;	Boolean doPre;	Boolean doPost;	Boolean doAddSilenceStart;	Boolean doAddSilenceEnd;	Boolean doFadeStart;	Boolean doFadeEnd;		short noiseFloorOut;} cropSpec, *cropSpecPtr;Boolean addTimeStampRegion(FSSpec mySpec, long timeStamp);Boolean extractSMPTEFromFile (FSSpec theFile,short regionNum, long *timeStamp);Boolean addFileToList(FSSpec mySpec);#define kInsertSilence 0#define kInsertFile 1Boolean extractSMPTEFromFile (FSSpec theFile,short regionNum, long * timeStamp);long calcCompositeSilence (long selectedTime, short numItems,long desiredLength);void calculateSelectionTime (long * selectedTime, short * numItems, long * selectedBytes);long inquireLength (long selectedTime, short numItems);	Fixed getOtherRate(void);	void addLeadingZeros (StringPtr theString, short totalDigits);short currentRegionNumber = 0;typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;Boolean ignoreZero;extern FSSpec theConvertDestLoc;void getConvertDest(void);Boolean autoTopTailSDII(FSSpec mySpec, short noiseFloor);extern Boolean autoCrop;Boolean GetSampleRateTime (FSSpec mySpec, short index, long theSize, long* theSRate, long* theDuration, Boolean* isStereo, OSType theFileType);void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);Boolean normalMode;Boolean useRegionNames;Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);Boolean writeSDIILoopsMarkers(FSSpec theSpec);Boolean exportRegions(FSSpec mySpec);Boolean exportRegion (FSSpec source, FSSpec destination, RegionRec	myRgn);Boolean exportRegionFromAIFF (FSSpec source, FSSpec destination, RegionRec	myRgn);Boolean useFolderID, overWriteFiles;Boolean exportRegionsMany(void);Boolean exportRegionsMany(void){	Cell theCell;	short theindex;		short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/		myDlg = GetNewDialog(1555,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,false);	if (!plusMode)	{		HideDItem(myDlg,7);		HideDItem(myDlg,8);		HideDItem(myDlg,9);	}	ShowWindow(myDlg);	itemHit = -1;	normalMode = true;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,255);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 7:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 10:				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 1:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					useRegionNames = true;				}				GetDItem(myDlg,6,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					useRegionNames = false;				}				GetDItem(myDlg,7,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					useFolderID = true;				}				else				{					useFolderID = false;				}				GetDItem(myDlg,8,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					overWriteFiles = true;				}				else				{					overWriteFiles = false;				}				GetDItem(myDlg,10,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					ignoreZero = true;				}				else				{					ignoreZero = false;				}							break;		}	}		DisposDialog(myDlg);	if (itemHit == 2)		return;			getConvertDest();		SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));						exportRegions((*therealResults)[theindex]);				LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	return true;}Boolean exportRegions(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle hRsrc;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	long regtimeStamp;	FSSpec destFile;	Str255 theNumString;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		SysBeep(5);		return false;	}		if (fndrInfo.fdType != 'Sd2f')	{		genError ("\pRegions can be exported only from Sound Designer II files");		return false;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}		UseResFile(fRefNum);		hRsrc = Get1Resource('ddRL',1000);		if (!hRsrc)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		lByteCnt = SizeResource(hRsrc);		if (lByteCnt <= 18L)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(hRsrc);	CloseResFile(fRefNum);	UseResFile(iRefNum);		progressCreate("\pCreating Regions");	for (z = (ignoreZero) ? 1 : 0;z<regionCount;z++)	{					currentRegionNumber = z;				BlockMove ((((*hRsrc) +18)+(56L * z)), &tempRegRec, 56L);		BlockMove (&mySpec, &destFile, 70L);		if (!useRegionNames)		{			NumToString((long)(z+1),theNumString);			addLeadingZeros (theNumString, 3);			concatStrings(destFile.name,theNumString,"\p-");		}		else		{						if (useFolderID)			{				Str255 theExtractedName = "\p", theExtractedParID = "\p";				long exParID;				FSSpec testSpec;				long presDestID,x;								normalMode = false;				if (*(tempRegRec.RegionName + 1) == '|')				{					x=2;					while (*(tempRegRec.RegionName + x) != '|' && x<32)					{						*(theExtractedParID + *theExtractedParID + 1) = *(tempRegRec.RegionName + x);						*theExtractedParID += 1;						x++;					}						x++;					while ((x< ((*tempRegRec.RegionName)+1)) && x<64)					{						*(theExtractedName + *theExtractedName + 1) = *(tempRegRec.RegionName + x);						*theExtractedName += 1;						x++;					}						BlockMove(theExtractedName, destFile.name, 32L);					StringToNum(theExtractedParID,&exParID);					presDestID = destFile.parID;					destFile.parID = exParID;						iErr = FSMakeFSSpec(destFile.vRefNum,destFile.parID,destFile.name,&testSpec);						if (iErr != 0 && iErr != -43)					{						writeLogS((unsigned char *)"could not respect folderID for file:");						writeLog((char *)tempRegRec.RegionName);						writeLogS((unsigned char *)"writing it to destination folder instead");						destFile.parID = presDestID;						BlockMove(tempRegRec.RegionName, destFile.name, 32L);					}				}				else					BlockMove(tempRegRec.RegionName, destFile.name, 32L);			}			else			{				BlockMove(tempRegRec.RegionName, destFile.name, 32L);			}		}		if (progressDisp((z*100) / regionCount))		{			return false;		}		exportRegion (mySpec, destFile, tempRegRec);			}	progressDispos();		return true;}Boolean	YesNo (Str255	myText);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);Boolean exportRegion (FSSpec source, FSSpec destination, RegionRec	myRgn){	OSErr	iErr;	short	destRefNum,sourRefNum;	Boolean worked;	long theSRate,theDuration;	Boolean isStereo;	Handle dataH;	short iRefNum,fRefNum,xRefNum;	StringHandle	h1,h2,h3;	long chans,wordsize;	long inOutCount, startPos, endPos;	Boolean doitagain;	long filePos;	FInfo fndrInfo;	Str255	theasker = "\pexists, Overwrite ?";	Str255 theCopyStr;		long theRate;	short theWordSize;	Boolean stereo; 	long theBytes,regtimeStamp;			iErr = FSpGetFInfo(&source,&fndrInfo);	if (iErr)	{		return;	}	switch (fndrInfo.fdType)	{		case 'AIFF':			return exportRegionFromAIFF ( source,  destination, 	myRgn);		break;		case 'Sd2f':		break;		default:			return;		break;	}	extractSMPTEFromFile (source,currentRegionNumber, &regtimeStamp);			destination.vRefNum = theConvertDestLoc.vRefNum;	if (normalMode)	{		destination.parID = theConvertDestLoc.parID;	}	if (*destination.name > 31)	{		*destination.name = 31;	}	iErr = FSpCreate(&destination,'Sd2a','Sd2f',0);	if (iErr == -48)	{		if (overWriteFiles == true)		{			FSpDelete (&destination);			iErr = FSpCreate(&destination,'Sd2a','Sd2f',0);		}			else		{					BlockMove (destination.name,theCopyStr,64L);			concatStrings(theCopyStr,theasker,"\p ");			if (YesNo (theCopyStr))			{				FSpDelete (&destination);				iErr = FSpCreate(&destination,'Sd2a','Sd2f',0);			}			else			{				return false;			}		}	}	worked = GetSampleRateTime (source, 0,0L,&theSRate, &theDuration, &isStereo,'Sd2f');		getSDIIData (source, &theRate, &theWordSize, &stereo,&theBytes);		xRefNum = CurResFile();/*	fRefNum = FSpOpenResFile(&source,fsCurPerm);	if (fRefNum == -1)	{		genError ("\pCan't open sources Res Fork");		UseResFile(xRefNum);		return false;	}	h1 = GetString(1000);	if (!h1)	{		genError ("\pCan't get str 1000");		UseResFile(xRefNum);		return false;	}	h2 = GetString(1001);	if (!h2)	{		genError ("\pCan't get str 1001");		UseResFile(xRefNum);		return false;	}	h3 = GetString(1002);	if (!h3)	{		genError ("\pCan't get str 1002");		UseResFile(xRefNum);		return false;	}	DetachResource((Handle)h1);	DetachResource((Handle)h2);	DetachResource((Handle)h3);		FSClose (fRefNum);	UseResFile(xRefNum);*//*	FSpCreateResFile(&destination,'Sd2a','Sd2f',0);	fRefNum = FSpOpenResFile(&destination,fsWrPerm);	if (fRefNum == -1)	{		genError ("\pCan't open destination resfork");		UseResFile(xRefNum);		return false;	}	UseResFile(fRefNum);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		UseResFile(xRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		UseResFile(xRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add str 1002");		UseResFile(xRefNum);		return false;	}	StringToNum(*h1,&wordsize);	StringToNum(*h3,&chans);		CloseResFile(fRefNum);	UseResFile(xRefNum);*/		writeSDIIResources(destination,theRate,stereo,theWordSize);	dataH = NewHandle(131072); 	if (!dataH)	{		genError ("\pNot enough memory to perform this function");		return false;	}		iErr = FSpOpenDF(&destination,fsWrPerm,&fRefNum);	if (iErr != 0)	{		genError ("\pCan't open DF of destination file");		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}	iErr = FSpOpenDF(&source,fsCurPerm,&iRefNum);	if (iErr != 0)	{		genError ("\pCan't open DF of source file");		FSClose (fRefNum);		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}	wordsize = theWordSize;	chans = stereo+1;	startPos = myRgn.StartFrame * (wordsize * chans);	endPos = myRgn.StopFrame * (wordsize * chans);		if (theWordSize == 3)	{		startPos = (startPos / 3) * 3;		endPos = (endPos / 3) * 3;	}	if (theWordSize == 2)	{		startPos = startPos >> 1 << 1;		endPos = endPos >> 1 << 1;	}	doitagain = true;		iErr = SetFPos(iRefNum,1,startPos);	if (iErr != 0)	{		genError ("\pCan't position in DF of source file");		FSClose (iRefNum);		FSClose (fRefNum);		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}			iErr = GetFPos(iRefNum,&filePos);		iErr = SetFPos(fRefNum,1,0L);	if (iErr != 0)	{		genError ("\pCan't position in DF of dest file");		FSClose (iRefNum);		FSClose (fRefNum);		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}				while (doitagain)	{		inOutCount = endPos - startPos;		if (inOutCount > 131072L)		{			inOutCount = 131072L;			doitagain = true;		}		else		{			doitagain = false;		}				iErr = GetFPos(iRefNum,&filePos);				iErr = FSRead(iRefNum,&inOutCount,*dataH);		if (iErr != 0)		{			genError ("\pCan't read DF of source file");			FSClose (iRefNum);			FSClose (fRefNum);			DisposHandle(dataH);			UseResFile(xRefNum);			return false;		}				iErr = GetFPos(iRefNum,&filePos);				iErr = FSWrite(fRefNum,&inOutCount,*dataH);		if (iErr != 0)		{			genError ("\pCan't write DF of dest file");			FSClose (iRefNum);			FSClose (fRefNum);			DisposHandle(dataH);			UseResFile(xRefNum);			return false;		}		startPos += 131072L;	}			FSClose (iRefNum);		FSClose (fRefNum);				//writeSDIILoopsMarkers(destination);		DisposHandle(dataH);		UseResFile(xRefNum);						addTimeStampRegion(destination, regtimeStamp);						if (normalMode)			addFileToList(destination);		return true;			}Boolean getAIFFDataIII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes, long  *headerSize);Boolean exportRegionFromAIFF (FSSpec source, FSSpec destination, RegionRec	myRgn){	OSErr	iErr;	short	destRefNum,sourRefNum;	Boolean worked;	long theSRate,theDuration;	Boolean isStereo;	Handle dataH;	short iRefNum,fRefNum,xRefNum;	StringHandle	h1,h2,h3;	long chans,wordsize;	long inOutCount, startPos, endPos;	Boolean doitagain;	long filePos;	FInfo fndrInfo;	Str255	theasker = "\pexists, Overwrite ?";	Str255 theCopyStr;	long AIFFHeaderSize;	long theRate;	short theWordSize;	Boolean stereo; 	long theBytes,regtimeStamp;	short channels;		destination.vRefNum = theConvertDestLoc.vRefNum;	if (normalMode)	{		destination.parID = theConvertDestLoc.parID;	}	iErr = FSpCreate(&destination,'Sd2a','Sd2f',0);	if (iErr == -48)	{		if (overWriteFiles == true)		{			FSpDelete (&destination);			iErr = FSpCreate(&destination,'Sd2a','Sd2f',0);		}			else		{					BlockMove (destination.name,theCopyStr,64L);			concatStrings(theCopyStr,theasker,"\p ");			if (YesNo (theCopyStr))			{				FSpDelete (&destination);				iErr = FSpCreate(&destination,'Sd2a','Sd2f',0);			}			else			{				return false;			}		}	}//	worked = GetSampleRateTime (source, 0,0L,&theSRate, &theDuration, &isStereo,'Sd2f');		getAIFFDataIII (source, &theRate, &theWordSize, &channels,&theBytes, &AIFFHeaderSize);	stereo = (channels == 2);		xRefNum = CurResFile();		writeSDIIResources(destination,theRate,stereo,theWordSize);	dataH = NewHandle(131072); 	if (!dataH)	{		genError ("\pNot enough memory to perform this function");		return false;	}		iErr = FSpOpenDF(&destination,fsWrPerm,&fRefNum);	if (iErr != 0)	{		genError ("\pCan't open DF of destination file");		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}	iErr = FSpOpenDF(&source,fsCurPerm,&iRefNum);	if (iErr != 0)	{		genError ("\pCan't open DF of source file");		FSClose (fRefNum);		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}	wordsize = theWordSize;	chans = stereo+1;	startPos = myRgn.StartFrame * (wordsize * chans);	endPos = myRgn.StopFrame * (wordsize * chans);		doitagain = true;		iErr = SetFPos(iRefNum,1,startPos + AIFFHeaderSize);	if (iErr != 0)	{		genError ("\pCan't position in DF of source file");		FSClose (iRefNum);		FSClose (fRefNum);		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}			iErr = GetFPos(iRefNum,&filePos);		iErr = SetFPos(fRefNum,1,0L);	if (iErr != 0)	{		genError ("\pCan't position in DF of dest file");		FSClose (iRefNum);		FSClose (fRefNum);		DisposHandle(dataH);		UseResFile(xRefNum);		return false;	}				while (doitagain)	{		inOutCount = endPos - startPos;		if (inOutCount > 131072L)		{			inOutCount = 131072L;			doitagain = true;		}		else		{			doitagain = false;		}				iErr = GetFPos(iRefNum,&filePos);				iErr = FSRead(iRefNum,&inOutCount,*dataH);		if (iErr != 0)		{			genError ("\pCan't read DF of source file");			FSClose (iRefNum);			FSClose (fRefNum);			DisposHandle(dataH);			UseResFile(xRefNum);			return false;		}				iErr = GetFPos(iRefNum,&filePos);				iErr = FSWrite(fRefNum,&inOutCount,*dataH);		if (iErr != 0)		{			genError ("\pCan't write DF of dest file");			FSClose (iRefNum);			FSClose (fRefNum);			DisposHandle(dataH);			UseResFile(xRefNum);			return false;		}		startPos += 131072L;	}			FSClose (iRefNum);		FSClose (fRefNum);				DisposHandle(dataH);		UseResFile(xRefNum);						if (normalMode)			addFileToList(destination);		return true;			}Boolean CompositeSDIIDialog(void);Boolean CompositeSDIIDialog(void){		Cell theCell;	short theindex;		short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean preserveRegions,deleteOriginals;	long theSpace;	Str255 theSpaceStr;	StandardFileReply reply;	short refNum, sourceRef,iRefNum, destRef;	OSErr 	iErr,eErr;	long filePos;	Str255 rate,numBits,StereoMono,tempStr;	StringHandle h1,h2,h3;	Handle	tempBuff;	long inOutCount,theDivider,tempLong;	short theDivTime = 1;	Handle hNew;	Handle	regionsHandle;	short regionCounter = 0;	ddRLHeader myRegHeader;	unsigned long secs;	RegionRec	currentRegion;	FInfo fndrInfo;			myDlg = GetNewDialog(12312,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 12:				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						default:						break;		}	}	if (itemHit == 2)	{		DisposDialog(myDlg);		return false;	}	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	preserveRegions = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,12,&iType,&iHndl,&iRect);	deleteOriginals = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	GetIText(iHndl,theSpaceStr);	StringToNum(theSpaceStr,&theSpace);		/*9,10,11 stero, rate, bits*/		GetDItem(myDlg,9,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p1",StereoMono);		break;				case 2:			makeStr255("\p2",StereoMono);			theDivTime = 2;		break;	}	GetDItem(myDlg,10,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p44100.0000",rate);		break;				case 2:			makeStr255("\p48000.0000",rate);		break;				case 3:			makeStr255("\p32000.0000",rate);		break;	}		GetDItem(myDlg,11,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p2",numBits);			theDivTime *= 2;		break;				case 2:			makeStr255("\p1",numBits);		break;	}		DisposDialog(myDlg);}Boolean encodeFolderID;Boolean CompositeSDII(void);Boolean CompositeSDII(void){		Cell theCell;	short theindex;		short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean preserveRegions,deleteOriginals;	long theSpace;	Str255 theSpaceStr;	StandardFileReply reply;	short refNum, sourceRef,iRefNum, destRef;	OSErr 	iErr,eErr;	long filePos;	Str255 rate,numBits,StereoMono,tempStr;	StringHandle h1,h2,h3;	Handle	tempBuff;	long inOutCount,theDivider,tempLong;	short theDivTime = 1;	Handle hNew;	Handle	regionsHandle;	short regionCounter = 0;	ddRLHeader myRegHeader;	unsigned long secs;	RegionRec	currentRegion;	FInfo fndrInfo;	short insertMode = kInsertSilence;	FSSpec theInsertSpec;	StandardFileReply theReply;	SFTypeList myTypes;	Fixed theFixedRate;	long longRate;	Boolean stereo;	short wordSize;	long selectedTime,selectedBytes;	long desiredLength,silenceTime;	short numItems;	long zfilePos;					theInsertSpec.vRefNum = -999;			myDlg = GetNewDialog(12312,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);			if (!plusMode)	{		HideDItem(myDlg,13);	}			ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 12:				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 13:				GetDItem(myDlg,13,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 7:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,14,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;						case 14:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,14,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				if (theInsertSpec.vRefNum == -999)				{																				myTypes[0] = (OSType)('Sd2f');										StandardGetFile(0,1,myTypes,&theReply);					if (theReply.sfGood)					{						theInsertSpec = theReply.sfFile;						GetDItem(myDlg,15,&iType,&iHndl,&iRect);						SetCTitle((ControlHandle)iHndl,theInsertSpec.name);					}					else					{						GetDItem(myDlg,7,&iType,&iHndl,&iRect);						SetCtlValue((ControlHandle)iHndl,true);						GetDItem(myDlg,14,&iType,&iHndl,&iRect);						SetCtlValue((ControlHandle)iHndl,false);						GetDItem(myDlg,15,&iType,&iHndl,&iRect);						SetCTitle((ControlHandle)iHndl,"\pNot Defined");					}				}			break;						case 15:				myTypes[0] = (OSType)('Sd2f');								StandardGetFile(0,1,myTypes,&theReply);				if (theReply.sfGood)				{					theInsertSpec = theReply.sfFile;					GetDItem(myDlg,15,&iType,&iHndl,&iRect);					SetCTitle((ControlHandle)iHndl,theInsertSpec.name);					GetDItem(myDlg,7,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,false);					GetDItem(myDlg,14,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,true);				}				else				{					GetDItem(myDlg,7,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,true);					GetDItem(myDlg,14,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,false);					GetDItem(myDlg,15,&iType,&iHndl,&iRect);					SetCTitle((ControlHandle)iHndl,"\pNot Defined");				}			break;						case 16:				/* get the pop up values first */								GetDItem(myDlg,10,&iType,&iHndl,&iRect);				switch (GetCtlValue((ControlHandle)iHndl))				{					case 1:						longRate = 44100L;					break;										case 2:						longRate = 48000L;					break;										case 3:						longRate = 32000L;					break;										case 5:						longRate = (unsigned long)(theFixedRate >> 16) & 0x0000FFFF;					break;				}								GetDItem(myDlg,9,&iType,&iHndl,&iRect);				switch (GetCtlValue((ControlHandle)iHndl))				{					case 1:						stereo = false;					break;										case 2:						stereo = true;					break;				}								GetDItem(myDlg,11,&iType,&iHndl,&iRect);							switch (GetCtlValue((ControlHandle)iHndl))				{					case 1:						wordSize = 2;					break;										case 2:						wordSize = 1;					break;				}						calculateSelectionTime(&selectedTime, &numItems, &selectedBytes);				selectedTime = ((selectedBytes >> stereo >> (wordSize - 1)) * 1000L) / longRate; 				if (selectedTime < 0)				{					 /* you havent set the menus right */				}				desiredLength = inquireLength(selectedTime,numItems);				silenceTime = calcCompositeSilence(selectedTime,numItems,desiredLength);								NumToString(silenceTime,theSpaceStr);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetIText(iHndl,theSpaceStr);				/* insert that value into the dialog */			break;									case 10:				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl) == 5)				{					theFixedRate = getOtherRate();				}			break;									default:			break;		}	}	if (itemHit == 2)	{		DisposDialog(myDlg);		return false;	}	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	preserveRegions = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,13,&iType,&iHndl,&iRect);	encodeFolderID = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,12,&iType,&iHndl,&iRect);	deleteOriginals = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	GetIText(iHndl,theSpaceStr);	StringToNum(theSpaceStr,&theSpace);			GetDItem(myDlg,7,&iType,&iHndl,&iRect);	if (GetCtlValue((ControlHandle)iHndl))	{		insertMode = kInsertSilence;	}		else	{		insertMode = kInsertFile;	}			/*9,10,11 stero, rate, bits*/		GetDItem(myDlg,9,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p1",StereoMono);		break;				case 2:			makeStr255("\p2",StereoMono);			theDivTime = 2;		break;	}	GetDItem(myDlg,10,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p44100.0000",rate);		break;				case 2:			makeStr255("\p48000.0000",rate);		break;				case 3:			makeStr255("\p32000.0000",rate);		break;				case 5:			longRate = (unsigned long)(theFixedRate >> 16) & 0x0000FFFF;			NumToString ((unsigned long)longRate,rate);			concatStrings(rate,"\p0000","\p.");			/*makeStr255("\p32000.0000",rate);*/		break;	}		GetDItem(myDlg,11,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			makeStr255("\p2",numBits);			theDivTime *= 2;		break;				case 2:			makeStr255("\p1",numBits);		break;	}		DisposDialog(myDlg);			BlockMove (rate,tempStr,6L);	*tempStr = 5;	StringToNum(tempStr,&theDivider);	theDivider /= 1000L;	theDivider *= (long)theDivTime;	theSpace *= theDivider;		StandardPutFile("\pEnter name for new SDII file","\pComposite File",&reply);	if (!reply.sfGood)		return  false;			if (reply.sfReplacing)		iErr = FSpDelete(&(reply.sfFile));			iErr = FSpCreate(&(reply.sfFile),'Sd2a','Sd2f',0);	if (iErr !=0)		return false;	FSpCreateResFile(&(reply.sfFile),'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr !=0)		return false;			iRefNum = CurResFile();		refNum = FSpOpenResFile(&(reply.sfFile),fsWrPerm);	if (refNum == -1)	{		genError ("\pCould not open res file");		return false;	}	UseResFile(refNum);	h1 = NewString(numBits);	h2 = NewString(rate);	h3 = NewString(StereoMono);		AddResource((Handle)h1,'STR ',1000,"\psample-size");	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	AddResource((Handle)h3,'STR ',1002,"\pchannels");	CloseResFile(refNum);	UseResFile(iRefNum);			tempBuff = NewHandle(32768L);	if (!tempBuff)	{		genError ("\pNot enough memory for that operation");		return false;		}		hNew = NewHandleClear(32768L);	if (!hNew)	{		genError ("\pNot enough memory for that operation");		DisposHandle(tempBuff);		return false;		}		if (preserveRegions)	{		regionsHandle = NewHandle(sizeof(ddRLHeader) + sizeof(RegionRec));		if (!regionsHandle)		{			genError ("\pNot enough memory for that operation");			DisposHandle(tempBuff);			DisposHandle(hNew);						return false;			}		myRegHeader.VersionNumber = 1;		myRegHeader.HeaderSize = 12L;		myRegHeader.RegionSize = 56L;		GetDateTime(&secs);		myRegHeader.ResourceDate = secs;		myRegHeader.NextID = 1L;		BlockMove (&myRegHeader,*regionsHandle,sizeof(ddRLHeader));	}		iErr = FSpOpenDF(&(reply.sfFile),fsCurPerm,&destRef);	if (iErr !=0)	{		genError ("\pCould not open dest DF file");		DisposHandle(tempBuff);		DisposHandle(hNew);		return false;	}			SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				iErr = FSpGetFInfo(&((*therealResults)[theindex]),&fndrInfo);		if (iErr != 0 || fndrInfo.fdType != 'Sd2f')			break;				extractSMPTEFromFile (((*therealResults)[theindex]),0, (long *)&secs);			iErr = FSpOpenDF(&((*therealResults)[theindex]),fsCurPerm,&sourceRef);		if (iErr !=0)		{			SysBeep(5);			break;		}				iErr = GetFPos(destRef,&filePos);		if (!theDivTime)			theDivTime = 1;		filePos = filePos / (long)theDivTime;				if (preserveRegions)		{			currentRegion.RegionID = regionCounter + 1;			currentRegion.StartFrame = filePos;			//currentRegion.StopFrame = 			currentRegion.SynchFrame = filePos;						currentRegion.TimeStampMS = secs;			currentRegion.TimeStampLS = secs;						if (encodeFolderID)			{				Str255 theIDString;								*currentRegion.RegionName = 0;				NumToString(((*therealResults)[theindex]).parID,theIDString);				concatStrings(currentRegion.RegionName,"\p|","\p");				concatStrings(currentRegion.RegionName,theIDString,"\p");				concatStrings(currentRegion.RegionName,"\p|","\p");				concatStrings(currentRegion.RegionName,((*therealResults)[theindex]).name,"\p");			}			else			{				BlockMove(((*therealResults)[theindex]).name,currentRegion.RegionName,32L); 			}					}		eErr = 0;		progressCreate("\pCompositing File");		while (iErr != eofErr && !eErr)		{			if(progressDisp(100))			{				FSClose (sourceRef);				FSClose (destRef);				DisposHandle(tempBuff);				DisposHandle(hNew);						}			inOutCount = 32000L;			iErr = FSRead(sourceRef,&inOutCount,*tempBuff);			eErr = FSWrite(destRef,&inOutCount,*tempBuff);		}		FSClose (sourceRef);				if (deleteOriginals)		{			iErr = FSpDelete(&((*therealResults)[theindex]));		}		progressDispos();				iErr = GetFPos(destRef,&filePos);		if (!theDivTime)			theDivTime = 1;		filePos /= (long)theDivTime;				if (preserveRegions)		{			currentRegion.StopFrame = filePos;				//(RegionRec)((*regionsHandle) + sizeof(ddRLHeader) + ((sizeof(RegionRec) * regionCounter))) = currentRegion;			BlockMove(&currentRegion,((*regionsHandle) + sizeof(ddRLHeader) + ((sizeof(RegionRec) * regionCounter))),sizeof(RegionRec));			regionCounter ++;			SetHandleSize(regionsHandle,sizeof(ddRLHeader) + (sizeof(RegionRec) * (regionCounter+1)));			iErr = MemError();			if (iErr != 0)			{				FSClose (destRef);				DisposHandle(regionsHandle);				DisposHandle(tempBuff);				DisposHandle(hNew);				}		}		if (insertMode == kInsertSilence)		{			tempLong = theSpace;			eErr = 0;						iErr = GetFPos(destRef,&zfilePos);						progressCreate("\pAdding Silence");			while (tempLong > 0L && !eErr)			{				if (tempLong >= 32000L)				{					inOutCount = 32000L;				}				else				{					inOutCount = tempLong;				}				tempLong -= inOutCount;				if(progressDisp(100))				{					FSClose (destRef);					DisposHandle(tempBuff);					DisposHandle(hNew);							}				eErr = FSWrite(destRef,&inOutCount,*hNew);			}			progressDispos();		}		else		{			iErr = FSpOpenDF(&theInsertSpec,fsRdPerm,&sourceRef);			if (iErr !=0)			{				SysBeep(5);				break;			}						iErr = GetFPos(destRef,&filePos);			if (!theDivTime)				theDivTime = 1;			filePos = filePos / (long)theDivTime;						eErr = 0;			progressCreate("\pInserting link File");			while (iErr != eofErr && !eErr)			{				if(progressDisp(100))				{					FSClose (sourceRef);					FSClose (destRef);					DisposHandle(tempBuff);					DisposHandle(hNew);							}				inOutCount = 32000L;				iErr = FSRead(sourceRef,&inOutCount,*tempBuff);				eErr = FSWrite(destRef,&inOutCount,*tempBuff);			}			FSClose (sourceRef);									progressDispos();						iErr = GetFPos(destRef,&filePos);			if (!theDivTime)				theDivTime = 1;			filePos /= (long)theDivTime;				}						LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	if (preserveRegions)	{		iRefNum = CurResFile();		refNum = FSpOpenResFile(&(reply.sfFile),fsWrPerm);		if (refNum == -1)		{			genError ("\pCould not open res file");			FSClose (destRef);			DisposHandle(tempBuff);			DisposHandle(hNew);			return false;		}		UseResFile(refNum);		((ddRLHeader *)(*regionsHandle))->NextID = regionCounter + 1;		SetHandleSize(regionsHandle,sizeof(ddRLHeader) + (sizeof(RegionRec) * (regionCounter)));		AddResource((Handle)regionsHandle,'ddRL',1000,"\pRegion List"); 		CloseResFile(refNum);		UseResFile(iRefNum);	}	if (insertMode == kInsertSilence)	{		iErr = SetEOF(destRef,zfilePos);	}	FSClose (destRef);	DisposHandle(tempBuff);	DisposHandle(hNew);	addFileToList(reply.sfFile);	return true;	}void topTailMany(void);void topTailMany(void){	Cell theCell;	short theindex;	OSErr	iErr;	FInfo fndrInfo;	short itemHit,iCtlVal,iCtlPart;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 theText;	long theTextConv;	Point localPt;	GrafPtr savePort;	short TTnoiseFloor;			GetPort(&savePort);	myDlg = GetNewDialog(1987,0L,(WindowPtr)-1);	if (!myDlg)	{		genError ("\pCouldn't get dialog");		return;	}	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,15);	GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetIText(iHndl,"\p15");	ShowWindow(myDlg);		itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 6:				GetMouse(&localPt);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				iCtlPart = TestControl((ControlHandle)iHndl,localPt);				switch (iCtlPart)				{					case inUpButton:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);						iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<0) ? 0 : iCtlVal;					break;										case inDownButton:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>100) ? 100 : iCtlVal;					break;										case inPageUp:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<0) ? 0 : iCtlVal;											break;										case inPageDown:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>100) ? 100 : iCtlVal;					break;										default:					break;				}				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				iCtlVal = GetCtlValue((ControlHandle)iHndl);				NumToString((long)iCtlVal,theText);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetIText(iHndl,theText);			break;						case 1:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);					GetIText(iHndl,theText);				StringToNum(theText,&theTextConv);				TTnoiseFloor = LoWord(theTextConv);			break;		}	}		DisposDialog(myDlg);	SetPort(savePort); 	if (itemHit == 2)		return;			SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	progressCreate("\pPerforming AutoCropª");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		autoCrop = true;		if (progressDisp((theindex * 100) / totfindcounter))		{			return;		}		iErr = FSpGetFInfo(&(*therealResults)[theindex],&fndrInfo);		if (!iErr && fndrInfo.fdType == 'Sd2f')			autoTopTailSDII((*therealResults)[theindex],TTnoiseFloor);				LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	progressDispos();	return;}Fixed getOtherRate(void){	DialogPtr dialog;	Str255 numStr;	short iType,type;	ControlHandle iHandle,hndl;	Rect iRect,box;	long longa,longb, result;		OSType myType;	short itemHit;	GrafPtr savePort;		GetPort(&savePort);	dialog = GetNewDialog(130, 0, (WindowPtr)(-1L) );	SetPort(dialog);	ModalDialog(0, &itemHit);	GetDItem(dialog,6,&type,(Handle *)&hndl,&box);	GetIText((Handle)hndl,numStr);	StringToNum (numStr,&longa);	GetDItem(dialog,5,&type,(Handle *)&hndl,&box);	GetIText((Handle)hndl,numStr);	StringToNum (numStr,&longb);	DisposDialog(dialog);	SetPort(savePort);	result = ((longa << 16) | longb);	return (Fixed)result;}				long calcCompositeSilence (long selectedTime, short numItems,long desiredLength){	long silenceT = 0;		if (numItems > 2)	{		silenceT = (desiredLength - selectedTime) / (numItems - 1);	}	else	{		silenceT = 0;	}		if (silenceT < 0)	{		genError("\pDesired time shorter than selection");	}		return silenceT;}void calculateSelectionTime (long * selectedTime, short * numItems, long * selectedBytes){	Cell theCell;	long totalBytesSoFar = 0,totalTimeSoFar = 0;	short itemsSoFar = 0;	 long theRate; 	 short theWordSize; 	 Boolean stereo; 	 long theBytes;	 long mSecsThisFile;	 short theindex;	 	SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));						if (!getSDIIData ((*therealResults)[theindex], &theRate, &theWordSize, &stereo, &theBytes))		{			itemsSoFar++;			totalBytesSoFar += theBytes;			mSecsThisFile = 0;			if (theRate)			{				mSecsThisFile = ((theBytes >> stereo >> (theWordSize - 1)) * 1000L) / theRate; 			}			totalTimeSoFar += mSecsThisFile;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		*selectedTime = totalTimeSoFar;	*numItems = itemsSoFar;	*selectedBytes = totalBytesSoFar;}long inquireLength (long selectedTime, short numItems){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 wantTime;	long theTime;	Str255 theSelected, theItems;			NumToString (selectedTime,theSelected);	NumToString ((long)numItems,theItems);		ParamText(theSelected,theItems,theSelected,0);		myDlg = GetNewDialog(9001,0L,(WindowPtr)-1);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	NumToString(selectedTime,wantTime);	SetIText(iHndl,wantTime);	ShowWindow(myDlg);	ModalDialog(xAlertFilter,&itemHit);		GetDItem(myDlg,6,&iType,&iHndl,&iRect);	GetIText(iHndl,wantTime);	StringToNum(wantTime,&theTime);		DisposDialog(myDlg);	return theTime;}