/****************************************************//*													*//*  "ReverServer" source code						*//*  from Ultimate Mac Programming, Volume I			*//*	Copyright 1994, Dave Mark and Donald Olson.		*//*	This code is free to one and all...				*//*													*/	/****************************************************/#include <Gestalt.h>#include <AppleEvents.h>#include "applescriptServer.h"void genError(Str255 theError);Boolean transferProTools(FSSpec sourceSpec, Boolean sendRegions);OSType writeResToPrefs(Handle rpHandle, OSType thePrefType, short prefID,  long handleSize);Boolean translateParentToChildFolder(FSSpec *mySpec);//#include "processAction.h"#include "prefs.h"extern newPrefsRec theNewPrefs;Boolean FSpCheckReferencec(FSSpec theSpec/*, Str255 volumeName*/);void setConvertDest(void);//#include "globals.h"#include "menus.h"extern FSSpec theConvertDestLoc;void gogetvolref(void);//#include  "v1Structs.h"//#include "TCStringFunctions.h"void Audition(FSSpec mySpec, short playFreq);void SDIIPlay(FSSpec mySpec, short playFreq);#define kBaseResID			128#define kErrorALRTid		128#define kAboutALRTid		129#define kServerDLOGid		130#define kVisible			true#define	kMoveToFront		(WindowPtr)-1L#define kSleep				60L#define kNilFilterProc		0L#define kGestaltMask		1L#define kOn					1#define kOff				0void scriptedAdd(FSSpec theFile);//extern SaveData theSaveSpec;#define mApple				kBaseResID#define iAbout				1#define mFile				kBaseResID+1#define iQuit				1#define iDisplayText		2#define kReverServerClass		'Tsrv'#define kReverServerSignature	'Tsrv'#define kSetTextID				'SETT'#define kReverseTextID			'RVRS'#define kGetTextID				'GETT'#define kNoTextString		"\p<No Text>"#define kMaxTextSize		255void makeStr255 (Str255 theString, StringPtr theStr);/*************//*  Globals  *//*************/Boolean		gHasText;DialogPtr	gServerDialog;/***************//*  Functions  *//***************//******************************** main *********/void	startAppleScript( void ){	AEInit();}/******************************** AEInit *********/void	AEInit( void ){	OSErr	err;	long	feature;		err = Gestalt( gestaltAppleEventsAttr, &feature );		if ( err != noErr )		genError( "\pError returned by Gestalt!" );			if ( !( feature & ( kGestaltMask << gestaltAppleEventsPresent ) ) )		genError( "\pThis configuration does not support Apple events..." );		AEInstallHandlers();}/******************************** AEInstallHandlers *********/	AEEventHandlerUPP	DoSendDataEventUPP,						DoGetDataEventUPP;void	AEInstallHandlers( void ){	OSErr				err;		DoSendDataEventUPP = NewAEEventHandlerProc( DoSendDataEvent );	err = AEInstallEventHandler( kReverServerClass, kSetTextID,				DoSendDataEventUPP, 0L, false );	//DisposeRoutineDescriptor( DoSendDataEventUPP );		if ( err != noErr )	{		genError( "\pError installing send data handler..." );	}				DoGetDataEventUPP = NewAEEventHandlerProc( DoGetDataEvent );	err = AEInstallEventHandler( kReverServerClass, kGetTextID,				DoGetDataEventUPP, 0L, false );//	DisposeRoutineDescriptor( DoGetDataEventUPP );		if ( err != noErr )		genError( "\pError installing get text handler..." );}/****************** DoSendDataEvent ***********************/extern ProcessSerialNumber PSNus;Boolean selectLast = false;pascal OSErr		DoSendDataEvent( AppleEvent *event, AppleEvent *reply, long refcon ){	DescType		actualtype;	Size			actualSize;	Str255			theText;	OSErr			err;	Byte realSize;	// The direct parameter of this event contains the text to set...	err = AEGetParamPtr( event, keyDirectObject, typeChar,			&actualtype, (Ptr)(&(theText[ 1 ])), kMaxTextSize, &actualSize );		realSize = 	(Byte)(actualSize & 0x000000FF);	theText[ 0 ] = realSize;	//	err = AEGetParamPtr( event, keyDirectObject, typeChar,//			&actualtype, (Ptr)(&(theText[ 1 ])), kMaxTextSize, &actualSize );//			//	theText[ 0 ] = actualSize;		if ( err != noErr )		return err;		DoSendData( theText );	return noErr;}/****************** DoSendData ***********************/Boolean addFileToList(FSSpec mySpec);void DoSendData( Str255  theText){	/* do something with this text */	FSSpec spec;	//genError(theText);	Str255 copyText;	OSErr iErr;	/*	if(EqualString(theText,"\pplay",false,false)) 	{		SysBeep(5);		return;	} */	/* so what's left */	makeStr255 (theText, copyText);	*copyText = 4;	if(EqualString(copyText,"\padd_",false,false)) 	{			gogetvolref();		BlockMove (theText + 5, copyText + 1, *theText - 4);		*copyText = *theText - 4;		iErr = FSMakeFSSpec(0,0,copyText,&spec);		if (iErr)		{			iErr = SetFrontProcess(&PSNus);			//FSpCheckReferencec(spec);			genError("\pThat volume is not online, or the file has moved. Please insert the appropriate disk and try again");				}		else		{		// add the file in copy text (full path) to the list 		// add the file in copy text (full path) to the list 			selectLast = true;			addFileToList(spec);		}		return;	}	makeStr255 (theText, copyText);	*copyText = 5;	if(EqualString(copyText,"\pplay_",false,false)) 	{		gogetvolref();		BlockMove (theText + 6, copyText + 1, *theText - 5);		*copyText = *theText - 5;		iErr = FSMakeFSSpec(0,0,copyText,&spec);		if (iErr)		{			iErr = SetFrontProcess(&PSNus);			//FSpCheckReferencec(spec);			genError("\pThat volume is not online, or the file has moved. Please insert the appropriate disk and try again");				}		else		{		// add the file in copy text (full path) to the list 			Audition(spec,0x3C);		}		return;	}		makeStr255 (theText, copyText);	*copyText = 5;	if(EqualString(copyText,"\pbitp_",false,false)) 	{			gogetvolref();		BlockMove (theText + 6, copyText + 1, *theText - 5);		*copyText = *theText - 5;		iErr = FSMakeFSSpec(0,0,copyText,&spec);		if (iErr)		{			iErr = SetFrontProcess(&PSNus);			//FSpCheckReferencec(spec);			genError("\pThat volume is not online, or the file has moved. Please insert the appropriate disk and try again");				}		else		{		// add the file in copy text (full path) to the list 		// add the file in copy text (full path) to the list 			transferProTools(spec,false);		}		return;	}		makeStr255 (theText, copyText);	*copyText = 6;	if(EqualString(copyText,"\ppaths_",false,false)) 	{			BlockMove (theText + 7, copyText + 1, *theText - 6);		*copyText = *theText - 6;		iErr = FSMakeFSSpec(0,0,copyText,&spec);		scriptedAdd(spec);		return;	}				makeStr255 (theText, copyText);	*copyText = 9;	if(EqualString(copyText,"\pbitpDest_",false,false)) 	{			BlockMove (theText + 10, copyText + 1, *theText - 6);		*copyText = *theText - 9;		iErr = FSMakeFSSpec(0,0,copyText,&theNewPrefs.theBITPTPrefs.destFolder);		if (!iErr)			theNewPrefs.theBITPTPrefs.destFolderValid = true;		else			theNewPrefs.theBITPTPrefs.destFolderValid = false;		return;	}	makeStr255 (theText, copyText);	*copyText = 9;	if(EqualString(copyText,"\pconvDest_",false,false)) 	{			BlockMove (theText + 10, copyText + 1, *theText - 6);		*copyText = *theText - 9;		iErr = FSMakeFSSpec(0,0,copyText,&theConvertDestLoc);		if (!iErr)		{	Handle theTempH;			OSErr	iErr;				translateParentToChildFolder(&theConvertDestLoc);				theTempH = NewHandle(70L);				BlockMove (&theConvertDestLoc, *theTempH , 70L);				writeResToPrefs(theTempH,'CoFS', 128,  70L);				DisposHandle (theTempH);		}	}	/*		if(EqualString(copyText,"\pplay_",false,false)) 	{	//	BlockMove (theText + 6, copyText + 1, *theText - 5);	//	*copyText = *theText - 5;		//play the file in copy text		return;	}*/}/****************** DoGetDataEvent ***********************/pascal OSErr		DoGetDataEvent( AppleEvent *event, AppleEvent *reply, long refcon ){	Str255			theText;	OSErr			err;	DescType		actualtype;	Size			actualSize;			err = AEGetParamPtr( event, keyDirectObject, typeChar,			&actualtype, (Ptr)(&(theText[ 1 ])), kMaxTextSize, &actualSize );				theText[ 0 ] = actualSize;			DoGetData( theText );		return AEPutParamPtr( reply, keyDirectObject, typeChar,			(Ptr)(&(theText[ 1 ])), theText[ 0 ] );}/****************** DoGetData ***********************/void DoGetData( Str255 string ){	/* "string" this is the request, reply to it */	genError (string);		/* manipulate the string, which will be returned to the sender */	makeStr255 ("\pHello There",string);}