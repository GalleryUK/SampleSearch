#include "SampleSearch.h"#include "Globals.h"  #include <Sound.h>#include <Resources.h>#include <SoundInput.h>#define kSoundComplete 1 #define kWaitIfFull TRUE	// wait for room in queue#define kSoundComplete  1	// last command in channel;  Application definedextern Boolean autoSustain;extern long dblBufferSize;Boolean gCallBackPerformed;  SndChannelPtr CreateSndChannel(Boolean Stereo);short isPressed(unsigned short k );OSErr InstallCallBack(SndChannelPtr);void SDIPlay(FSSpec mySpec, short playFreq);pascal void SampleCallBack(SndChannelPtr,SndCommand);void genErrorN(Str255 myText,long Errno);Boolean pleaseStop(void);void SDIPlay(FSSpec mySpec,short playFreq){	Handle	mySndH[2];	short	fRefNum;	short	thecurfile;	Str255	sampsize;	OSErr	iErr;	SndChannelPtr mySndChan;	// pointer to a sound channel	OSErr myErr;	Str255	samprate;	Boolean	whichBuff;	short keycounter;	Str255	chans;	char	mysampsize;	long	mysamprate,xx,inOutCount;	char	mychans;	Handle 	hRsrc;	long z;	Fixed	sampleRate;	short 	numChans;	short		numBits;	short	refNum,tempchans;	Boolean fileEnded,Endedfile;	SCStatus theStatus;	EventRecord theEvent;	short headerLen;	Ptr mySndPtr;	unsigned char km[16];			iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);		if (iErr!=0)		genErrorN("\pCould not open SDI file to audition",iErr);			iErr = SetFPos(refNum,1,1020L);	if (iErr!=0)		genErrorN("\pCould not position in file",iErr);	inOutCount = 4;		iErr = FSRead(refNum,&inOutCount,&mysamprate);	if (iErr!=0)		genErrorN("\pCould not sample rate from SDI file",iErr);	sampleRate = mysamprate;	sampleRate = (sampleRate * (Fixed)playFreq) /(Fixed)0x3C;	sampleRate = sampleRate * 65536L;			inOutCount = 2;		iErr = SetFPos(refNum,1,1028L);	if (iErr!=0)		genErrorN("\pCould not position in file",iErr);	watchcursor (true);		iErr = FSRead(refNum,&inOutCount,&tempchans);	if (iErr!=0)		genErrorN("\pCould not bit depth from SDI file",iErr);			numBits = tempchans;		numChans = 1;		mySndH[0] = Get1Resource('snd ',2000);	if (!mySndH[0])	{		mySndH[0] = NewHandle(dblBufferSize);		if (!mySndH[0])			genErrorN("\pError making new handle",0);				/*AddResource(mySndH[0],'snd ',2000,"\pmySound");		iErr = ResError();		if (iErr!=0)			genErrorN("\pError adding resource",iErr);*/	}		mySndH[1] = Get1Resource('snd ',2001);	if (!mySndH[1])	{		mySndH[1] = NewHandle(dblBufferSize);		if (!mySndH[1])			genErrorN("\pError making new handle",0);				/*AddResource(mySndH[1],'snd ',2001,"\pmySound");		iErr = ResError();		if (iErr!=0)			genErrorN("\pError adding resource",iErr);*/	}			iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,sampleRate,numBits,'NONE',0x3C,0,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 1",iErr);	iErr = SetFPos(refNum,1,1336L);	if (iErr!=0)		genErrorN("\pCould not position in file",iErr);	//MoveHHi(mySndH[0]);	//MoveHHi(mySndH[1]);		HLock(mySndH[0]);	mySndPtr = (*mySndH[0])+headerLen;	inOutCount = dblBufferSize - 800L;		iErr = FSRead(refNum,&inOutCount,mySndPtr);			/** fill buff a ready **/	if (iErr!=0 && iErr!=-39)		genErrorN("\pError reading data fork",iErr);	Endedfile = (iErr == eofErr);	iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,sampleRate,numBits,'NONE',0x3C,inOutCount,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 2",iErr);	HUnlock(mySndH[0]);	mySndChan = CreateSndChannel(numChans == 2);		/** SDI is mono **/	gCallBackPerformed = false;	whichBuff = 0;	fileEnded = false;	if ( mySndH[0] != nil ) 	{		do		{			Endedfile = fileEnded;			myErr = SndPlay (mySndChan, (SndListResource **)mySndH[whichBuff], true);			if ( myErr )				genErrorN("\pError playing sound",myErr);			iErr = InstallCallBack (mySndChan);			whichBuff = !whichBuff;			/** swap double buffers **/			HLock(mySndH[whichBuff]);			mySndPtr = (*mySndH[whichBuff])+headerLen;			inOutCount = dblBufferSize - 800L;			iErr = FSRead(refNum,&inOutCount,mySndPtr);			fileEnded = (iErr == eofErr);			if (iErr!=0 && iErr!=-39)				genErrorN("\pError reading data fork",iErr);			iErr = SetupSndHeader((SndListResource **)mySndH[whichBuff],numChans,sampleRate,numBits,'NONE',0x3C,inOutCount,&headerLen);			if (iErr!=0)				genErrorN("\pError setting up snd header 2",iErr);			HUnlock(mySndH[whichBuff]);				if (gCallBackPerformed)			{				if (pleaseStop())				{					Endedfile = true;									}			}			while (!gCallBackPerformed)			{				keycounter = 0;				GetKeys((long*)km);				for (z=0;z<=15;z++)					keycounter += (km[z] * ((z+1)*16));									if (pleaseStop())				{					Endedfile = true;					GetNextEvent(everyEvent,&theEvent);					gCallBackPerformed = true;					break;				}				}				gCallBackPerformed = false;		}while (!Endedfile);		iErr = SndDisposeChannel(mySndChan,false);		DisposPtr((Ptr)mySndChan);	}		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		/*	RmveResource(mySndH[0]);	myErr = ResError();	if (myErr!=0)		genErrorN("\pError removing resource 1",myErr);	RmveResource(mySndH[1]);	myErr = ResError();	if (myErr!=0)		genErrorN("\pError removing resource 2",myErr);*/		DisposPtr((Ptr)mySndChan);			DisposHandle(mySndH[0]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle 1",myErr);	DisposHandle(mySndH[1]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle",myErr);		/*	UpdateResFile(CurResFile());	myErr = ResError();	if (myErr!=0)		genErrorN("\pError updating res map",myErr);*/			watchcursor (false);	}SndCallBackUPP zSampleCallBack;SndChannelPtr CreateSndChannel(Boolean Stereo){	SndChannelPtr mySndChan;	// pointer to a sound channel	OSErr myErr;	//xSampleCallBack = NewSndCallBackProc (SampleCallBack);	mySndChan = (SndChannelPtr)NewPtrClear(sizeof(SndChannel));	if ( mySndChan != nil ) 	{		mySndChan->qLength = stdQLength;	 //128 sound commands		if (!Stereo)			myErr = SndNewChannel(&mySndChan, sampledSynth, initMono,zSampleCallBack);		else			myErr = SndNewChannel(&mySndChan, sampledSynth, initStereo,zSampleCallBack);	}	return mySndChan;			// return SndChannelPtr}OSErr InstallCallBack (SndChannelPtr mySndChan){	SndCommand mySndCmd;	// command record	mySndCmd.cmd = callBackCmd;	// install the callback command	mySndCmd.param1 = kSoundComplete;	// last command for this channel	mySndCmd.param2 = SetCurrentA5();	// pass the callback the A5	return SndDoCommand (mySndChan, &mySndCmd, kWaitIfFull);}extern ListHandle theList;pascal void SampleCallBack (SndChannelPtr theChan, SndCommand theCmd){	long myA5;	// variable to hold current value of A5			myA5 = SetA5(theCmd.param2);	// set my A5		gCallBackPerformed = TRUE;	// set a global flag		myA5 = SetA5(myA5);	// restore the current A5}