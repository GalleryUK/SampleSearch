#include  "furphul_premiere.h"#include <stdio.h>#include "SampleSearch.h"#include "Globals.h"PremierePlugInPtr		pPlugIns;CInfoPBRec		CPB;HFileInfo		*myCPB = (HFileInfo *)&CPB;ConnectionID		connID = 0;Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);Boolean checkFor68KPlug(FSSpec *theSpec);void setConvertDest(void);typedef struct processParams {	FSSpec theFile;	Boolean stereo;	short numBits;	long SelectStart;	long SelectEnd;	Fixed srate;	FSSpec newFile;} processParams;#include "newPremiere.h"extern FSSpec theApplSpec;extern short applVRefNum;extern long applDirID;short AFM_DoPremierePlugIn(short theItem, processParams theParms, Boolean queryDialog, Boolean processFile);processParams theParms;extern FSSpec theConvertDestLoc;char fName[256];void getConvertDest(void);extern Boolean plusMode;Boolean premiereProcessMany(short plugInNum);Boolean premiereProcessMany(short plugInNum){	Cell theCell;	short theindex;	Boolean memoryError = false;	long theRate; 	short theWordSize;	Boolean stereo;	long theBytes;	Boolean cancelled = false;			getConvertDest();		SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting Premiere plug in");		if (plusMode)	{		if ( LGetSelect( TRUE, &theCell, myList) ) 		{			theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));					if(getSDIIData ((*therealResults)[theindex],&theRate, &theWordSize,&stereo, &theBytes))			{				genError("\pCurrently only 16bit SDII files are supported");				writeLogS((unsigned char *)"Failed to Convert due to file type or parameters:");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;							}			else			{									if (theWordSize == 2)				{					writeLog((Ptr)(*therealResults)[theindex].name);					theParms.theFile = (*therealResults)[theindex];					theParms.stereo = stereo;					theParms.numBits = theWordSize * 8;					theParms.SelectStart = 0;					theParms.SelectEnd = theBytes / (theWordSize);					theParms.srate = (Fixed)theRate;					BlockMove (&theParms.theFile,&theParms.newFile,70L);										if ((theConvertDestLoc.vRefNum == theParms.theFile.vRefNum) && (theConvertDestLoc.parID == theParms.theFile.parID))					{						if (YesNo("\pSource and destination folders are the same, choose another ?"))						{							setConvertDest();							getConvertDest();						}					}					theParms.newFile.vRefNum = theConvertDestLoc.vRefNum;					theParms.newFile.parID = theConvertDestLoc.parID;										if (AFM_DoPremierePlugIn(plugInNum, theParms,true,true))					{						cancelled = true;					}										/*writeSDIIResources(theParms.newFile,theRate,stereo,theWordSize);					addFileToList(theParms.newFile);*/				}				else				{					genError("\pCurrently only 16bit SDII files are supported");					writeLogS((unsigned char *)"Failed to Convert due to 8 bit :");					writeLog((Ptr)(*therealResults)[theindex].name);						writeLogS((unsigned char *)"Continuing.....");					memoryError = true;				}			}		}		if (cancelled == false)		{			LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */			while ( LGetSelect( TRUE, &theCell, myList) ) 			{				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));							if(getSDIIData ((*therealResults)[theindex],&theRate, &theWordSize,&stereo, &theBytes))				{					writeLogS((unsigned char *)"Failed to Convert due to file type or parameters:");					writeLog((Ptr)(*therealResults)[theindex].name);						writeLogS((unsigned char *)"Continuing.....");					memoryError = true;				}				else				{					if (theWordSize == 2)					{						writeLog((Ptr)(*therealResults)[theindex].name);							theParms.theFile = (*therealResults)[theindex];						theParms.stereo = stereo;						theParms.numBits = theWordSize*8;						theParms.SelectStart = 0;						theParms.SelectEnd = theBytes / (theWordSize);						theParms.srate = (Fixed)theRate;						BlockMove (&theParms.theFile,&theParms.newFile,70L);								if ((theConvertDestLoc.vRefNum == theParms.theFile.vRefNum) && (theConvertDestLoc.parID == theParms.theFile.parID))						{							if (YesNo("\pSource and destination folders are the same, choose another ?"))							{								setConvertDest();								getConvertDest();							}						}						theParms.newFile.vRefNum = theConvertDestLoc.vRefNum;						theParms.newFile.parID = theConvertDestLoc.parID;												if (AFM_DoPremierePlugIn(plugInNum, theParms,false,true))						{							cancelled = true;						}						/*writeSDIIResources(theParms.newFile,theRate,stereo,theWordSize);						addFileToList(theParms.newFile);*/					}					else					{						writeLogS((unsigned char *)"Failed to Convert due to 8 bit :");						writeLog((Ptr)(*therealResults)[theindex].name);							writeLogS((unsigned char *)"Continuing.....");						memoryError = true;					}				 			}				LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */			}		}	}	else /* non plus mode doesnt offer batch processing */	{		if ( LGetSelect( TRUE, &theCell, myList) ) 		{			theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));					if(getSDIIData ((*therealResults)[theindex],&theRate, &theWordSize,&stereo, &theBytes))			{				genError("\pCurrently only 16bit SDII files are supported");				writeLogS((unsigned char *)"Failed to Convert due to file type or parameters:");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;							}			else			{									if (theWordSize == 2)				{					writeLog((Ptr)(*therealResults)[theindex].name);					theParms.theFile = (*therealResults)[theindex];					theParms.stereo = stereo;					theParms.numBits = theWordSize * 8;					theParms.SelectStart = 0;					theParms.SelectEnd = theBytes / (theWordSize);					theParms.srate = (Fixed)theRate;					BlockMove (&theParms.theFile,&theParms.newFile,70L);										if ((theConvertDestLoc.vRefNum == theParms.theFile.vRefNum) && (theConvertDestLoc.parID == theParms.theFile.parID))					{						if (YesNo("\pSource and destination folders are the same, choose another ?"))						{							setConvertDest();							getConvertDest();						}					}					theParms.newFile.vRefNum = theConvertDestLoc.vRefNum;					theParms.newFile.parID = theConvertDestLoc.parID;										if (AFM_DoPremierePlugIn(plugInNum, theParms,true,true))					{						cancelled = true;					}										/*writeSDIIResources(theParms.newFile,theRate,stereo,theWordSize);					addFileToList(theParms.newFile);*/				}				else				{					genError("\pCurrently only 16bit SDII files are supported");					writeLogS((unsigned char *)"Failed to Convert due to 8 bit :");					writeLog((Ptr)(*therealResults)[theindex].name);						writeLogS((unsigned char *)"Continuing.....");					memoryError = true;				}			}		}	}			if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}void genErrorN(Str255 myText,long Errno);AFilterCallBackUPP		fetchRoutine;Boolean IN_PREMIERE;#define MAX_PREMIERE_PLUGINS 60#define CHUNK_PROCESSING_TIME		0.5short totalPremierePlugIns = 0;pascal short PremierePlugInFetchRoutine(long sample, long count, Ptr buffer, Handle privateData);pascal short PremierePlugInFetchRoutine(long sample, long count, Ptr buffer, Handle privateData){	short		bps=16; 	long		start, end, amtReq, limit, i; 	Ptr		output = 0; 	start = sample/bps;	end = (start+count)/bps;	limit = count/bps;		for (i=start; i < end; i+=amtReq)	{		amtReq=limit;		if ((i+amtReq)>end)			amtReq = (end-i);						//amtReq = AAM_GetSample(theParms,theParms.stereo+1, amtReq, &output);		//amtReq = AAM_GetSample(processingWin, i, processingWin->aam->numChannels, processingWin->aam, AFMBufferLeftJustify, -1L, -1L, amtReq, &output, NULL,FALSE);		/* a routine to get more samples from the file */				if (!theParms.stereo)			BlockMove(output,&(((short *)buffer)[i-start]),amtReq*2L);		else			BlockMove(output,&(((long *)buffer)[i-start]),amtReq*4L);	}	return 0;}void AFM_MakePremiereMenus(void);void AFM_MakePremiereMenus(void){		short		foundVRefNum;	long		foundDirID;	short		iErr;	long		dirID;	Str255		volName="\p";	Ptr			myPtr;	short		i;		// allocate a routine descriptor for the callback if it is powerpc	fetchRoutine = NewFilterCallbackUPP(PremierePlugInFetchRoutine);		// allocate space for the premiere plug-ins	 	myPtr = NewPtrClear(sizeof(PremierePlugIn)*MAX_PREMIERE_PLUGINS);	if (myPtr==NULL)	{		genErrorN("\pPeak was unable to allocate enough memory to support Premiereª plug-ins.  Try increasing application size from the Finder and restarting Peak.",FALSE);		return;	}		pPlugIns = (PremierePlugInPtr)myPtr;		for (i=0;i<MAX_PREMIERE_PLUGINS;++i)	{		pPlugIns[i].aRec = (AudioFilter)NewHandle(sizeof(AudioRecord));	}		IN_PREMIERE=FALSE;		HSetVol(volName,theApplSpec.vRefNum,theApplSpec.parID);		sprintf(fName,"SampleSearchª Plug-Ins");	c2pstr(fName);	myCPB->ioNamePtr = (unsigned char *)fName;	myCPB->ioVRefNum = 0;		//theVRefNum = vRefNum;	AFM_FindPremierePlugIns(applDirID);	// start at the root}void AFM_MakePremiereMenus(void);void AFM_ClosePremierePlugIns(void);void AFM_ClosePremierePlugIns(void){	short		i;	for (i=0;i<totalPremierePlugIns;++i)	{	}}void AFM_FindPremierePlugIns(long dirIDToSearch){	short 				index = 1;	/* for ioFDirIndex */	OSErr 				err;	short				theParID;	short				fRefNum;	StandardFileReply	reply;	Point				where = {-1,-1};	Handle				hRsrc;	FInfo				fndrInfo;	long				Count;	short				numEntries, m;				do 	{		myCPB->ioFDirIndex = index;					myCPB->ioDirID = dirIDToSearch;		err = PBGetCatInfo((CInfoPBPtr)myCPB, false);		BlockMove((CInfoPBPtr)myCPB->ioNamePtr,fName,64L);				if(err == noErr) 		{			p2cstr((StringPtr)fName);			if(((myCPB->ioFlAttrib >> 4) & 0x01) == 1) 			{				IN_PREMIERE=TRUE;				theParID=myCPB->ioDirID;				AFM_FindPremierePlugIns(myCPB->ioDirID);							} 			else			{				/* found a file */				if (IN_PREMIERE)				{					//AboutMessage(fName);  /* show it is loading that plug in on startup */					c2pstr(fName);										FSMakeFSSpec(theApplSpec.vRefNum,dirIDToSearch,(StringPtr)fName,&(pPlugIns[totalPremierePlugIns].filespec));					FSpGetFInfo(&pPlugIns[totalPremierePlugIns].filespec,&fndrInfo);										if ((fndrInfo.fdType == 'AFlt') && (fndrInfo.fdCreator == 'PrMr')) 					{			#ifdef powerc						(*pPlugIns[totalPremierePlugIns].aRec)->specsHandle = nil;						++totalPremierePlugIns;			#else						if (checkFor68KPlug(&pPlugIns[totalPremierePlugIns].filespec))						{							(*pPlugIns[totalPremierePlugIns].aRec)->specsHandle = nil;							++totalPremierePlugIns;						}			#endif					}				}						}			index += 1;		}	} while(err == noErr);}void xAFM_FindPremierePlugIns(long dirIDToSearch);void xAFM_FindPremierePlugIns(long dirIDToSearch){	short 				index = 1;	/* for ioFDirIndex */	OSErr 				err;	short				theParID;	short				fRefNum;	StandardFileReply	reply;	Point				where = {-1,-1};	short				resID, iRefNum;	Handle				hRsrc;	FInfo				fndrInfo;	long				Count;	short				numEntries, m;		do 	{		myCPB->ioFDirIndex = index;					myCPB->ioDirID = dirIDToSearch;		err = PBGetCatInfo((CInfoPBPtr)myCPB, false);			if(err == noErr) 		{			p2cstr((StringPtr)fName);			if(((myCPB->ioFlAttrib >> 4) & 0x01) == 1) 			{				/* found a directory */				if (strcmp(fName,"SampleSearchª Plug-Ins")==0)				{					IN_PREMIERE=TRUE;					theParID=myCPB->ioDirID;					AFM_FindPremierePlugIns(myCPB->ioDirID);				}				IN_PREMIERE=FALSE;				err = 0;			} 			else			{				/* found a file */				if (IN_PREMIERE)				{					//AboutMessage(fName);  /* show it is loading that plug in on startup */					c2pstr(fName);										FSMakeFSSpec(theApplSpec.vRefNum,dirIDToSearch,(StringPtr)fName,&(pPlugIns[totalPremierePlugIns].filespec));					FSpGetFInfo(&pPlugIns[totalPremierePlugIns].filespec,&fndrInfo);										if ((fndrInfo.fdType == 'AFlt') && (fndrInfo.fdCreator == 'PrMr')) 					{						//AppendMenu(myMenus[premiereM],(StringPtr)fName);						(*pPlugIns[totalPremierePlugIns].aRec)->specsHandle = nil;						++totalPremierePlugIns;					}				}						}			index += 1;		}	} while(err == noErr);}short AFM_DoPremierePlugIn(short theItem, processParams theParms, Boolean queryDialog, Boolean processFile){	 Ptr					inBuff, outBuff;	 long					bps, outBufferSize;	 Ptr					output;	 long					i, amtReq, start, end, limit;	 Handle					destHand = NULL;	 float					selectionLength;	 float					previewLength;	 short					settingsResult = noErr;	 Boolean				done=FALSE;	 short					outID;	 short					iRefNum, resID;	 Handle					pHandle, dumbHandle;	 char					PlugInName[256], text[256];	 long					bufferSize;	 Boolean				PowerPCResource, alreadyClosed=FALSE;	 long					loc;	 PremiereEntryProcPtr	entry;	 OSErr					err;	 short					numTries;	OSErr	iErr;	short sourceRefNum,destRefNum;	long inOutCount;	GrafPtr savePort;	Handle specSaver;	Boolean powerPCPlug = false;	GetPort (&savePort);	 	dumbHandle = NewHandle(1L);	/* make a global pointing to the audio window being processed in	case the callback fetch routine is called.*/		/* bytes per sample */		bps = 2L * (theParms.stereo +1);		//P2Cstrcpy(PlugInName, pPlugIns[theItem-1].filespec.name);		BlockMove(pPlugIns[theItem-1].filespec.name + 1,PlugInName + 1,*pPlugIns[theItem-1].filespec.name + 1);	P2CStr((unsigned char *)PlugInName);		selectionLength = (float)((theParms.SelectEnd-theParms.SelectStart) / (double)theParms.srate);		previewLength = 3.0;	if (selectionLength < previewLength)		previewLength = selectionLength;		numTries = 0;	/* try to get some memory to do the preview.. */	trysmaller:	bufferSize = (long)(((long)theParms.srate * previewLength * bps ));	/* we need three seconds worth of audio... load it up from the insertion point. */	inBuff = NewPtrClear(bufferSize);	if (inBuff == NULL)	{		if (numTries==2)		{			genErrorN("\pSampleSearchª does not have enough memory left to support Premiereª Plug-In Previews.  Try allocating more memory to SampleSearchª from the Finder.", FALSE);			SetPort (savePort);			return;		}		else		{			previewLength /= 2.0;			++numTries;			goto trysmaller;		}	}	/* allocate the output buffer */	outBuff = NewPtrClear(bufferSize);	if (outBuff == NULL)	{		DisposePtr(inBuff);		genErrorN("\pSampleSearchª does not have enough memory left to support Premiereª Plug-In Previews.  Try allocating more memory to SampleSearchª from the Finder.", FALSE);		SetPort (savePort);		return;	}	start = theParms.SelectStart;	end = theParms.SelectStart+(previewLength*theParms.srate);	iErr = FSpOpenDF(&theParms.theFile,fsRdPerm,&sourceRefNum);	if (iErr)	{		genError("\pCouldnt open file");			}		if (theParms.stereo==1)	{		for (i=start; i < end; i+=amtReq)		{			amtReq=(end-i);									inOutCount = amtReq  * (theParms.numBits >> 3);			iErr = FSRead(sourceRefNum,&inOutCount,inBuff);			if (iErr)			{				genError("\pCouldnt read");			}		}	}	else	{		for (i=start; i < end; i+=amtReq)		{			amtReq=(end-i);						inOutCount = amtReq  * (theParms.stereo + 1) * (theParms.numBits >> 3);			iErr = FSRead(sourceRefNum,&inOutCount,inBuff);			if (iErr)			{				genError("\pCouldnt read");			}		}	}	/* fill out the initial aRec that the plug-in will understand. */	(*pPlugIns[theItem-1].aRec)->source = inBuff;	(*pPlugIns[theItem-1].aRec)->destination = outBuff;	(*pPlugIns[theItem-1].aRec)->samplenum = 0L;	(*pPlugIns[theItem-1].aRec)->samplecount = ((long)theParms.srate * previewLength * bps);	(*pPlugIns[theItem-1].aRec)->previewing = 0;	(*pPlugIns[theItem-1].aRec)->privateData = dumbHandle;	(*pPlugIns[theItem-1].aRec)->callBack = fetchRoutine;	(*pPlugIns[theItem-1].aRec)->totalsamples = (theParms.SelectEnd - theParms.SelectStart)*bps;		if (theParms.numBits == 16)	{		(*pPlugIns[theItem-1].aRec)->flags =  ga16Bit;	}		if (theParms.stereo)	{		(*pPlugIns[theItem-1].aRec)->flags |= gaStereo;	}		(*pPlugIns[theItem-1].aRec)->rate = theParms.srate;	(*pPlugIns[theItem-1].aRec)->bottleNecks = nil;	(*pPlugIns[theItem-1].aRec)->version = 0;	(*pPlugIns[theItem-1].aRec)->extraFlags = 0;	(*pPlugIns[theItem-1].aRec)->fps = 30;	/* open it up... */	iRefNum = CurResFile();	resID = FSpOpenResFile(&pPlugIns[theItem-1].filespec,fsRdWrShPerm);	UseResFile(resID);#ifdef powerc	pHandle = 0;	pHandle = Get1Resource('AFlT',1000);	if (pHandle != NULL)	{		OSErr err;		Str255 errorName;//		DetachResource(pHandle);		HLockHi(pHandle);		powerPCPlug = TRUE;		connID = 0;				err=GetMemFragment(*pHandle, GetHandleSize(pHandle), "\pPremiere Plug-In",		kLoadNewCopy, &connID, (Ptr *)&(pPlugIns[theItem-1].pEntry), errorName);				/*	FileError(err, "\pCalling GetMemFragment for PPC Plug-In.");*/			if (err)		{			genErrorN ("\pCould not get memory fragment",err);			pPlugIns[theItem-1].pEntry = 0;		}			}	else	{		pHandle = Get1Resource('AFlt',1000);//		DetachResource(pHandle);		HLockHi(pHandle);		powerPCPlug = false;	}#else	pHandle = Get1Resource('AFlt',1000);//	DetachResource(pHandle);	HLockHi(pHandle);	powerPCPlug = false;#endif	if (pHandle==NULL)	{		goto abortpremiereplugin;	}if (!powerPCPlug){	pPlugIns[theItem-1].pEntry = NewPremiereEntryProc(*pHandle, 0);}	//	settingsResult = 1;	if (queryDialog)	{		if (pPlugIns[theItem-1].pEntry != NULL)		{		#ifdef powerc			if (powerPCPlug)			{				settingsResult = (*(PremiereEntryProcPtr)(pPlugIns[theItem-1].pEntry))(fsSetup, pPlugIns[theItem-1].aRec);					//FlashMenuBar(0)	;					}		#endif			if (!powerPCPlug)			{				settingsResult = CallPremiereEntryProc( pPlugIns[theItem-1].pEntry,fsSetup, pPlugIns[theItem-1].aRec);  /* call plug-in panel */			}			}		HLock( (*pPlugIns[theItem-1].aRec)->specsHandle);	}	//HLock ((*pPlugIns[totalPremierePlugIns].aRec)->specsHandle);/*	if (!alreadyClosed)	{		 #ifdef powerc		 {		 	if (powerPCPlug && connID) 				{					if (connID)						{						OSErr iErr;						iErr = CloseConnection(&connID);						if (iErr)						{							genError("\pCould not close connection to plug in");						}						alreadyClosed = true;					}				}		 }		 #endif		if (pHandle!=NULL)		{			HUnlock(pHandle);			DisposeHandle((Handle)pHandle);		}		CloseResFile(resID); 		UseResFile(iRefNum); 	}	*/	#ifdef powerc#else	if (pHandle!=NULL)	{		HUnlock(pHandle);		DisposeHandle((Handle)pHandle);	}#endifCloseResFile(resID); UseResFile(iRefNum);     /******* this is the actual processing bit ********/      	if (processFile)   	{ 				if (settingsResult==noErr || !queryDialog) /* process the selection.. user said go for it! */		{					iErr = FSpCreate(&theParms.newFile,'Sd2a','Sd2f',0);			if (iErr)			{				/* file exists */				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theParms.newFile);					iErr = FSpCreate(&theParms.newFile,'Sd2a','Sd2f',0);				}				else				{						alreadyClosed=TRUE;						goto abortpremiereplugin;				}						}						iErr = iErr = FSpOpenDF(&theParms.newFile,fsWrPerm,&destRefNum);			if (iErr)			{				genError("\pCant open dest file");				alreadyClosed=TRUE;				goto abortpremiereplugin;			}						iErr = SetEOF(destRefNum,theParms.SelectEnd - theParms.SelectStart * (theParms.numBits >> 3) * (theParms.stereo * 2));			if (iErr)			{				FSClose (destRefNum);				iErr = FSpDelete(&theParms.newFile);				genErrorN("\pPremiereª Plug-In could not complete because there is not enough disk space in your destination volume",FALSE);				alreadyClosed=TRUE;				goto abortpremiereplugin;			}				/* use a smaller processing chunk size */			if (previewLength>CHUNK_PROCESSING_TIME)			{				previewLength=CHUNK_PROCESSING_TIME;			}						limit = previewLength*theParms.srate;			end = theParms.SelectEnd;			start = theParms.SelectStart;			done = FALSE;						/* put up a progress bar... */						sprintf(text, "%s Premiereª Plug-In...", PlugInName);			c2pstr(text);						progressCreate ((StringPtr)text);					/*	APM_ProgressInitiate(0L, (long)(end-start), 10L, (StringPtr)text); */						/* get the plug-in again */			iRefNum = CurResFile();			resID = FSpOpenResFile(&pPlugIns[theItem-1].filespec,fsRdWrShPerm);			UseResFile(resID);#ifdef powerc#else			pHandle=NULL;#endif			alreadyClosed = false;/* heeeeeeere */		/*		pHandle = Get1Resource('AFlt',1000);				PowerPCResource = FALSE;*/#ifdef powerc	if (!connID)		{		pHandle = 0;		pHandle = Get1Resource('AFlT',1000);		if (pHandle != NULL)		{			OSErr err;			Str255 errorName;	//		DetachResource(pHandle);			HLockHi(pHandle);			powerPCPlug = TRUE;			connID = 0;						err=GetMemFragment(*pHandle, GetHandleSize(pHandle), "\pPremiere Plug-In",			kLoadNewCopy, &connID, (Ptr *)&(pPlugIns[theItem-1].pEntry), errorName);						/*	FileError(err, "\pCalling GetMemFragment for PPC Plug-In.");*/					if (err)			{				genErrorN ("\pCould not get memory fragment",err);				pPlugIns[theItem-1].pEntry = 0;			}					}		else		{			pHandle = Get1Resource('AFlt',1000);	//		DetachResource(pHandle);			HLockHi(pHandle);			powerPCPlug = false;		}	}#else	pHandle = Get1Resource('AFlt',1000);//	DetachResource(pHandle);	HLockHi(pHandle);	powerPCPlug = false;#endif						if (pHandle==NULL)			{								iErr = FSpDelete(&theParms.newFile);				progressDispos();				goto abortpremiereplugin;			}					//	HLock(pHandle); 						loc=0L;					bufferSize = (long)(((long)theParms.srate * previewLength * bps ));				/* here's the main processing loop where we read in some samples, pass it it, and write to the output.*/						iErr = FSpOpenDF(&theParms.theFile,fsRdPerm,&sourceRefNum);			settingsResult = 1;				pPlugIns[theItem-1].pEntry = NULL;				if (!powerPCPlug)				{					pPlugIns[theItem-1].pEntry = NewPremiereEntryProc(*pHandle, 0);				}			do 			{				/* load in some samples, at least the preview buffer size worth. */				if ((start+limit)>=end)				{					limit=(end-start);					done=TRUE;				}					for (i=start; i < (start+limit); i+=amtReq)				{					amtReq=((start+limit)-i);															inOutCount = amtReq  * (theParms.stereo + 1) * (theParms.numBits >> 3);					iErr = FSRead(sourceRefNum,&inOutCount,inBuff);				/*	if (theParms.stereo)					{						BlockMove(output,&(((short *)inBuff)[i-start]),amtReq*2L);					}					else					{						BlockMove(output,&(((long *)inBuff)[i-start]),amtReq*4L);					}*/				}							/*	if (progressDisp(50))				{					goto abortpremiereplugin;				}*/									/* hand  it to the plug-in  */				(*pPlugIns[theItem-1].aRec)->source = inBuff;				(*pPlugIns[theItem-1].aRec)->destination = outBuff;				(*pPlugIns[theItem-1].aRec)->samplenum = (loc)*bps;				(*pPlugIns[theItem-1].aRec)->samplecount = bufferSize;				(*pPlugIns[theItem-1].aRec)->previewing = 0;				(*pPlugIns[theItem-1].aRec)->privateData = dumbHandle;				(*pPlugIns[theItem-1].aRec)->callBack = fetchRoutine;				(*pPlugIns[theItem-1].aRec)->totalsamples = (theParms.SelectEnd - theParms.SelectStart) *bps;								if (theParms.numBits == 16)				{					(*pPlugIns[theItem-1].aRec)->flags =  ga16Bit;				}									if (theParms.stereo)				{					(*pPlugIns[theItem-1].aRec)->flags |= gaStereo;				}								(*pPlugIns[theItem-1].aRec)->rate = theParms.srate;				(*pPlugIns[theItem-1].aRec)->bottleNecks = nil;				(*pPlugIns[theItem-1].aRec)->version = 0;				(*pPlugIns[theItem-1].aRec)->extraFlags = 0;				(*pPlugIns[theItem-1].aRec)->fps = 30;															HUnlock( (*pPlugIns[theItem-1].aRec)->specsHandle);				if (pPlugIns[theItem-1].pEntry != NULL)				{				#ifdef powerc					if (powerPCPlug)					{						settingsResult = (*(PremiereEntryProcPtr)(pPlugIns[theItem-1].pEntry))(fsExecute, pPlugIns[theItem-1].aRec);							//FlashMenuBar(0)	;							}				#endif					if (!powerPCPlug)					{						settingsResult = CallPremiereEntryProc( pPlugIns[theItem-1].pEntry, fsExecute, pPlugIns[theItem-1].aRec);					}					}				HLock( (*pPlugIns[theItem-1].aRec)->specsHandle);			 				/* write out the results */								/*inOutCount = bufferSize;*/								iErr = FSWrite(destRefNum,&inOutCount,outBuff);												start+=limit;				loc+=limit;								} while (!done && !settingsResult);					progressDispos();					DisposePtr(inBuff);			DisposePtr(outBuff);			inBuff=NULL;outBuff=NULL;					}	}	/************************************************************************************************************************/	abortpremiereplugin:	HUnlock( (*pPlugIns[theItem-1].aRec)->specsHandle);	/* close it up. *///	CloseResFile(resID); /* close up the resource*///	UseResFile(iRefNum); /*use the original resource...*/	FSClose (sourceRefNum);	FSClose (destRefNum);		if (settingsResult==noErr)	{		writeSDIIResources(theParms.newFile,theParms.srate,theParms.stereo,theParms.numBits >> 3);		addFileToList(theParms.newFile);	}	if (!alreadyClosed)	{		 #ifdef powerc		 {		 	if (powerPCPlug && connID) /* release code fragment */				{					if (connID)						{						OSErr iErr;						iErr = CloseConnection(&connID);						if (iErr)						{							genError("\pCould not close connection to plug in");						}						alreadyClosed = true;					}				}		 }		 #endif		if (pHandle!=NULL)		{			HUnlock(pHandle);			DisposeHandle((Handle)pHandle);		}		CloseResFile(resID); 		UseResFile(iRefNum); 	}							if (inBuff!=NULL)	{		DisposePtr(inBuff);	}	if (outBuff!=NULL)	{		DisposePtr(outBuff);	}			DisposeHandle(dumbHandle);	SetPort (savePort);	return settingsResult;}Boolean checkFor68KPlug(FSSpec *theSpec){	short iRefNum, rfRefNum;	short numRes;	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(theSpec,fsRdPerm);	if (rfRefNum == -1)		return false;	UseResFile (rfRefNum);	numRes = Count1Resources('AFlt');	CloseResFile (rfRefNum);	UseResFile (iRefNum);	return numRes;}