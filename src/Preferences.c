#include "SampleSearch.h"#include "Globals.h"#define prefsVersion 41#include <Lists.h>/*#include <Folders.h>#include <stdio.h>#include <Dialogs.h>#include <Picker.h>*/long normBuffer;long dblBufferSize;#include "prefs.h"newPrefsRec theNewPrefs;pascal Boolean myPTXFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);pascal void PTXUserProc(WindowPtr theDialog, short theItem);Boolean isPTExcludedDrive (short vRefNum);OSErr addPTExcludedDrive (Str63 theName);OSErr removePTExcludedDrive (Str63 theName);typedef struct listFontRec {Str255 fontName;short fontSize;} listFontRec, *listFontRecPtr;//pascal OSErr	GetStdFilterProc(ProcPtr *theProc) = {0x303C, 0x0203,0xAA68};Boolean VgetvolName(short theVRefNum, StringPtr myString);pascal void MyColorProc(WindowPtr theDlg,short theItem);Boolean stickyInfo;listFontRec  theFontRec;void PTExcludeList(void);#define handleTooSmall 1#define cantOpenResFile 2#define resourceNotFound 3FSSpec theSSPrefSpec;//Boolean checkoutGearbox(void);/*pascal OSErr SetDialogCancelItem (DialogPtr theDialog,		short newItem) = {0x303C,0x0305,0xAA68};pascal OSErr SetDialogTrackCursor (DialogPtr theDialog,	Boolean tracks) = {0x303C,0x0306,0xAA68};*//*pascal OSErr GetStdFilterProc(ProcPtr *theProc) = {0x303C, 0x0203, 0xAA68};*//*pascal OSErr SetDialogDefaultItem (DialogPtr theDialog,		short newItem) = {0x303C,0x0304,0xAA68};*/pascal Boolean myXFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);OSErr readResFromPrefs(Handle rpHandle, OSType thePrefType, short prefID, long handleSize);OSType writeResToPrefs(Handle rpHandle, OSType thePrefType, short prefID,  long handleSize);void ExcludeList(void);void RetrievePrefs(void);Point	Xp;Boolean 	firstInvoke;ListHandle theXList;extern Boolean MakeCompositeAE;FILE *Xstream;extern Boolean AutoLaunchDivert;extern Boolean ExcludeDrives;extern Boolean PreservePopups;Boolean checkListfor(Str255 nameString);pascal void XUserProc(WindowPtr theDialog, short theItem);pascal Boolean myXDlgFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit);void QueryDrive(Str255	myString);void ExcludeList(void){	short	dataLen;	Str255 NewNameString,theTempVol;			OSErr	iErr;	short z, excCount = 0;	Handle	hRsrc;	Str255 myString;	Rect	itRect;	short itemHit = 0;				DialogPtr	myDlg;				Handle	iHndl;					Rect	iRect;					short	iType;					ListHandle	theExcList;	ModalFilterUPP xmyXFilter = NewModalFilterProc(myXFilter);	Point	theXPoint;	short iInsRow;	short menuVRefs[99];	short menuitem = 1;	Rect	xrView,rDataBnds;	Cell XlCellCoords, temporCell;		hRsrc = (Handle)NewMenu(1099,"\pDrives");	for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{		makeStr255 (volName[z], theTempVol);		doTheSlashAnalysis(theTempVol);		if (*theTempVol)		{			menuVRefs[menuitem] = volumes[z];			menuitem++;			AppendMenu((MenuHandle)hRsrc,theTempVol);			iErr = ResError();		}	}		InsertMenu((MenuHandle)hRsrc,-1);	SetResAttrs(hRsrc,16);	myDlg = GetNewDialog(11010,nil,(WindowPtr)-1);		SetPort (myDlg);	/*color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);*/		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,6,&iType,&iHndl,&iRect);	HiliteControl((ControlHandle)iHndl,255);			GetDItem(myDlg,7,&iType,&iHndl,&iRect);		GetDItem(myDlg,4,&iType,&iHndl,&itRect);	SetDItem(myDlg,4,iType,(Handle)NewUserItemProc(XUserProc),&itRect);		ShowWindow(myDlg);	firstInvoke = true;		do	{		ModalDialog(xmyXFilter,&itemHit);			switch (itemHit)		{			case 1:				iErr = remove("SampleSearch Excluded Drives");				Xstream = fopen("SampleSearch Excluded Drives","w");				if (!Xstream)					genError("\pProblem opening Exclude file");				if (Xstream)				{					for (z=0;z<(*theXList)->dataBounds.bottom;z++)					{						SetPt(&temporCell,0,z);						//PtoCstr(NewNameString);						dataLen = 254;						LGetCell(NewNameString,&dataLen,temporCell,theXList);						*(NewNameString+dataLen) = 0;						iErr = fputs((Ptr)NewNameString,Xstream);						fprintf(Xstream,"\n");						excCount++;					}					iErr = fclose(Xstream);					if (!excCount)							iErr = remove("SampleSearch Excluded Drives");				}				SetResAttrs(hRsrc,0);				ReleaseResource(hRsrc);				LDispose(theXList);				DisposDialog(myDlg);				return;			break;						case 2:				SetResAttrs(hRsrc,0);				SetResAttrs(hRsrc,0);				ReleaseResource(hRsrc);				LDispose(theXList);				DisposDialog(myDlg);				return;			break;						case 4:				/*XlCellCoords = LLastClick(theXList);				if(LGetSelect(0,&XlCellCoords,theXList)) 				{					GetDItem(myDlg,6,&iType,&iHndl,&iRect);					HiliteControl((ControlHandle)iHndl,0);				}*/			break;						case 5:				//	GetDItem(myDlg,8,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/				//	iCtlValue = GetCtlValue((ControlHandle)iHndl);				//	BlockMove (volName[iCtlValue],myString,28L);						GetDItem(myDlg,8,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/					iCtlValue = GetCtlValue((ControlHandle)iHndl);						GetItem((MenuHandle)hRsrc,iCtlValue,myString);				if (!checkListfor(myString))					{						iInsRow = LAddRow(1,99,theXList);						SetPt(&temporCell,0,iInsRow);						dataLen = *myString+1;						PtoCstr(myString);						LSetCell(myString,dataLen,temporCell,theXList);					}					itemHit = 0;			break;						case 6:				SetPt(&XlCellCoords,0,0);				if(LGetSelect(true,&XlCellCoords,theXList)) 				{					LDelRow(1,XlCellCoords.v,theXList);					GetDItem(myDlg,6,&iType,&iHndl,&iRect);					HiliteControl((ControlHandle)iHndl,255);				}							break;					default:			break;		}	} while (itemHit !=1 && itemHit !=2);	LDispose(theXList);	DisposDialog(myDlg);	return;}short openPrefFile(void){	short	prefRefNum;	long	prefDirID;	FSSpec	mySpec;	short refNum;	OSErr	iErr;	OSType	theDefault= 'CRAP';	long	inOutCount;	short	z;	short zeroer = 0;		iErr = FindFolder(-1,'pref',kDontCreateFolder,&prefRefNum,&prefDirID);	if (iErr!=0)	{		genError("\pCan't find Preferences folder");		return 0;	}	iErr = FSMakeFSSpec(prefRefNum,prefDirID,"\pSampleSearchª Prefs",&mySpec);	if (iErr!=0 && iErr!=-43  )	{		genError("\pCan't make FSSpec for prefs");		return 0;	}	BlockMove (&mySpec,&theSSPrefSpec,70L);	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0 && iErr!=-43)	{		genError("\pCan't open old Preferences file");		return 0;	}		if (iErr == -43)	/** does not exist **/	{		iErr = FSpCreate(&mySpec,'MgAl','TEXT',0);		if (iErr!=0)		{			genError("\pCan't create Preferences file");			return 0;		}		FSpCreateResFile(&mySpec,'MgAl','TEXT',0);		iErr = ResError();		if (iErr!=0)		{			genError("\pCan't create Preferences file");			return 0;		}				iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);		if (iErr!=0)		{			genError("\pCan't open new Preferences file");			return 0;		}		inOutCount = 4;		for (z = 0 ;z<=50;z++)		{			iErr = FSWrite(refNum,&inOutCount,&theDefault);			if (iErr!=0)			{				genError("\pCan't write default into Preferences file");				iErr = FSClose(refNum);				return 0;			}		}		iErr = SetFPos(refNum,1,70L);		inOutCount = 2;		for (z = 0 ;z<=20;z++)		{			iErr = FSWrite(refNum,&inOutCount,&zeroer);			if (iErr!=0)			{				genError("\pCan't write zero into Preferences file");				iErr = FSClose(refNum);				return 0;			}		}			}	return refNum;}FSSpec	getDivertAppSpec(void){	short refNum;	FSSpec	theDAppSpec;	OSErr	iErr;	long inOutCount;	OSType	checkForDefault;		*(theDAppSpec.name) = 0;	theDAppSpec.vRefNum = -999;	if (!(refNum = openPrefFile()))		return theDAppSpec;	iErr = SetFPos(refNum,1,0L);	if (iErr!=0)	{		genError("\pCan't set pos for DivertAppSpec read in Preferences file");		iErr = FSClose(refNum);		return theDAppSpec;	}		inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&checkForDefault);	if (iErr!=0)	{		genError("\pCan't read default divert spec in Preferences file");		iErr = FSClose(refNum);		return theDAppSpec;	}	if (checkForDefault == 'CRAP') /** spec has not been initialised **/	{		theDAppSpec.vRefNum = 0;		iErr = FSClose(refNum);		return theDAppSpec;	}	iErr = SetFPos(refNum,1,0L);	if (iErr!=0)	{		genError("\pCan't set pos for DivertAppSpec read in Preferences file");		iErr = FSClose(refNum);		return theDAppSpec;	}	inOutCount = 70;	iErr = FSRead(refNum,&inOutCount,&theDAppSpec);	if (iErr!=0)	{		genError("\pCan't read DivertAppSpec in Preferences file");		iErr = FSClose(refNum);		return theDAppSpec;	}		iErr = FSClose(refNum);	return theDAppSpec;}void setDivertAppSpec(FSSpec	theDAppSpec){	short refNum;	OSErr	iErr;	long inOutCount;		if (!(refNum = openPrefFile()))		return;				iErr = SetFPos(refNum,1,0L);	if (iErr!=0)	{		genError("\pCan't set pos for DivertAppSpec read in Preferences file");		iErr = FSClose(refNum);		return;	}		inOutCount = 70;	iErr = FSWrite(refNum,&inOutCount,&theDAppSpec);	if (iErr!=0)	{		genError("\pCan't write DivertAppSpec in Preferences file");		iErr = FSClose(refNum);		return ;	}		iErr = FSClose(refNum);	return;}void setMenuDefaults(short * myMenus);void setMenuDefaults(short * myMenus){	short z;	short refNum;	OSErr	iErr;	long inOutCount;	short theOne;		if (!(refNum = openPrefFile()))		return;				iErr = SetFPos(refNum,1,70L);	if (iErr!=0)	{		genError("\pCan't set pos for menu prefs read in Preferences file");		iErr = FSClose(refNum);		return;	}	for (z=0;z<=6;z++)	{		theOne = (short)myMenus[z];		inOutCount = 2;		iErr = FSWrite(refNum,&inOutCount,&theOne);		if (iErr!=0)		{			genError("\pCan't write a menu pref in Preferences file");			iErr = FSClose(refNum);			return ;		}	}	iErr = FSClose(refNum);	return;	}	void getMenuDefaults(short * myMenus);		void getMenuDefaults(short * myMenus){	short z;	short refNum;	OSErr	iErr;	long inOutCount;	short theOne;		if (!(refNum = openPrefFile()))		return;				iErr = SetFPos(refNum,1,70L);	if (iErr!=0)	{		genError("\pCan't set pos for menu prefs read in Preferences file");		iErr = FSClose(refNum);		return;	}	for (z=0;z<=6;z++)	{				inOutCount = 2;		iErr = FSRead(refNum,&inOutCount,&theOne);		if (iErr!=0)		{			genError("\pCan't read a menu pref in Preferences file");			iErr = FSClose(refNum);			return ;		}		myMenus[z] = theOne;	}	iErr = FSClose(refNum);	return;	}	void setOptionDefaults(short * myMenus);void setOptionDefaults(short * myMenus){	short z;	short refNum;	OSErr	iErr;	long inOutCount;	short theOne;		if (!(refNum = openPrefFile()))		return;				iErr = SetFPos(refNum,1,80L);	if (iErr!=0)	{		genError("\pCan't set pos for option prefs read in Preferences file");		iErr = FSClose(refNum);		return;	}	for (z=0;z<=6;z++)	{		theOne = (short)myMenus[z];		inOutCount = 2;		iErr = FSWrite(refNum,&inOutCount,&theOne);		if (iErr!=0)		{			genError("\pCan't write an option pref in Preferences file");			iErr = FSClose(refNum);			return ;		}	}	iErr = FSClose(refNum);	return;	}	void getOptionDefaults(short * myMenus);void PrefsPage(void);void RetrievePrefs(void){	short refNum;	OSErr iErr;	long inOutCount;	Handle rpHandle, SDBHandle;		refNum = openPrefFile();	if (!refNum)	{		genError ("\pCan't open Prefs");		return;	}		iErr = SetFPos(refNum,1,100L);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}	inOutCount = 2;	iErr = FSRead(refNum,&inOutCount,&MakeCompositeAE);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}	iErr = FSRead(refNum,&inOutCount,&AutoLaunchDivert);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}	AutoLaunchDivert = !AutoLaunchDivert;		iErr = FSRead(refNum,&inOutCount,&ExcludeDrives);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}		iErr = FSRead(refNum,&inOutCount,&PreservePopups);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}	PreservePopups = !PreservePopups;		inOutCount = 4L;	iErr = FSRead(refNum,&inOutCount,&dblBufferSize);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}	if (dblBufferSize == 0L)		dblBufferSize = 32768L;			inOutCount = 4L;	iErr = FSRead(refNum,&inOutCount,&normBuffer);	if (iErr !=0)	{		FSClose(refNum);		genError ("\pProblem with prefs file");		return;	}	if (normBuffer == 0L | normBuffer > 8000000L)		normBuffer = 300000L;			FSClose(refNum);		rpHandle = NewHandle(sizeof (listFontRec));	if (!rpHandle)	{		genError ("\pNot Enough Memory");		return;	}	SDBHandle = NewHandle(sizeof (Boolean));	if (!SDBHandle)	{		genError ("\pNot Enough Memory");		return;	}		if (readResFromPrefs(rpHandle,'LFon', 1000, sizeof (listFontRec)) == noErr)	{		BlockMove (*rpHandle, &theFontRec,sizeof (listFontRec));	}	else	{		SetHandleSize(rpHandle,sizeof (listFontRec));		iErr = MemError();		makeStr255("\pGeneva",theFontRec.fontName);		theFontRec.fontSize = 9;		BlockMove (&theFontRec,*rpHandle, sizeof (listFontRec));		if (writeResToPrefs(rpHandle, 'LFon', 1000, sizeof (listFontRec)) != noErr)		{			genError ("\pAn error occured whilst making prefs");		}		}		if (readResFromPrefs(SDBHandle,'SDbf', 1000, sizeof (Boolean)) == noErr)	{		stickyInfo = **SDBHandle;	}	else	{		SetHandleSize(SDBHandle,sizeof (Boolean));		iErr = MemError();		**SDBHandle = false;		if (writeResToPrefs(SDBHandle, 'SDbf', 1000, sizeof (Boolean)) != noErr)		{			genError ("\pAn error occured whilst making prefs");		}		}		DisposHandle(rpHandle);	DisposHandle(SDBHandle);	return;}pascal void XUserProc(WindowPtr theDialog, short theItem){	Rect 	iRect,xrView,rBounds;	short 	h,v;	char 	s[25];	Point 	pCellSz,theCell;	Handle theHandle;	short 	itype;	Rect 	tempRect;	Str255	theCellText, textIn;	short		CellTextLen;	short myCount;	Cell	tempCell;	short iInsRow;			// Grab item information	GetDItem(theDialog,theItem,&itype,&theHandle,&iRect);	// Set up view for the list.  Notice that there is some	// margin left on all sides for the frame, and the verical scroll bar	xrView = iRect;	xrView.right -= 16;		xrView.left +=2;	xrView.bottom -=1;	xrView.top += 1;	// list array is 1 column with 0 rows			// force auto calculations when displaying the cells.	pCellSz.h = 0;	pCellSz.v = 0;	// create list and draw it.	if(firstInvoke)	{		Xstream = fopen("SampleSearch Excluded Drives","r");				SetRect(&rBounds,0,0,1,0);		theXList = LNew (&xrView, &rBounds, pCellSz, 0, theDialog, TRUE, TRUE, FALSE,						TRUE);				if (!theXList) {				SysBeep(5);				return;		}		(*theXList)->selFlags = 186;		if (Xstream)		{			while (!feof(Xstream))			{					fgets((Ptr)textIn,254,Xstream);					if (feof(Xstream))						break;					CtoPstr((Ptr)textIn);					CellTextLen = (*textIn)-1;					PtoCstr(textIn);					iInsRow = LAddRow(1,99,theXList);					SetPt(&tempCell,0,iInsRow);					LSetCell(textIn,CellTextLen,tempCell,theXList);			}			fclose(Xstream);		}			}	firstInvoke = false;	// Draw a frame around the user item		PenSize(1,1);	FrameRect (&iRect);	// associate the new list handle with this user item	SetDItem(theDialog,theItem,0,(Handle)NewUserItemProc(theXList),&iRect);}/***************/pascal Boolean myXFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	OSErr	myErr;	Boolean	returnVal = FALSE;	WindowPtr	temp;	ModalFilterUPP	standardProc;	Point thePoint;	Cell XlCellCoords;	short iType;	Handle iHndl;	Rect iRect;	GrafPtr savePort;		if(theEventIn->what==updateEvt &&				(WindowPtr) theEventIn->message!=currentDialog)	{		/* if the update is for the dialog box, ignore it since the regular			ModalDialog function will redraw it as necessary.		*/		returnVal = false; //MyDrawProc((WindowPtr) theEventIn->message);	}	else	{		/* it wasn't an update, pass it on to the system filter */		//GetPort(&temp);/* save the current port, set to the dialog */		//SetPort(currentDialog);						/* necessary to track the edit cursor changes */					#ifdef powerc				myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = CallUniversalProc(standardProc,uppModalFilterProcInfo,currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#else	myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = ((ModalFilterProcPtr)standardProc)				(currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#endif		/************/		/**************/			if (theEventIn->what == mouseDown)		/*if (*theDialogItem == 4)*/		{			GetPort(&savePort);			SetPort(currentDialog);			thePoint = theEventIn->where;			GlobalToLocal(&thePoint);			LClick(thePoint,theEventIn->modifiers,theXList);			//XlCellCoords = LLastClick(theXList);			SetPt (&XlCellCoords,0,0);			if(LGetSelect(true,&XlCellCoords,theXList)) 			{				GetDItem(currentDialog,6,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);			}			SetPort(savePort);		}		return returnVal;	}}/************/pascal Boolean myXDlgFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit){	Rect	iRect;	short	type;	Handle	iHndle;	GrafPtr	savePort;		char	theChar;	// case on the event	switch (theEvent->what) {	case keyDown:			// if key was pressed, handle return key			theChar = (theEvent->message) & charCodeMask;			if ( (theChar == 0x0d) || (theChar == 0x03)) {					*itemHit = 1;					return TRUE;			}			return FALSE;	case mouseDown:			// Get where mouse click occured in global coordinates.			Xp = theEvent->where;			//   Save the current port.			//   Then make sure port is set to the dialog.			//GetPort (&savePort);			//SetPort (theDialog);			// Convert the coordinates to local to the dialog window			GlobalToLocal(&Xp);			// Since I am only concerned with mouse clicks in the user item,			// get information for that item.			GetDItem(theDialog,4,&type,&iHndle,&iRect);			// If the mouse click was not in LISTITEM, then let ModalDialog handle			// it.			if (!PtInRect(Xp,&iRect)) {					//SetPort(savePort);					return FALSE;			}			// Mouse Click was in list item,			// Set the itemHit to be the LISTITEM,			// and call LClick on itemhandle (the list).			*itemHit = 4;			LClick(Xp,theEvent->modifiers,(ListHandle)iHndle);			// Reset Port, and let ModalDialog know that we handled the event.			//SetPort(savePort);			return TRUE;			case updateEvt:			return TRUE;			default :			return FALSE;	}}Boolean checkListfor(Str255 nameString){	short theLen;	Cell tempCell;	short z;	Str255	theText;		for (z=0;z<(*theXList)->dataBounds.bottom;z++)	{		SetPt(&tempCell,0,z);		theLen = 254;		LGetCell(theText,&theLen,tempCell,theXList);		*(theText+theLen) = 0;		CtoPstr((Ptr)theText);		if(EqualString(nameString,theText,true,true)) 		{			if (*nameString == *theText)			{				return true;			}		}	}	return false;}//	{SetPt(&tempCell,0,0);//	//	theLen = *nameString;//	PtoCstr (nameString);//	if(LSearch(nameString,theLen,0,&tempCell,theXList)) //	{//		CtoPstr (nameString);//		return true;//	}//	CtoPstr (nameString);//	return false;//}void QueryDrive(Str255	myString){	Handle	hRsrc;	short z;	short itemHit;				/** for dialog enquiry **/	DialogPtr	QmyDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	OSErr	iErr;	Str255 theTempVol;	short menuVRefs[99];	short menuitem = 1;	hRsrc = (Handle)GetMenu(1010);	hRsrc = GetResource('MENU',1010);	for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{		makeStr255 (volName[z], theTempVol);		doTheSlashAnalysis(theTempVol);		if (*theTempVol)		{			menuVRefs[menuitem] = volumes[z];			menuitem++;			AppendMenu((MenuHandle)hRsrc,volName[z]);			iErr = ResError();		}	}	ParamText("\pSelect volume to Exclude from searches",0,0,0);	QmyDlg = GetNewDialog(6015,0L,(WindowPtr)-1);		SetPort (QmyDlg);	/*color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);*/	GetDItem(QmyDlg,3,&iType,&iHndl,&iRect);	SetDItem(QmyDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	ShowWindow(QmyDlg);	ModalDialog(xAlertFilter,&itemHit);	GetDItem(QmyDlg,5,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	iCtlValue = GetCtlValue((ControlHandle)iHndl);	GetItem((MenuHandle)hRsrc,iCtlValue,myString);  	ReleaseResource(hRsrc);	DisposDialog (QmyDlg);	return;}OSType writeResToPrefs(Handle rpHandle, OSType thePrefType, short prefID,  long handleSize){	short piRefNum,prefNum;	Handle recPrefsH;		piRefNum = CurResFile();	prefNum = FSpOpenResFile (&theSSPrefSpec,fsCurPerm);	if (!prefNum)	{		return cantOpenResFile;	}	UseResFile(prefNum);		recPrefsH = Get1Resource(thePrefType,prefID);	if (recPrefsH)	{		if (GetHandleSize(recPrefsH) < handleSize)			return handleTooSmall;		BlockMove (*rpHandle, *recPrefsH, handleSize);		ChangedResource(recPrefsH);		WriteResource(recPrefsH);		ReleaseResource(recPrefsH);	}	else	{		recPrefsH = NewHandle(handleSize);		if (!recPrefsH)			return handleTooSmall;		BlockMove (*rpHandle, *recPrefsH, handleSize);		AddResource(recPrefsH,thePrefType,prefID,"\pPrefs Item");	}	CloseResFile(prefNum);	UseResFile(piRefNum);	return noErr;}OSErr readResFromPrefs(Handle rpHandle, OSType thePrefType, short prefID, long handleSize){	short iRefNum,prefNum;	Handle recPrefsH;			if (GetHandleSize(rpHandle) < handleSize)	return handleTooSmall;		iRefNum = CurResFile();			prefNum = FSpOpenResFile (&theSSPrefSpec,fsCurPerm);	if (!prefNum)	{		return cantOpenResFile;	}	UseResFile(prefNum);	recPrefsH = Get1Resource(thePrefType,prefID);	if (recPrefsH)	{		BlockMove (*recPrefsH, *rpHandle, handleSize);		ReleaseResource(recPrefsH);	}	else	{		CloseResFile(prefNum);		UseResFile(iRefNum);		return resourceNotFound;	}	CloseResFile(prefNum);	UseResFile(iRefNum);	return noErr;}void createNewPrefs (void){	long prefDirID;	short prefRefNum;	FSSpec prefFile;	OSErr	iErr;			iErr = FindFolder(-1,'pref',kDontCreateFolder,&prefRefNum,&prefDirID);	if (iErr!=0)	{		genError("\pCan't find Preferences folder");		return;	}		iErr = FSMakeFSSpec(prefRefNum,prefDirID,"\pSampleSearchª 2.0 Prefs",&prefFile);	if (iErr!=0 && iErr!=-43  )	{		genError("\pCan't make FSSpec for prefs");		return ;	}			iErr = FSpCreate(&prefFile,'MgAl','prfs',0);	if (iErr!=0)	{		genError("\pCan't create Preferences file");		return ;	}			FSpCreateResFile(&prefFile,'MgAl','prfs',0);	iErr = ResError();	if (iErr!=0)	{		genError("\pCan't create Preferences file");		return ;	}		}void readNewPrefs (void){	long prefDirID;	short prefRefNum;	FSSpec prefFile;	NumVersion version;	short iRefNum,rfRefNum;	Handle thePData;	OSErr	iErr;		iErr = FindFolder(-1,'pref',kDontCreateFolder,&prefRefNum,&prefDirID);	if (iErr!=0)	{		genError("\pCan't find Preferences folder");		return ;	}		iErr = FSMakeFSSpec(prefRefNum,prefDirID,"\pSampleSearchª 2.0 Prefs",&prefFile);	if (iErr!=0 && iErr!=-43  )	{		genError("\pCan't make FSSpec for prefs");		return ;	}		if (iErr == -43)	{		createNewPrefs ();		setNewPrefsDefaults ();		saveNewPrefs ();	}	iRefNum = CurResFile();		rfRefNum = FSpOpenResFile(&prefFile,fsRdPerm);	if (rfRefNum == -1)	{		FSpDelete(&prefFile);		genError("\pProblem opening prefs 2.0");		return;	}	UseResFile(rfRefNum);	thePData = GetResource('NPrf',1000);	if (!thePData)	{		CloseResFile(rfRefNum);		FSpDelete(&prefFile);		createNewPrefs ();		setNewPrefsDefaults ();		saveNewPrefs ();		rfRefNum = FSpOpenResFile(&prefFile,fsRdPerm);		if (rfRefNum == -1)		{			CloseResFile(rfRefNum);			UseResFile(iRefNum);			genError("\pProblem opening prefs 2.0");			return;		}		thePData = GetResource('NPrf',1000);	}	setNewPrefsDefaults ();	BlockMove (*thePData, &theNewPrefs,sizeof(newPrefsRec));		CloseResFile(rfRefNum);		UseResFile(iRefNum);			if (theNewPrefs.prefsVers != prefsVersion)	{		FSpDelete(&prefFile);		createNewPrefs ();		setNewPrefsDefaults ();		saveNewPrefs ();	}		theNewPrefs.whichTab = 0;		//if (!checkoutGearbox())	//{		theNewPrefs.theBITPTPrefs.changeRate = true;	//}		version = SndSoundManagerVersion();	if ( ! ( version.majorRev >= 3 && version.minorAndBugRev >= 0x02) )	{			theNewPrefs.theBITPTPrefs.changeRate = false;	}	}void saveNewPrefs (void){	long prefDirID;	short prefRefNum;	FSSpec prefFile;	short iRefNum,rfRefNum;	Handle thePData;	OSErr		iErr;		iErr = FindFolder(-1,'pref',kDontCreateFolder,&prefRefNum,&prefDirID);	if (iErr!=0)	{		genError("\pCan't find Preferences folder");		return ;	}		iErr = FSMakeFSSpec(prefRefNum,prefDirID,"\pSampleSearchª 2.0 Prefs",&prefFile);	if (iErr!=0 && iErr!=-43  )	{		genError("\pCan't make FSSpec for prefs");		return ;	}		iRefNum = CurResFile();		rfRefNum = FSpOpenResFile(&prefFile,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pProblem opening prefs 2.0");		return;	}	UseResFile(rfRefNum);	thePData = GetResource('NPrf',1000);	if (!thePData)	{		thePData = NewHandle(sizeof(newPrefsRec));		AddResource(thePData,'NPrf',1000,"\pNew Prefs");		thePData = GetResource('NPrf',1000);	}		/*if (SizeResource(thePData) < sizeof(newPrefsRec))	{		genError("\pBad prefs file");		CloseResFile(rfRefNum);		UseResFile(iRefNum);		return;		}*/		BlockMove (&theNewPrefs,*thePData, sizeof(newPrefsRec));	ChangedResource(thePData);	WriteResource(thePData);	CloseResFile(rfRefNum);	UseResFile(iRefNum);}void setNewPrefsDefaults (void){	short y;	theNewPrefs.prefsVers = prefsVersion;	theNewPrefs.whichTab = 0;	theNewPrefs.noSearch = false;		for (y=1;y<=16;y++)	{		NumToString((long)(y),theNewPrefs.tabName[y-1]);		theNewPrefs.tabLocked[y-1] = false;	}		NumToString(10L,theNewPrefs.tabName[9]);		theNewPrefs.normaliseLevel = 128;	theNewPrefs.normaliseRewriteOrig = true;	theNewPrefs.theBITPTPrefs.destFolderValid = false;	theNewPrefs.theBITPTPrefs.destFolder.vRefNum = -1;	theNewPrefs.theBITPTPrefs.destFolder.parID = 2;	makeStr255("\pUndefined",theNewPrefs.theBITPTPrefs.destFolder.name);	theNewPrefs.theBITPTPrefs.forceCopy = false;	theNewPrefs.theBITPTPrefs.targetApp = 'PTul';	*theNewPrefs.theBITPTPrefs.targetAppName = 0;	theNewPrefs.theBITPTPrefs.splitFiles = 1;	theNewPrefs.theBITPTPrefs.sessionResolution = kSession16Bit;	theNewPrefs.numberOfPTExclusions = 0;	theNewPrefs.PTResolveFindOne = true;	theNewPrefs.waveFormWindow = true;	theNewPrefs.theWaveFormHeight = 50;		theNewPrefs.theWaveFormColor.red = 0x0000;	theNewPrefs.theWaveFormColor.green = 0x4000;	theNewPrefs.theWaveFormColor.blue = 0xAFFF;	theNewPrefs.theWaveFormBackGround.red = 0xF000;	theNewPrefs.theWaveFormBackGround.green = 0xF000;	theNewPrefs.theWaveFormBackGround.blue = 0xFFFF;	theNewPrefs.SDIIToolBar = true; 	theNewPrefs.toolsHeight = 15;	theNewPrefs.modernDblBufferAudition = true;	theNewPrefs.modernAutoSustainAudition = true;			theNewPrefs.theCropSpec.noiseFloor = 15;	theNewPrefs.theCropSpec.noiseFloorOut = 15;	theNewPrefs.theCropSpec.preRoll = 0;	theNewPrefs.theCropSpec.postRoll = 0;	theNewPrefs.theCropSpec.addSilenceStart = 0;	theNewPrefs.theCropSpec.addSilenceEnd = 0;	theNewPrefs.theCropSpec.fadeInTime = 0;	theNewPrefs.theCropSpec.fadeOutTime = 0;	theNewPrefs.theCropSpec.rewriteOriginal = false;	theNewPrefs.theCropSpec.compositeFiles = false;	theNewPrefs.theCropSpec.silencePeriod = 0;	theNewPrefs.theCropSpec.doPre = false;	theNewPrefs.theCropSpec.doPost = false;	theNewPrefs.theCropSpec.doAddSilenceStart = false;	theNewPrefs.theCropSpec.doAddSilenceEnd = false;	theNewPrefs.theCropSpec.doFadeStart = false;	theNewPrefs.theCropSpec.doFadeEnd = false;		theNewPrefs.useMoreFiles = false;	theNewPrefs.dontFindAliases = true;	theNewPrefs.ignorePTFades = false;	theNewPrefs.dontAddToList = false;	theNewPrefs.deselectAsPlayed = false;	theNewPrefs.windowLocation.top = 50;	theNewPrefs.windowLocation.left = 50;	theNewPrefs.windowLocation.bottom = 350;	theNewPrefs.windowLocation.right = 600;			theNewPrefs.findWindowLocation.top = 100;	theNewPrefs.findWindowLocation.left = 100;	theNewPrefs.findWindowLocation.right = 0;	theNewPrefs.findWindowLocation.bottom = 0;	theNewPrefs.findDropDownOpen = false;	theNewPrefs.theDSPSettings.termEnabled[0] = 0;	theNewPrefs.theDSPSettings.termEnabled[1] = 0;	theNewPrefs.theDSPSettings.termEnabled[2] = 0;	theNewPrefs.theDSPSettings.termEnabled[3] = 0;	theNewPrefs.theDSPSettings.termEnabled[4] = 0;	theNewPrefs.theDSPSettings.termEnabled[5] = 0;	theNewPrefs.theDSPSettings.termEnabled[6] = 0;	theNewPrefs.theDSPSettings.termEnabled[7] = 0;	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[0]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[1]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[2]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[3]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[4]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[5]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[6]);	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.termMultiplier[7]);	makeStr255 ("\p0",theNewPrefs.theDSPSettings.termPosition[0]);	makeStr255 ("\p1",theNewPrefs.theDSPSettings.termPosition[1]);	makeStr255 ("\p2",theNewPrefs.theDSPSettings.termPosition[2]);	makeStr255 ("\p3",theNewPrefs.theDSPSettings.termPosition[3]);	makeStr255 ("\p4",theNewPrefs.theDSPSettings.termPosition[4]);	makeStr255 ("\p5",theNewPrefs.theDSPSettings.termPosition[5]);	makeStr255 ("\p6",theNewPrefs.theDSPSettings.termPosition[6]);	makeStr255 ("\p7",theNewPrefs.theDSPSettings.termPosition[7]);	theNewPrefs.theDSPSettings.invert = false;	makeStr255 ("\p1.0",theNewPrefs.theDSPSettings.gainCorrection);	SetRect (&theNewPrefs.displayPictRect, 0,0,400,400);	makeStr255 ("\p.L",theNewPrefs.theStereoMonoXLatePrefs.leftSuffix);	makeStr255 ("\p.R",theNewPrefs.theStereoMonoXLatePrefs.rightSuffix);	theNewPrefs.theStereoMonoXLatePrefs.mixOrDeinterleave = kDeinterleaveStereoToSplit;	theNewPrefs.theStereoMonoXLatePrefs.interleaveOrDouble = kInterleaveSplitToStereo;	theNewPrefs.trimEndValue = 0;}Boolean isPTExcludedDrive (short vRefNum){	short z;	Str63 theDriveName;		VgetvolName(vRefNum, theDriveName);	for (z=0;z<theNewPrefs.numberOfPTExclusions;z++)	{		if(EqualString(theNewPrefs.PTExcludedDrive[z],theDriveName,true,true))		{			return true;		}	}		return false;}OSErr addPTExcludedDrive (Str63 theName){		BlockMove (theName,	theNewPrefs.PTExcludedDrive[theNewPrefs.numberOfPTExclusions],64L);	theNewPrefs.numberOfPTExclusions ++;}OSErr removePTExcludedDrive (Str63 theName){	short z;	Boolean exists = false;		z=0;		while (z<theNewPrefs.numberOfPTExclusions)	{		if(EqualString(theNewPrefs.PTExcludedDrive[z],theName,true,true))		{			*theNewPrefs.PTExcludedDrive[z] = 0;			BlockMove (theNewPrefs.PTExcludedDrive[z+1], theNewPrefs.PTExcludedDrive[z], 64L * (theNewPrefs.numberOfPTExclusions - z));			 exists = true;		}	}	return (exists == false);}void PTExcludeList(void){	short itemHit = 0;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	ListHandle	theExcList;	Rect	xrView,rDataBnds;	Point	theXPoint;	short iInsRow;	Cell XlCellCoords, temporCell;	Str255 NewNameString,theTempVol;	short 	dataLen;	OSErr	iErr;	short z, excCount = 0;	MenuHandle	hRsrc;	Str255 myString, volumeName;	Rect	itRect;short menuVRefs[99];short menuitem = 1;	ModalFilterUPP xmyPTXFilter = NewModalFilterProc(myPTXFilter);		hRsrc = NewMenu(1099,"\pDrives");	for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{		makeStr255 (volName[z], theTempVol);		doTheSlashAnalysis(theTempVol);		if (*theTempVol)		{			menuVRefs[menuitem] = volumes[z];			menuitem++;			AppendMenu((MenuHandle)hRsrc,theTempVol);			iErr = ResError();		}	}		InsertMenu((MenuHandle)hRsrc,-1);	SetResAttrs((Handle)hRsrc,16);	myDlg = GetNewDialog(11010,nil,(WindowPtr)-1);		SetPort (myDlg);	/*color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);*/		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,6,&iType,&iHndl,&iRect);	HiliteControl((ControlHandle)iHndl,255);			GetDItem(myDlg,7,&iType,&iHndl,&iRect);		GetDItem(myDlg,4,&iType,&iHndl,&itRect);	SetDItem(myDlg,4,iType,(Handle)NewUserItemProc(PTXUserProc),&itRect);			ShowWindow(myDlg);	firstInvoke = true;		do	{		ModalDialog(xmyPTXFilter,&itemHit);			switch (itemHit)		{			case 1: /* finished */				for (z=0;z<(*theXList)->dataBounds.bottom;z++)				{					SetPt(&temporCell,0,z);					//PtoCstr(NewNameString);					dataLen = 64;					LGetCell(theNewPrefs.PTExcludedDrive[z],&dataLen,temporCell,theXList);					*(theNewPrefs.PTExcludedDrive[z] + (long)dataLen) = 0;					CtoPstr ((Ptr)theNewPrefs.PTExcludedDrive[z]);					*(NewNameString+dataLen) = 0;					excCount++;				}				theNewPrefs.numberOfPTExclusions = (*theXList)->dataBounds.bottom;				SetResAttrs((Handle)hRsrc,0);				ReleaseResource((Handle)hRsrc);				LDispose(theXList);				DisposDialog(myDlg);				return;			break;						case 2:				SetResAttrs((Handle)hRsrc,0);				ReleaseResource((Handle)hRsrc);				LDispose(theXList);				DisposDialog(myDlg);				return;			break;						case 4:							break;						case 5: /* add one */					GetDItem(myDlg,8,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/					iCtlValue = GetCtlValue((ControlHandle)iHndl);						GetItem(hRsrc,iCtlValue,myString);									//	BlockMove (menuVRefs[iCtlValue] /*volName[iCtlValue]*/,myString,28L);					if (!checkListfor(myString))					{						iInsRow = LAddRow(1,99,theXList);						SetPt(&temporCell,0,iInsRow);						dataLen = *myString+1;						PtoCstr(myString);						LSetCell(myString,dataLen,temporCell,theXList);					}					itemHit = 0;			break;						case 6: /* remove */				SetPt(&XlCellCoords,0,0);				if(LGetSelect(true,&XlCellCoords,theXList)) 				{					LDelRow(1,XlCellCoords.v,theXList);					GetDItem(myDlg,6,&iType,&iHndl,&iRect);					HiliteControl((ControlHandle)iHndl,255);				}			break;					default:			break;		}	} while (itemHit !=1 && itemHit !=2);	LDispose(theXList);	DisposDialog(myDlg);	return;}pascal Boolean myPTXFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	OSErr	myErr;	Boolean	returnVal = FALSE;	WindowPtr	temp;	ModalFilterUPP standardProc;	Point thePoint;	Cell XlCellCoords;	short iType;	Handle iHndl;	Rect iRect;	GrafPtr savePort;		if(theEventIn->what==updateEvt &&				(WindowPtr) theEventIn->message!=currentDialog)	{		/* if the update is for the dialog box, ignore it since the regular			ModalDialog function will redraw it as necessary.		*/		returnVal = false; //MyDrawProc((WindowPtr) theEventIn->message);	}	else	{		/* it wasn't an update, pass it on to the system filter */		//GetPort(&temp);/* save the current port, set to the dialog */		//SetPort(currentDialog);						/* necessary to track the edit cursor changes */					#ifdef powerc				myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = CallUniversalProc(standardProc,uppModalFilterProcInfo,currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#else	myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = ((ModalFilterProcPtr)standardProc)				(currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#endif		/************/		/**************/			if (theEventIn->what == mouseDown)		{			GetPort(&savePort);			SetPort(currentDialog);			thePoint = theEventIn->where;			GlobalToLocal(&thePoint);			LClick(thePoint,theEventIn->modifiers,theXList);			SetPt (&XlCellCoords,0,0);			if(LGetSelect(true,&XlCellCoords,theXList)) 			{				GetDItem(currentDialog,6,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);			}			SetPort(savePort);		}		return returnVal;	}}pascal void PTXUserProc(WindowPtr theDialog, short theItem){	Rect 	iRect,			xrView,			rBounds;	short 	h,			v;	char 	s[25];	Point 	pCellSz,theCell;	Handle theHandle;	short 	itype;	Rect 	tempRect;	Str255	theCellText, textIn;	short		CellTextLen;	short myCount;	Cell	tempCell;	short iInsRow;			// Grab item information	GetDItem(theDialog,theItem,&itype,&theHandle,&iRect);	// Set up view for the list.  Notice that there is some	// margin left on all sides for the frame, and the verical scroll bar	xrView = iRect;	xrView.right -= 16;		xrView.left +=2;	xrView.bottom -=1;	xrView.top += 1;	// list array is 1 column with 0 rows			// force auto calculations when displaying the cells.	pCellSz.h = 0;	pCellSz.v = 0;	// create list and draw it.	if(firstInvoke)	{					SetRect(&rBounds,0,0,1,0);		theXList = LNew (&xrView, &rBounds, pCellSz, 0, theDialog, TRUE, TRUE, FALSE,						TRUE);				if (!theXList) {				SysBeep(5);				return;		}		(*theXList)->selFlags = 186;		if (true)		{			short z;			for (z=0;z<theNewPrefs.numberOfPTExclusions;z++)			{					Str63 theTempStr;										BlockMove (theNewPrefs.PTExcludedDrive[z],theTempStr,64L);					CellTextLen = (*theTempStr);					PtoCstr(theTempStr);					iInsRow = LAddRow(1,99,theXList);					SetPt(&tempCell,0,iInsRow);					LSetCell(theTempStr,CellTextLen,tempCell,theXList);			}		}			}	firstInvoke = false;	// Draw a frame around the user item		PenSize(1,1);	FrameRect (&iRect);	// associate the new list handle with this user item	SetDItem(theDialog,theItem,0,(Handle)NewUserItemProc(theXList),&iRect);}pascal void MyColorProc(WindowPtr theDlg,short theItem)		/** draws the line round the default dialog item **/{	Rect	iRect;	Handle	iHndl;	short	iType;	RGBColor tempColor, presCol,presCol2;	short presLeft;	CWindowPeek	myPeek;	GrafPtr savePort;			GetPort(&savePort);	SetPort (theDlg);		myPeek = (CWindowPeek)theDlg;	presCol = myPeek->port.rgbBkColor;	presCol2 = myPeek->port.rgbFgColor;			GetDItem(theDlg,theItem,&iType,&iHndl,&iRect);	if (theItem == 25)	{		BlockMove(&theNewPrefs.theWaveFormBackGround,&tempColor,sizeof(RGBColor));	}	else	{		BlockMove(&theNewPrefs.theWaveFormColor,&tempColor,sizeof(RGBColor));	}		RGBBackColor(&tempColor);	EraseRect(&iRect);		presLeft = iRect.left;	iRect.left = iRect.right - 10;	InvertRect(&iRect);	iRect.left = presLeft;		tempColor.red = 0xFFFF;	tempColor.green = 0xFFFF;	tempColor.blue = 0xFFFF;	RGBBackColor(&tempColor);		tempColor.red = 0;	tempColor.green = 0;	tempColor.blue = 0;	RGBForeColor(&tempColor);		FrameRect(&iRect);		RGBBackColor(&presCol);	RGBForeColor(&presCol2);		SetPort (savePort);}void getOptionDefaults(short * myMenus){	short z;	short refNum;	OSErr	iErr;	long inOutCount;	short theOne;		if (!(refNum = openPrefFile()))		return;				iErr = SetFPos(refNum,1,80L);	if (iErr!=0)	{		genError("\pCan't set pos for options prefs read in Preferences file");		iErr = FSClose(refNum);		return;	}	for (z=0;z<=6;z++)	{				inOutCount = 2;		iErr = FSRead(refNum,&inOutCount,&theOne);		if (iErr!=0)		{			genError("\pCan't read an option pref in Preferences file");			iErr = FSClose(refNum);			return ;		}		myMenus[z] = theOne;	}	iErr = FSClose(refNum);	return;	}	