#include "SampleSearch.h"#include "Globals.h"Boolean ExamineSD2A(void);Boolean InstExamine;typedef struct	examineRec {	Str31	theFName;	Str27	theVName;	long	theDirID;	OSType	theType;	}ERec;struct examineRec	*myERPtr,*mySERPtr;short		theFNameListLen;short		theSFNameListLen;	//Str31	theFilename[40];short fillStruct(ERec *  myERecPtr, FSSpec	mySpec);Boolean ResolveSCIIFile(ERec *  myERecPtr,short	theIndex, short* AtheUpdated);extern Boolean SDIIRegionType;void ExamineSCII(FSSpec theSelFile, short theIndex){	OSErr	iErr;	short refNum;	long 	numberOfFiles;	long	inOutCount;	Ptr		tempPtr;	short	z;	FInfo	fndrInfo;	short myvRefNum;	FSSpec	myTempSpec;		if ((-(*therealResults)[theIndex].vRefNum) > maxVRef)	{		genError ("\pCan't Examine ghost files");		return;	}	iErr = FSpGetFInfo(&((*therealResults)[theIndex]),&fndrInfo);		//BlockMove(&(*theFInfo)[theIndex],&fndrInfo,16L);	if (fndrInfo.fdType != 'MixD' && fndrInfo.fdType != 'SCin' && fndrInfo.fdType != 'SCsi' && fndrInfo.fdType != 'SCsd' && fndrInfo.fdType != 'SCss')	{		switch (fndrInfo.fdType)		{			case  'Sd2f':				SDIIRegionType = true;				ExamineSD2A();			break;						/*case 'PSes':				SDIIRegionType = false;				ExamineSD2A();			break;*/						default:				genError("\pNot an instrument or Bank or SD2 file");			break;		}		return;	}		myERPtr = (ERec *)NewPtr(99*68);		if(!myERPtr)	{		genError("\pCan't allocate memory a");		return;	}	mySERPtr = (ERec *)NewPtr(99*68);		if(!myERPtr)	{		genError("\pCan't allocate memory b");		return;	}	theFNameListLen = 0;	theSFNameListLen = 0;	/********************/	InstExamine = false;	switch (fndrInfo.fdType)	{		case 'MixD':			theFNameListLen=fillStruct(myERPtr,theSelFile);			theSFNameListLen=0;			InstExamine = false;		break;				case 'SCin':case 'SCsi':case 'SCsd':case 'SCss':			theSFNameListLen=fillStruct(mySERPtr,theSelFile);			theFNameListLen = 1;			((myERPtr)[0]).theType = fndrInfo.fdType;			BlockMove(theSelFile.name,((myERPtr)[0]).theFName,32L);			BlockMove(&(volName[-(theSelFile.vRefNum)]),&(((myERPtr)[0]).theVName),28L);			((myERPtr)[0]).theDirID = theSelFile.parID;			InstExamine = true;		break;	}		/************************************/		 DialogList(theSelFile);		SetPort(myWindow);	return;}short fillStruct(ERec *  myERecPtr, FSSpec	mySpec){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern short theFNameListLen;	short z;	long filpPOS;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		return 0;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{		FSClose(refNum);		return 0;	}	iErr = SetFPos(refNum,1,filpPOS+8L);	if(iErr!=0)	{		FSClose(refNum);		return 0;	}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&numberOfFiles);	if(iErr!=0)	{		FSClose(refNum);		return 0;	}	iErr = SetFPos(refNum,1,filpPOS+16L);	if(iErr!=0)	{		//genError ("\p Can't set pos in that file");		FSClose(refNum);		return 0;	}	if (numberOfFiles <1)	{		//genError("\pThat file is empty");		FSClose(refNum);		return 0;	}	for (z=0;z<numberOfFiles;z++)	{		inOutCount = 28;		iErr = FSRead(refNum,&inOutCount,&((myERecPtr)[z].theVName));		if(iErr!=0)		{			//genErrorN ("\p Can't read a volume name in that file",iErr);			FSClose(refNum);			return 0;		}		inOutCount = 4;		iErr = FSRead(refNum,&inOutCount,&(((myERecPtr)[z]).theDirID));		if(iErr!=0)		{			//genError ("\p Can't read a DirID in that file");			FSClose(refNum);			return 0;		}		inOutCount = 32;		iErr = FSRead(refNum,&inOutCount,&(((myERecPtr)[z]).theFName));		if(iErr!=0)		{			//genError ("\p Can't read a filename in that file");			FSClose(refNum);			return 0;		}		inOutCount = 4;		iErr = FSRead(refNum,&inOutCount,&(((myERecPtr)[z]).theType));		if(iErr!=0)		{			//genError ("\p Can't read a filetype in that file");			FSClose(refNum);			return 0;		}	}	FSClose(refNum);		if(iErr!=0)		{			//genError ("\p Can't close that file");			return 0;		}	return numberOfFiles;}short FgetVRefNum(Str255 myString ){	short theVRefNum = 0;	short z;		gogetvolref();	for (z=0;z<=volumearrayptr;z++)	{	 if (EqualString(myString,volName[z],false,false)) 	 	{			theVRefNum = volumes[z];		}	}	return theVRefNum;}Boolean VgetvolName(short theVRefNum, StringPtr myString);Boolean VgetvolName(short theVRefNum, StringPtr myString){	short z;		for (z=1;z<=volumearrayptr;z++)	{		if (volumes[z] == theVRefNum) 	 	{			BlockMove (volName[z],myString,28L);			return true;		}	}		for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{		if (fvolumes[z] == theVRefNum) 	 	{			BlockMove (fvolName[z],myString,28L);			return true;		}	}	return false;}