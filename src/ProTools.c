#include "SampleSearch.h"#include "Globals.h"#include "prefs.h"#include "overViews.h"#include "ProToolsImport.h"short FgetVRefNum(Str255 myString );extern newPrefsRec theNewPrefs;#include "undoStuff.h"Boolean SDIIStereoToMonoLRSRConv(FSSpec theSpec, long newRate);Boolean convertSRSD2File(FSSpec theSource,FSSpec theDest,long newRate);Boolean WAVToSDIISRConv(FSSpec mySpec,FSSpec destSpec, long newRate);pascal void zRUserProc(WindowPtr theDialog, short theItem);Ptr splitBufferL,splitBufferR;Boolean resolvePTSpec(Str31	myFileName, long	catHint, short driveHint, OSType	theType);void PTsaveFSList(FSSpec mySpec);Boolean PTMemToFSSpec(FSSpec mySpec);Boolean transferProTools(FSSpec sourceSpec, Boolean sendRegions);Boolean isPTExcludedDrive (short vRefNum);OSErr GetFileGray(FSSpec *myFSSpec);Boolean SDIIStereoToMonoLR(FSSpec theSpec);Boolean translateParentToChildFolder(FSSpec *mySpec);Boolean WAVStereoToSDIISplitSRConv(FSSpec mySpec, long newRate);short GetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);OSErr sendPTRegion(FSSpec theTransferredFile);Boolean transferProToolsWithRegion(FSSpec sourceSpec);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);void transferProToolsManySpot(void);void writeLogP(Str255 theLogTextPtr);OSErr SDIITileRegionsIntoPTMany(void);OSErr makeSuredCodeisRunning(void);Boolean ConvertAIFFToSDII(FSSpec mySpec, FSSpec destSpec);extern FSSpec theApplSpec;Boolean SwitchToApp(long lSignature);OSErr sendODOCEvent(FSSpec theTransferredFile, OSType destProcess);long convertSamplesFramesToTCFrames (long SRate, long theTimeStamp, short frameRate);typedef struct FindFileRec {	Str31	FileName;	Str27	VolumeName;	short	VolRefNum;	long	DirID;	OSType 	FileType;} FindFileRec, *FindFileRecPtr;Boolean WAVToSDII(FSSpec mySpec);typedef struct AudioFilesRec {	long	Version;	long	NumFiles;} AudioFilesRec, *AudioFilesRecPtr;void ProToolsSpotRegionII (FSSpec theFile,Str255 regionName, short trkNum, long startFrame, long endFrame, long spotTimeInSamples, short theSessFrameRate);void Audition(FSSpec mySpec, short playFreq);#define PT24FPS 0000#define PT25FPS 0001#define PT2997NDFPS 0004#define PT2997DFFPS 0005#define PT30FPS 0003#define PT30DFFPS 0002OSErr swapNames (FSSpec* sourceSpec,FSSpec* tempSpec);void SendTextToMessageBoard(Str255 theText );void checkForMPG(StringPtr theName,FInfo * theFinfo);void checkForWAV(StringPtr theName,FInfo * theFinfo);Boolean SDII16To24II(FSSpec theSourceSpec, FSSpec theSpec);typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;Boolean fileMissing = false;Boolean spotRegions(FSSpec mySpec);Boolean scanList(Str255	theDrive);extern Str255 leftSuffixStr,rightSuffixStr;void checkList(void);void saveForUndo (void);pascal Boolean zmySDDlgFilter (DialogPtr theDialog, EventRecord *theEvent,short *itemHit);		pascal	OSErr	myPBCatSearchSyncCompat(CSParamPtr paramBlock);					 	pascal	OSErr	PBCatSearchSyncCompat(CSParamPtr paramBlock);						 OSErr copyFile(FSSpec sourceSpec, FSSpec destspec);short ptResolvePickOne(short numEntries, FSSpec * theFiles);extern  FSSpec theConvertDestLoc;Boolean SDII16to8(FSSpec theSpec);Boolean VgetvolName(short theVRefNum, StringPtr myString);Boolean ProToolsResolve (FSSpec mySpec);Boolean updateDisk;Boolean makeList;extern OSType  myeventFileType;    //	'APPL'extern OSType  myeventCreatorType;   //'WILD'extern unsigned long myEventID;	//kAEOpenDocumentsextern unsigned long myEventClass;  //kCoreEventClass						OSErr FindAProcess(OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN);OSErr PFindAProcess(OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN);			Boolean checkReference(short	indexToSpec);		void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);OSErr sendPTAEvent(FSSpec theTransferredFile, Boolean sendRegions);short theNewPTListCounter;FSSpec** theProToolsFiles;FInfo** theProToolsTypes; Boolean problemOccurred;Boolean resolvePTMany(void);Boolean resolvePTMany(void){	Cell theCell;	short theindex;	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	short itemHit;	FSSpec theNewPTList;	StandardFileReply PTreply;	GrafPtr savePort;		GetPort(&savePort);	myDlg = GetNewDialog(3333,0L,(WindowPtr)-1);	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;						case 1:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					updateDisk = false;					makeList = true;				}				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					updateDisk = true;					makeList = true;				}				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					updateDisk = true;					makeList = false;				}			break;						case 2:			break;					}	}	DisposDialog(myDlg);	if (itemHit == 2)	{		color.red = 0xFFFF;		color.green = 0xFFFF;		color.blue = 0xFFFF;		RGBBackColor(&color);		return 0;	}			if (makeList)	{		StandardPutFile("\pEnter a name for the new list","\pUntitled",&PTreply);		if (!PTreply.sfGood)			return false;					if (PTreply.sfReplacing)		{			FSpDelete(&(PTreply.sfFile));		}				BlockMove (&(PTreply.sfFile), &theNewPTList,70L);	}		theProToolsFiles = (FSSpec **)NewHandle(172000L);	if (!theProToolsFiles)	{		genError ("\pNot enough memory for that operation");		SetPort(savePort);		return false;	}		theProToolsTypes = (FInfo **)NewHandle(40000L);	if (!theProToolsTypes)	{		genError ("\pNot enough memory for that operation");		SetPort(savePort);		DisposHandle((Handle)theProToolsFiles);		return false;	}	theNewPTListCounter = 0;		fileMissing = false;	/*******************/	SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				ProToolsResolve ((*therealResults)[theindex]);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (makeList)	{		PTMemToFSSpec(theNewPTList);		saveForUndo ();		openFSList(theNewPTList);		checkList();		gogetvolref();		resolveOVols();	}		DisposHandle((Handle)theProToolsFiles);	DisposHandle((Handle)theProToolsTypes);	watchcursor(false);	/**********************/	if (fileMissing)	{		genError("\pSome files could not be resolved, consult the SampleSearch Log for details");	}	return true;}Boolean ProToolsResolve (FSSpec mySpec){	short fRefNum, iRefNum;	Handle hData;	FInfo fndrInfo;	AudioFilesRec theAFRec;	FindFileRec theFFrec;	long theSizeofPTdata;	long theFileCount;	long z;	OSErr	iErr;	OSType myFadeTest;			iRefNum = CurResFile();	iErr = FSpGetFInfo(&mySpec,&fndrInfo);		if (fndrInfo.fdType != 'PSes' && fndrInfo.fdType != 'PT4S' && fndrInfo.fdType != 'PT24' && fndrInfo.fdType != 'PT5S')		return false;			fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (fRefNum == -1)	{		genError ("\pCan't open file");		return false;	}	UseResFile(fRefNum);	hData = Get1Resource('ddFP',1000);	if (!hData)	{		genError ("\pCan't get information from file");		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		theSizeofPTdata = SizeResource(hData);	theFileCount = (theSizeofPTdata - sizeof(AudioFilesRec)) / sizeof (FindFileRec);	if (!theFileCount)	{		genError ("\pSession has no files attached");		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}			BlockMove (*hData, &theAFRec, sizeof(AudioFilesRec));		if (theFileCount != theAFRec.NumFiles)	{		genError ("\pData Mismatch in file, this files parameters don't add up, Beware");		/*CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;*/		}		if (theNewPTListCounter >2439)	{		genError ("\pToo many Files");		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		BlockMove (&mySpec,&((*theProToolsFiles)[theNewPTListCounter]),70L);  /* this enters the session itself into the list of files you may not want this */	BlockMove (&fndrInfo,&((*theProToolsTypes)[theNewPTListCounter]),16L); /* this type info is irrelevant */	theNewPTListCounter ++;  /* this enters the session itself into the list of files you may not want this */		progressCreate ("\pResolving Session");	writeLogP("\p------------------------------------");	writeLogP("\pStarting Resolve of File :");	writeLogP(mySpec.name);	writeLogP("\p>>>");//	fileMissing = false;	for (z=0;z<theFileCount;z++)	{		if (progressDisp(z*100 / theFileCount))		{			SysBeep(5);			CloseResFile(fRefNum);			UseResFile(iRefNum);			return false;		}		if (theNewPTListCounter >2439)		{			writeLogP("\pThis session contains more than 2439 files - aborting");			genError ("\pToo many Files");			CloseResFile(fRefNum);			UseResFile(iRefNum);			progressDispos();			return false;		}				BlockMove ((*hData) + (z * sizeof (FindFileRec)) + sizeof(AudioFilesRec),&theFFrec,sizeof (FindFileRec));				iErr = FSMakeFSSpec(FgetVRefNum(theFFrec.VolumeName),theFFrec.DirID,theFFrec.FileName,&((*theProToolsFiles)[theNewPTListCounter]));		 (*(FInfo*)&((*theProToolsTypes)[theNewPTListCounter])).fdType = theFFrec.FileType;				if (theFFrec.FileType == 'PT4S' || theFFrec.FileType == 'PT24' || theFFrec.FileType == 'PT5S')		{			(*(FInfo*)&((*theProToolsTypes)[theNewPTListCounter])).fdCreator = 'PTul'; /* check the file type */		}		else		{			(*(FInfo*)&((*theProToolsTypes)[theNewPTListCounter])).fdCreator = 'Sd2a'; /* check the file type */		}				(*(FInfo*)&((*theProToolsTypes)[theNewPTListCounter])).fdFldr = 0;				if (iErr != 0)		{			BlockMove (theFFrec.FileName + 1, &myFadeTest,4L);			if (myFadeTest == 'Fade' && theNewPrefs.ignorePTFades)			{				theNewPTListCounter --;				/* ignore it */			}			else			{				if (!(resolvePTSpec(theFFrec.FileName, 0, 0, theFFrec.FileType)))				{					writeLogP("\pCould not resolve the file :");					writeLogP(theFFrec.FileName);					fileMissing = true;				}				else				{					if (updateDisk)					{						theFFrec.VolRefNum = (*(FSSpec*)&((*theProToolsFiles)[theNewPTListCounter])).vRefNum;						VgetvolName(theFFrec.VolRefNum, (theFFrec.VolumeName));						theFFrec.DirID =  (*(FSSpec*)&((*theProToolsFiles)[theNewPTListCounter])).parID;						BlockMove (&theFFrec,(*hData) + (z * sizeof (FindFileRec)) + sizeof(AudioFilesRec),sizeof (FindFileRec));					}				}			}		}		theNewPTListCounter ++;	}	writeLogP("\pDONE");		progressDispos();	if (updateDisk)	{		ChangedResource(hData);	}	CloseResFile(fRefNum);	UseResFile(iRefNum);		return true;}Boolean resolvePTSpec(Str31	myFileName, long	catHint, short driveHint, OSType	theType){	HParamBlockRec RPb; 				/** parameter block for PBCatSearch **/	short z;	long numsofar;	FSSpec * theResolveSpec;		/*FSSpec	theResolveSpec[199];*/	OSErr	gErr;	FSSpec	retSpec;			char *occur;	Str255 Cstring,substring;		retSpec.vRefNum = -999;/* bus error here */		gogetvolref();		theResolveSpec = (FSSpec *)NewPtrClear(1000 * 70L);	if (!theResolveSpec)	{		genError("\pNot enough memory to resolve");		return false;	}		/**********************/	/**********************/	numsofar = 0;	for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{	 BlockMove (volName[z],Cstring,28L);	  PtoCstr (Cstring);	  makeStr255("\pAudio CD",substring);	  PtoCstr (substring);	  occur = strstr((const char *)Cstring,(const char *)substring);	if (!(*volName[z]))	{		occur = (Ptr)1;	}	  if (!occur)	  {	  if (!scanList(volName[z]))		{		  			RPb.csParam.ioVRefNum = volumes[z];		/** select relevant volume **/						RPb.csParam.ioCompletion = nil;  				/** no completion routine **/			RPb.csParam.ioNamePtr = nil;   			 		/** no volume name;  use vRefNum **/			RPb.csParam.ioMatchPtr = theResolveSpec + (numsofar * 70L);  			/** points to results buffer **/			RPb.csParam.ioReqMatchCount = 1000-numsofar;   	/** number of matches **/												/** search for name + file or directory + file TYPE  **/			RPb.csParam.ioSearchBits = fsSBFullName + fsSBFlAttrib + fsSBFlFndrInfo;												RPb.csParam.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/			RPb.csParam.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/			RPb.csParam.ioSearchTime = 0;              	/** don't time out on searches **/			RPb.csParam.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/			RPb.csParam.ioOptBuffer = gBuffer;    			/** point to search cache  **/			RPb.csParam.ioOptBufSize  = kOptBufferSize;		/** size of search cache **/					gSpec1.hFileInfo.ioNamePtr = myFileName;   		/** point to string to find **/			gSpec1.hFileInfo.ioFlAttrib = 0x00;      		/** clear bit 4 to ask for files **/			gSpec1.hFileInfo.ioFlFndrInfo.fdType = theType ; //searchType;	/** just find ???? files **/			gSpec1.hFileInfo.ioFlFndrInfo.fdCreator = 0;						gSpec2.hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/			gSpec2.hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/			gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  			gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0;												if (theNewPrefs.dontFindAliases)			{				gSpec1.hFileInfo.ioFlFndrInfo.fdFlags = 0;				gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;					}							else				{					gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;					}				watchcursor(TRUE);					/** display watch **/			do 			{				gErr = myPBCatSearchSyncCompat((CSParam *)&RPb);	/** get some files returns error 0 (noErr) if it returns without finishing **/			} while (gErr == 0 && ((theNewPrefs.PTResolveFindOne) ? (RPb.csParam.ioActMatchCount == 0) : true));			if ( RPb.csParam.ioActMatchCount > 0 && theNewPrefs.PTResolveFindOne)			{				numsofar ++;				break;															/** display arrow **/			}			 	 }	  }	  numsofar += RPb.csParam.ioActMatchCount;	}	watchcursor(FALSE);	if ( numsofar == 0)	{				FlashMenuBar(0);			FlashMenuBar(0);		DisposPtr((Ptr)theResolveSpec);		return false;	}	else	{			if ( numsofar > 0)		{			if ((theNewPrefs.PTResolveFindOne) || (numsofar == 1))			{				BlockMove(&(theResolveSpec[0]),&retSpec,70L); 				BlockMove (&retSpec, &((*theProToolsFiles)[theNewPTListCounter]), 70L);				DisposPtr((Ptr)theResolveSpec);				return true;			}			else			{				short myReturn = ptResolvePickOne(numsofar, theResolveSpec);				if (myReturn == -99)				{					DisposPtr((Ptr)theResolveSpec);					return false;				}				else				{									BlockMove(&(theResolveSpec[myReturn]),&retSpec,70L); 					BlockMove (&retSpec, &((*theProToolsFiles)[theNewPTListCounter]), 70L);					DisposPtr((Ptr)theResolveSpec);					return true;				}			}		}	}	DisposPtr((Ptr)theResolveSpec);	return false;}void PTsaveFSList(FSSpec mySpec){	OSErr	iErr;		short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	long theProToolsTypesCount;	short iRefNum;	Handle hString[16];		iErr = FSpCreate(&mySpec,'MgAl','SFlf',0);	if (iErr!=0)		genError("\pCould not create file");	iErr = HOpen(mySpec.vRefNum,mySpec.parID,mySpec.name,2,&myRefNum);	if (iErr!=0)		genError("\pCould not open new file");	myInOutCounter = theNewPTListCounter * 70L; 	totfindlen = 4;	iErr = FSWrite(myRefNum,&totfindlen,&myInOutCounter);	if (iErr!=0)		genError("\pCould not write to new file");	iErr = FSWrite(myRefNum,&myInOutCounter,(*theProToolsFiles));	if (iErr!=0)		genError("\pCould not write to new file");			iErr = FSWrite(myRefNum,&totfindlen,&theNewPTListCounter);	if (iErr!=0)		genError("\pCould not write to new file");		theProToolsTypesCount = theNewPTListCounter*sizeof(FInfo);			 	HLock((Handle)theProToolsTypes);										// needs to be implemented 	iErr = FSWrite(myRefNum,&theProToolsTypesCount,*theProToolsTypes);		if (iErr!=0)		genError("\pCould not write to new file");	HUnlock ((Handle)theProToolsTypes);	iErr = FSClose(myRefNum);		//myRefNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);		gogetvolref();	iRefNum = CurResFile();		HCreateResFile(mySpec.vRefNum,mySpec.parID,mySpec.name);	iErr = ResError();	if (iErr!=0)		genError("\pCould not create resource file");	myRefNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);		if (myRefNum == -1)		genError("\pCould not open new resource fork");	UseResFile(myRefNum);		iErr = ResError();		if (iErr!=0)		genError("\pCould not use new resource fork");	for (z=1;z<=volumearrayptr;z++)	{			hString[z] = NewHandle(256);		//MoveHHi(hString[z]);		BlockMove(volName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{			hString[z] = NewHandle(256);		//MoveHHi(hString[z]);		BlockMove(fvolName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}		CloseResFile(myRefNum);	for (z=1;z<=fvolumearrayptr;z++)		{			//DisposHandle (vRefRes[z]);			ReleaseResource(hString[z]);			//DisposHandle (hString[z]);		}	UseResFile(iRefNum);		iErr = ResError();	if (iErr!=0)		genError("\pCould not use old resource file");	iErr = FlushVol(0,mySpec.vRefNum);/*	if (iErr!=0)		genError("\pCould not flush volume");*/}Boolean PTMemToFSSpec(FSSpec mySpec){	short z,x;	short refNum,iRefNum;	StandardFileReply	theReply;	short selectedCounter;	Cell theCell;	short theindex;	long inOutCount,numberOfEntries, currentPos;	Handle	volumeName[499],volumeRef[499];	extern FSSpec	faveFSpec, faveISpec;	OSErr	iErr;	OSType theType = 'SFlf';					iErr = FSpCreate(&mySpec,'MgAl',theType,0);	if (iErr!=0)	{		genError ("\pCan't create new file");		return false;	}		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		genError ("\pCan't open the new file");		return false;	}			inOutCount = 4L;		numberOfEntries = theNewPTListCounter * 70L;		iErr = FSWrite(refNum,&inOutCount,&numberOfEntries);		if (iErr!=0)		{			genError ("\pProblem writing data to file");			return false;		}		inOutCount = theNewPTListCounter * 70L;		iErr = FSWrite(refNum,&inOutCount,*theProToolsFiles);		if (iErr!=0)		{			genError ("\pProblem writing data to file");			return false;		}		inOutCount = 4L;		numberOfEntries = theNewPTListCounter;		iErr = FSWrite(refNum,&inOutCount,&numberOfEntries);		if (iErr!=0)		{			genError ("\pProblem writing data to file");			return false;		}		inOutCount = theNewPTListCounter * 16L;		iErr = FSWrite(refNum,&inOutCount,*theProToolsTypes);		if (iErr!=0)		{			genError ("\pProblem writing data to file");			return false;		}			FSClose (refNum);	FSpCreateResFile(&mySpec,'MgAl',theType,0);	/** add OVOLS and OREFS**/	iRefNum = CurResFile();	refNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!refNum)	{		genError ("\pProblem opening resource fork");		return false;	}	for (z=1; z<=volumearrayptr;z++)	/** mounted vols **/	{		volumeName[z] = NewHandle(63);		if (!volumeName[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		volumeRef[z] = NewHandle(2);		if (!volumeRef[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		BlockMove (volName[z],*(volumeName[z]),28L);				AddResource(volumeName[z],'oVOL',z,"\pVolume Name");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			UseResFile(iRefNum);			return false;		}		**(volumeRef[z]) = volumes[z];		AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			UseResFile(iRefNum);			return false;		}	}	for (z=volumearrayptr+1; z<=fvolumearrayptr;z++)	/** ghost vols **/	{		volumeName[z] = NewHandle(63);		if (!volumeName[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		volumeRef[z] = NewHandle(2);		if (!volumeRef[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		BlockMove (fvolName[z],*(volumeName[z]),28L);		AddResource(volumeName[z],'oVOL',z,"\pVolume Name");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			UseResFile(iRefNum);			return false;		}		**(volumeRef[z]) = fvolumes[z];		AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			UseResFile(iRefNum);			return false;		}	}	CloseResFile(refNum);	UseResFile(iRefNum);	for (z=1;z<=fvolumearrayptr;z++)	{		ReleaseResource(volumeRef[z]);					ReleaseResource(volumeRef[z]);	}	}void transferProToolsMany(Boolean sendRegions);void transferProToolsMany(Boolean sendRegions){	Cell theCell;	short theindex;	Boolean memoryError = false;	FSSpec thePresDestination;	Str63 testName = "\p@@@@";	FSSpec testSpec;		writeLogS((unsigned char *)"Starting ProTools transfer");	SetPt( &theCell, 0,0 );		/* start at top of list  */	//getConvertDest();		thePresDestination = theConvertDestLoc;		if (theNewPrefs.theBITPTPrefs.destFolderValid)	{		OSErr iErr;				BlockMove (&theNewPrefs.theBITPTPrefs.destFolder, &testSpec,70L);		//translateParentToChildFolder(&theConvertDestLoc);		translateParentToChildFolder(&testSpec);			makeStr255 ("\p~@@@~~@@",testSpec.name);					iErr = FSpCreate(&testSpec,'test','test',0);		switch (iErr)		{			case noErr:						break;						case -48:						break;						default:				genError ("\pYour target folder is not valid, please choose a new folder");				iErr = GetFileGray(&theNewPrefs.theBITPTPrefs.destFolder);				if (iErr)				{					theNewPrefs.theBITPTPrefs.destFolderValid = false;						theNewPrefs.theBITPTPrefs.destFolder.vRefNum = -1;					theNewPrefs.theBITPTPrefs.destFolder.parID = 2;					return;				}				else				{					theNewPrefs.theBITPTPrefs.destFolderValid = true;				}			break;					}		iErr = FSpDelete(&testSpec);		theConvertDestLoc = theNewPrefs.theBITPTPrefs.destFolder;	}	else	{		OSErr iErr  =  GetFileGray(&theNewPrefs.theBITPTPrefs.destFolder);		if (iErr)		{			theNewPrefs.theBITPTPrefs.destFolderValid = false;				theNewPrefs.theBITPTPrefs.destFolder.vRefNum = -1;			theNewPrefs.theBITPTPrefs.destFolder.parID = 2;			return;		}		else		{			theNewPrefs.theBITPTPrefs.destFolderValid = true;		}	}		theConvertDestLoc = theNewPrefs.theBITPTPrefs.destFolder;		translateParentToChildFolder(&theConvertDestLoc);			while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (checkReference (theindex))		{			if (transferProTools((*therealResults)[theindex],sendRegions))			{				writeLogP((*therealResults)[theindex].name);					memoryError = false;			}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLogP((*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		//theConvertDestLoc = thePresDestination;	if (memoryError)		genError("\pSome files could not be transferred, consult the SampleSearchª Log for details");}FSSpec theNewFileLeft, theNewFileRight;Boolean ignoreRegZeroSpot = true;Boolean sessionframerate = PT25FPS;short theSpotTrack = 1;OSErr SDIITileRegionsIntoPT(FSSpec sourceFile);long tileframeCount = 0;/* spotting is based on 30FPS so it leaves a gap *//* plus we add a frame every region */OSErr SDIITileRegionsIntoPTMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	FSSpec thePresDestination;	Str63 testName = "\p@@@@";	FSSpec testSpec;	Str255 endName;/* hard coded to 25FPS and trak 1 and ignore reg 1 */	ignoreRegZeroSpot = true;	theSpotTrack =1;	sessionframerate = PT25FPS;		tileframeCount = 0;	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		BlockMove ((*therealResults)[theindex].name + (*(*therealResults)[theindex].name - 1),endName + 1,2);		*endName = 2;				theSpotTrack = 1;		if(EqualString(endName,"\p.R",false,false) || EqualString(endName,"\p-R",false,false) ) 		{			/* put it on trk 2 */			theSpotTrack = 2;		}		SDIITileRegionsIntoPT((*therealResults)[theindex]);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}OSErr SDIITileRegionsIntoPT(FSSpec sourceFile){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle hRsrc;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	long regtimeStamp;	FSSpec destFile;	Str255 theNumString;	long theBytes;	long theRate;	long theDuration;	Boolean stereo;	short theWordSize;	ignoreRegZeroSpot = isPressed(0x37);		getSDIIData (sourceFile, &theRate,&theWordSize,&stereo, &theBytes);	iErr = FSpGetFInfo(&sourceFile,&fndrInfo);	if (iErr !=0)	{		SysBeep(5);		return false;	}		if (fndrInfo.fdType != 'Sd2f')	{		return false;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&sourceFile,fsCurPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}		UseResFile(fRefNum);		hRsrc = Get1Resource('ddRL',1000);	if (!hRsrc)	{		regionCount = 0;		goto skipper;	}		lByteCnt = SizeResource(hRsrc);		if (lByteCnt <= 18L)	{	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(hRsrc);skipper:		CloseResFile(fRefNum);	UseResFile(iRefNum);	if (!regionCount)	{		ProToolsSpotRegionII (sourceFile,sourceFile.name, theSpotTrack,0,theBytes >> (stereo + (theWordSize - 1)) , tileframeCount, PT30FPS);		tileframeCount += theBytes >> (stereo + (theWordSize - 1));		tileframeCount += 2000L;	}	else	{		for (z = (ignoreRegZeroSpot) ? 1 : 0;z<regionCount;z++)		{					BlockMove ((((*hRsrc) +18)+(56L * z)), &tempRegRec, 56L);			ProToolsSpotRegionII (sourceFile,tempRegRec.RegionName, theSpotTrack, tempRegRec.StartFrame, tempRegRec.StopFrame, tileframeCount, PT30FPS);			tileframeCount += tempRegRec.StopFrame - tempRegRec.StartFrame;			tileframeCount += 2000L;		}	}	if (hRsrc)		DisposHandle (hRsrc);	return true;}void transferProToolsManySpot(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	FSSpec thePresDestination;	Str63 testName = "\p@@@@";	FSSpec testSpec;	Str255 endName;/* hard coded to 25FPS and trak 1 and ignore reg 1 */	ignoreRegZeroSpot = true;	theSpotTrack =1;	sessionframerate = PT25FPS;	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				BlockMove ((*therealResults)[theindex].name + 1 + (*(*therealResults)[theindex].name - 1),endName + 1,1);		*endName = 1;				theSpotTrack = 1;		if(EqualString(endName,"\pR",false,false) || EqualString(endName,"\p2",false,false) ) 		{			/* put it on trk 2 */			theSpotTrack = 2;		}		spotRegions((*therealResults)[theindex]);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}Boolean spotRegions(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle hRsrc;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	long regtimeStamp;	FSSpec destFile;	Str255 theNumString;	Boolean spotToUser = isPressed(0x3B);	ignoreRegZeroSpot = isPressed(0x37);		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		SysBeep(5);		return false;	}		if (fndrInfo.fdType != 'Sd2f')	{		return false;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}		UseResFile(fRefNum);		hRsrc = Get1Resource('ddRL',1000);		if (!hRsrc)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		lByteCnt = SizeResource(hRsrc);		if (lByteCnt <= 18L)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(hRsrc);	CloseResFile(fRefNum);	UseResFile(iRefNum);		for (z = (ignoreRegZeroSpot) ? 1 : 0;z<regionCount;z++)	{				BlockMove ((((*hRsrc) +18)+(56L * z)), &tempRegRec, 56L);		ProToolsSpotRegionII (mySpec,tempRegRec.RegionName, theSpotTrack, tempRegRec.StartFrame, tempRegRec.StopFrame, spotToUser ? tempRegRec.TimeStampMS : tempRegRec.TimeStampLS, sessionframerate);	}		DisposHandle (hRsrc);	return true;}extern FSSpec theNewFileLeft, theNewFileRight;Boolean transferProTools(FSSpec sourceSpec, Boolean sendRegions){	OSErr	iErr,theErr;	FSSpec destspec,tempSpec;	Str255 theStrTemp;	FInfo fndrInfo;	//Boolean problemOccurred;	short theSource, theDestination;	Ptr copyBuff;	long inOutCount;	long bytesToCopy, bytesCopied = 0L;	HFileInfo pb;	long theRate=0;	short theWordSize;	Boolean stereo;	long theBytes;	long theSRate;	long theDuration;	Boolean isStereo,needtochange;	long bytes;	Str255 temperStr;	short Sstereo;	pb.ioFDirIndex = 0;	pb.ioNamePtr = sourceSpec.name;	pb.ioVRefNum = sourceSpec.vRefNum;	pb.ioDirID = sourceSpec.parID;	iErr = PBGetCatInfo((union CInfoPBRec *)&pb,false);	if (iErr)	{			genError("\pCan't get info for source file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred : Can't get info for source file : ");			writeLogP(sourceSpec.name);			writeLogS((unsigned char *)"abandoning transfer function");			writeLogS((unsigned char *)" ");			return false;	}		bytesToCopy = pb.ioFlLgLen;		/* maybe add the opyion to copy it locally  and make it a pref */	/* add a global preference to control file automatic deletion */	 	 /* at this point allow you to force a local copy */	 	 BlockMove (&sourceSpec,&destspec,70L);	 makeStr255(sourceSpec.name,temperStr);	 iErr = 0;	 	 while (iErr != -43)	 {		iErr = FSMakeFSSpec(theConvertDestLoc.vRefNum,theConvertDestLoc.parID,temperStr,&destspec);		if (iErr != -43)		{			concatStrings(temperStr,"\p~","\p");		}	}			if ((isPTExcludedDrive (sourceSpec.vRefNum) || (sourceSpec.vRefNum == theConvertDestLoc.vRefNum)) && !theNewPrefs.theBITPTPrefs.forceCopy)  /* on correct drive */	{		OSType myWAVType;		FInfo fndrInfo;				iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);		switch(fndrInfo.fdType)		{			case 'Sd2f':				getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes);				if (!stereo || (!theNewPrefs.theBITPTPrefs.splitFiles))  /* mono or interleaved stereo */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							convertSRSD2File(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit)							{								tempSpec = destspec;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(destspec,tempSpec);								iErr = FSpDelete(&destspec);								iErr = FSpRename(&tempSpec,destspec.name);							}							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						else						{							if (theNewPrefs.theBITPTPrefs.forceCopy)							{								if ((theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit) && (theWordSize == 2))								{									SDII16To24II(sourceSpec,destspec);								}								else								{									copyFile(sourceSpec,destspec);								}								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}							else							{									createSDIIOverview(sourceSpec,0x00000100);								sendPTAEvent(sourceSpec,sendRegions);							}							}										}					else					{						if (theNewPrefs.theBITPTPrefs.forceCopy)						{							copyFile(sourceSpec,destspec);							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						else						{							createSDIIOverview(sourceSpec,0x00000100);							sendPTAEvent(sourceSpec,sendRegions);						}					}					return true;				}				else /* split stereo */				{					/* samplerate convert here */					if (theNewPrefs.theBITPTPrefs.changeRate)					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							SDIIStereoToMonoLRSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)							{								tempSpec = theNewFileLeft;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileLeft,tempSpec);								iErr = FSpDelete(&theNewFileLeft);								iErr = FSpRename(&tempSpec,theNewFileLeft.name);								tempSpec = theNewFileRight;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileRight,tempSpec);								iErr = FSpDelete(&theNewFileRight);								iErr = FSpRename(&tempSpec,theNewFileRight.name);							}						}						else						{							makeStr255 ("\p.L",leftSuffixStr);							makeStr255 ("\p.R",rightSuffixStr);							SDIIStereoToMonoLR(sourceSpec);							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)							{								tempSpec = theNewFileLeft;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileLeft,tempSpec);								iErr = FSpDelete(&theNewFileLeft);								iErr = FSpRename(&tempSpec,theNewFileLeft.name);								tempSpec = theNewFileRight;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileRight,tempSpec);								iErr = FSpDelete(&theNewFileRight);								iErr = FSpRename(&tempSpec,theNewFileRight.name);							}						}										}					else					{						makeStr255 ("\p.L",leftSuffixStr);						makeStr255 ("\p.R",rightSuffixStr);						SDIIStereoToMonoLR(sourceSpec);						if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)						{							tempSpec = theNewFileLeft;							*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;							SDII16To24II(theNewFileLeft,tempSpec);							iErr = FSpDelete(&theNewFileLeft);							iErr = FSpRename(&tempSpec,theNewFileLeft.name);							tempSpec = theNewFileRight;							*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;							SDII16To24II(theNewFileRight,tempSpec);							iErr = FSpDelete(&theNewFileRight);							iErr = FSpRename(&tempSpec,theNewFileRight.name);						}							/* check for 16-24 bit !! */					}					createSDIIOverview(theNewFileLeft,0x00000100);					createSDIIOverview(theNewFileRight,0x00000100);					sendPTAEvent(theNewFileLeft,sendRegions);					sendPTAEvent(theNewFileRight,sendRegions);					return true;				}			break;						case 'AIFF':				/* convert to SDII */				getAIFFDataII (sourceSpec,&theRate, &theWordSize,&Sstereo, &theBytes);						needtochange = false;				if (Sstereo == 2 && theNewPrefs.theBITPTPrefs.splitFiles)				{					needtochange = true;				}				if (Sstereo == 2 && theNewPrefs.theBITPTPrefs.splitFiles)				{					needtochange = true;				}				if (theNewPrefs.theBITPTPrefs.changeRate)				{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))					{						needtochange = true;					}				}				if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)				{						needtochange = true;				}				if (needtochange)				{						tempSpec = sourceSpec;					*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;					ConvertAIFFToSDII(sourceSpec, tempSpec);					swapNames (&sourceSpec,&tempSpec);					iErr = transferProTools(tempSpec,sendRegions);					swapNames (&sourceSpec,&tempSpec);					FSpDelete(&tempSpec);					return iErr;				}				if (!Sstereo || (!theNewPrefs.theBITPTPrefs.splitFiles))  /* mono or interleaved */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{													if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							tempSpec = sourceSpec;							*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;							ConvertAIFFToSDII(sourceSpec, tempSpec);							swapNames (&sourceSpec,&tempSpec);							convertSRSD2File(tempSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit)							{								tempSpec = destspec;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x82;								SDII16To24II(destspec,tempSpec);								iErr = FSpDelete(&destspec);								iErr = FSpRename(&tempSpec,destspec.name);							}							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);							swapNames (&sourceSpec,&tempSpec);							FSpDelete(&tempSpec);						}						else						{							if (theNewPrefs.theBITPTPrefs.forceCopy)							{								copyFile(sourceSpec,destspec);								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}							else							{									createSDIIOverview(sourceSpec,0x00000100);								sendPTAEvent(sourceSpec,sendRegions);							}							}										}					else					{						if (theNewPrefs.theBITPTPrefs.forceCopy)						{							copyFile(sourceSpec,destspec);							//createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						else						{							//createSDIIOverview(sourceSpec,0x00000100);							sendPTAEvent(sourceSpec,sendRegions);						}					}					return true;				}				else /* stereo to split */				{					/* samplerate convert here */					tempSpec = sourceSpec;					*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;					ConvertAIFFToSDII(sourceSpec, tempSpec);					swapNames (&sourceSpec,&tempSpec);					if (theNewPrefs.theBITPTPrefs.changeRate) 					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							SDIIStereoToMonoLRSRConv(tempSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));						}						else						{							makeStr255 ("\p.L",leftSuffixStr);							makeStr255 ("\p.R",rightSuffixStr);							SDIIStereoToMonoLR(tempSpec);						}										}					else					{						makeStr255 ("\p.L",leftSuffixStr);							makeStr255 ("\p.R",rightSuffixStr);						SDIIStereoToMonoLR(tempSpec);					}					createSDIIOverview(theNewFileLeft,0x00000100);					createSDIIOverview(theNewFileRight,0x00000100);					sendPTAEvent(theNewFileLeft,sendRegions);					sendPTAEvent(theNewFileRight,sendRegions);					swapNames (&sourceSpec,&tempSpec);					FSpDelete(&tempSpec);					return true;				//	sendPTAEvent(sourceSpec,sendRegions);				}			break;			case 'MPEG':case '.MPG':case 'MPG ':case 'PLAY':case 'MP3 ':case '.MP3':case '.mp3':case 'Mp3 ':				if (!makeSuredCodeisRunning())				{					ProcessSerialNumber process;					Str255 thePth, theCommands = "\pbitp_";					PathNameFromDirID(sourceSpec.parID, sourceSpec.vRefNum,(StringPtr)thePth);					concatStrings(thePth,sourceSpec.name,"\p");					concatStrings(theCommands,thePth,"\p");					SwitchToApp('dCOD');					SendTextToMessageBoard(theCommands);				//	sendODOCEvent(sourceSpec, 'dCOD');				}				return true;			break;			case '.WAV':case 'WAVE':case 'bin ':				if (!GetWAVInfo (sourceSpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))				{					return false;				}				if (isStereo && theNewPrefs.theBITPTPrefs.splitFiles) /* stereo wav */				{					/* samplerate convert here */					WAVStereoToSDIISplitSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));					createSDIIOverview(theNewFileLeft,0x00000100);					createSDIIOverview(theNewFileRight,0x00000100);					sendPTAEvent(theNewFileLeft,sendRegions);					sendPTAEvent(theNewFileRight,sendRegions);				}				else /* mono wav */				{					BlockMove(&sourceSpec,&destspec,70L);					destspec.parID = theConvertDestLoc.parID;					destspec.vRefNum = theConvertDestLoc.vRefNum;					/* samplerate convert here */					if (theNewPrefs.theBITPTPrefs.changeRate)					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							WAVToSDIISRConv(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						else /* already Correct rate */						{							WAVToSDII(sourceSpec);							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}					}						else /* dont SR Conv */					{						WAVToSDII(sourceSpec);						createSDIIOverview(sourceSpec,0x00000100);						sendPTAEvent(destspec,sendRegions);					}					/*copyFile(sourceSpec, destspec);*/					/*sendPTAEvent(destspec);*/				}				return true;			break;						default:				BlockMove(sourceSpec.name + (*sourceSpec.name) -3L,&myWAVType,4L);				if (myWAVType == '.WAV')				{					if (!GetWAVInfo (sourceSpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))					{						return false;					}					if (isStereo) /* stereo wav */					{						/* samplerate convert here */						WAVStereoToSDIISplitSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));						createSDIIOverview(theNewFileLeft,0x00000100);						createSDIIOverview(theNewFileRight,0x00000100);						sendPTAEvent(theNewFileLeft,sendRegions);						sendPTAEvent(theNewFileRight,sendRegions);					}					else /* mono wav */					{						BlockMove(&sourceSpec,&destspec,70L);						destspec.parID = theConvertDestLoc.parID;						destspec.vRefNum = theConvertDestLoc.vRefNum;						/* samplerate convert here */						if (theNewPrefs.theBITPTPrefs.changeRate)						{							if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))							{								WAVToSDIISRConv(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}							else /* already Correct rate */							{								WAVToSDII(sourceSpec);								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}						}							else /* dont SR Conv */						{							WAVToSDII(sourceSpec);							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						/*copyFile(sourceSpec, destspec);*/						/*sendPTAEvent(destspec);*/					}					return true;				}			break;				}	}	else  /* on WRONG DRIVE */	{		OSType myWAVType;		FInfo fndrInfo;				iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);		switch(fndrInfo.fdType)		{			case 'MPEG':case '.MPG':case 'MPG ':case 'PLAY':case 'MP3 ':case '.MP3':case '.mp3':case 'Mp3 ':				if (!makeSuredCodeisRunning())				{					ProcessSerialNumber process;					Str255 thePth, theCommands = "\pbitp_";					PathNameFromDirID(sourceSpec.parID, sourceSpec.vRefNum,(StringPtr)thePth);					concatStrings(thePth,sourceSpec.name,"\p");					concatStrings(theCommands,thePth,"\p");					SwitchToApp('dCOD');					SendTextToMessageBoard(theCommands);				//	sendODOCEvent(sourceSpec, 'dCOD');				}				return true;			break;				case 'Sd2f': 				getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes);				if (!stereo) /* mono SDII File on wrong drive */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							convertSRSD2File(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit)							{								FSSpec tempSpec;								tempSpec = destspec;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(destspec,tempSpec);								iErr = FSpDelete(&destspec);								iErr = FSpRename(&tempSpec,destspec.name);							}						}						else /* already correct rate */						{ 							if ((theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit) && (theWordSize == 2))							{								SDII16To24II(sourceSpec,destspec);							}							else							{								if ((theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit) && (theWordSize == 2))								{									SDII16To24II(sourceSpec,destspec);								}								else								{									copyFile(sourceSpec,destspec);								}							}						}					}					else					{						if ((theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit) && (theWordSize == 2))						{							SDII16To24II(sourceSpec,destspec);						}						else						{							copyFile(sourceSpec,destspec);						}					}					addFileToList(destspec);					createSDIIOverview(destspec,0x00000100);					sendPTAEvent(destspec,sendRegions);					return true;				}				else /* stereo SDII on wrong drive - we should really check here if we want it split !! */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							SDIIStereoToMonoLRSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));													if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)							{								FSSpec tempSpec;								tempSpec = theNewFileLeft;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileLeft,tempSpec);								iErr = FSpDelete(&theNewFileLeft);								iErr = FSpRename(&tempSpec,theNewFileLeft.name);								tempSpec = theNewFileRight;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileRight,tempSpec);								iErr = FSpDelete(&theNewFileRight);								iErr = FSpRename(&tempSpec,theNewFileRight.name);							}							createSDIIOverview(theNewFileLeft,0x00000100);							createSDIIOverview(theNewFileRight,0x00000100);							sendPTAEvent(theNewFileLeft,sendRegions);							sendPTAEvent(theNewFileRight,sendRegions);						}						else /* correct rate */						{							makeStr255 ("\p.L",leftSuffixStr);							makeStr255 ("\p.R",rightSuffixStr);							SDIIStereoToMonoLR(sourceSpec);							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)							{								FSSpec tempSpec;								tempSpec = theNewFileLeft;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileLeft,tempSpec);								iErr = FSpDelete(&theNewFileLeft);								iErr = FSpRename(&tempSpec,theNewFileLeft.name);								tempSpec = theNewFileRight;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileRight,tempSpec);								iErr = FSpDelete(&theNewFileRight);								iErr = FSpRename(&tempSpec,theNewFileRight.name);							}							createSDIIOverview(theNewFileLeft,0x00000100);							createSDIIOverview(theNewFileRight,0x00000100);							sendPTAEvent(theNewFileLeft,sendRegions);							sendPTAEvent(theNewFileRight,sendRegions);						}					}					else /* dont change rate - just split it */					{						makeStr255 ("\p.L",leftSuffixStr);						makeStr255 ("\p.R",rightSuffixStr);						SDIIStereoToMonoLR(sourceSpec);						if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)						{							FSSpec tempSpec;							tempSpec = theNewFileLeft;							*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;							SDII16To24II(theNewFileLeft,tempSpec);							iErr = FSpDelete(&theNewFileLeft);							iErr = FSpRename(&tempSpec,theNewFileLeft.name);							tempSpec = theNewFileRight;							*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;							SDII16To24II(theNewFileRight,tempSpec);							iErr = FSpDelete(&theNewFileRight);							iErr = FSpRename(&tempSpec,theNewFileRight.name);						}						createSDIIOverview(theNewFileLeft,0x00000100);						createSDIIOverview(theNewFileRight,0x00000100);						sendPTAEvent(theNewFileLeft,sendRegions);						sendPTAEvent(theNewFileRight,sendRegions);					}					return true;				}			break;						case 'AIFF':				getAIFFDataII (sourceSpec,&theRate, &theWordSize,&Sstereo, &theBytes);				/* convert to SDII */						needtochange = false;				if (Sstereo == 2 && theNewPrefs.theBITPTPrefs.splitFiles)				{					needtochange = true;				}				if (Sstereo == 2 && theNewPrefs.theBITPTPrefs.splitFiles)				{					needtochange = true;				}				if (theNewPrefs.theBITPTPrefs.changeRate)				{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))					{						needtochange = true;					}				}				if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)				{						needtochange = true;				}				if (needtochange)				{						tempSpec = sourceSpec;					*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;					ConvertAIFFToSDII(sourceSpec, tempSpec);					swapNames (&sourceSpec,&tempSpec);					iErr = transferProTools(tempSpec,sendRegions);					swapNames (&sourceSpec,&tempSpec);					FSpDelete(&tempSpec);					return iErr;				}				if (!Sstereo || (!theNewPrefs.theBITPTPrefs.splitFiles)) /* mono AIFF File on wrong drive */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{													if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							tempSpec = sourceSpec;							*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;							ConvertAIFFToSDII(sourceSpec, tempSpec);							swapNames (&sourceSpec,&tempSpec);							convertSRSD2File(tempSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit)							{								tempSpec = destspec;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x83;								SDII16To24II(destspec,tempSpec);								iErr = FSpDelete(&destspec);								iErr = FSpRename(&tempSpec,destspec.name);							}							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);							swapNames (&sourceSpec,&tempSpec);							FSpDelete(&tempSpec);						}						else						{							if (theNewPrefs.theBITPTPrefs.forceCopy)							{								copyFile(sourceSpec,destspec);								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}							else							{									createSDIIOverview(sourceSpec,0x00000100);								sendPTAEvent(sourceSpec,sendRegions);							}							}										}					else					{						if (theNewPrefs.theBITPTPrefs.forceCopy)						{							copyFile(sourceSpec,destspec);							//createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						else						{							//createSDIIOverview(sourceSpec,0x00000100);							sendPTAEvent(sourceSpec,sendRegions);						}					}					return true;				}				else /* stereo AIFF on wrong drive */				{					/* samplerate convert here */					tempSpec = sourceSpec;					*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;					ConvertAIFFToSDII(sourceSpec, tempSpec);					swapNames (&sourceSpec,&tempSpec);					if (theNewPrefs.theBITPTPrefs.changeRate) 					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							SDIIStereoToMonoLRSRConv(tempSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							if (theNewPrefs.theBITPTPrefs.sessionResolution == kSession24Bit && theWordSize == 2)							{								tempSpec = theNewFileLeft;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileLeft,tempSpec);								iErr = FSpDelete(&theNewFileLeft);								iErr = FSpRename(&tempSpec,theNewFileLeft.name);								tempSpec = theNewFileRight;								*(tempSpec.name + 1) = *(tempSpec.name + 1) + 0x80;								SDII16To24II(theNewFileRight,tempSpec);								iErr = FSpDelete(&theNewFileRight);								iErr = FSpRename(&tempSpec,theNewFileRight.name);							}						}						else						{							makeStr255 ("\p.L",leftSuffixStr);							makeStr255 ("\p.R",rightSuffixStr);							SDIIStereoToMonoLR(tempSpec);						}										}					else					{						makeStr255 ("\p.L",leftSuffixStr);							makeStr255 ("\p.R",rightSuffixStr);						SDIIStereoToMonoLR(tempSpec);					}					createSDIIOverview(theNewFileLeft,0x00000100);					createSDIIOverview(theNewFileRight,0x00000100);					sendPTAEvent(theNewFileLeft,sendRegions);					sendPTAEvent(theNewFileRight,sendRegions);					swapNames (&sourceSpec,&tempSpec);					FSpDelete(&tempSpec);					return true;				//	sendPTAEvent(sourceSpec,sendRegions);				}			break;						case '.WAV':case 'WAVE':case 'bin ':				if (!GetWAVInfo (sourceSpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))				{					return false;				}				if (isStereo) /* stereo wav */				{					/* samplerate convert here */					WAVStereoToSDIISplitSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));					createSDIIOverview(theNewFileLeft,0x00000100);					createSDIIOverview(theNewFileRight,0x00000100);					sendPTAEvent(theNewFileLeft,sendRegions);					sendPTAEvent(theNewFileRight,sendRegions);				}				else /* mono wav */				{					BlockMove(&sourceSpec,&destspec,70L);					destspec.parID = theConvertDestLoc.parID;					destspec.vRefNum = theConvertDestLoc.vRefNum;					/* samplerate convert here */					if (theNewPrefs.theBITPTPrefs.changeRate)					{						if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))						{							WAVToSDIISRConv(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						else /* already Correct rate */						{							WAVToSDII(sourceSpec);							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}					}						else /* dont SR Conv */					{						WAVToSDII(sourceSpec);						createSDIIOverview(destspec,0x00000100);						sendPTAEvent(destspec,sendRegions);					}					/*copyFile(sourceSpec, destspec);*/					/*sendPTAEvent(destspec);*/				}				return true;			break;						default:				BlockMove(sourceSpec.name + (*sourceSpec.name) -3L,&myWAVType,4L);				if (myWAVType == '.WAV')				{					if (!GetWAVInfo (sourceSpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))					{						return false;					}					if (isStereo) /* stereo wav */					{						/* samplerate convert here */						WAVStereoToSDIISplitSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));						createSDIIOverview(theNewFileLeft,0x00000100);						createSDIIOverview(theNewFileRight,0x00000100);						sendPTAEvent(theNewFileLeft,sendRegions);						sendPTAEvent(theNewFileRight,sendRegions);					}					else /* mono wav */					{						BlockMove(&sourceSpec,&destspec,70L);						destspec.parID = theConvertDestLoc.parID;						destspec.vRefNum = theConvertDestLoc.vRefNum;						/* samplerate convert here */						if (theNewPrefs.theBITPTPrefs.changeRate)						{							if (theRate != ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L))							{								WAVToSDIISRConv(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}							else /* already Correct rate */							{								WAVToSDII(sourceSpec);								createSDIIOverview(destspec,0x00000100);								sendPTAEvent(destspec,sendRegions);							}						}							else /* dont SR Conv */						{							WAVToSDII(sourceSpec);							createSDIIOverview(destspec,0x00000100);							sendPTAEvent(destspec,sendRegions);						}						/*copyFile(sourceSpec, destspec);*/						/*sendPTAEvent(destspec);*/					}					return true;				}			break;		}	}	 	return true;}Boolean transferProTools99(FSSpec sourceSpec, Boolean sendRegions){	OSErr	iErr,theErr;	FSSpec destspec;	Str255 theStrTemp;	FInfo fndrInfo;	short theSource, theDestination;	Ptr copyBuff;	long inOutCount;	long bytesToCopy, bytesCopied = 0L;	HFileInfo pb;	long theRate=0;	short theWordSize;	Boolean stereo;	long theBytes;	long theSRate;	long theDuration;	Boolean isStereo;	long bytes;	Str255 temperStr;	short Sstereo;	short 	sourceRate;	short 	sourceType;	short 	sourceBits;	short 	sourceChans;Boolean needToReproduceData = false;	pb.ioFDirIndex = 0;	pb.ioNamePtr = sourceSpec.name;	pb.ioVRefNum = sourceSpec.vRefNum;	pb.ioDirID = sourceSpec.parID;	iErr = PBGetCatInfo((union CInfoPBRec *)&pb,false);	if (iErr)	{			genError("\pCan't get info for source file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred : Can't get info for source file : ");			writeLogP(sourceSpec.name);			writeLogS((unsigned char *)"abandoning transfer function");			writeLogS((unsigned char *)" ");			return false;	}		bytesToCopy = pb.ioFlLgLen;		/* maybe add the opyion to copy it locally  and make it a pref */	/* add a global preference to control file automatic deletion */	 	 /* at this point allow you to force a local copy */	 	 BlockMove (&sourceSpec,&destspec,70L);	 makeStr255(sourceSpec.name,temperStr);	 iErr = 0;	/* make sure file doesnt already exist at destination */	 while (iErr != -43)	 {		iErr = FSMakeFSSpec(theConvertDestLoc.vRefNum,theConvertDestLoc.parID,temperStr,&destspec);		if (iErr != -43)		{			concatStrings(temperStr,"\p~","\p");		}	}/* figure out whether it needs changing */		if (theNewPrefs.theBITPTPrefs.forceCopy) 	{		if (sourceSpec.vRefNum == theConvertDestLoc.vRefNum && sourceSpec.parID == theConvertDestLoc.parID)		{			/* dont copy....*/		}		else		{			needToReproduceData = true;		}	}	else	{		if (!isPTExcludedDrive (sourceSpec.vRefNum) && (sourceSpec.vRefNum != theConvertDestLoc.vRefNum))		{			needToReproduceData = true;		}	}	iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);	switch(fndrInfo.fdType)	{			case 'Sd2f':				getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes);				sourceRate = theRate;				sourceType = kRAWMotorola;				sourceBits = theWordSize;				sourceChans = stereo + 1;				if (stereo && theNewPrefs.theBITPTPrefs.splitFiles)  /* mono */				{					needToReproduceData = true;				}				if ((theWordSize - 1) != theNewPrefs.theBITPTPrefs.sessionResolution)  /* wrong bit rate */				{					needToReproduceData = true;				}				if (theRate != (theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L)  /* wrong bit rate */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{						needToReproduceData = true;					}				}			break;			case 'AIFF':				getAIFFDataII (sourceSpec,&theRate, &theWordSize,&Sstereo, &theBytes);				sourceRate = theRate;				sourceType = kAIFF;				sourceBits = theWordSize;				sourceChans = Sstereo + 1;				if (Sstereo && theNewPrefs.theBITPTPrefs.splitFiles)  /* mono */				{					needToReproduceData = true;				}				if ((theWordSize - 1) != theNewPrefs.theBITPTPrefs.sessionResolution)  /* wrong bit rate */				{					needToReproduceData = true;				}				if (theRate != (theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L)  /* wrong bit rate */				{					if (theNewPrefs.theBITPTPrefs.changeRate)					{						needToReproduceData = true;					}				}			break;			default:				checkForWAV(sourceSpec.name,&fndrInfo);				checkForMPG(sourceSpec.name,&fndrInfo);				sourceRate = kUnknown;				sourceType = kUnknown;				sourceBits = kUnknown;				sourceChans = kUnknown;				needToReproduceData = true;			break;				}	if (!needToReproduceData) /* all done !!! */	{		createSDIIOverview(sourceSpec,0x00000100);		sendPTAEvent(sourceSpec,sendRegions);		return true;	}	switch(fndrInfo.fdType)	{			case 'Sd2f':				/* source data captured earlier */			break;			case 'AIFF':				/* source data captured earlier */			break;			case '.WAV': case 'WAVE': case 'bin ':				GetWAVInfo (sourceSpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes);				sourceRate = theSRate;				sourceType = kWAVE;				sourceBits = theWordSize;				sourceChans = isStereo+1;			break;			case 'MPEG':case '.MPG':case 'MPG ':case 'PLAY':case 'MP3 ':case '.MP3':case '.mp3':case 'Mp3 ':				if (!makeSuredCodeisRunning())				{					ProcessSerialNumber process;					Str255 thePth, theCommands = "\pbitp_";					PathNameFromDirID(sourceSpec.parID, sourceSpec.vRefNum,(StringPtr)thePth);					concatStrings(thePth,sourceSpec.name,"\p");					concatStrings(theCommands,thePth,"\p");					SwitchToApp('dCOD');					SendTextToMessageBoard(theCommands);				//	sendODOCEvent(sourceSpec, 'dCOD');				}				return true;				/* right now we dont support format swapping for MPEG */			break;			default:				/* we dont know what it is.....QT maybe... */			break;				}//	convertFileFormat (fndrInfo.fdType, 'Sd2f', sourceRate, //		(theNewPrefs.theBITPTPrefs.changeRate) ? ((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L) : sourceRate, //		sourceBits, theNewPrefs.theBITPTPrefs.sessionResolution, sourceChans, splitFiles);	return true;/* end *//* mono 16-16 sd2 to sd2, converting rate *///			convertSRSD2File(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));/* straight local sd2 copy *///			copyFile(sourceSpec,destspec);/* sd2 16-16 split and SRConv *///			SDIIStereoToMonoLRSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));/* sd2 16-16 split *///			SDIIStereoToMonoLR(sourceSpec);/* wav 16-16 split and conv *///			WAVStereoToSDIISplitSRConv(sourceSpec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));/* wav 16-16 just conv *///			WAVToSDIISRConv(sourceSpec,destspec,((theNewPrefs.theBITPTPrefs.sampleRate48K) ? 48000L : 44100L));/* wav mono 16-16 *///			WAVToSDII(sourceSpec);//			createSDIIOverview(destspec,0x00000100);//			sendPTAEvent(destspec,sendRegions);}extern Boolean DialogPresent;extern short lastListItem;ListHandle ztheRList;extern Point pp;short znumEntries;FSSpec * ztheFilesPtr;short ptResolvePickOne(short numEntries, FSSpec * theFiles){	short itemHit = 0;			/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	ListHandle	theExcList;	Rect	rView,rDataBnds;	Point	theXPoint;	short iInsRow;	Cell XlCellCoords, temporCell;	Str255 NewNameString;	short	dataLen,x;	OSErr	iErr;	short z, excCount = 0;	Handle	hRsrc;	Str255 myString;	Rect	itRect;	long theRate, theBytes;	Boolean stereo,doItAgain;	short theWordSize;	Cell theCell;	FSSpec destination;	StandardFileReply theDestReply;	Point where, thePoint;	Str255 theNameCell,theCurCellName;	ModalFilterUPP xzmySDDlgFilter = NewModalFilterProc(zmySDDlgFilter);	ParamText(theFiles[0].name,0,0,0);	znumEntries = numEntries;	ztheFilesPtr = theFiles;		lastListItem = 0;here:	DialogPresent = true;	myDlg = GetNewDialog(19011,nil,(WindowPtr)-1);	if(!myDlg)	{		SysBeep(5);		return false;	}		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,4,&iType,&iHndl,&itRect);	SetDItem(myDlg,4,iType,(Handle)NewUserItemProc(zRUserProc),&itRect);	ShowWindow(myDlg);	do	{			ModalDialog(xzmySDDlgFilter,&itemHit);			switch (itemHit)		{			case 1:			break;						case 2:			break;						case 4:				LClick(pp,0,(ListHandle)ztheRList);				SetPt( &theCell, 0,0 );		/* start at top of list  */				if (LGetSelect( TRUE, &theCell, ztheRList))				{					FInfo fndrInfo;					Str255 theString;					PathNameFromDirID(theFiles[theCell.v].parID, theFiles[theCell.v].vRefNum, theString);					GetDItem(myDlg,15,&iType,&iHndl,&itRect);					SetIText(iHndl,theString);										FSpGetFInfo(&theFiles[theCell.v],&fndrInfo);					BlockMove(&fndrInfo.fdType,theString + 1,4L);					*theString = 4;					GetDItem(myDlg,16,&iType,&iHndl,&itRect);					SetIText(iHndl,theString);				}							break;						case 5:				SetPt( &theCell, 0,0 );		/* start at top of list  */				LGetSelect( TRUE, &theCell, ztheRList);						Audition(theFiles[theCell.v], 0x3C);					break;						case 12:				SetPt( &theCell, 0,0 );		/* start at top of list  */				LGetSelect( TRUE, &theCell, ztheRList) ;					LSetSelect(false,theCell,ztheRList);				theCell.v ++;				LSetSelect(true,theCell,ztheRList);				LAutoScroll(ztheRList);			break;									case 13:				SetPt( &theCell, 0,0 );		/* start at top of list  */				LGetSelect( TRUE, &theCell, ztheRList) ;					LSetSelect(false,theCell,ztheRList);				theCell.v --;				LSetSelect(true,theCell,ztheRList);				LAutoScroll(ztheRList);			break;						default:			break;		}	} while (itemHit !=1 && itemHit !=2);		SetPt( &theCell, 0,0 );			LGetSelect( TRUE, &theCell, ztheRList) ;		LDispose(ztheRList);	DisposDialog(myDlg);		lastListItem = theCell.v;		DialogPresent = false;		if (itemHit == 2)	{		return -99;	}		return theCell.v;}void PathNameFromDirID(long dirID, short vRefNum, StringPtr fullPathName);pascal void zRUserProc(WindowPtr theDialog, short theItem){	Rect 	iRect,			rView,			rBounds;	short 	h,			v;	char 	s[25];	Point 	pCellSz,theCell;	Handle theHandle;	short 	itype;	Rect 	tempRect;	Str255	theCellText, textIn;	short		CellTextLen;	short myCount;	Cell	tempCell,xCel;	short iInsRow;	short dataLen,z;			// Grab item information	GetDItem(theDialog,theItem,&itype,&theHandle,&iRect);	// Set up view for the list.  Notice that there is some	// margin left on all sides for the frame, and the verical scroll bar	rView = iRect;	rView.right -= 16;		rView.left +=2;	rView.bottom -=1;	rView.top += 1;	// list array is 1 column with 0 rows			// force auto calculations when displaying the cells.	pCellSz.h = 0;	pCellSz.v = 0;	// create list and draw it.				SetRect(&rBounds,0,0,1,znumEntries);		ztheRList = LNew (&rView, &rBounds, pCellSz, 0, theDialog, TRUE, TRUE, FALSE,						TRUE);				if (!ztheRList) {				SysBeep(5);				return;		}		(*ztheRList)->selFlags = 186-32;		for (z= 0 ;z < znumEntries; z++)		{			Str255 theString;			tempCell.h = 0;			tempCell.v = z;			PathNameFromDirID(ztheFilesPtr[z].parID, ztheFilesPtr[z].vRefNum, theString);			dataLen = *theString;			LSetCell(theString + 1,dataLen,tempCell,ztheRList);		}				// Draw a frame around the user item		PenSize(1,1);	FrameRect (&iRect);	// associate the new list handle with this user item	SetDItem(theDialog,theItem,0,(Handle)NewUserItemProc(ztheRList),&iRect);	xCel.h = 0;	xCel.v = lastListItem;	LSetSelect(true,xCel,ztheRList);	LAutoScroll(ztheRList);}pascal Boolean zmySDDlgFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit){	Rect	iRect;	short	type,iType;	Handle	iHndle;	Handle	iHandle;	Point	theCell;	OSErr	iErr;	char theChar;	short theItem;	short 	itype;	Handle theHandle;	short theQuay;	Rect dragRect;	WindowPtr	whichWindow;	short thePart;	GrafPtr	savePort;		switch (theEvent->what) 	{		case keyDown:			// if key was pressed, handle return key			theQuay = (theEvent->message) & keyCodeMask;			theChar = (theEvent->message) & charCodeMask;			if ( (theChar == 0x0d) || (theChar == 0x03)) 			{					*itemHit = 1;					return TRUE;			}			if (theQuay == 0x7D00)			{				*itemHit = 12;					return TRUE;/** down arrow pressed **/			}			if (theQuay == 0x7E00)			{				*itemHit = 13;					return TRUE;/** up arrow pressed **/			}			if (theQuay == 0x3100)			{					*itemHit = 5;					return true;			}			if (theQuay == 0x0E00)			{					*itemHit = 8;					return true;			}						return FALSE;	break;		case mouseDown:			GetPort(&savePort);			SetPort(theDialog);			// Get where mouse click occured in global coordinates.			pp = theEvent->where;			GlobalToLocal(&pp);			SetPort(savePort);			GetDItem(theDialog,4,&type,&iHndle,&iRect);			if (PtInRect(pp,&iRect))			{				*itemHit = 4;				return FALSE;			}			else			{				return FALSE;			}					break;				case updateEvt:		 return false;		break;				case activateEvt:		 return FALSE;		break;				default :			return FALSE;		break;	}}Boolean isDropSecond(Byte Hours,Byte Mins,Byte Secs);OSErr ProToolsOpenRegion(AliasHandle theFileAlias,						 short sTrackNumber, 						unsigned long lSMPTEstartTime, short sFrameFormat,						 ConstStr255Param strRegionName,						 unsigned long lStartSample, unsigned long lStopSample);OSErr ProToolsSpotRegionSampleAccurate(AliasHandle theFileAlias,						 short sTrackNumber, 						unsigned long lSamplestartTime,						 ConstStr255Param strRegionName,						 unsigned long lStartSample, unsigned long lStopSample);void ProToolsSpotRegionII (FSSpec theFile,Str255 regionName, short trkNum, long startFrame, long endFrame, long spotTimeInSamples, short theSessFrameRate){	Boolean fSpot;	AliasHandle alFile;	long theFrameCount;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;		getSDIIData (theFile, &theRate,&theWordSize,&stereo, &theBytes);		theFrameCount = convertSamplesFramesToTCFrames (theRate, spotTimeInSamples, theSessFrameRate);	//theFrameCount = spotTimeInSamples;							NewAliasMinimal(&theFile, &alFile);	//ProToolsOpenRegion(alFile, 2,/* TrkNum*/ 2,/* SMPTEstartTime */ 0, /* sFrameFormat */"\pVocALign",/* RegName*/ 0,/*StartSample*/44100*5); /*lStopSample*/	if (isPressed(0x3A))	{		ProToolsSpotRegionSampleAccurate(alFile, trkNum, spotTimeInSamples, regionName, startFrame,endFrame);	}	else	{		ProToolsOpenRegion(alFile, trkNum, theFrameCount, theSessFrameRate, regionName, startFrame,endFrame); 	}}short roundUpDown(float theFloat);void samplesToDropTimeCode(unsigned long theTimeStamp,long *hour,long *min,long *sec,long *frame,long SRate);long convertSamplesFramesToTCFrames (long SRate, long theTimeStamp, short frameRate){		OSErr	iErr;	long Thours,Tmins,Tsecs, Tframes, TRemainder, TMarker,theFrameCount;	float fperHour, fperMin, fperSec;		if (SRate == 48000)	{		switch (frameRate)		{			case PT25FPS:				Thours = (long)theTimeStamp / 172800000L;				theTimeStamp -= (Thours * 172800000L);								Tmins = (long)theTimeStamp / 2880000L;				theTimeStamp -= (Tmins * 2880000L);								Tsecs = (long)theTimeStamp / 48000L;				theTimeStamp -= (Tsecs * 48000L);								TRemainder = theTimeStamp;								Tframes = roundUpDown ((float)(TRemainder * 25L) / 48000L);								fperHour = (25.0*60.0*60.0);				fperMin = (25.0*60.0);				fperSec = 25.0;							break;						case PT30FPS:case PT2997NDFPS:case PT30DFFPS:				Thours = (long)theTimeStamp / 172800000L;				theTimeStamp -= (Thours * 172800000L);								Tmins = (long)theTimeStamp / 2880000L;				theTimeStamp -= (Tmins * 2880000L);								Tsecs = (long)theTimeStamp / 48000L;				theTimeStamp -= (Tsecs * 48000L);								TRemainder = theTimeStamp;								Tframes = roundUpDown ((float)(TRemainder * 30) / 48000L);								fperHour = (30.0*60.0*60.0);				fperMin = (30.0*60.0);				fperSec = 30.0;			break;						case PT24FPS:				Thours = (long)theTimeStamp / 172800000L;				theTimeStamp -= (Thours * 172800000L);								Tmins = (long)theTimeStamp / 2880000L;				theTimeStamp -= (Tmins * 2880000L);								Tsecs = (long)theTimeStamp / 48000L;				theTimeStamp -= (Tsecs * 48000L);								TRemainder = theTimeStamp;								Tframes = roundUpDown ((float)(TRemainder * 24L) / 48000L);									fperHour = (24.0*60.0*60.0);				fperMin = (24.0*60.0);				fperSec = 24.0;			break;						case PT2997DFFPS:				samplesToDropTimeCode(theTimeStamp,&Thours,&Tmins,&Tsecs,&Tframes,SRate);				fperHour = (29.97*60.0*60.0);				fperMin = (29.97*60.0);				fperSec = 29.97;			break;		}	}	else	{		switch (frameRate)		{			case PT25FPS:				Thours = (long)theTimeStamp / 158760000L;				theTimeStamp -= (Thours * 158760000L);								Tmins = (long)theTimeStamp / 2646000L;				theTimeStamp -= (Tmins * 2646000L);								Tsecs = (long)theTimeStamp / 44100L;				theTimeStamp -= (Tsecs * 44100L);								TRemainder = theTimeStamp;								Tframes = roundUpDown ((float)(TRemainder * 25L) / 44100L);								fperHour = (25.0*60.0*60.0);				fperMin = (25.0*6.00);				fperSec = 25.0;			break;						case PT30FPS:case PT2997NDFPS:case PT30DFFPS:				Thours = (long)theTimeStamp / 158760000L;				theTimeStamp -= (Thours * 158760000L);								Tmins = (long)theTimeStamp / 2646000L;				theTimeStamp -= (Tmins * 2646000L);								Tsecs = (long)theTimeStamp / 44100L;				theTimeStamp -= (Tsecs * 44100L);								TRemainder = theTimeStamp;								Tframes = roundUpDown ((float)(TRemainder * 30) / 44100L);								fperHour = (30.0*60.0*60.0);				fperMin = (30.0*60.0);				fperSec = 30.0;			break;						case PT24FPS:				Thours = (long)theTimeStamp / 158760000L;				theTimeStamp -= (Thours * 158760000L);								Tmins = (long)theTimeStamp / 2646000L;				theTimeStamp -= (Tmins * 2646000L);								Tsecs = (long)theTimeStamp / 44100L;				theTimeStamp -= (Tsecs * 44100L);								TRemainder = theTimeStamp;								Tframes = roundUpDown ((float)(TRemainder * 24L) / 44100L);								fperHour = (24.0*60.0*60.0);				fperMin = (24.0*60.0);				fperSec = 24.0;			break;						case PT2997DFFPS:				samplesToDropTimeCode(theTimeStamp,&Thours,&Tmins,&Tsecs,&Tframes,SRate);								fperHour = (29.97*60.0*60.0);				fperMin = (29.97*60.0);				fperSec = 29.97;			break;		}	}		theFrameCount =  ((float)Thours * fperHour) +  ((float)Tmins * fperMin) + ((float)Tsecs * fperSec) + Tframes;	return  theFrameCount;}short roundUpDown(float theFloat){	float rem;	short theL;		theL  = (long)theFloat;	rem = theFloat - (float)theL;		if (rem >= 0.5)	{		return theL+1;	}	else	{		return theL;	}}void samplesToDropTimeCode(unsigned long theTimeStamp,long *hour,long *min,long *sec,long *frame,long SRate){	float samplesPerHour = (float)SRate * 3603.6;	float samplesPerMin = (float)SRate * 60.06;	float samplesPerSec = (float)SRate * 1.001;	float samplesPerFrame = samplesPerSec / 29.97;	float otherLong = (float)theTimeStamp;	float fHour,fMin,fSec,fFrame;		fHour = otherLong / samplesPerHour;	fMin = (otherLong -= ((long)fHour * samplesPerHour)) / samplesPerMin;	fSec = (otherLong -= ((long)fMin * samplesPerMin)) / samplesPerSec;	fFrame = (otherLong -= ((long)fSec * samplesPerSec)) / samplesPerFrame;		*hour = fHour;	*min = fMin;	*sec = fSec;	*frame = fFrame;		if (isDropSecond(*hour,*min,*sec))	{		fFrame = *frame;				fFrame = ((fFrame / 30) * 28) + 2;				*frame = fFrame;	}}Boolean isDropSecond(Byte Hours,Byte Mins,Byte Secs){	if (Secs != 0)	{		return false;	}	if (Mins == 0 || Mins == 10 || Mins == 20 || Mins == 30 || Mins == 40 || Mins == 50)	{		return false;		}	return true;}OSErr OpenSelection(FSSpec);OSErr makeSuredCodeisRunning(void){	FSSpec launchSpec;	ProcessSerialNumber process;	EventRecord theEvent;	long startTick;	OSErr iErr;	if(PFindAProcess('APPL','dCOD',&process))	{		launchSpec.vRefNum = theApplSpec.vRefNum;		launchSpec.parID = theApplSpec.parID;		makeStr255("\popen dCODEª",launchSpec.name);		OpenSelection(launchSpec);		if(!PFindAProcess('FNDR','MACS',&process))		{			iErr = SetFrontProcess(&process);		}	}	startTick = TickCount();	while ((PFindAProcess('APPL','dCOD',&process) && TickCount() - startTick < 300))	{		WaitNextEvent(everyEvent,&theEvent,30,0);	}/*	if(PFindAProcess('APPL','dCOD',&process))	{		SysBeep(5);		return -1;	}	else	{		iErr = SetFrontProcess(&process);	}*/	return noErr;}OSErr swapNames (FSSpec* sourceSpec,FSSpec* tempSpec){	Str255 tempName, srcStart, tempStart;	OSErr iErr;	BlockMove (sourceSpec->name,tempName,*(sourceSpec->name)+1);	BlockMove (sourceSpec->name,srcStart,*(sourceSpec->name)+1);	BlockMove (tempSpec->name,tempStart,*(sourceSpec->name)+1);	*(tempName + 1) += 0x81;	iErr = FSpRename(sourceSpec,tempName);	iErr = FSpRename(tempSpec,sourceSpec->name);	BlockMove (tempName,sourceSpec->name,*tempName+1);	iErr = FSpRename(sourceSpec,tempSpec->name);	BlockMove (tempStart,sourceSpec->name,*tempStart+1);	BlockMove (srcStart,tempSpec->name,*srcStart+1);	return noErr;}