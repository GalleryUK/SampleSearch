#include "SampleSearch.h"#include "Globals.h"#include <AIFF.h>#include "prefs.h"#include <SoundInput.h>#include <fp.h>extern newPrefsRec theNewPrefs;			#include <stdio.h>			#include <stdlib.h>#define kCantDoIt -1#define kNameTruncated 1#define kNameDePunctuated 2#define kNumbered 3extern Str255 leftSuffixStr,rightSuffixStr;long  obtainSize(short theIndex);void addLeadingZeros (StringPtr theString, short totalDigits);Boolean addFileToList(FSSpec mySpec);extern Ptr inBuffer;extern Ptr outBuffer;extern Ptr procBufferL;extern Ptr procBufferR;extern long inputSize, outSize;extern long sourceBytes;void textToComments(void);Boolean GetFSComment(FSSpec mySpec, Str255 theComment);Boolean SetFSComment (FSSpec mySpec, StringPtr theComment);Boolean PCWriteL(short destRef,long theBytes);Boolean PCWriteI(short destRef,short theBytes);void stripComments(void);short GetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);Boolean pcConv(Ptr theBuff, long inOutCount);Boolean pcConv8(Ptr theBuff,long inOutCount);Boolean SetComment (FSSpec mySpec, short index, StringPtr theComment);long findCOMM(short localRefNum, OSType	theType);Boolean SRgetStarted (Fixed SRin, Fixed SRout, Boolean doSR, short BITSin, short BITSout, Boolean doBITS, short CHANSin, short CHANSout, Boolean doCHANS);typedef struct listFontRec {Str255 fontName;short fontSize;} listFontRec, *listFontRecPtr;void SDIIProcessMany(void);OSErr copySDIIRegionsNoConversion (FSSpec sourceFile, FSSpec destFile);void TrashSDDDMany(void);extern listFontRec  theFontRec;Boolean SRprocessBuffer(void);void outLineCell (Cell theCell, ListHandle theList);void unOutLineCell (Cell theCell, ListHandle theList);Boolean SDII24to16(FSSpec theSourceSpec, FSSpec theSpec);Boolean SRstopIt(void);Boolean SDIIAddSilenceEnd(FSSpec theSpec);Boolean SDIIAddSilenceStart(FSSpec theSpec);Boolean progressIIDisp(short percentFull);void progressIICreate(Str255	theText);void progressIIDispos(void);extern long theMilliseconds;OSErr renameFileAttempts(StringPtr theText, FSSpec destination);OSErr convertSDIIFormat (FSSpec inFile, FSSpec outFile, long destRate, short destBits, short destChans);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);Boolean SDIItoPCSampleVision(FSSpec sourceSpec);extern Ptr splitBufferL,splitBufferR;void getConvertDest(void);Boolean RecoverSDII(FSSpec theSpec, short numBits, short channels, Str255 srate);Boolean TrashSDDD(FSSpec theSpec);Boolean TrashSDDD(FSSpec theSpec);extern FSSpec theConvertDestLoc;Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);Boolean AIFF3ChToMono(FSSpec theSpec, short channelSelect);void TrashSDDDMany(void){	Cell theCell;	short theindex;			getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		TrashSDDD((*therealResults)[theindex]);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}Boolean TrashSDDD(FSSpec theSpec){	short refNum;	Handle hRsrc;	OSErr	iErr;		refNum = FSpOpenResFile(&theSpec,fsWrPerm);	hRsrc = Get1Resource('sdDD',1000);	RmveResource(hRsrc);	CloseResFile(refNum);}#define EOL 13	// line delimiter is CR (ASCII 13)#define MAXLINE 256	// caller's buffer size; max line len		void selectScripted(void);	void textToComments(void){	Cell theCell;	short theindex;	StandardFileReply myReply;	OSErr	iErr;	short refNum;	IOParam pb;	Str255 theText;	long inOutCount = 0;	short	len, rc;	Str255 theOtherText;	short whichFile = 0;	Boolean selected = false;			StandardGetFile(0,-1,0,&myReply);	if (!myReply.sfGood)		return;	iErr = FSpOpenDF(&myReply.sfFile,fsRdPerm,&refNum);	if (iErr)	{		SysBeep(5);		return;	}		if (DisplayedColumns == 4)	{		theCell.v = whichFile/4;		theCell.h = whichFile - (theCell.v * 4);	}	else	{		theCell.v = whichFile;		theCell.h = 0;	}	if(LGetSelect(false,&theCell,myList)) 	{		selected = true;	}	while (!selected && whichFile < totfindcounter)	{		whichFile++;		if (DisplayedColumns == 4)		{			theCell.v = whichFile/4;			theCell.h = whichFile - (theCell.v * 4);		}		else		{			theCell.v = whichFile;			theCell.h = 0;		}		if(LGetSelect(false,&theCell,myList)) 		{			selected = true;		}	}		watchcursor(true);		rc=0;	pb.ioActCount = 0;		while (!(rc==eofErr && pb.ioActCount==0) && whichFile<totfindcounter)	{		short z;				pb.ioRefNum = refNum;		pb.ioPosMode = fsAtMark | 0x80 | (256*EOL);		pb.ioReqCount = 250;	// max line size		pb.ioBuffer = (Ptr)theText;		// transfer to this address				rc=PBRead((union ParamBlockRec *) &pb, FALSE );	// read one line			BlockMove (theText, theOtherText+1,pb.ioActCount);		*theOtherText = pb.ioActCount-1;				SetComment ((*therealResults)[whichFile],whichFile, theOtherText);		selected = false;		while (!selected && whichFile < totfindcounter)		{			whichFile++;			if (DisplayedColumns == 4)			{				theCell.v = whichFile/4;				theCell.h = whichFile - (theCell.v * 4);			}			else			{				theCell.v = whichFile;				theCell.h = 0;			}			if(LGetSelect(false,&theCell,myList)) 			{				selected = true;			}		}	}		watchcursor(false);	FSClose (refNum);}void selectScripted(void){	Cell theCell;	short theindex;	StandardFileReply myReply;	OSErr	iErr;	short refNum;	IOParam pb;	Str255 theText;	long inOutCount = 0;	short	len, rc;	Str255 theOtherText;			SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{				LSetSelect(false,theCell,myList);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}				StandardGetFile(0,-1,0,&myReply);	if (!myReply.sfGood)		return;	iErr = FSpOpenDF(&myReply.sfFile,fsRdPerm,&refNum);	if (iErr)	{		SysBeep(5);		return;	}		watchcursor(true);		rc=0;	pb.ioActCount = 0;		while (!(rc==eofErr && pb.ioActCount==0))	{		short z;				pb.ioRefNum = refNum;		pb.ioPosMode = fsAtMark | 0x80 | (256*EOL);		pb.ioReqCount = 250;	// max line size		pb.ioBuffer = (Ptr)theText;		// transfer to this address				rc=PBRead((union ParamBlockRec *) &pb, FALSE );	// read one line			BlockMove (theText, theOtherText+1,pb.ioActCount);		*theOtherText = pb.ioActCount-1;				for (z=0;z<totfindcounter;z++)		{			if(EqualString((*therealResults)[z].name,theOtherText,false,false)) 			{								if (DisplayedColumns == 4)				{					theCell.v = z/4;					theCell.h = z - (theCell.v * 4);				}				else				{					theCell.v = z;					theCell.h = 0;				}				LSetSelect(true,theCell,myList);			}		}	}		watchcursor(false);	FSClose (refNum);}void scriptedAdd(FSSpec theFile);void scriptedAddAsk(void);void scriptedAddAsk(void){	StandardFileReply myReply;	OSErr	iErr;	StandardGetFile(0,-1,0,&myReply);	if (!myReply.sfGood)		return;	scriptedAdd(myReply.sfFile);}OSErr showSelectionSize(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	long totalSelection = 0L;	Str255 theReport = "\pThe size of that selection is : ";	Str255 theTermByte = "\p bytes";	Str255 theTermK = "\p k";	Str255 theTermMb = "\p Mb";	Str255 tempStr;	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));			totalSelection += obtainSize(theindex);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (totalSelection < 10000)	{		/* use no suffix */		NumToString(totalSelection, tempStr);		concatStrings (theReport,theTermByte ,tempStr);		genError (theReport);	}	else	{		if (totalSelection < 1000000)		{			NumToString(totalSelection/1000, tempStr);			concatStrings (theReport,theTermK ,tempStr);			genError (theReport);		}		else		{			float theDivider;			int numchars;			/* use MB */			/* use K */			theDivider = (float)totalSelection/1000000;			numchars = sprintf((char *)tempStr,(const char *)"The size of that selection is : %10.1f MBytes",theDivider);			C2PStr ((char *)tempStr);			genError (tempStr);		}	}}/* this add is limited to 255 char length paths */void scriptedAdd(FSSpec theFile){	Cell theCell;	short theindex;	StandardFileReply myReply;	OSErr	iErr;	short refNum;	IOParam pb;	Str255 theText;	long inOutCount = 0;	short	len, rc;	Str255 theOtherText;	FSSpec spec;		iErr = FSpOpenDF(&theFile,fsRdPerm,&refNum);	if (iErr)	{		SysBeep(5);		return;	}		watchcursor(true);		rc=0;	pb.ioActCount = 0;		while (!(rc==eofErr && pb.ioActCount==0))	{		short z;				pb.ioRefNum = refNum;		pb.ioPosMode = fsAtMark | 0x80 | (256*EOL);		pb.ioReqCount = 254;	// max line size		pb.ioBuffer = (Ptr)theText;		// transfer to this address				rc=PBRead((union ParamBlockRec *) &pb, FALSE );	// read one line			BlockMove (theText, theOtherText+1,pb.ioActCount);		*theOtherText = pb.ioActCount-1;				iErr = FSMakeFSSpec(0,0,theOtherText,&spec);		if (!iErr)			addFileToList(spec);	}		watchcursor(false);	FSClose (refNum);}	void RenameScripted(void);	void RenameScripted(void){	Cell theCell;	short theindex;	StandardFileReply myReply;	OSErr	iErr;	short refNum;	IOParam pb;	Str255 theText;	long inOutCount = 0;	short	len, rc;	Str255 theOtherText,oldName;	Boolean memoryError = false;		StandardGetFile(0,-1,0,&myReply);	if (!myReply.sfGood)		return;	iErr = FSpOpenDF(&myReply.sfFile,fsRdPerm,&refNum);	if (iErr)	{		SysBeep(5);		return;	}		watchcursor(true);	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"*********** Starting Scripted Rename");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{				/*			ReadLine reads a line of text from the file represented by pbp.			It returns -1 if the file is not delimited, or a file manager			result code (i.e. eofErr.) It places the null terminated string			in the buffer pointed to by lineBuf.		*/		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));			pb.ioRefNum = refNum;		pb.ioPosMode = fsAtMark | 0x80 | (256*EOL);		pb.ioReqCount = 250;	// max line size		pb.ioBuffer = (Ptr)theText;		// transfer to this address				rc=PBRead((union ParamBlockRec *)&pb, FALSE );	// read one line			BlockMove (theText, theOtherText+1,pb.ioActCount);		*theOtherText = pb.ioActCount-1;				if (rc==eofErr && pb.ioActCount==0)			 return;		// end of file reached			if (*theOtherText > 31)		{			writeLog((char *)theOtherText);				writeLogS((unsigned char *)"Is too long for a file name, truncating to :");			renameFileAttempts(theOtherText, (*therealResults)[theindex]);		//	*theOtherText = 31;			writeLog((char *)theOtherText);			}		makeStr255((*therealResults)[theindex].name,oldName);		if (!FSpRename(&(*therealResults)[theindex],theOtherText))		{			BlockMove(theOtherText,(*therealResults)[theindex].name,(*theOtherText) + 1);			LSetCell(theOtherText+1,(*theOtherText),theCell,myList);			writeLogS((unsigned char *)"Sucessfully Renamed :");			writeLog((char *)oldName);				writeLogS((unsigned char *)"As :");			writeLog((char *)theOtherText);				writeLogS((unsigned char *)"***********************");		}		else		{			writeLogS((unsigned char *)"*********************** Failed to Rename :");			writeLog((char *)oldName);				writeLogS((unsigned char *)"As :");			writeLog((char *)theOtherText);				writeLogS((unsigned char *)"*********************** Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");	watchcursor(false);	FSClose (refNum);}OSErr removePunctuation(StringPtr theText);OSErr renameFileAttempts(StringPtr theText, FSSpec destination){	OSErr iErr;	Str255 nameInProgress, tempStr;	FSSpec theSpec;	long theIndex;/* first try cropping it */	makeStr255 (theText, nameInProgress);	*nameInProgress = 31;	iErr = FSMakeFSSpec(destination.vRefNum,destination.parID,nameInProgress,&theSpec);	if (iErr == -43)	{		makeStr255 (nameInProgress,theText);		return kNameTruncated;	}/* next try removing spaces, and punctuation */	makeStr255 (theText, nameInProgress);	removePunctuation (nameInProgress);	*nameInProgress = 31;	iErr = FSMakeFSSpec(destination.vRefNum,destination.parID,nameInProgress,&theSpec);	if (iErr == -43)	{		makeStr255 (nameInProgress,theText);		return kNameDePunctuated;	}/* if that dont work, add a numeric suffix */	makeStr255 (theText, nameInProgress);	if ((*nameInProgress) >= 29)	{			*nameInProgress = 29;	}	iErr = 0;	theIndex = 0;	while (!iErr)	{				NumToString (theIndex,tempStr);		addLeadingZeros (tempStr, 2);		theIndex ++;		if (theIndex >99)		{			return kCantDoIt;		}		concatStrings (nameInProgress,tempStr,"\p");		iErr = FSMakeFSSpec(destination.vRefNum,destination.parID,nameInProgress,&theSpec);		if (iErr == -43)		{			makeStr255 (nameInProgress,theText);			return kNumbered;		}		*nameInProgress = *nameInProgress-2;	}	return kCantDoIt;}OSErr removePunctuation(StringPtr theText){	Str255 nameCopy;	short soFar = 1;	short z;	for (z=1;z<*theText + 1;z++)	{		if (*(theText + z) >= 0x30 && *(theText + z) <= 0x7A)		{			*(nameCopy + soFar) = *(theText + z);			soFar ++;		}	}	*nameCopy = soFar -1;	makeStr255 (nameCopy, theText);	return noErr;}void RecoverSDIIMany(void);void RecoverSDIIMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr,srate;	short resID;	long tempLong;	Boolean memoryError = false;	short numBits = 2;	short chans = 2;		/****************/	myDlg = GetNewDialog(23000,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,4,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	ShowWindow(myDlg);	itemHit = 99;	while (itemHit>2)	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				chans = 2;			break;			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				chans = 1;			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				numBits = 2;			break;			case 7:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				numBits = 1;			break;		}	}	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,srate);					DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;					getConvertDest();	watchcursor(true);	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting SDII Recover");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (RecoverSDII((*therealResults)[theindex],numBits, chans, srate))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean RecoverSDII(FSSpec theSpec, short numBits, short channels, Str255 srate){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Handle theData;	FSSpec theSourceSpec;	Str255 theComment;	short headerLen;	Handle theSndHandle;	short iRefNum;	//Ptr theData = NewPtr(32768L);	/*if (!theData)	{		genError("\pNot enough memory");		return false;	}*/	BlockMove (&theSpec,&theSourceSpec,70L);		theSpec.parID = theConvertDestLoc.parID;	theSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);	if (iErr == -48)	{		/* replace */		SysBeep(5);		iErr = FSpDelete(&theSpec);		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);	}	iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);	if (iErr)		return false;	iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);	if (iErr)		return false;	inOutCount = 32768L;			theData = NewHandleClear(33000L);				if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\pConverting File");		while (err != eofErr)		{			inOutCount = 32768L;			err = FSRead(sRefNum,&inOutCount,*theData);			iErr = FSWrite(RefNum,&inOutCount,*theData);			if (iErr )			{				SysBeep(5);				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				watchcursor(false);				return false;			}		}		progressDispos();		watchcursor(false);				FSClose (RefNum);		FSClose(sRefNum);				FSClose(RefNum);		FSClose(sRefNum);	StringToNum(srate,&theRate);	writeSDIIResources(theSpec,theRate,(channels == 2),numBits);	DisposHandle(theData);		addFileToList(theSpec);	return true;/* copy comment */}Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize){	short iRefNum,rfRefNum;	Str255 theStringa,theStringb,theStringc,theStringd;	StringHandle h1,h2,h3;	Handle theExtraHandleA,theExtraHandleB;	OSErr iErr=0;	long thefirstbit,thesecondbit;	long extraA,extraB;	Handle tempHandle;		extraA = 0x00010000;	extraB = 0x00000000;		FSpCreateResFile(&theSpec,'Sd2a','Sd2f',0);	if (iErr != 0)	{			}	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&theSpec,fsWrPerm);	if (rfRefNum == -1)	{		return false;	}	UseResFile (rfRefNum);		NumToString((long)(stereo+1),theStringa);	NumToString((long)theWordSize,theStringb);		NumToString(theRate,theStringc);	makeStr255("\p0000",theStringd);		concatStrings(theStringc,theStringd,"\p.");	h1 = NewString(theStringa);	h2 = NewString(theStringb);	h3 = NewString(theStringc);		tempHandle = Get1Resource('STR ',1000);	if (tempHandle)	{		RmveResource(tempHandle);		DisposHandle(tempHandle);	}	AddResource((Handle)h2,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		UseResFile(iRefNum);		return false;	}		tempHandle = Get1Resource('STR ',1001);	if (tempHandle)	{		RmveResource(tempHandle);		DisposHandle(tempHandle);	}	AddResource((Handle)h3,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		UseResFile(iRefNum);		return false;	}		tempHandle = Get1Resource('STR ',1002);	if (tempHandle)	{		RmveResource(tempHandle);		DisposHandle(tempHandle);	}	AddResource((Handle)h1,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add str 1002");		UseResFile(iRefNum);		return false;	}		theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);			tempHandle = Get1Resource('sdML',1000);	if (tempHandle)	{		RmveResource(tempHandle);		DisposHandle(tempHandle);	}	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}		tempHandle = Get1Resource('sdLL',1000);	if (tempHandle)	{		RmveResource(tempHandle);		DisposHandle(tempHandle);	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}		CloseResFile(rfRefNum);	UseResFile(iRefNum);		//writeSDIILoopsMarkers(theSpec);/* write markers */}OSErr copySDIIRegionsNoConversion (FSSpec sourceFile, FSSpec destFile){	short iRefNum,rfRefNum;	Handle theDDRL;	OSErr iErr;	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&sourceFile,fsRdPerm);	if (rfRefNum == -1)	{		return false;	}	UseResFile (rfRefNum);	theDDRL = Get1Resource('ddRL',1000);	if (!theDDRL)	{		CloseResFile(rfRefNum);		UseResFile(iRefNum);		return noErr;	}	DetachResource(theDDRL);	CloseResFile(rfRefNum);	rfRefNum = FSpOpenResFile(&destFile,fsWrPerm);	if (rfRefNum == -1)	{		UseResFile(iRefNum);		return false;	}	UseResFile (rfRefNum);		AddResource((Handle)theDDRL,'ddRL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add regions");		CloseResFile(rfRefNum);		UseResFile(iRefNum);		return false;	}	CloseResFile(rfRefNum);	UseResFile(iRefNum);	return noErr;}Boolean writeSDIILoopsMarkers(FSSpec theSpec);Boolean writeSDIILoopsMarkers(FSSpec theSpec){	short iRefNum,rfRefNum;	Str255 theStringa,theStringb,theStringc,theStringd;	StringHandle h1,h2,h3;	Handle theExtraHandleA,theExtraHandleB;	OSErr iErr=0;	long thefirstbit,thesecondbit;	long extraA,extraB;		extraA = 0x00010000;	extraB = 0x00000000;		FSpCreateResFile(&theSpec,'Sd2a','Sd2f',0);	if (iErr != 0)	{			}	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&theSpec,fsWrPerm);	if (rfRefNum == -1)	{		return false;	}	UseResFile (rfRefNum);			theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile(rfRefNum);	UseResFile(iRefNum);}void SDIIAIFF3ChToMonoMany(void);void SDIIAIFF3ChToMonoMany(void){	Cell theCell;	short theindex;	short chanSelect = 1;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(17000,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);			ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:case 4:case 5:case 6:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,itemHit,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				chanSelect = itemHit - 2;			break;		}	}while (itemHit != 1 && itemHit != 2);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;					getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting MultiChannel extraction");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (AIFF3ChToMono((*therealResults)[theindex],chanSelect))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");		}				LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}extern FSSpec theNewFileLeft, theNewFileRight;Boolean AIFF3ChToMono(FSSpec theSpec, short channelSelect){	FSSpec destLSpec, destRSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, destRRef, iRefNum, rfRefNum;	Str255 destLName, destRName, num8Bits = "\p1", num16Bits = "\p2",rate,StereoMono = "\p1";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos, theDestRPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short channels;	long bytesWritten = 0;	short escCount;	long inOutCount;	Ptr theBuffer, theLBuffer,theRBuffer;	long z, infoLength, theTempLong,filePos;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	extraA = 0x00010000;	extraB = 0x00000000;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'AIFF')	{		return false;	}	if (getAIFFDataII (theSpec,&theRate, &theWordSize,&channels, &theBytes))		return false;			if (channelSelect>channels)		return false;		BlockMove (&theSpec,&destLSpec,70L);	destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','AIFF',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','AIFF',0);				}				else				{					return false;				}			}		}						BlockMove (&destLSpec,&theNewFileLeft,70L);		iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;					iErr = SetupAIFFHeader(destLRef,1,(theRate << 16),(theWordSize << 3),'NONE',theBytes / channels,(theBytes / channels) >> (theWordSize == 16));	if (iErr)	{		FSClose (destLRef);		return false;	}				iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		//FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}		filePos = findCOMM(sourceRef,'SSND') + 8;	if (!filePos)	{		genError ("\pCan't find common chunk");		FSClose (destLRef);		FSClose(sourceRef);		return false;	}		iErr = SetFPos(sourceRef,1,filePos);	if (iErr)	{		FSClose (destLRef);		FSClose(sourceRef);		return false;	}		/* now enter the data */	theBuffer = NewPtr(65536L);	if (!theBuffer)	{		genError("\pNot enough Memory");		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		theLBuffer = NewPtr(65536L);	if (!theLBuffer)	{		genError("\pNot enough Memory");		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}			iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	bytesWritten = 0;	while (iErr != eofErr && !eErr)	{		inOutCount = 63996L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);				switch (theWordSize)		{			case 1:				for (z=0;z<inOutCount;z+=channels)				{						*((Byte *)(theLBuffer + (z/channels))) = *((Byte *)(theBuffer + z + (channelSelect - 1)));				}				inOutCount = (inOutCount / channels);				eErr = FSWrite(destLRef,&inOutCount,theLBuffer);				bytesWritten += inOutCount;			break;									case 2:				for (z=0;z<inOutCount;z+= (channels * 2))				{						*(short *)(theLBuffer + (z/(channels))  ) = *((short *)(theBuffer + z + ((channelSelect - 1) * 2)));				}				inOutCount = (inOutCount / channels);				eErr = FSWrite(destLRef,&inOutCount,theLBuffer);				bytesWritten += inOutCount;			break;		}			}		if ((bytesWritten >> 1 << 1) != bytesWritten)	{		short theByte = 0;		inOutCount = 1L;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);		bytesWritten ++;	}		iErr = SetFPos(destLRef,1,0);	if (iErr)	{		FSClose (destLRef);		FSClose(sourceRef);		return false;	}		iErr = SetupAIFFHeader(destLRef,1,(theRate << 16),(theWordSize << 3),'NONE',bytesWritten,0);	if (iErr)	{		FSClose (destLRef);		return false;	}			progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	addFileToList(destLSpec);	return true;}void SDIItoPCSampleVisionMany(void);void SDIItoPCSampleVisionMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;		getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting SDII to SampleVision convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDIItoPCSampleVision((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}OSErr MPGToSDII(FSSpec sourceMPEG, FSSpec destSDII);void MPGToSDIIMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;		getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting MPG to SDII convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		FSSpec destSpec;		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		BlockMove (&(*therealResults)[theindex],&destSpec,70L);		destSpec.parID = theConvertDestLoc.parID;		destSpec.vRefNum = theConvertDestLoc.vRefNum;			if (MPGToSDII((*therealResults)[theindex],destSpec))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}OSErr MPGToSDII(FSSpec sourceMPEG, FSSpec destSDII){	return noErr;}typedef struct SampleVisionheader{	char theFileID[18];	char theVersion[4];	char theComment[60];	char theName[30];	long theSampleFrames;} SampleVisionheader, *SampleVisionheaderPtr;typedef struct SampleVisionloop{	long theloopstart;	long theloopend;	Byte thelooptype;	short theloopcount;} SampleVisionloop, *SampleVisionloopPtr;typedef struct SampleVisionmarker{	char markerName[10];	long markerPosition;} SampleVisionmarker, *SampleVisionmarkerPtr;typedef struct SampleVisiontail{	short theReserved;	SampleVisionloop theLoops[8];	SampleVisionmarker theMarkers[8];	Byte theMidiNote;	long theSampleRate;	long theSMPTEOffset;	long theCycleSize;} SampleVisiontail, *SampleVisiontailPtr;Boolean SDIItoPCSampleVision(FSSpec sourceSpec){	short theWordSize;	Boolean stereo;	long theRate,theSVRate;	short q;	long theBytes;	Fixed theSRate;	short sourceRef, destRef;	FSSpec destSpec;	Str255 destName;	long theSourcePos;	long theDestPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType fileExt = '.SMP';	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer;	long z, infoLength, theTempLong;	Boolean addFill;		Handle theSVISHeader;	Handle theSVISTailer;	long theFrames;	long filePos;		iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}			if (getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;		if (theWordSize != 2 || stereo)	{		genError ("\pSampleVision files are 16-bit Mono");		return false;	}				BlockMove (&sourceSpec,&destSpec,70L);		if (*destSpec.name < 12)	{		for (z= *destSpec.name;z<=12L;z++)		{			*(destSpec.name + z + 1L) = ' ';		}	}		*destSpec.name = 12;	BlockMove (&fileExt, destSpec.name + 9L,4L);	iErr = -1;	escCount = 0;		destSpec.parID = theConvertDestLoc.parID;	destSpec.vRefNum = theConvertDestLoc.vRefNum;		while (iErr != 0 && escCount<254)	{		iErr = FSpCreate(&destSpec,'MgAl','Svis',0);		if (iErr)		{			(*(destSpec.name + 8L))++;			escCount ++;		}	}	if (escCount>=254)		return false;		iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRef);		if (iErr != 0)		return false;	iErr = FSpOpenDF(&sourceSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}		theSVISHeader = GetResource('Svis',128);	if (!theSVISHeader)	{		SysBeep(5);		return false;	}		theSVISTailer = GetResource('Svis',129);	if (!theSVISTailer)	{		SysBeep(5);		return false;	}	inOutCount = GetHandleSize(theSVISHeader);		iErr = FSWrite(destRef,&inOutCount,*theSVISHeader);		inOutCount = 4L;	theFrames = theBytes/2L;	PCWriteL(destRef,theFrames);	/* now enter the data */	theBuffer = NewPtr(32768L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 32000L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		if (theWordSize == 2)			pcConv(theBuffer,inOutCount);		if (theWordSize == 1)			pcConv8(theBuffer,inOutCount);		eErr = FSWrite(destRef,&inOutCount,theBuffer);	}	progressDispos();	watchcursor(false);	inOutCount = GetHandleSize(theSVISTailer);			iErr = FSWrite(destRef,&inOutCount,*theSVISTailer);	iErr = SetFPos(destRef,2,-12L);		inOutCount = 4L;	theSVRate = theRate;		PCWriteL(destRef,theSVRate);		FSClose (sourceRef);	FSClose (destRef);	DisposPtr(theBuffer);		addFileToList(destSpec);	return true;}Boolean ChangeSRInfo(FSSpec theSpec, Str255 theText);Boolean ChangeSRInfo(FSSpec theSpec, Str255 theText){	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	short refNum,iRefNum;	StringHandle theString;	OSErr	iErr;	FInfo fndrInfo;	 Fixed theFixed;		 extended80 theExtd;		 unsigned long theLong;		 CommonChunk theComm;	long filePos,inOutCount;	long double myLD;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);		switch(fndrInfo.fdType)	{		 case 'Sd2f':			iRefNum = CurResFile();						refNum = FSpOpenResFile(&theSpec,fsWrPerm);				iErr = ResError();			if(iErr)				return false;							UseResFile(refNum);						concatStrings(theText,"\p0000","\p.");			SetResLoad(false);			theString = GetString(1001);			SetResLoad(true);			if(!theString)			{				CloseResFile(refNum);				UseResFile(iRefNum);				return false;			}			SetResourceSize((Handle)theString,(*theText + 1));			theString = GetString(1001);			BlockMove(theText,*theString,(*theText)+ 1);			ChangedResource((Handle)theString);			CloseResFile(refNum);			UseResFile(iRefNum);		 break;	 		 case 'AIFF':				 	StringToNum(theText,(long *)&theLong);		/* 	theFixed = (Fixed)theLong << 16 & 0xFFFF0000;		 					 	myLD = Fix2X(theFixed);			#if defined(powerc) || defined(__powerc)	// PPC versions				ldtox80 (&myLD, &theExtd );			#else				fp68k( &myLD, &theExtd, FD2X );	// 68K versions			#endif			*/			// ldtox80 (&myLD, &theExtd );		 		 			iErr = FSpOpenDF(&theSpec,fsWrPerm,&refNum);		 	filePos = findCOMM(refNum, 'COMM');		 	SetFPos (refNum,1,filePos);		 	inOutCount = sizeof(CommonChunk);		 	iErr = FSRead(refNum,&inOutCount,&theComm);#ifdef powerc	// PPC versions			myLD = theLong;			ldtox80 (&myLD,&theComm.sampleRate);			//theComm.sampleRate = Fix2X((Fixed)theLong<<16);			#else		 	theComm.sampleRate = theLong; //theExtd;#endif		 	SetFPos (refNum,1,filePos);		 	inOutCount = sizeof(CommonChunk);		 	iErr = FSWrite(refNum,&inOutCount,&theComm);		 	FSClose(refNum);		 break;	 		 default:	 		return false;	 	break;		}	return true;}void ChangeSRInfoMany(void);void ChangeSRInfoMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr;	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(1807,0L,(WindowPtr)-1);	SetPort (myDlg);		ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);	}while (itemHit != 1 && itemHit != 2);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,textStr);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;	writeLogS((unsigned char *)"Starting SRInfo change");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (ChangeSRInfo((*therealResults)[theindex],textStr))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}extern FSSpec theNewFileLeft, theNewFileRight;Boolean SDIIStereoToMonoLRSRConv(FSSpec theSpec, long newRate);Boolean SDIIStereoToMonoLRSRConv(FSSpec theSpec, long newRate){	FSSpec destLSpec, destRSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, destRRef, iRefNum, rfRefNum;	Str255 destLName, destRName, num8Bits = "\p1", num16Bits = "\p2",rate,StereoMono = "\p1";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos, theDestRPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer, theLBuffer,theRBuffer;	long z, infoLength, theTempLong;	long extraA,extraB;	long bytesRead = 0;	Handle theExtraHandleA,theExtraHandleB;	float theFloat;    short thePercent;	extraA = 0x00010000;	extraB = 0x00000000;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;			if (!stereo)		return false;		BlockMove (&theSpec,&destLSpec,70L);	BlockMove (&theSpec,&destRSpec,70L);		/*if (*destLSpec.name < 27)		concatStrings (destLSpec.name,"\pL","\p.");	else		*(destLSpec.name+1) = '~';			if (*destRSpec.name < 26)		concatStrings (destRSpec.name,"\pR","\p.");	else		*(destLSpec.name+1) = '*';*/	*destLSpec.name = ((*destLSpec.name + *leftSuffixStr) > 31) ? (31 - (*leftSuffixStr)) : *destLSpec.name;concatStrings (destLSpec.name,leftSuffixStr,"\p");*destRSpec.name = ((*destRSpec.name + *rightSuffixStr) > 31) ? (31 - (*rightSuffixStr)) : *destRSpec.name;concatStrings (destRSpec.name,rightSuffixStr,"\p");		destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;	destRSpec.parID = theConvertDestLoc.parID;	destRSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}			iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destRSpec);					iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}				BlockMove (&destLSpec,&theNewFileLeft,70L);	BlockMove (&destRSpec,&theNewFileRight,70L);	iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;			iErr = FSpOpenDF(&destRSpec,fsWrPerm,&destRRef);		if (iErr != 0)		return false;					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}				iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	iErr = SRgetStarted ((Fixed)(theRate << 16), (Fixed)(newRate << 16),			 true, theWordSize << 3, theWordSize << 3, false, 2, 2, false);	if (iErr)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		progressDispos();		return false;	}		theLBuffer = procBufferL;	theRBuffer = procBufferR;	theBuffer = outBuffer;		while (iErr != eofErr && !eErr)	{		//inOutCount = 131072L;				inOutCount = inputSize;				iErr = FSRead(sourceRef,&inOutCount,inBuffer);		sourceBytes = inOutCount;				bytesRead += inOutCount;		/* convert */		SRprocessBuffer();					inOutCount = ((outSize >>1) << 1);		if (theWordSize == 16)		{					inOutCount = ((outSize >>2) << 2);		}						for (z=0;z<inOutCount;z+=4L)		{			if (theWordSize == 2)		 	{				*(short *)(theLBuffer + (z>>1)) = *(short *)(theBuffer + z);				*(short *)(theRBuffer + (z>>1)) = *(short *)(theBuffer + z + 2L);			}			else			{				*(Byte *)(theLBuffer + (z>>2)) = *(Byte *)(theBuffer + z);				*(Byte *)(theRBuffer + (z>>2)) = *(Byte *)(theBuffer + z + 1L);				*(Byte *)(theLBuffer + (z>>2) + 1L) = *(Byte *)(theBuffer + z + 2L);				*(Byte *)(theRBuffer + (z>>2) + 1L) = *(Byte *)(theBuffer + z + 3L);			}		}		inOutCount = inOutCount >> 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);				eErr = FSWrite(destRRef,&inOutCount,theRBuffer);						theFloat = ((float)bytesRead / (float)theBytes) * 100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			watchcursor(false);			FSClose (sourceRef);			FSClose (destLRef);			FSClose (destRRef);			SRstopIt();				return false;		}	}		watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	FSClose (destRRef);	SRstopIt();	progressDispos();	//DisposPtr(theBuffer);	//DisposPtr(theLBuffer);	//DisposPtr(theRBuffer);	writeSDIIResources(destLSpec,newRate,0,theWordSize);	writeSDIIResources(destRSpec,newRate,0,theWordSize);		addFileToList(destLSpec);	addFileToList(destRSpec);	return true;}extern Boolean problemOccurred;Boolean convertSRSD2File(FSSpec theSource,FSSpec theDest,long newRate);Boolean convertSRSD2File(FSSpec sourceSpec,FSSpec destspec,long newRate){	Ptr copyBuff;	OSErr iErr,theErr;	FInfo fndrInfo;	Str255 theStrTemp;	short theSource, theDestination;	long inOutCount;	long bytesCopied = 0,bytesToCopy = 0;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	long bytesRead = 0;	Boolean deleteTempFile = false;	FSSpec tempStor;	if (getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;					problemOccurred = false;			iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);	iErr = FSMakeFSSpec(theConvertDestLoc.vRefNum,theConvertDestLoc.parID,sourceSpec.name,&destspec);	iErr =1;	while (iErr !=0)	{		iErr = FSpCreate(&destspec,fndrInfo.fdCreator,fndrInfo.fdType,0);		if (iErr == -48) 	/** file exists **/		{			*destspec.name += 1;			*(destspec.name+(*destspec.name)) = '~';		}	}			makeStr255 ("\pTransferring:", theStrTemp);	concatStrings(theStrTemp,sourceSpec.name,"\p");	progressCreate (theStrTemp);	if (theWordSize == 3)	{		/* convert to 16-bit on temp stor */		tempStor = destspec;		*(tempStor.name + 1) += 0x80;		SDII24to16(sourceSpec,tempStor);		deleteTempFile = true;		sourceSpec = tempStor;	}		iErr = FSpOpenDF(&sourceSpec,fsRdPerm,&theSource);	if (!iErr)	{		iErr = FSpOpenDF(&destspec,fsCurPerm,&theDestination);		if (iErr!=0)		{			progressDispos();			genError("\pCan't open DF of new file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred opening the data fork of the new file: ");			writeLog((Ptr)destspec.name);			writeLogS((unsigned char *)"abandoning transfer function");			writeLogS((unsigned char *)" ");			//DisposPtr(copyBuff);			return false;		}		theErr = 0;						iErr = SRgetStarted ((Fixed)(theRate << 16), (Fixed)(newRate << 16),			 true, theWordSize << 3, theWordSize << 3, false, stereo+1, stereo+1, false);		if (iErr)		{			genError("\pOut of memory");			FSClose (theSource);			FSClose (theDestination);			FSpDelete (&destspec);			progressDispos();			return false;		}					copyBuff = outBuffer;					while(theErr!= eofErr)		{					inOutCount = inputSize;					theErr = FSRead(theSource,&inOutCount,inBuffer);			if (theErr!=0 && theErr != eofErr)			{				progressDispos();				genError("\pCan't read from DF of source file");				writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"a problem occurred read the data fork of the source file: ");				writeLog((Ptr)destspec.name);				writeLogS((unsigned char *)"abandoning transfer function");				writeLogS((unsigned char *)" ");				return false;			}			bytesRead += inOutCount;						sourceBytes = inOutCount;				/* convert */			SRprocessBuffer();						inOutCount = outSize;								iErr = FSWrite(theDestination,&inOutCount,outBuffer);			if (iErr!=0)			{				progressDispos();				genError("\pCan't write to DF of new file, disk may be full");				writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"a problem occurred writing to the data fork of the new file: ");				writeLog((Ptr)destspec.name);				writeLogS((unsigned char *)"abandoning transfer function");				writeLogS((unsigned char *)" ");								return false;			}			bytesCopied += inOutCount;			if (!bytesToCopy)				bytesToCopy  = 10L; 			if (progressDisp(LoWord (bytesCopied * 100L / bytesToCopy)))			{			 	writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"protools transfer function terminated by user");				writeLogS((unsigned char *)" ");				return false;			}		}		FSClose(theSource);		FSClose(theDestination);	}			FSpCreateResFile(&destspec,fndrInfo.fdCreator,fndrInfo.fdType,0);	iErr = ResError();	if (iErr!=0)	{		genError("\pCan't create RF of new file");		writeLogS((unsigned char *)"*********** ERROR ************");		writeLogS((unsigned char *)"a problem occurred creating the Res fork of the new file: ");		writeLog((Ptr)destspec.name);		writeLogS((unsigned char *)"abandoning transfer function");		writeLogS((unsigned char *)" ");				return false;	}	iErr = FSpOpenRF(&sourceSpec,fsCurPerm,&theSource);	if (iErr!=0 && iErr != -43)	{		genError("\pCan't open RF of source file");		writeLogS((unsigned char *)"*********** ERROR ************");		writeLogS((unsigned char *)"a problem occurred opening the Res fork of the source file: ");		writeLog((Ptr)destspec.name);		writeLogS((unsigned char *)"abandoning transfer function");		writeLogS((unsigned char *)" ");				return false;	}	if (!iErr)	{		iErr = FSpOpenRF(&destspec,fsCurPerm,&theDestination);		if (iErr!=0)		{			genError("\pCan't open RF of new file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred opening the Res fork of the new file: ");			writeLog((Ptr)destspec.name);			writeLogS((unsigned char *)"abandoning transfer function");			writeLogS((unsigned char *)" ");						return false;		}		theErr = 0;		while(theErr!= eofErr)		{			inOutCount = 262144L;			theErr = FSRead(theSource,&inOutCount,copyBuff);			iErr = FSWrite(theDestination,&inOutCount,copyBuff);			if (iErr!=0)			{				genError("\pCan't write to RF of new file, disk may be full");				writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"a problem occurred writing data to the new file: ");				writeLog((Ptr)destspec.name);				writeLogS((unsigned char *)"abandoning transfer function");				writeLogS((unsigned char *)" ");								return false;			}											}		FSClose(theSource);		FSClose(theDestination);	}	SRstopIt();	writeLogS((unsigned char *)"Sucessfully transferred");	writeLog((Ptr)destspec.name);	progressDispos();	problemOccurred = false;		ChangeSRInfo(destspec, (theNewPrefs.theBITPTPrefs.sampleRate48K) ? "\p48000" : "\p44100");	if (theWordSize == 3)	{		if (deleteTempFile)			FSpDelete(&tempStor);	}	addFileToList(destspec);}Boolean WAVToSDIISRConv(FSSpec mySpec,FSSpec destSpec, long newRate);Boolean WAVToSDIISRConv(FSSpec mySpec,FSSpec destSpec, long newRate){	Fixed theRate;	short numBits,numChans;	Boolean stereo;	short sourceRef, destRef, rfRefNum, iRefNum,theWordSize;	OSErr	iErr;	long filePos,bytesTilEnd,theTote;	long inOutCount;	long audiosize,AOffset;	FSSpec theNewFile;	Str255 theComment;	Ptr mySndH;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	Boolean notDone = true;	long bytes,bytesRead=0;	float theFloat;    short thePercent;    long bytesCopied = 0;    	if (!GetWAVInfo (mySpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))	{		return false;	}	iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}		filePos = findCOMM(sourceRef,'data');	if (!filePos)	{		genError ("\pCan't find data chunk");		iErr = FSClose(sourceRef);		return false;	}	iErr = SetFPos(sourceRef,1,filePos + 8L);			stereo = isStereo;		theRate = (unsigned long)theSRate;		/* strip .WAV if present */		iErr = FSpCreate(&destSpec,'Sd2a','Sd2f',0);	if (iErr != 0)	{		if (iErr == dupFNErr)		{			if (YesNo ("\pFile Exists, overwrite ?"))			{				FSpDelete (&destSpec);				iErr = FSpCreate(&destSpec,'Sd2a','Sd2f',0);			}			else			{				return false;			}		}	}	FSpCreateResFile(&destSpec,'Sd2a','Sd2f',0);	if (iErr != 0)	{		genError("\pCan't create new res file");		FSClose(sourceRef);		return false;	}	iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRef);	if (iErr != 0)	{		genError("\pCan't create new file");		FSClose(sourceRef);		return false;	}		progressCreate("\pConverting File");		iErr = SRgetStarted ((Fixed)(theSRate << 16), (Fixed)(newRate << 16),			 true, theWordSize, theWordSize, false, isStereo+1, isStereo+1, false);	if (iErr)	{		genError("\pOut of memory");		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		progressDispos();		return false;	}								while (notDone)	{				/***inOutCount = inputSize;					theErr = FSRead(theSource,&inOutCount,inBuffer);			if (theErr!=0 && theErr != eofErr)			{				progressDispos();				genError("\pCan't read from DF of source file");				writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"a problem occurred read the data fork of the source file: ");				writeLog((Ptr)destSpec.name);				writeLogS((unsigned char *)"abandoning transfer function");				writeLogS((unsigned char *)" ");				return false;			}						bytesCopied += inOutCount;			if (!bytes)				bytes = 1;			if (!bytesToCopy)				bytesToCopy  = 10L; 			if (progressDisp(LoWord (bytesCopied * 100L / bytes)))			{			 	writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"protools transfer function terminated by user");				writeLogS((unsigned char *)" ");				return false;			}						sourceBytes = inOutCount;							SRprocessBuffer();						inOutCount = outSize;		******/								//inOutCount = 262144L;		inOutCount = inputSize;						if (!bytes)		{			bytes = 1L;		}				theFloat = ((float)bytesRead / (float)bytes) * 100;    	thePercent = theFloat;				if (progressDisp(thePercent))		{			FSClose(sourceRef);			FSClose(destRef);			return false;		}					iErr = FSRead(sourceRef,&inOutCount,inBuffer);		//iErr = FSRead(sourceRef,&inOutCount,mySndH);		if (iErr != 0 && iErr != eofErr)		{			progressDispos();			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destRef);			return false;		}		if (iErr == eofErr)		{			notDone = false;		}				if (theWordSize == 16)			pcConv(inBuffer,inOutCount);		if (theWordSize == 8)			pcConv8(inBuffer,inOutCount);		bytesRead += inOutCount;				sourceBytes = inOutCount;			SRprocessBuffer();		inOutCount = outSize;									iErr = FSWrite(destRef,&inOutCount,outBuffer);		if (iErr != 0)		{						progressDispos();			genError("\pCan't write dest file");			FSClose(sourceRef);			FSClose(destRef);			return false;		}											}	FSClose (sourceRef);	FSClose (destRef);	SRstopIt();	progressDispos();			writeSDIIResources(destSpec,newRate,isStereo,theWordSize >> 3);		addFileToList(destSpec);	GetFSComment(mySpec, theComment);	SetFSComment (destSpec, theComment);	return true;	}Boolean WAVStereoToSDIISplitSRConv(FSSpec mySpec, long newRate);Boolean WAVStereoToSDIISplitSRConv(FSSpec mySpec, long newRate){	Fixed theRate;	FSSpec destLSpec, destRSpec;	short numBits,numChans;	Boolean stereo;	short sourceRef, destRef, rfRefNum, iRefNum,theWordSize;	OSErr	iErr;	long filePos,bytesTilEnd,theTote;	long inOutCount;	long audiosize,AOffset;	FSSpec destSpec;	Str255 theComment;	Ptr mySndH,mySndHL,mySndHR;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	Boolean notDone = true;	long bytes,bytesRead = 0;	float newSize;	long theNewSize;		float theFloat;    short thePercent,destLRef,destRRef;    long z;    	if (!GetWAVInfo (mySpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))	{		return false;	}		newSize = ((float)newRate/(float)theSRate) * (float)bytes;	theNewSize = (long)newSize >> 1;			/* strip the .WAVS */	BlockMove (&mySpec,&destLSpec,70L);	BlockMove (&mySpec,&destRSpec,70L);		/*if (*destLSpec.name < 27)		concatStrings (destLSpec.name,"\pL","\p.");	else		*(destLSpec.name+1) = '~';			if (*destRSpec.name < 26)		concatStrings (destRSpec.name,"\pR","\p.");	else		*(destRSpec.name+1) = '*';*/		*destLSpec.name = ((*destLSpec.name + *leftSuffixStr) > 31) ? (31 - (*leftSuffixStr)) : *destLSpec.name;concatStrings (destLSpec.name,leftSuffixStr,"\p");*destRSpec.name = ((*destRSpec.name + *rightSuffixStr) > 31) ? (31 - (*rightSuffixStr)) : *destRSpec.name;concatStrings (destRSpec.name,rightSuffixStr,"\p");	destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;	destRSpec.parID = theConvertDestLoc.parID;	destRSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}									iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destRSpec);					iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}				BlockMove (&destLSpec,&theNewFileLeft,70L);	BlockMove (&destRSpec,&theNewFileRight,70L);	iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;			iErr = FSpOpenDF(&destRSpec,fsWrPerm,&destRRef);		if (iErr != 0)		return false;					/*if (AllocContig(destLRef,&theNewSize))	{		if (Allocate(destLRef,&theNewSize))		{				genError("\pCant Allocate Disk space");		}	}		if (AllocContig(destRRef,&theNewSize))	{		if (Allocate(destRRef,&theNewSize))	}*/		iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}		filePos = findCOMM(sourceRef,'data');	if (!filePos)	{		genError ("\pCan't find data chunk");		iErr = FSClose(sourceRef);		iErr = FSClose(destLRef);		iErr = FSClose(destRRef);		return false;	}	iErr = SetFPos(sourceRef,1,filePos + 8L);						stereo = isStereo;		theRate = (unsigned long)theSRate;		/* strip .WAV if present */				progressCreate("\pConverting File");			iErr = SRgetStarted ((Fixed)(theRate << 16), (Fixed)(newRate << 16),			 true, theWordSize, theWordSize, false, 2, 2, false);	if (iErr)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		progressDispos();		return false;	}		while (notDone)	{		inOutCount = inputSize;		//inOutCount = 131072L;		if (!bytes)		{			bytes = 1L;		}				theFloat = ((float)bytesRead / (float)bytes) * 100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			FSClose(sourceRef);			FSClose(destLRef);			FSClose(destRRef);						return false;		}			//iErr = FSRead(sourceRef,&inOutCount,mySndH);		iErr = FSRead(sourceRef,&inOutCount,inBuffer);		if (iErr != 0 && iErr != eofErr)		{			progressDispos();			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destLRef);			FSClose(destRRef);						return false;		}		if (iErr == eofErr)		{			notDone = false;		}				if (theWordSize == 16)			pcConv(inBuffer,inOutCount);		if (theWordSize == 8)			pcConv8(inBuffer,inOutCount);						/* split them */											bytesRead += inOutCount;				sourceBytes = inOutCount;		/* convert */		SRprocessBuffer();			inOutCount = ((outSize >>1) << 1);		if (theWordSize == 16)		{					inOutCount = ((outSize >>2) << 2);		}		for (z=0;z<inOutCount;z+=4L)		{			if (theWordSize == 16)		 	{				*(short *)(procBufferL + (z>>1)) = *(short *)(outBuffer + z);				*(short *)(procBufferR + (z>>1)) = *(short *)(outBuffer + z + 2L);			}			else			{				*(Byte *)(procBufferL + (z>>2)) = *(Byte *)(outBuffer + z);				*(Byte *)(procBufferR + (z>>2)) = *(Byte *)(outBuffer + z + 1L);				*(Byte *)(procBufferL + (z>>2) + 1L) = *(Byte *)(outBuffer + z + 2L);				*(Byte *)(procBufferR + (z>>2) + 1L) = *(Byte *)(outBuffer + z + 3L);			}		}				inOutCount = inOutCount >> 1;		iErr = FSWrite(destLRef,&inOutCount,procBufferL);		if (iErr != 0)		{						progressDispos();			genError("\pCan't write dest file");			FSClose(sourceRef);			iErr = FSClose(destLRef);		iErr = FSClose(destRRef);						return false;		}		iErr = FSWrite(destRRef,&inOutCount,procBufferR);		if (iErr != 0)		{						progressDispos();			genError("\pCan't write dest file");			FSClose(sourceRef);			iErr = FSClose(destLRef);			iErr = FSClose(destRRef);						return false;		}					}	FSClose (sourceRef);	iErr = FSClose(destLRef);	iErr = FSClose(destRRef);		SRstopIt();	progressDispos();		writeSDIIResources(destLSpec,newRate,0,theWordSize >> 3);	writeSDIIResources(destRSpec,newRate,0,theWordSize >> 3);		addFileToList(destLSpec);	addFileToList(destRSpec);	GetFSComment(mySpec, theComment);	SetFSComment (destLSpec, theComment);	SetFSComment (destRSpec, theComment);	return true;	}void SDIIScriptedConcat(void);void SDIIScriptedConcat(void){	StandardFileReply reply;	SFTypeList typeList;	long rate;	short numBits,scriptRefNum,sourceRefNum, destRefNum;	Boolean stereo;	long theBytes;	FSSpec destSpec, sourceSpec;	Ptr theLine;	short z;	short whereWeAre = 1;	Str255 destName;	Str255 sourceName;	char theChar = 0;	Ptr copyBuffer;	OSErr iErr, eErr;	Str255 theText;	long inOutCount = 0;	short	len, rc;	IOParam pb;	long whereStart;	GrafPtr savePort;	short fontNum;		GetPort(&savePort);		typeList[0] = 'TEXT';		//genError ("\pSelect Script");		StandardGetFile(0,1,typeList,&reply);	if (!reply.sfGood)	{			return;		}		SetPort(myWindow);		GetFNum(theFontRec.fontName,&fontNum);	TextFont(fontNum);						/** font for list - chicago **/	TextSize(theFontRec.fontSize);	TextFace(0);	LUpdate((*myList)->port->visRgn,myList);										//SetPort(savePort);		theLine = NewPtrClear (32768L);	if (!theLine)	{		genError("\p Out of Memory");		return;	}		copyBuffer = NewPtrClear (65536L);	if (!copyBuffer)	{		genError("\p Out of Memory");		DisposPtr(theLine);		return;	}			/* open the script */	iErr = FSpOpenDF(&reply.sfFile,fsRdPerm,&scriptRefNum);	if (iErr)	{		SysBeep(5);		return;	}		watchcursor(true);	theChar = 0;	rc=0;	pb.ioActCount = 0;	while (rc!=eofErr)	{				pb.ioRefNum = scriptRefNum;		pb.ioPosMode = fsAtMark | 0x80 | (256*EOL);		pb.ioReqCount = 250;	// max line size		pb.ioBuffer = theLine + 1;		// transfer to this address				rc=PBRead((union ParamBlockRec *) &pb, FALSE );	// read one line		*theLine = pb.ioActCount;				if (pb.ioActCount > 1 && (!rc || rc == eofErr))		{			whereWeAre = 1;						/* get the dest name and location */			BlockMove (theLine + whereWeAre, destSpec.name+1, 63L);			theChar = 0;			while (theChar != 0x09 && theChar != EOL && whereWeAre<64)			{				theChar = *(theLine + whereWeAre);				whereWeAre ++;			}			*destSpec.name = whereWeAre - 2;			getConvertDest();			destSpec.parID = theConvertDestLoc.parID;			destSpec.vRefNum = theConvertDestLoc.vRefNum;						/* create the destination file */			iErr = FSpCreate(&destSpec,'Sd2a','Sd2f',0);			if (iErr)			{				Str255 theMessage = "\pDest File could not be created, skipping line : ";				concatStrings (theMessage,destSpec.name,"\p");				genError(theMessage);								while (theChar != EOL)				{					theChar = *(theLine + whereWeAre);					whereWeAre ++;				}			}			else			{				/* open the dest file */				iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRefNum);				if (iErr)				{					genError("\pCant open dest file");									}											while (theChar != EOL   && (whereWeAre<= pb.ioActCount))				{					Cell thereadCell;					/* get a source name */					whereStart = whereWeAre;					BlockMove (theLine + whereWeAre, sourceSpec.name+1, 63L);					theChar = 0;					whereWeAre ++;					while (theChar != 0x09 && theChar != EOL && (whereWeAre-whereStart<64L))					{						theChar = *(theLine + whereWeAre);						whereWeAre ++;					}					*sourceSpec.name = whereWeAre - whereStart - 1;									/* search for the source file in the list */					sourceSpec.vRefNum = -999;					for (z=0;z<totfindcounter;z++)					{						if(EqualString((*therealResults)[z].name,sourceSpec.name,true,true)) 						{							sourceSpec = (*therealResults)[z];							if (DisplayedColumns == 4)							{								thereadCell.v = z/4;								thereadCell.h = z - (thereadCell.v * 4);							}							else							{								thereadCell.v = z;								thereadCell.h = 0;							}							outLineCell (thereadCell, myList);							break;						}					}										/* check for failure */					if (sourceSpec.vRefNum == -999)					{						Str255 theMessage = "\pSource File could not be found, skipping item : ";						concatStrings (theMessage,sourceSpec.name,"\p");						genError(theMessage);					}					else					{						/* get copying */						if (!getSDIIData (sourceSpec, &rate, &numBits, &stereo, &theBytes))						{							iErr = FSpOpenDF(&sourceSpec,fsRdPerm,&sourceRefNum);							if (!iErr)							{																while (iErr!= eofErr)								{									inOutCount = 60000L;									iErr = FSRead(sourceRefNum,&inOutCount,copyBuffer);									eErr = FSWrite(destRefNum, &inOutCount,copyBuffer);									if (eErr)									{										genError("\pProblem writing maybe disk is full");										goto bailout1;																		}								}								FSClose (sourceRefNum);											}							else							{									Str255 theMessage = "\pSource File could not be opened, skipping item : ";								concatStrings (theMessage,sourceSpec.name,"\p");								genError(theMessage);							}						}						else						{							Str255 theMessage = "\pSource File is not SDII, skipping item : ";							concatStrings (theMessage,sourceSpec.name,"\p");							genError(theMessage);						}					}					unOutLineCell (thereadCell, myList);					}		bailout1:				FSClose (destRefNum);				writeSDIIResources(destSpec,rate,stereo,numBits);				addFileToList(destSpec);			}						}	}	bailout2:			watchcursor(false);	FSClose (scriptRefNum);		}void SDIIAddSilenceMany(void);void SDIIAddSilenceMany(void){	Cell theCell;	short theindex;	Boolean mixMode = true;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr;	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(11113,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);			ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				mixMode = true;			break;						case 4:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				mixMode = false;			break;		}	}while (itemHit != 1 && itemHit != 2);		GetDItem(myDlg,5,&iType,&iHndl,&iRect);	GetIText(iHndl,textStr);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;	StringToNum(textStr,&theMilliseconds);		getConvertDest();	writeLogS((unsigned char *)"Starting Add silence convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (mixMode)		{			if (SDIIAddSilenceStart((*therealResults)[theindex]))			{				writeLog((Ptr)(*therealResults)[theindex].name);				}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}		}		else		{			if (SDIIAddSilenceEnd((*therealResults)[theindex]))			{				writeLog((Ptr)(*therealResults)[theindex].name);				}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean SDIIReverse(FSSpec theSpec);void SDIIReverseMany(void);void SDIIReverseMany(void){	Cell theCell;	short theindex;			getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		SDIIReverse((*therealResults)[theindex]);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}void SDIIProcessMany(void){	Cell theCell;	short theindex;	FSSpec destSpec;		getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		BlockMove (&(*therealResults)[theindex],&destSpec,70L);			destSpec.parID = theConvertDestLoc.parID;		destSpec.vRefNum = theConvertDestLoc.vRefNum;		convertSDIIFormat ((*therealResults)[theindex],destSpec, 48000L, 16, 1);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}Boolean SDIIReverse(FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err, eErr;	long theRate, inOutCount;	short theWordSize;	Boolean stereo;	long theBytes,z;	Ptr theData, theData2;	FSSpec theSourceSpec;	Str255 theComment;	long theMilliBytes;	short iRefNum;	long sourcePtr;	BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	sourcePtr = theBytes;	theSpec.parID = theConvertDestLoc.parID;	theSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}						theData = NewPtrClear(66000L);		if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				theData2 = NewPtrClear(66000L);		if (!theData2)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			DisposPtr(theData);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\pre-writing file");		while (sourcePtr > 0)		{			inOutCount = 65536L;			if (sourcePtr - inOutCount < 0)			{				inOutCount = sourcePtr;			}			sourcePtr -= inOutCount;						iErr = SetFPos(sRefNum,1,sourcePtr);			if (iErr)			{									}						err = FSRead(sRefNum,&inOutCount,theData);						if (theWordSize == 2)			{					for (z=(inOutCount - 2);z>=0;z-=2L)				{					*(((short *)theData2) + (((inOutCount - 2) - z) >> 1)) = *(((short *)theData) + (z >> 1));				}						}			else			{				for (z=(inOutCount - 1);z>=0;z--)				{					*(((char *)theData2) + ((inOutCount - 1) - z)) = *(((char *)theData) + z);				}				}			/* reverse it */									iErr = FSWrite(RefNum,&inOutCount,theData2);			if (iErr )			{				SysBeep(5);				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				watchcursor(false);				DisposPtr(theData);				DisposPtr(theData2);				return false;			}		}		progressDispos();		watchcursor(false);				FSClose (RefNum);		FSClose(sRefNum);				/* copy res fork */		writeSDIIResources(theSpec,theRate,stereo,theWordSize);				DisposPtr(theData);		DisposPtr(theData2);		GetFSComment(theSourceSpec, theComment);		SetFSComment (theSpec, theComment);			addFileToList(theSpec);		return true;/* copy comment */}Boolean SDIIAddSilenceStart(FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err, eErr;	long theRate, inOutCount;	short theWordSize;	Boolean stereo;	long theBytes,z;	Handle theData;	FSSpec theSourceSpec;	Str255 theComment;	long theMilliBytes;	short iRefNum;	BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	theMilliBytes = (theMilliseconds *  (theRate * (long)theWordSize * (long)(stereo +1))) / 1000L;		if (theMilliBytes & 0x00000001)		theMilliBytes ++;	theSpec.parID = theConvertDestLoc.parID;	theSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}						theData = NewHandleClear(33000L);				if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				memset(*theData,0,32768L);				while (theMilliBytes > 0L)		{			inOutCount = (theMilliBytes >= 32768L) ? 32768L : theMilliBytes;			iErr = FSWrite(RefNum,&inOutCount,*theData);			theMilliBytes -= inOutCount;				}				err = 0;		watchcursor(true);		progressCreate("\pre-writing file");		while (err != eofErr)		{			inOutCount = 32768L;			err = FSRead(sRefNum,&inOutCount,*theData);			iErr = FSWrite(RefNum,&inOutCount,*theData);			if (iErr )			{				SysBeep(5);				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				watchcursor(false);				return false;			}		}		progressDispos();		watchcursor(false);				FSClose (RefNum);		FSClose(sRefNum);				/* copy res fork */		writeSDIIResources(theSpec,theRate,stereo,theWordSize);		/*iRefNum = CurResFile();				sRefNum = FSpOpenResFile(&theSourceSpec,fsRdPerm);		if (sRefNum == -1)		{			SysBeep(5);			return false;		}		FSpCreateResFile(&theSpec,'Sd2a','Sd2f',0);		RefNum = FSpOpenResFile(&theSpec,fsWrPerm);		if (RefNum == -1)		{			SysBeep(5);			return false;		}		iErr =0;		while (iErr != eofErr)		{			inOutCount = 2L;			iErr = FSRead(sRefNum,&inOutCount,*theData);			eErr = FSWrite(RefNum,&inOutCount,*theData);				}		CloseResFile(sRefNum);		CloseResFile(RefNum);		UseResFile(iRefNum);*/		DisposHandle(theData);				GetFSComment(theSourceSpec, theComment);		SetFSComment (theSpec, theComment);			addFileToList(theSpec);		return true;/* copy comment */}Boolean SDIIAddSilenceEnd(FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Handle theData;	FSSpec theSourceSpec;	Str255 theComment;	long theMilliBytes;			if (getSDIIData (theSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	theMilliBytes = (theMilliseconds *  (theRate * (long)theWordSize * (long)(stereo +1))) / 1000L;	if (theMilliBytes & 0x00000001)		theMilliBytes ++;		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = SetFPos(RefNum,2,0);				theData = NewHandleClear(33000L);				if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			//FSClose(sRefNum);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\padding silence");		while (theMilliBytes > 0L)		{			inOutCount = (theMilliBytes >= 32768L) ? 32768L : theMilliBytes;			iErr = FSWrite(RefNum,&inOutCount,*theData);			theMilliBytes -= inOutCount;				}		progressDispos();		watchcursor(false);				FSClose (RefNum);		DisposHandle(theData);		return true;/* copy comment */}short GetKRZInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);short GetKRZInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length){	OSErr	iErr;	short refNum;	long inOutCount;	OSType theWAVHeader;	long tempLong;	short tempShort;	Boolean isIMA = false;	OSType myIMATest;	long mylong;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		return false;	}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&theWAVHeader);	if (iErr!=0)	{		iErr = FSClose(refNum);		return false;	}		if (theWAVHeader != 'PRAM')	{		iErr = FSClose(refNum);		return 0;	}		inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&theWAVHeader);	if (iErr!=0)	{		iErr = FSClose(refNum);		return false;	}		*length = theWAVHeader + 4;	*isStereo = false;	*theSRate = 44100L;		*theWordSize = 16;				*theDuration = 0;	iErr = FSClose(refNum);	return 1;}void stripComments(void){	Cell theCell;	short theindex;		SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		SetComment ((*therealResults)[theindex],theindex, "\p");		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}short countSDIIRegions(FSSpec mySpec);void deselectIfMoreThanOneRegion(void);void deselectIfMoreThanOneRegion(void){	Cell theCell;	short theindex;	short numRgns;	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		numRgns = countSDIIRegions((*therealResults)[theindex]);		if (numRgns > 1)		{			LSetSelect(false,theCell,myList);		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}