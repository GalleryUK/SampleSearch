#include "SampleSearch.h"#include "Globals.h"#include "prefs.h"extern newPrefsRec theNewPrefs;#include "undoStuff.h"Boolean lookWhereLast;Boolean checkFileTypes;Boolean MultipleTypesSearch;OSType theRegisteredType;short getNumberSelected(void);Boolean burnSampToInstPlusType (FSSpec theInstSpec,FSSpec theSampSpec,short theSampIndex, OSType theType);Boolean burntheData;Boolean makeNewList;OSType theActualType;FSSpec theLastThingFound;Boolean scanList(Str255	theDrive);#define kNoSCIIData -5Boolean	resolveDawn (FSSpec theSpec);typedef struct resolveRec {Str27	driveName;long	dirID;Str31	fileName;OSType	type;Boolean	found;} resolveRec, *resRecPtr;short ptResolvePickOne(short numEntries, FSSpec * theFiles);void progressWindowCreate(Str255	theText);OSErr progressWinDisp(short percent);void progressWindowDispose(void);Boolean VgetvolName(short theVRefNum, StringPtr myString);Boolean resolveBank (FSSpec mySpec, short index);OSErr  getNumOfEntries (FSSpec	mySpec);void	getSCIIfile(FSSpec	mySpec,short	index,resRecPtr myRec);void saveForUndo (void);Boolean rRectoFSSpec(resRecPtr myResRecPtr, FSSpecPtr mySpecPtr);Boolean ResolveSCIIFSSpec(Str31	myFileName, long	catHint, short driveHint, OSType	theType, FSSpecPtr mySpecPtr);Boolean burnInstToBank (FSSpec theBankSpec,FSSpec theInstSpec,short theInstIndex);Boolean burnSampToInst (FSSpec theInstSpec,FSSpec theSampSpec,short theSampIndex);pascal	OSErr	PBCatSearchSyncCompat(CSParamPtr paramBlock);pascal	OSErr	myPBCatSearchSyncCompat(CSParamPtr paramBlock);Boolean resolveBank (FSSpec mySpec, short index){		FInfo **	myInstanceTypeH;	FSSpec ** myInstanceH;	Ptr	myInstancePtr;	Ptr	myInstanceTypePtr;	resRecPtr	tempRRecPtr, nullRec;	struct resolveRec myTempRec;	long inst,samp,instTot,sampTot;	long	memSize, memtypeSize;	short 	arrayPointer = 0;	StandardFileReply	reply;	OSErr  iErr;	short	 itemHit,refNum;	FInfo	fndrInfo;	long	fileLength;	long inOutCount;	FSSpec	myTempSpec;	short iRefNum, myRefNum;	short z;	Handle hString[28];	Handle volumeRef[28];	short dispFar;	short dispFarSeg;	FSSpec	myPSpec;	FSSpec	myInstSpec;	Str31	theDefName;	Str31	resText = "\p resolved";		//BlockMove (mySpec,&myPSpec,70L);	//mySpec = &myPSpec;			if 	(!FInfolistInMem)	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)			{				genError("\pCould not expand FInfo in Resolve");				return false;			}						checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));									for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}	if (((*theFInfo)[index]).fdType != 'MixD')	{		genError ("\pSampleSearch can only resolve SampleCell Files");		return false;	}	if (-(mySpec.vRefNum) > (maxVRef))	{		genError("\pCan't resolve a ghost bank");		return false;	}		tempRRecPtr = &myTempRec;		instTot = getNumOfEntries (mySpec);				/** how many instruments ? **/	if (!instTot)	{		genError ("\pThat file is empty");		return false;	}		if (instTot == kNoSCIIData)	{		genError ("\pCant Resolve SampleCell I files, only SampleCell II files");		return;	}					myInstanceH = (FSSpec **)NewHandle(70L);				/** make mem **/	memSize = 70L;	if (!myInstanceH)	{		genError ("\pNot enough memory to allocate Handle");		return;	}	//MoveHHi(myInstanceH);	myInstanceTypeH = (FInfo **)NewHandle(16L);				/** make mem **/	memtypeSize = 16L;	if (!myInstanceTypeH)	{		genError ("\pNot enough memory to allocate type Handle");		return;	}	//MoveHHi(myInstanceTypeH);	BlockMove (&mySpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/	BlockMove (&((*theFInfo)[index]),((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/	arrayPointer++;	progressWindowCreate("\pResolving Bank");	writeLogS((unsigned char *)"Began Resolve of File");	writeLog((Ptr)(mySpec.name));		   				for (inst = 0;inst < instTot;inst ++)	{		getSCIIfile(mySpec,inst,&myTempRec);		/** get a name from bank **/		if (!(myTempRec.found))		{			genError("\pCannot complete the instruction because an unexpected error occured");			progressWindowDispose();			return false;		}				//tempSpecPtr = &myTempSpec;		iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/		if (!iErr && (myTempSpec.vRefNum == 0))		{			if (checkFileTypes)			{				checkFileTypes = 0;				iErr = ResolveSCIIFSSpec(tempRRecPtr->fileName,0,1,tempRRecPtr->type,&myTempSpec);				checkFileTypes = 1;			}			else			{				 iErr = ResolveSCIIFSSpec(tempRRecPtr->fileName,0,1,tempRRecPtr->type,&myTempSpec);			}		}		 if (myTempSpec.vRefNum == -999)	/** abort this inst **/		 {		   	writeLogS((unsigned char *)"*********** ERROR ************");		    writeLogS((unsigned char *)"Could not find the instrument file below, which has been ignored as has it's samples");		    writeLog((Ptr)(tempRRecPtr->fileName));		    writeLogS((unsigned char *)" ");		 }		 else		{			memSize += 70L;							SetHandleSize((Handle)myInstanceH, memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}			memtypeSize += 16L;							SetHandleSize((Handle)myInstanceTypeH, memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}						BlockMove (&myTempSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/				iErr = FSpGetFInfo(&myTempSpec,&fndrInfo);			if (iErr!=0)			{				genError("\pProblem getting FInfo");				progressWindowDispose();				return false;			}			BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/				/** burn instrument in to bank here **/						if (burntheData)			{				burnInstToBank (mySpec,myTempSpec,inst);			}				/************************************/			arrayPointer ++;					sampTot = getNumOfEntries (myTempSpec);			/** find out how many samples it has **/				if (sampTot == kNoSCIIData)		{			progressWindowDispose();			genError ("\pCant Resolve SampleCell I files, only SampleCell II files");			return;		}									memSize += (70L*(sampTot+1));							SetHandleSize((Handle)myInstanceH,memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}							memtypeSize += (16L*(sampTot+1));							SetHandleSize((Handle)myInstanceTypeH,memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}				if (instTot>1)			{				dispFar = ((inst+1) * 100)/(instTot);				dispFarSeg = 100/(instTot-1);			}			else			{				dispFar =0;				dispFarSeg =100;			}			if (progressWinDisp(dispFar))			{				DisposHandle((Handle)myInstanceH);				DisposHandle((Handle)myInstanceTypeH);				return;			}							BlockMove (&myTempSpec,&myInstSpec,70L);						for (samp = 0;samp < sampTot;samp ++)			{							if (sampTot && dispFarSeg)				{					short progressAmount;					progressAmount = ((float)(samp+1) / (float)(sampTot)) * dispFarSeg;//					if(progressWinDisp(dispFar+((((samp+1) * 100)/(sampTot)*dispFarSeg)/100)))					if(progressWinDisp(progressAmount))					{						DisposHandle((Handle)myInstanceH);						DisposHandle((Handle)myInstanceTypeH);						return;					}				}				/*if(progressDisp(dispFar+((((samp+1) * 100)/(sampTot)*dispFarSeg)/100)))				{					DisposHandle((Handle)myInstanceH);					DisposHandle((Handle)myInstanceTypeH);					return;				}*/				getSCIIfile(myInstSpec,samp, tempRRecPtr);		/** get a name from bank **/				if (!tempRRecPtr->found)				{					genError ("\pA problem occurred getting a sample name");					progressWindowDispose();					return false;				}				iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/				if (!iErr && (myTempSpec.vRefNum == -999))				{					genError("\pCan't make FSSpec");					progressWindowDispose();					return false;				}				if (!iErr && (myTempSpec.vRefNum == 0))				{					iErr = ResolveSCIIFSSpec(myTempSpec.name,0,1,tempRRecPtr->type, &myTempSpec);				}				if (!iErr)				{				 	writeLogS((unsigned char *)"*********** ERROR ************");					 writeLogS((unsigned char *)"Could not find the sample file below, which has been ignored");		   			 writeLog((Ptr)(myTempSpec.name));		   			 writeLogS((unsigned char *)" ");				}				else				{								BlockMove (&myTempSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/													iErr = FSpGetFInfo(&myTempSpec,&fndrInfo);						if (iErr!=0)						{							genError("\pProblem getting FInfo");							progressWindowDispose();							return false;						}					BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/				/** burn sample in to instrument here **/					if (burntheData)					{						if (checkFileTypes)						{							burnSampToInstPlusType (myInstSpec,myTempSpec,samp, fndrInfo.fdType);						}						else							burnSampToInst (myInstSpec,myTempSpec,samp);					}		/***************************************/					arrayPointer ++;				}			}		}	}	progressWindowDispose();		BlockMove(mySpec.name,theDefName,*(mySpec.name)+1);	BlockMove(resText + 1,theDefName + (*theDefName) + 1,*resText);	*theDefName = *(mySpec.name) + *resText;		if (makeNewList)	{		StandardPutFile("\pEnter a filename for the bank list",theDefName,&reply);		if (reply.sfGood)		{			if (reply.sfReplacing)						iErr = FSpDelete(&reply.sfFile);			iErr = FSpCreate(&(reply.sfFile),'MgAl','SFlf',reply.sfScript);			if (iErr !=0 && iErr!= -48)			{				genError ("\pCan't create new list file");				return false;			}			if (iErr == -48)			{					color.red = 56797;				color.green = 56797;				color.blue = 56797;				RGBBackColor(&color);				itemHit = dAlert(2684,0);				if (itemHit == 1)				{					iErr = FSpDelete(&(reply.sfFile));					if (iErr != 0)						genError ("\pCan't delete");					iErr = FSpCreate(&(reply.sfFile),'MgAl','SFlf',reply.sfScript);					if (iErr != 0)						genError ("\pStill Can't create file");				}				}			iErr = FSpOpenDF(&(reply.sfFile),fsCurPerm,&refNum);			if (iErr !=0)			{				genError ("\pCan't open new file");				return false;			}			inOutCount = 4L;			fileLength = arrayPointer * 70L;			iErr = FSWrite(refNum,&inOutCount,&fileLength);			if (iErr !=0)			{				genError ("\pCan't write to list file");				return false;			}				inOutCount = arrayPointer *70L;			iErr = FSWrite(refNum,&inOutCount,(*myInstanceH));			if (iErr !=0)			{				genError ("\pCan't write to list file");				return false;			}				inOutCount = 4L;			fileLength = arrayPointer;			iErr = FSWrite(refNum,&inOutCount,&fileLength);			if (iErr !=0)			{				genError ("\pCan't write to list file");				return false;			}				inOutCount = arrayPointer *16L;			iErr = FSWrite(refNum,&inOutCount,(*myInstanceTypeH));			if (iErr !=0)			{				genError ("\pCan't write to list file");				return false;			}				iErr = FSClose (refNum);				if (iErr !=0)				genError ("\pProblem closing file ");						/****************************/			gogetvolref();		iRefNum = CurResFile();			HCreateResFile(reply.sfFile.vRefNum,reply.sfFile.parID,reply.sfFile.name);		iErr = ResError();		if (iErr!=0)			genError("\pCould not create resource file");		myRefNum = HOpenResFile(reply.sfFile.vRefNum,reply.sfFile.parID,reply.sfFile.name,fsCurPerm);				if (myRefNum == -1)			genError("\pCould not open new resource fork");			UseResFile(myRefNum);			iErr = ResError();			if (iErr!=0)			genError("\pCould not use new resource fork");			for (z=1;z<=volumearrayptr;z++)		{				hString[z] = NewHandle(256);			if (!hString[z])			{				genError ("\pMemory Allocation Failed");				UseResFile(iRefNum);				return false;			}			volumeRef[z] = NewHandle(2);			if (!volumeRef[z])			{				genError ("\pMemory Allocation Failed");				UseResFile(iRefNum);				return false;			}			BlockMove(volName[z],*hString[z],*volName[z]+1);			AddResource(hString[z],'oVOL',z,"\pVolume Name for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");			**(volumeRef[z]) = volumes[z];			AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");			iErr = ResError();			if (iErr != 0)			{				genError ("\pCan't create resource");				UseResFile(iRefNum);				return false;			}			}		for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)		{				hString[z] = NewHandle(256);			if (!hString[z])			{				genError ("\pMemory Allocation Failed");				return false;			}			volumeRef[z] = NewHandle(2);			if (!volumeRef[z])			{				genError ("\pMemory Allocation Failed");				UseResFile(iRefNum);				return false;			}			BlockMove(fvolName[z],*hString[z],*fvolName[z]+1);			AddResource(hString[z],'oVOL',z,"\pVolume Name for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");			**(volumeRef[z]) = volumes[z];			AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");			iErr = ResError();			if (iErr != 0)			{				genError ("\pCan't create resource");				UseResFile(iRefNum);				return false;			}		}							CloseResFile(myRefNum);		UseResFile(iRefNum);				iErr = ResError();		if (iErr!=0)			genError("\pCould not use old resource file");					for (z=1;z<=fvolumearrayptr;z++)		{			ReleaseResource(volumeRef[z]);			ReleaseResource(hString[z]);		}					/******************************/					//DisposPtr(myInstanceTypePtr);			//DisposPtr(myInstancePtr);						writeLogS((unsigned char *)"Finished Resolve");				color.red = 56797;				color.green = 56797;				color.blue = 56797;				RGBBackColor(&color);			itemHit = dAlert (1994,0);			if (itemHit == 1)			{				saveForUndo ();				openFSList((reply.sfFile));				checkList();		gogetvolref();		resolveOVols();			}		}		else		{			DisposHandle((Handle)myInstanceH);			DisposHandle((Handle)myInstanceTypeH);		 	writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"Resolve cancelled");			writeLogS((unsigned char *)" ");			return 0;		}	}	DisposHandle((Handle)myInstanceH);	DisposHandle((Handle)myInstanceTypeH);}Boolean rRectoFSSpec(resRecPtr myResRecPtr, FSSpecPtr mySpecPtr){	short	myVRefNum;	OSErr	iErr;		mySpecPtr->vRefNum = 0;	BlockMove (myResRecPtr->fileName,mySpecPtr->name,(*(myResRecPtr->fileName))+1);	myVRefNum = FgetVRefNum(myResRecPtr->driveName);	if (!myVRefNum)	{		mySpecPtr->vRefNum = 0;		return false;	}	iErr = FSMakeFSSpec(myVRefNum,myResRecPtr->dirID,myResRecPtr->fileName,mySpecPtr);	if (iErr == -43 || iErr == -120)	{		mySpecPtr->vRefNum = 0;		BlockMove(myResRecPtr->fileName,mySpecPtr->name,*(myResRecPtr->fileName)+1);		return false;	}	if (iErr != 0 )	{		mySpecPtr->vRefNum = -999;		BlockMove(myResRecPtr->fileName,mySpecPtr->name,*(myResRecPtr->fileName)+1);		return false;	}	return	true;}OSErr getNumOfEntries (FSSpec	mySpec){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles = 0;	extern theFNameListLen;	short z;	long filpPOS;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if(iErr!=0)	{		//genError ("\p Can't open that file");		SysBeep(5);		return 0;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{		FSClose(refNum);		return kNoSCIIData;	}		iErr = SetFPos(refNum,1,(long)filpPOS+8L);	if(iErr!=0)	{		genError ("\p Can't set pos in that file");		FSClose(refNum);		return 0;	}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&numberOfFiles);	if(iErr!=0)	{		genError ("\p Can't read number of files in that file");		FSClose(refNum);		return 0;	}	FSClose(refNum);	return numberOfFiles;}/** pass the resrecPtr for this function to mod **/void getSCIIfile(FSSpec	mySpec,short	index, resRecPtr myRec){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern theFNameListLen;	short z;	long filpPOS;			iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		(*myRec).found = false;		return;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{		FSClose(refNum);		(*myRec).found = false;		return;	}		iErr = SetFPos(refNum,1,((long)filpPOS+16L) + (long)((long)index * 68L));	if(iErr!=0)	{		//genError ("\p Can't set pos in that file");		SysBeep(5);		FSClose(refNum);		(*myRec).found = false;		return;	}	inOutCount = 28;	iErr = FSRead(refNum,&inOutCount,(*myRec).driveName);		if(iErr!=0)		{			//genError ("\p Can't read a drive name in that file");			SysBeep(5);			FSClose(refNum);			(*myRec).found = false;			return;		}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&((*myRec).dirID));		if(iErr!=0)		{			//genError ("\p Can't read a DirID in that file");			SysBeep(5);			FSClose(refNum);			(*myRec).found = false;			return;		}	inOutCount = 32;	iErr = FSRead(refNum,&inOutCount,&((*myRec).fileName));		if(iErr!=0)		{			//genError ("\p Can't read a filename in that file");			SysBeep(5);			FSClose(refNum);			(*myRec).found = false;			return;		}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&((*myRec).type));		if(iErr!=0)		{			//genError ("\p Can't read a type in that file");			SysBeep(5);			FSClose(refNum);			(*myRec).found = false;			return;		}		FSClose(refNum);	(*myRec).found = true;	return;}Boolean ResolveSCIIFSSpec(Str31	myFileName, long	catHint, short driveHint, OSType	theType, FSSpecPtr mySpecPtr){	HParamBlockRec RPb; 				/** parameter block for PBCatSearch **/	short z;	OSErr	gErr,iErr;	short q;	short fTypes;	OSType ftypelist[3];	FInfo fndrInfo;			char *occur;	Str255 Cstring,substring;	long numsofar;	FSSpec * theResolveSpec;	ftypelist[1] = 'AIFF';	ftypelist[0] = 'Sd2f';	ftypelist[2] = 'SFIL';		if (checkFileTypes && (theType =='AIFF' || theType =='Sd2f' || theType =='SFIL'))	{		fTypes = 2;	}	else		fTypes = 0;					theResolveSpec = (FSSpec *)NewPtrClear(1000 * 70L);	if (!theResolveSpec)	{		genError("\pNot enough memory to resolve");		return false;	}		/**********************/	/**********************/	numsofar = 0;			mySpecPtr->vRefNum = -999;/* bus error here */		gogetvolref();		/**********************/	/**********************/	if (lookWhereLast)	{		iErr = FSMakeFSSpec(theLastThingFound.vRefNum,theLastThingFound.parID,myFileName,&theResolveSpec[0]);		if (!iErr)		{			iErr = FSpGetFInfo(&theResolveSpec[0],&fndrInfo);			if (fndrInfo.fdType == theType);			{				BlockMove(&(theResolveSpec[0]),mySpecPtr,70L); 				DisposPtr((Ptr)theResolveSpec);				return true;			}		}	}		for (q=0;q<=fTypes;q++)	{		for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/		{		 	 BlockMove (volName[z],Cstring,*(volName[z])+1);		  PtoCstr (Cstring);		  makeStr255("\pAudio CD",substring);		  PtoCstr (substring);		  occur = strstr((const char *)Cstring,(const char *)substring);			if (!(*volName[z]))			{				occur = (Ptr)1;			}		  if (!occur)		   {		    if (!scanList(volName[z]))			{			  				RPb.csParam.ioVRefNum = volumes[z];		/** select relevant volume **/								RPb.csParam.ioCompletion = nil;  				/** no completion routine **/				RPb.csParam.ioNamePtr = nil;   			 		/** no volume name;  use vRefNum **/				RPb.csParam.ioMatchPtr = theResolveSpec + (numsofar * 70L);  			/** points to results buffer **/				RPb.csParam.ioReqMatchCount = 1000-numsofar;;   	/** number of matches **/														/** search for name + file or directory + file TYPE  **/				RPb.csParam.ioSearchBits = fsSBFullName + fsSBFlAttrib + fsSBFlFndrInfo;														RPb.csParam.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/				RPb.csParam.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/				RPb.csParam.ioSearchTime = 0;              	/** don't time out on searches **/				RPb.csParam.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/				RPb.csParam.ioOptBuffer = gBuffer;    			/** point to search cache  **/				RPb.csParam.ioOptBufSize  = kOptBufferSize;		/** size of search cache **/							gSpec1.hFileInfo.ioNamePtr = myFileName;   		/** point to string to find **/				gSpec1.hFileInfo.ioFlAttrib = 0x00;      		/** clear bit 4 to ask for files **/					if (fTypes > 0)					gSpec1.hFileInfo.ioFlFndrInfo.fdType = ftypelist[q] ; //searchType;	/** just find ???? files **/				else					gSpec1.hFileInfo.ioFlFndrInfo.fdType = theType;									gSpec1.hFileInfo.ioFlFndrInfo.fdCreator = 0;								gSpec2.hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/				gSpec2.hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/				gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  				gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0;											if (theNewPrefs.dontFindAliases)			{				gSpec1.hFileInfo.ioFlFndrInfo.fdFlags = 0;				gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;					}							else				{					gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;					}								watchcursor(TRUE);					/** display watch **/					do 					{						gErr = myPBCatSearchSyncCompat((CSParam *)&RPb);	/** get some files returns error 0 (noErr) if it returns without finishing **/							} while (gErr == 0 && ((theNewPrefs.PTResolveFindOne) ? (RPb.csParam.ioActMatchCount == 0) : true));					if ( RPb.csParam.ioActMatchCount > 0 && theNewPrefs.PTResolveFindOne)				{					numsofar ++;					goto herey;															/** display arrow **/				}		    }		  }		   numsofar += RPb.csParam.ioActMatchCount;		}	}	herey:	watchcursor(FALSE);	if ( numsofar == 0)	{		FlashMenuBar(0);		FlashMenuBar(0);		DisposPtr((Ptr)theResolveSpec);		return false;	}	else	{			if ( numsofar > 0)		{			if (theNewPrefs.PTResolveFindOne ||  (numsofar == 1))			{				BlockMove(&(theResolveSpec[0]),mySpecPtr,70L); 				BlockMove(&(theResolveSpec[0]),&theLastThingFound,70L);				DisposPtr((Ptr)theResolveSpec);				return true;			}			else			{				short myReturn = ptResolvePickOne(numsofar, theResolveSpec);				if (myReturn == -99)				{					DisposPtr((Ptr)theResolveSpec);					return false;				}				else				{									BlockMove(&(theResolveSpec[myReturn]),mySpecPtr,70L); 					BlockMove(&(theResolveSpec[myReturn]),&theLastThingFound,70L);					DisposPtr((Ptr)theResolveSpec);					return true;				}			}		}	}	DisposPtr((Ptr)theResolveSpec);	return true;}FSSpec ResolveSCIIFSSpec2(Str31	myFileName, long	catHint, short driveHint, OSType	theType);FSSpec ResolveSCIIFSSpec2(Str31	myFileName, long	catHint, short driveHint, OSType	theType){	HParamBlockRec RPb; 				/** parameter block for PBCatSearch **/	short z;	OSErr	gErr;	FSSpec	retSpec;	char *occur;	Str255 Cstring,substring;	long numsofar;	FSSpec * theResolveSpec;	retSpec.vRefNum = -999;/* bus error here */		gogetvolref();		/**********************/	/**********************/	theResolveSpec = (FSSpec *)NewPtrClear(1000 * 70L);		if (!theResolveSpec)	{		genError("\pNot enough memory to resolve");		retSpec.vRefNum = -999;		return retSpec;	}		/**********************/	/**********************/	numsofar = 0;	for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{		BlockMove (volName[z],Cstring,*(volName[z])+1);	    PtoCstr (Cstring);	    makeStr255("\pAudio CD",substring);	    PtoCstr (substring);	    occur = strstr((const char *)Cstring,(const char *)substring);	if (!(*volName[z]))	{		occur = (Ptr)1;	}	    if (!occur)	    {			if (!scanList(volName[z]))			{				{					RPb.csParam.ioVRefNum = volumes[z];		/** select relevant volume **/										RPb.csParam.ioCompletion = nil;  				/** no completion routine **/					RPb.csParam.ioNamePtr = nil;   			 		/** no volume name;  use vRefNum **/					RPb.csParam.ioMatchPtr = theResolveSpec + (numsofar * 70L);  			/** points to results buffer **/					RPb.csParam.ioReqMatchCount = 1000-numsofar;   	/** number of matches **/																/** search for name + file or directory + file TYPE  **/					RPb.csParam.ioSearchBits = fsSBFullName + fsSBFlAttrib + fsSBFlFndrInfo;																RPb.csParam.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/					RPb.csParam.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/					RPb.csParam.ioSearchTime = 0;              	/** don't time out on searches **/					RPb.csParam.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/					RPb.csParam.ioOptBuffer = gBuffer;    			/** point to search cache  **/					RPb.csParam.ioOptBufSize  = kOptBufferSize;		/** size of search cache **/									gSpec1.hFileInfo.ioNamePtr = myFileName;   		/** point to string to find **/					gSpec1.hFileInfo.ioFlAttrib = 0x00;      		/** clear bit 4 to ask for files **/					gSpec1.hFileInfo.ioFlFndrInfo.fdType = theType ; //searchType;	/** just find ???? files **/					gSpec1.hFileInfo.ioFlFndrInfo.fdCreator = 0;										gSpec2.hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/					gSpec2.hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/					gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  					gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0;																		if (theNewPrefs.dontFindAliases)					{						gSpec1.hFileInfo.ioFlFndrInfo.fdFlags = 0;						gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;							}							else				{					gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;					}						watchcursor(TRUE);					/** display watch **/					do 					{						gErr = myPBCatSearchSyncCompat((CSParam *)&RPb);	/** get some files returns error 0 (noErr) if it returns without finishing **/									} while (gErr == 0 && ((theNewPrefs.PTResolveFindOne) ? (RPb.csParam.ioActMatchCount == 0) : true));									if ( RPb.csParam.ioActMatchCount > 0 && theNewPrefs.PTResolveFindOne)					{						numsofar ++;						break;															/** display arrow **/					}				}			}		}		numsofar += RPb.csParam.ioActMatchCount;	}	watchcursor(FALSE);	if ( numsofar == 0)	{				FlashMenuBar(0);			FlashMenuBar(0);		DisposPtr((Ptr)theResolveSpec);		retSpec.vRefNum = -999;		return retSpec;	}	else	{			if ( numsofar > 0)		{			if (theNewPrefs.PTResolveFindOne || (numsofar == 1))			{				BlockMove(&(theResolveSpec[0]),&retSpec,70L); 				BlockMove(&(theResolveSpec[0]),&theLastThingFound,70L);				DisposPtr((Ptr)theResolveSpec);				return retSpec;			}			else			{				short myReturn = ptResolvePickOne(numsofar, theResolveSpec);				if (myReturn == -99)				{					DisposPtr((Ptr)theResolveSpec);					retSpec.vRefNum = -999;					return retSpec;				}				else				{									BlockMove(&(theResolveSpec[myReturn]),&retSpec,70L); 					BlockMove(&(theResolveSpec[myReturn]),&theLastThingFound,70L);					DisposPtr((Ptr)theResolveSpec);					return retSpec;				}			}		}			}	DisposPtr((Ptr)theResolveSpec);	return retSpec;}Boolean resolveInst (FSSpec mySpec, short index);Boolean resolveInst (FSSpec mySpec, short index){		FInfo **	myInstanceTypeH;	FSSpec ** myInstanceH;	Ptr	myInstancePtr;	Ptr	myInstanceTypePtr;	resRecPtr	tempRRecPtr, nullRec;	struct resolveRec myTempRec;	long inst,samp,instTot,sampTot;	long	memSize, memtypeSize;	short 	arrayPointer = 0;	StandardFileReply	reply;	OSErr  iErr;	short	itemHit, refNum;	FInfo	fndrInfo;	long	fileLength;	long inOutCount;	FSSpec	myTempSpec;	short iRefNum, myRefNum;	short z;	Handle hString[499];	Handle volumeRef[499];	short dispFar;	short dispFarSeg;	FSSpec	myPSpec;	FSSpec	myInstSpec;	Str31	theDefName;	Str31	resText = "\p resolved";	long newMemSize,newMemTypeSize;				if 	(!FInfolistInMem)	{			FInfoArrayPtr = totfindcounter;			iErr = MemError();			if (iErr!=0)			{				genError("\pCould not expand FInfo in Resolve");				return false;			}						checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));									for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}	if (((*theFInfo)[index]).fdType != 'SCin' && ((*theFInfo)[index]).fdType != 'SCsi'&& ((*theFInfo)[index]).fdType != 'SCsd'&& ((*theFInfo)[index]).fdType != 'SCss')	{		genError ("\pSampleSearch can only resolve SampleCell Files");		return false;	}	if (-(mySpec.vRefNum) > (maxVRef))	{		genError("\pCan't resolve a ghost bank");		return false;	}	tempRRecPtr = &myTempRec;	instTot = 1;	if (!instTot)	{		genError ("\pThat file is empty");		return false;	}		myInstanceH = (FSSpec **)NewHandle(70000L);				/** make mem **/	memSize = 70000L;	if (!myInstanceH)	{		genError ("\pNot enough memory to allocate Handle");		return;	}	myInstanceTypeH = (FInfo **)NewHandle(16000L);				/** make mem **/	memtypeSize = 16000L;	if (!myInstanceTypeH)	{		genError ("\pNot enough memory to allocate type Handle");		return;	}	BlockMove (&mySpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/	BlockMove (&((*theFInfo)[index]),((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/	arrayPointer++;//	progressCreate("\pResolving Instrument");	progressWindowCreate("\pResolving Instrument");	writeLogS((unsigned char *)"Began Resolve of File");	writeLog((Ptr)(mySpec.name));		   				for (inst = 0;inst < instTot;inst ++)	{			myTempRec.found = 1;		BlockMove (volName[-(mySpec.vRefNum)],myTempRec.driveName,*(volName[-(mySpec.vRefNum)])+1);		myTempRec.dirID = mySpec.parID;		BlockMove (mySpec.name,myTempRec.fileName,*(mySpec.name)+1);		myTempRec.type = ((*theFInfo)[index]).fdType;				if (!(myTempRec.found))		{			genError("\pCannot complete the instruction because an unexpected error occured");			progressWindowDispose();			return false;		}		iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/		if (!iErr && (myTempSpec.vRefNum == 0))		{			 iErr = ResolveSCIIFSSpec(tempRRecPtr->fileName,0,1,tempRRecPtr->type,&myTempSpec);		}		 if (myTempSpec.vRefNum == -999)	/** abort this inst **/		 {		 	writeLogS((unsigned char *)"*********** ERROR ************");		    writeLogS((unsigned char *)"Could not find the instrument file below, which has been ignored as has it's samples");		    writeLog((Ptr)(tempRRecPtr->fileName));		    writeLogS((unsigned char *)" ");		 }		 else		{				/*	memSize += 70L;							SetHandleSize((Handle)myInstanceH, memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}			memtypeSize += 16L;							SetHandleSize((Handle)myInstanceTypeH, memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}		*/			if (arrayPointer >= (memSize / 70))			{				memSize += 70000L;								SetHandleSize((Handle)myInstanceH, memSize);				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize pointer");					progressWindowDispose();					return;				}				memtypeSize += 16000L;								SetHandleSize((Handle)myInstanceTypeH, memtypeSize);				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize type pointer");					progressWindowDispose();					return;				}			}					iErr = FSpGetFInfo(&myTempSpec,&fndrInfo);			if (iErr!=0)			{				genError("\pProblem getting FInfo");				progressWindowDispose();				return false;			}			//BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/					//arrayPointer ++;					sampTot = getNumOfEntries (myTempSpec);			/** find out how many samples it has **/							if (sampTot == kNoSCIIData)			{				progressWindowDispose();				genError ("\pCant Resolve SampleCell I files, only SampleCell II files");				return;			}					newMemSize = (arrayPointer + sampTot+1) * 70L;			newMemTypeSize = (arrayPointer + sampTot+1) * 16L;			if (memSize <= newMemSize)			{				memSize += 70000L;							if (newMemSize > memSize)				{					SetHandleSize((Handle)myInstanceH, newMemSize);					memSize = newMemSize;				}				else				{					SetHandleSize((Handle)myInstanceH, memSize);				}					iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize pointer");				progressWindowDispose();					return;				}				memtypeSize += 16000L;								if (newMemTypeSize > memtypeSize)				{					SetHandleSize((Handle)myInstanceTypeH, newMemTypeSize);					newMemTypeSize = newMemTypeSize;				}				else				{					SetHandleSize((Handle)myInstanceTypeH, memtypeSize);				}				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize type pointer");					progressWindowDispose();					return;				}			}		/*	memSize += (70L*(sampTot+1));							SetHandleSize((Handle)myInstanceH,memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressDispos();				return;			}							memtypeSize += (16L*(sampTot+1));							SetHandleSize((Handle)myInstanceTypeH,memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressDispos();				return;			}	*/			dispFar = 0;			dispFarSeg = 100;			if (progressWinDisp(0))			{				DisposHandle((Handle)myInstanceH);				DisposHandle((Handle)myInstanceTypeH);				return;			} 			BlockMove (&myTempSpec,&myInstSpec,70L);			for (samp = 0;samp < sampTot;samp ++)			{				short progressAmount;				if (sampTot && dispFarSeg)				{					short progressAmount;					progressAmount = ((float)(samp+1) / (float)(sampTot)) * dispFarSeg;//					if(progressWindowDisp(dispFar+((((samp+1) * 100)/(sampTot)*dispFarSeg)/100)))					if(progressWinDisp(progressAmount))					{						DisposHandle((Handle)myInstanceH);						DisposHandle((Handle)myInstanceTypeH);						return;					}				}								getSCIIfile(myInstSpec,samp, tempRRecPtr);		/** get a name from bank **/				if (!tempRRecPtr->found)				{					genError ("\pA problem occurred getting a sample name");				progressWindowDispose();					return false;				}				iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/				if (!iErr && (myTempSpec.vRefNum == -999))				{					genError("\pCan't make FSSpec");				progressWindowDispose();					return false;				}				if (!iErr && (myTempSpec.vRefNum == 0))				{					iErr = ResolveSCIIFSSpec(tempRRecPtr->fileName,0,1,tempRRecPtr->type, &myTempSpec);				}				if (!iErr)				{		 		 	writeLogS((unsigned char *)"*********** ERROR ************");					 writeLogS((unsigned char *)"Could not find the sample file below, which has been ignored");		   			 writeLog((Ptr)(myTempSpec.name));		   			 writeLogS((unsigned char *)" ");				}				else				{								BlockMove (&myTempSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/													iErr = FSpGetFInfo(&myTempSpec,&fndrInfo);						if (iErr!=0)						{							genError("\pProblem getting FInfo");							progressWindowDispose();							return false;						}					BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/										if (burntheData)					{						if (checkFileTypes)						{							burnSampToInstPlusType (myInstSpec,myTempSpec,samp, fndrInfo.fdType);						}						else							burnSampToInst (myInstSpec,myTempSpec,samp);					}					arrayPointer ++;				}			}		}	}	progressWindowDispose();	BlockMove(mySpec.name,theDefName,*(mySpec.name)+1);	BlockMove(resText + 1,theDefName + (*theDefName) + 1,*resText);	*theDefName = *(mySpec.name) + *resText;	if (makeNewList)  {	StandardPutFile("\pEnter a filename for the Instrument's list",theDefName,&reply);	if (reply.sfGood)	{		if (reply.sfReplacing)					iErr = FSpDelete(&reply.sfFile);		iErr = FSpCreate(&(reply.sfFile),'MgAl','SFlf',reply.sfScript);		if (iErr !=0 && iErr!= -48)		{			genError ("\pCan't create new list file");			return false;		}		if (iErr == -48)		{				color.red = 56797;			color.green = 56797;			color.blue = 56797;			RGBBackColor(&color);			itemHit = dAlert(2684,0);			if (itemHit == 1)			{				iErr = FSpDelete(&(reply.sfFile));				if (iErr != 0)					genError ("\pCan't delete");				iErr = FSpCreate(&(reply.sfFile),'MgAl','SFlf',reply.sfScript);				if (iErr != 0)					genError ("\pStill Can't create file");			}			}		iErr = FSpOpenDF(&(reply.sfFile),fsCurPerm,&refNum);		if (iErr !=0)		{			genError ("\pCan't open new file");			return false;		}		inOutCount = 4L;		fileLength = arrayPointer * 70L;		iErr = FSWrite(refNum,&inOutCount,&fileLength);		if (iErr !=0)		{			genError ("\pCan't write to list file");			return false;		}			inOutCount = arrayPointer *70L;		iErr = FSWrite(refNum,&inOutCount,(*myInstanceH));		if (iErr !=0)		{			genError ("\pCan't write to list file");			return false;		}			inOutCount = 4L;		fileLength = arrayPointer;		iErr = FSWrite(refNum,&inOutCount,&fileLength);		if (iErr !=0)		{			genError ("\pCan't write to list file");			return false;		}			inOutCount = arrayPointer *16L;		iErr = FSWrite(refNum,&inOutCount,(*myInstanceTypeH));		if (iErr !=0)		{			genError ("\pCan't write to list file");			return false;		}			iErr = FSClose (refNum);			if (iErr !=0)			genError ("\pProblem closing file ");				/****************************/		gogetvolref();	iRefNum = CurResFile();		HCreateResFile(reply.sfFile.vRefNum,reply.sfFile.parID,reply.sfFile.name);	iErr = ResError();	if (iErr!=0)		genError("\pCould not create resource file");	myRefNum = HOpenResFile(reply.sfFile.vRefNum,reply.sfFile.parID,reply.sfFile.name,fsCurPerm);		if (myRefNum == -1)		genError("\pCould not open new resource fork");	UseResFile(myRefNum);		iErr = ResError();		if (iErr!=0)		genError("\pCould not use new resource fork");	/*for (z=1;z<=volumearrayptr;z++)	{			hString = NewHandle(256);		//MoveHHi(hString);		BlockMove(volName[z],*hString,*volName[z]+1);		AddResource(hString,'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{			hString = NewHandle(256);		//MoveHHi(hString);		BlockMove(fvolName[z],*hString,*fvolName[z]+1);		AddResource(hString,'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}*/	for (z=1;z<=volumearrayptr;z++)	{			hString[z] = NewHandle(256);		if (!hString[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		volumeRef[z] = NewHandle(2);		if (!volumeRef[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		BlockMove(volName[z],*hString[z],*volName[z]+1);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");		**(volumeRef[z]) = volumes[z];		AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			UseResFile(iRefNum);			return false;		}	}	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{			hString[z] = NewHandle(256);		if (!hString[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		volumeRef[z] = NewHandle(2);		if (!volumeRef[z])		{			genError ("\pMemory Allocation Failed");			UseResFile(iRefNum);			return false;		}		BlockMove(fvolName[z],*hString[z],*fvolName[z]+1);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");		**(volumeRef[z]) = volumes[z];		AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			UseResFile(iRefNum);			return false;		}	}	CloseResFile(myRefNum);	UseResFile(iRefNum);	iErr = ResError();	if (iErr!=0)		genError("\pCould not use old resource file");			for (z=1;z<=fvolumearrayptr;z++)	{		ReleaseResource(volumeRef[z]);		ReleaseResource(hString[z]);	}					/******************************/		writeLogS((unsigned char *)"Finished Instrument Resolve");		color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	itemHit = dAlert (1994,0);	if (itemHit == 1)	{		saveForUndo ();		openFSList((reply.sfFile));		checkList();		gogetvolref();		resolveOVols();	}   }   else   {  		DisposHandle((Handle)myInstanceH);	DisposHandle((Handle)myInstanceTypeH);  	 return 0;   }  }	  DisposHandle((Handle)myInstanceH);	DisposHandle((Handle)myInstanceTypeH);	return 0;}Boolean burnInstToBank (FSSpec theBankSpec,FSSpec theInstSpec,short theInstIndex){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern theFNameListLen;	short z;	long filpPOS;	Str255 tempStr;		iErr = FSpOpenDF(&theBankSpec,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		//genError ("\p Can't open that file");		return ;	}			filpPOS = findFILP(refNum);	if (!filpPOS)	{		genError ("\p FILP failed");		FSClose(refNum);		return ;	}	iErr = SetFPos(refNum,1,((long)filpPOS+16L)+((long)theInstIndex * 68L));	if(iErr!=0)	{		genError ("\p Can't set pos in that file");		FSClose(refNum);		return ;	}	inOutCount = 28;		/*fill temp str with volume name */	VgetvolName(theInstSpec.vRefNum, (StringPtr) tempStr);	iErr = FSWrite(refNum,&inOutCount,tempStr);	if(iErr!=0)	{		genError ("\p Can't write a volume name in that file");		FSClose(refNum);		return ;	}	inOutCount = 4;	iErr = FSWrite(refNum,&inOutCount,&theInstSpec.parID);	if(iErr!=0)	{		genError ("\p Can't write a DirID in that file");		FSClose(refNum);		return;	}	FSClose(refNum);		if(iErr!=0)		{			genError("\p Can't close that file");		}	iErr = FlushVol(0,theBankSpec.vRefNum);		if(iErr!=0)		{			genError  ("\p flush vol failed");		}	return;}Boolean burnSampToInst (FSSpec theInstSpec,FSSpec theSampSpec,short theSampIndex){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern theFNameListLen;	short z;	long filpPOS;	Str255 tempStr;		iErr = FSpOpenDF(&theInstSpec,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		//genError ("\p Can't open that file");		return ;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{	 genError ("\pFilpPos didn't work");		FSClose(refNum);		return;	}	iErr = SetFPos(refNum,1,((long)filpPOS+16L)+((long)theSampIndex * 68L));	if(iErr!=0)	{		genError  ("\p Can't set pos in that file");		FSClose(refNum);		return ;	}	inOutCount = 28;	VgetvolName(theSampSpec.vRefNum, (StringPtr) tempStr);		iErr = FSWrite(refNum,&inOutCount,tempStr);	if(iErr!=0)	{		genError  ("\p Can't write a volume name in that file");		FSClose(refNum);		return ;	}	inOutCount = 4;	iErr = FSWrite(refNum,&inOutCount,&theSampSpec.parID);	if(iErr!=0)	{		genError  ("\p Can't write a DirID in that file");		FSClose(refNum);		return;	}	FSClose(refNum);		if(iErr!=0)		{			genError  ("\p Can't close that file");		}	iErr = FlushVol(0,theInstSpec.vRefNum);	if(iErr!=0)		{			genError  ("\p flush vol failed");		}	return;}void ResolveMany(void);void ResolveMany(void){	FInfo fndrInfo;	OSErr	iErr;	Point theCell;	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	short itemHit, theindex;	burntheData = false;	makeNewList = true;	lookWhereLast = true;		checkFileTypes = false;	myDlg = GetNewDialog(12010,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,9,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	if (getNumberSelected() > 1)	{		GetDItem(myDlg,4,&iType,&iHndl,&iRect);		HiliteControl((ControlHandle)iHndl,255);		GetDItem(myDlg,5,&iType,&iHndl,&iRect);		HiliteControl((ControlHandle)iHndl,255);	}	ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;						case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));				 if (GetCtlValue((ControlHandle)iHndl))				 {					 GetDItem(myDlg,9,&iType,&iHndl,&iRect);					 SetCtlValue((ControlHandle)iHndl,false);				 }			break;						case 9:				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));				 if (GetCtlValue((ControlHandle)iHndl))				 {					 GetDItem(myDlg,8,&iType,&iHndl,&iRect);					 SetCtlValue((ControlHandle)iHndl,false);				 }			break;						case 1:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					burntheData = false;					makeNewList = true;				}				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					burntheData = true;					makeNewList = true;				}				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					burntheData = true;					makeNewList = false;				}				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				checkFileTypes = GetCtlValue((ControlHandle)iHndl);				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				lookWhereLast = GetCtlValue((ControlHandle)iHndl);			break;			case 2:			break;					}	}	DisposDialog(myDlg);	if (itemHit == 2)		return;		SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		iErr = FSpGetFInfo(&((*therealResults)[theindex]),&fndrInfo);		if (!iErr)		{			switch(fndrInfo.fdType)			{				case 'MixD':					resolveBank (((*therealResults)[theindex]), theindex);				break;				case 'SCin':case 'SCsi':case 'SCsd':case 'SCss':					resolveInst (((*therealResults)[theindex]), theindex);				break;				case 'CR02':					resolveDawn ((*therealResults)[theindex]);				break;			}		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	return;}short getNumberSelected(void){	short theTotal = 0;	Point theCell;		SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theTotal++;		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	return theTotal;}Boolean burnSampToInstPlusType (FSSpec theInstSpec,FSSpec theSampSpec,short theSampIndex, OSType theType){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern theFNameListLen;	short z;	long filpPOS;	Str255 tempStr;		iErr = FSpOpenDF(&theInstSpec,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		//genError ("\p Can't open that file");		return ;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{	 genError ("\pFilpPos didn't work");		FSClose(refNum);		return;	}	iErr = SetFPos(refNum,1,((long)filpPOS+16L)+((long)theSampIndex * 68L));	if(iErr!=0)	{		genError  ("\p Can't set pos in that file");		FSClose(refNum);		return ;	}	inOutCount = 28;	VgetvolName(theSampSpec.vRefNum, (StringPtr) tempStr);		iErr = FSWrite(refNum,&inOutCount,tempStr);	if(iErr!=0)	{		genError  ("\p Can't write a volume name in that file");		FSClose(refNum);		return ;	}	inOutCount = 4;	iErr = FSWrite(refNum,&inOutCount,&theSampSpec.parID);	if(iErr!=0)	{		genError  ("\p Can't write a DirID in that file");		FSClose(refNum);		return;	}	iErr = SetFPos(refNum,3,32L);	inOutCount = 4;	iErr = FSWrite(refNum,&inOutCount,&theType);	if(iErr!=0)	{		genError  ("\p Can't write a type in that file");		FSClose(refNum);		return;	}	FSClose(refNum);		if(iErr!=0)		{			genError  ("\p Can't close that file");		}	iErr = FlushVol(0,theInstSpec.vRefNum);	if(iErr!=0)		{			genError  ("\p flush vol failed");		}	return;}