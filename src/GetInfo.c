#include "SampleSearch.h"#include "Globals.h"#include <Packages.h>#include <AIFF.h>#include <SoundInput.h>#include <stdio.h>#include <FixMath.h>//#include "fp.h"void checkForMPG(StringPtr theName,FInfo * theFinfo);#include <Sound.h>#include <Resources.h>extern Boolean dontQuery;Boolean GetFileInfo (FSSpec mySpec, short index, FInfo*	theFndrInfoPtr);Boolean GetComment (FSSpec mySpec, short index, StringPtr theComment);Boolean SetComment(FSSpec mySpec, short index, Str255 theComment);Boolean GetSizeDate (FSSpec mySpec, short index, long* theSize, long* theDate);Boolean GetSampleRateTime (FSSpec mySpec, short index, long theSize, long* theSRate, long* theDuration, Boolean* isStereo, OSType theFileType);Boolean DrawInfoBox (FSSpec mySpec, short index);Boolean translateFileType (OSType	theType, StringPtr theTypeText);void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);extern long theAPPLReply;Boolean VgetvolName(short theVRefNum, StringPtr myString);long theTXFERLong;short GetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);void checkForWAV(StringPtr theName,FInfo * theFinfo);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);void checkForKRZ(StringPtr theName,FInfo * theFinfo);long findCOMM(short localRefNum, OSType	theType);Boolean SetFSSpecComment(FSSpec mySpec, Str255 theComment);Boolean GetFSSpecComment(FSSpec mySpec, StringPtr theComment);short identifySCII(FSSpec mySpec);long findANNO(short localRefNum);long findAPPL(short localRefNum);Boolean removeCommentFromChunkEnd(short localRefNum, long theFPos, OSType theType);Boolean addCommentToChunkEnd(short localRefNum, Str255 theComment, OSType theType);Boolean addAIFFCommentToChunkEnd(short localRefNum, Str255 theComment, OSType theType);Boolean zapAPPL(short localRefNum);Boolean zapANNO(short localRefNum);Boolean isItTheLastChunk(short localRefNum, long theFPos);Boolean GetSizeDate (FSSpec mySpec, short index, long* theSize, long* theDate){	long theResSize = 0L;	long theDataSize = 0L;	long theModDate = 0;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	OSErr	iErr;	Str255 zfilename;	long	dirID,myDrDir;	short Fcounter = 0;		BlockMove((*therealResults)[index].name,zfilename,64L);	fpb->ioVRefNum = (*therealResults)[index].vRefNum;		/* default volume */	fpb->ioNamePtr = zfilename;	/* buffer to receive name */	fpb->ioFDirIndex = 0; 	fpb->ioDirID = (*therealResults)[index].parID;		rc = PBGetCatInfo( &cipbr, FALSE );		if (rc) 			return false;	if (!(fpb->ioFlAttrib & 16)) 	{		theDataSize = fpb->ioFlLgLen;		theResSize = fpb->ioFlRLgLen;		theModDate = fpb->ioFlMdDat;		*theSize = (long)(theDataSize+theResSize);		*theDate = (unsigned long)(theModDate);		return true;	}	else	{		return false;	}}Boolean GetFileInfo (FSSpec mySpec, short index, FInfo*	theFndrInfoPtr){	OSErr	iErr;		if (FInfolistInMem)	{		BlockMove (&((*theFInfo)[index]), theFndrInfoPtr, 16L);		return true;	}	else	{		if ((*therealResults)[index].vRefNum <= maxVRef)		{			iErr = FSpGetFInfo(&mySpec,theFndrInfoPtr);			return (iErr == 0);		}		(*theFndrInfoPtr).fdType = '....';		(*theFndrInfoPtr).fdCreator = '....';		(*theFndrInfoPtr).fdFldr = 0;		return false;	}}Boolean GetSampleRateTime (FSSpec mySpec, short index, long theSize, long* theSRate, long* theDuration, Boolean* isStereo, OSType theFileType){	short refNum, tempchans, fRefNum, thecurfile;	OSErr	iErr;	long inOutCount;	Fixed	sampleRate;	long	mysamprate;	long length;	Handle hRsrc;	Str255	chans,sampsize;	char	mysampsize;	long	xx;	char	mychans;	short 	numChans;	short	numBits;	Str255	samprate;	long filePos;	CommonChunk	myCommCnk;	long audiosize,AOffset;	/******/	Handle	mySndH[2];	SndChannelPtr mySndChan;	// pointer to a sound channel	OSErr myErr;	Boolean	whichBuff;	short keycounter;	long z;	Boolean fileEnded,Endedfile;	SCStatus theStatus;	short headerLen;	Boolean bigBit;	/***************/	long theRate;	short theWordSize;	short channels; 	long theBytes;	if (-((*therealResults)[index].vRefNum) > maxVRef)		return false;			switch (theFileType)	{		case 'SFIL':			*isStereo = false;			iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);				if (iErr!=0)			{				genErrorN("\pFile does not exist, is already open, or is damaged",iErr);				FSClose(refNum);				return false;			}							iErr = SetFPos(refNum,1,1020L);			if (iErr!=0)			{				genErrorN("\pCould not position in file",iErr);				iErr = FSClose(refNum);				return false;			}			inOutCount = 4;				iErr = FSRead(refNum,&inOutCount,&mysamprate);			if (iErr!=0)			{				genErrorN("\pCould not sample rate from SDI file",iErr);				iErr = FSClose(refNum);				return false;			}			sampleRate = mysamprate;			*theSRate = (long)sampleRate;			if (!sampleRate)				sampleRate = 1;			*theDuration = (theSize/2L) / (long) sampleRate;			iErr = FSClose(refNum);			return true;		break;				case 'AIFF':		getAIFFDataII (mySpec,&theRate, &theWordSize,&channels, &theBytes);			iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);			if (iErr!=0)			{				genError ("\pFile does not exist, is already open, or is damaged");				return;			}						filePos = findCOMM(refNum,'COMM');			filePos = theTXFERLong;			if (!filePos)			{				genError ("\pCan't find common chunk");				iErr = FSClose(refNum);				if (iErr!=0)				genErrorN("\pError closing DF",iErr);				return false;			}			inOutCount = sizeof (CommonChunk);			iErr = SetFPos(refNum,1,filePos);			iErr = FSRead(refNum,&inOutCount,&myCommCnk);			if (iErr!=0)			{				genError ("\pCan't read comm chunk from file");				iErr = FSClose(refNum);			if (iErr!=0)				genErrorN("\pError closing DF",iErr);				return false;			}			iErr = SetFPos(refNum,1,0L);						filePos = findCOMM(refNum,'SSND');			if (!filePos)			{				genError ("\pCan't find SSND chunk");				iErr = FSClose(refNum);			if (iErr!=0)				genErrorN("\pError closing DF",iErr);				return false;			}			filePos += 4L;			inOutCount = 4L;			iErr = SetFPos(refNum,1,filePos);			iErr = FSRead(refNum,&inOutCount,&audiosize);			if (iErr!=0)			{				genError ("\pCan't read audio size from file");				iErr = FSClose(refNum);			if (iErr!=0)				genErrorN("\pError closing DF",iErr);				return false;			}			iErr = FSRead(refNum,&inOutCount,&AOffset);			if (iErr!=0)			{				genError ("\pCan't read AOffset from file");				iErr = FSClose(refNum);			if (iErr!=0)				genErrorN("\pError closing DF",iErr);				return false;			}			if (false /*AOffset*/)			{				genError ("\pThis type of AIFF is not yet supported");				iErr = FSClose(refNum);			if (iErr!=0)				genErrorN("\pError closing DF",iErr);				return false;			}			filePos += 4L;			iErr = SetFPos(refNum,1,filePos);			numChans = myCommCnk.numChannels;			numBits = myCommCnk.sampleSize;									sampleRate = theRate;//(long)(myCommCnk.sampleRate);						*theSRate = (unsigned long)sampleRate;			*isStereo = (numChans == 2);			/* check this calculation  */						if (!*theSRate)				*theSRate = 1;			*theDuration = (audiosize / (long)(numBits / 8L) / (long)numChans / (long)(*theSRate));			iErr = FSClose(refNum);		break;				case 'Sd2f':			thecurfile = CurResFile();			fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);			iErr = ResError();			if (iErr!=0)			{				genErrorN("\pFile does not exist, is already open, or is damaged",iErr);				return false;			}			UseResFile(fRefNum);			iErr = ResError();			if (iErr!=0)			{				genErrorN("\pError using res file",iErr);				CloseResFile(fRefNum);				UseResFile(thecurfile);				return false;			}						hRsrc = Get1Resource('STR ',1000);			if (hRsrc == 0)			{				genErrorN("\pError getting ID1000",0);				CloseResFile(fRefNum);				UseResFile(thecurfile);				return false;			}						mysampsize =*(*hRsrc+1);			*sampsize = 1;			*(sampsize+1) = mysampsize;			StringToNum(sampsize,&xx);			numBits = LoWord(xx);						hRsrc = Get1Resource('STR ',1001);			if (hRsrc == 0)			{				CloseResFile(fRefNum);				UseResFile(thecurfile);				genErrorN("\pError getting ID1001",0);				return false;			}			BlockMove (*hRsrc,samprate,20L);			if (*(samprate + 5L) == '.')				*samprate = 4;			else				*samprate = 5;						StringToNum(samprate,&sampleRate);			//sampleRate = sampleRate * 65536L;						hRsrc = Get1Resource('STR ',1002);			if (hRsrc == 0)			{				CloseResFile(fRefNum);				UseResFile(thecurfile);				genErrorN("\pError getting ID1002",0);				return false;			}			mychans =*(*hRsrc+1);			*chans = 1;			*(chans+1) = mychans;			StringToNum(chans,&xx);			numChans = LoWord(xx);			CloseResFile(fRefNum);			iErr = ResError();			if (iErr!=0)				genErrorN("\pError closing res file",iErr);			UseResFile(thecurfile);			iErr = ResError();			if (iErr!=0)				genErrorN("\pError using old res file",iErr);				*theSRate = (long)sampleRate;			*isStereo = (numChans == 2);			*theDuration = theSize / (long)numBits / (long)numChans / (long)sampleRate;						return true;		break;			case '.WAV':			GetWAVInfo (mySpec,theSRate, &numBits,theDuration, isStereo, &length);		break;				default:			return false;		break;	}	/*	*theSRate = 0;	*theDuration = 0;	*isStereo = false;*/	return true;}Boolean translateFileType (OSType	theType, StringPtr theTypeText){	switch (theType)	{		case 'SCin':			makeStr255("\pSampleCell mono Instrument", theTypeText);			return true;		break;				case 'SCsi':			makeStr255("\pSampleCell stereo Instrument", theTypeText);			return true;		break;				case 'MixD':			makeStr255("\pSampleCell Bank", theTypeText);			return true;		break;				case 'SCss':			makeStr255("\pSampleCell thingy instrument", theTypeText);			return true;		break;				case 'SCsd':			makeStr255("\pSampleCell thingy 2 instrument", theTypeText);			return true;		break;				case 'Sd2f':			makeStr255("\pSound Designer II sample", theTypeText);			return true;		break;				case 'SFIL':			makeStr255("\pSound Designer I sample", theTypeText);			return true;		break;				case 'AIFF':			makeStr255("\pAIFF sample", theTypeText);			return true;		break;			case 'scSG':			makeStr255("\pCubase Audio Song", theTypeText);			return true;		break;				case 'WDBN':			makeStr255("\pMicrosoft Word File", theTypeText);			return true;		break;				case '.WAV':			makeStr255("\pMicrosoft WAVE File", theTypeText);			return true;		break;						case 'PSes':			makeStr255("\pPro Tools¨ v3.X session", theTypeText);			return true;		break;				case 'PT4S':			makeStr255("\pPro Tools¨ v4.X 16-bit session", theTypeText);			return true;		break;		case 'PT5S':			makeStr255("\pPro Tools¨ v5.X session", theTypeText);			return true;		break;		case 'PT24':			makeStr255("\pPro Tools¨ v4.X 24-bit session", theTypeText);			return true;		break;							case 'MPEG':			makeStr255("\pMPEG", theTypeText);			return true;		break;		case 'Mp3':			makeStr255("\pMp3 ", theTypeText);			return true;		break;		default:			BlockMove (&theType, theTypeText+1, 4L);			*theTypeText = 4;			return false;		break;		}}Boolean DrawInfoBox (FSSpec mySpec, short index){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean results, isStereo;	Str255 theComment;	Str255 secondsText = "\p seconds";	FInfo	fndrInfo;	GrafPtr	savePort;	Str255 theTypeText;	DateTimeRec	 dtrp;	Str255 DateStr, sizeStr, SRateStr, durationStr;	long theSize, theDate, theSRate, theDuration;	Str255 fullPathName,textStr,volnamestring;	OSErr	iErr;	Boolean dontChangeComment;	FSSpec BUSpec;	long duration;		GetPort(&savePort);	myDlg = GetNewDialog(15000,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	if ((*therealResults)[index].vRefNum > maxVRef)	{		HideDItem(myDlg,7);	}	else	{		HideDItem(myDlg,20);	}		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		if (!dontQuery)	{			results = GetComment (mySpec, index, theComment);		if (!results)		{			HideDItem(myDlg,7);			ShowDItem(myDlg,20);			dontChangeComment = true;		}		else		{			dontChangeComment = false;		}	}	else	{		*theComment = 0;		HideDItem(myDlg,7);		ShowDItem(myDlg,20);		dontChangeComment = true;	}		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetIText(iHndl,theComment);	GetDItem(myDlg,20,&iType,&iHndl,&iRect);	SetIText(iHndl,theComment);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetIText(iHndl,mySpec.name);			results = GetFileInfo (mySpec,index, &fndrInfo);	results = translateFileType (fndrInfo.fdType, theTypeText);		switch (fndrInfo.fdType)	{		case 'Sd2f':case 'AIFF':case 'AIFC':case 'SFIL':case '.WAV':case 'WAVE':case 'MooV':		break;		default:			checkForWAV(mySpec.name,&fndrInfo);		break;	}	GetDItem(myDlg,9,&iType,&iHndl,&iRect);	SetIText(iHndl,theTypeText);		BlockMove (&fndrInfo.fdCreator, theTypeText+1, 4L);	*theTypeText = 4;	GetDItem(myDlg,24,&iType,&iHndl,&iRect);	SetIText(iHndl,theTypeText);		results = GetSizeDate (mySpec,index, &theSize, &theDate);	if (!results)	{		theSize = 0L;		theDate = 0L;	}	IUDateString(theDate,0,DateStr);	GetDItem(myDlg,13,&iType,&iHndl,&iRect);	SetIText(iHndl,DateStr);	results = false;	*durationStr = 0;	makeStr255("\pNot Sample",SRateStr);	if ((fndrInfo.fdType == 'AIFF' || fndrInfo.fdType == 'SFIL' || fndrInfo.fdType == 'Sd2f' || fndrInfo.fdType == '.WAV') && !dontQuery)	{		short theWordSize;		long bytes;		Str255 tempStr;				if (fndrInfo.fdType == 'AIFF')			getAIFFDataII (mySpec, &theSRate, &theWordSize, (short *)&isStereo, &bytes);						results = GetSampleRateTime (mySpec, index, theSize, &theSRate, &theDuration, &isStereo, fndrInfo.fdType);		if (results)		{			NumToString(theSRate,SRateStr);			NumToString(theDuration,durationStr);		}		else		{			makeStr255("\pno info ",SRateStr);			makeStr255("\p??? ",durationStr);		}		if (isStereo)		{			GetDItem(myDlg,22,&iType,&iHndl,&iRect);			SetIText(iHndl,"\pStereo");		}		else		{			GetDItem(myDlg,22,&iType,&iHndl,&iRect);			SetIText(iHndl,"\pMono");		}				theWordSize = theWordSize * 8;		NumToString((long)theWordSize,tempStr);		GetDItem(myDlg,26,&iType,&iHndl,&iRect);		concatStrings(tempStr,"\pbits","\p ");		SetIText(iHndl,tempStr);				if (fndrInfo.fdType == 'Sd2f')		{			if (!getSDIIData (mySpec, &theSRate, &theWordSize, &isStereo, &bytes))			{				theWordSize = theWordSize * 8;				NumToString((long)theWordSize,tempStr);				GetDItem(myDlg,26,&iType,&iHndl,&iRect);				concatStrings(tempStr,"\pbits","\p ");				SetIText(iHndl,tempStr);			}		}		if (fndrInfo.fdType == '.WAV')		{			GetWAVInfo (mySpec, &theSRate, &theWordSize, &duration, &isStereo, &bytes);				//theWordSize = theWordSize * 8;				NumToString((long)theWordSize,tempStr);				GetDItem(myDlg,26,&iType,&iHndl,&iRect);				concatStrings(tempStr,"\pbits","\p ");				SetIText(iHndl,tempStr);		}	}		switch (fndrInfo.fdType)	{		case 'AIFF':case 'SFIL':case 'Sd2f':case 'SCin':case 'SCsi':case 'SCss':case 'SCsd':case '.WAV':		break;				default:		HideDItem(myDlg,19);		HideDItem(myDlg,14);		HideDItem(myDlg,15);		HideDItem(myDlg,21);		HideDItem(myDlg,22);		HideDItem(myDlg,26);		break;	}		theSize = theSize/1000L;	if (!theSize)		theSize=1L;	NumToString(theSize,sizeStr);	*(sizeStr + (*sizeStr) + 1) = 'k';	*sizeStr +=1;		if (results)	{		concatStrings(sizeStr,durationStr,"\p ");		concatStrings(sizeStr,secondsText,"\p");	}		GetDItem(myDlg,11,&iType,&iHndl,&iRect);	SetIText(iHndl,sizeStr);		GetDItem(myDlg,15,&iType,&iHndl,&iRect);	SetIText(iHndl,SRateStr);	/* need to update this maxVRef shit */	if (-(mySpec.vRefNum)<=maxVRef)	{		PathNameFromDirID(mySpec.parID, mySpec.vRefNum,(StringPtr)fullPathName);	}	else	{		makeStr255("\pThis file is on the unmounted volume : ",fullPathName);		if (!VgetvolName(mySpec.vRefNum, (StringPtr) volnamestring))			*volnamestring = 0;		concatStrings((StringPtr)fullPathName,(StringPtr) volnamestring,"\p          ");			}				ShowWindow (myDlg);	SetPort(myDlg);	GetDItem(myDlg,17,&iType,&iHndl,&iRect);	SetIText(iHndl,fullPathName);	GetDItem(myDlg,17,&iType,&iHndl,&iRect);	InsetRect(&iRect,-3,-3.);	FrameRect(&iRect);		if (-((*therealResults)[index].vRefNum) <= maxVRef)	{		GetDItem(myDlg,7,&iType,&iHndl,&iRect);		FrameRect(&iRect);	}	else	{		GetDItem(myDlg,20,&iType,&iHndl,&iRect);		InsetRect (&iRect,-1,-1);		FrameRect(&iRect);	}	itemHit = 0;	while (itemHit != 1 && itemHit !=2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 18: 				if (checkReference (index))					iErr = OpenSelection(mySpec);				itemHit = 2;			break;							case 19:				Audition(mySpec,0x3C);			break;						case 1:				if (mySpec.vRefNum <= maxVRef)				{					GetDItem(myDlg,7,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);					if(!EqualString(textStr,theComment,true,true) && !dontChangeComment)					{						SetComment(mySpec,index, textStr);					}				}			break;					default:			break;		}	}	DisposDialog(myDlg);	SetPort (savePort);	color.red = 0xFFFF;	color.green = 0xFFFF;	color.blue = 0xFFFF;	RGBBackColor(&color);	//reFound = true;		return true;}void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator){	BlockMove (theSeperator+1, sourceA + (*sourceA) + 1, *theSeperator);	*sourceA += *theSeperator;	BlockMove (sourceB+1, sourceA + (*sourceA) + 1,*sourceB);	*sourceA += *sourceB;	return;}Boolean isItOnLine(short myVRefNum);Boolean GetComment(FSSpec mySpec, short index, Str255 theComment){	FInfo fndrInfo;	OSErr	iErr,iLErr;	short refNum,iRefNum;	Handle hRsrc;	long inOutCount, SCinpos, AIFFpos;	short SCFormat;	FSSpec	BUSpec;		*theComment = 0;			if (!isItOnLine(mySpec.vRefNum))		return false;			if (!FInfolistInMem && !folderSearch)	{				if (-(mySpec.vRefNum) <= maxVRef)		{			iErr = FSpGetFInfo(&mySpec,&fndrInfo);			if (iErr !=0)			{				makeStr255("\pCan't get comment",theComment);				return false;			} 		}		else		{			BlockMove (&((*theFInfo)[index]),&fndrInfo,16L);		}	}	else	{		if (!folderSearch)		{			BlockMove (&((*theFInfo)[index]),&fndrInfo,16L);		}		else		{			makeStr255("\pCan't get comment",theComment);			return false;		}	}				if (!folderSearch && -(mySpec.vRefNum) <= maxVRef)		{			if (fndrInfo.fdCreator == 'CARI')			{				if (!GetFSSpecComment(mySpec, (StringPtr)theComment))				*theComment = 0;			}			else			{				switch(fndrInfo.fdType)				{ /* 13 */				case 'SFIL':					iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);					if (iErr!=0)					{						makeStr255("\pFile does not exist, is already open, or is damaged",theComment);						return false;					}					if( !iErr)					{ /* 9 */						iErr = SetFPos(refNum,1,764L);						if (iErr!=0)						{							makeStr255("\pCan't read file",theComment);							FSClose(refNum);							return false;						}						inOutCount = 255L;						iErr = FSRead(refNum,&inOutCount,theComment);						if (iErr!=0)						{							makeStr255("\pCan't read file",theComment);							FSClose(refNum);							return false;						}						FSClose(refNum);					} /* 9 */					else					{							*theComment = 0;						return false;					}				break;								case 'Sd2f':				iRefNum = CurResFile();					refNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);					if (refNum > 0)					{ 						hRsrc = Get1Resource('sdDD',1000);						iErr = ResError();						if(hRsrc)						{							BlockMove((*hRsrc)+10,theComment,256L);							ReleaseResource(hRsrc);						}						CloseResFile(refNum);						UseResFile(iRefNum);						return true;											}					else					{							*theComment = 0;						return false;  							}				break;								case 'SCin': case 'MixD': case 'SCsi' : case 'SCsd' : case 'SCss':					SCFormat = identifySCII(mySpec);				 	if (SCFormat !=2)				 	{				 		makeStr255("\pCan't read SampleCell 1 comments",theComment);				 		return false;				 	}					iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);					if (iErr!=0)					{						makeStr255("\pFile does not exist, is already open, or is damaged",theComment);						return false;					}					if( !iErr)					{ /* 9 */						SCinpos =  findANNO(refNum);						if (SCinpos)						{							iErr = SetFPos(refNum,1,SCinpos+4L);							if (iErr!=0)							{								makeStr255("\pCan't read file",theComment);								FSClose(refNum);								return false;							}															inOutCount = 4L;							iErr = FSRead(refNum,&inOutCount,&SCinpos);							if (iErr!=0)							{								makeStr255("\pCan't read file",theComment);								FSClose(refNum);								return false;							}							inOutCount = SCinpos;							if (SCinpos)							{								iErr = FSRead(refNum,&inOutCount,theComment);								if (iErr!=0)								{									makeStr255("\pCan't read file",theComment);									FSClose(refNum);									return false;								}							}						}						FSClose(refNum);					} /* 9 */				break;								case 'AIFF':					iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);					if (iErr!=0)					{							makeStr255("\pFile does not exist, is already open, or is damaged",theComment);						return false;					}					if( !iErr)					{ /* 9 */						BlockMove (&mySpec,&BUSpec, 70L);						iLErr =  findAPPL(refNum);						BlockMove (&BUSpec,&mySpec, 70L);						if (iLErr)						{							AIFFpos = theAPPLReply;							iErr = SetFPos(refNum,1,AIFFpos+22L);							if (iErr!=0)							{								makeStr255("\pCan't read file",theComment);								FSClose(refNum);								return false;							}															inOutCount = 255L;							iErr = FSRead(refNum,&inOutCount,theComment);							if (iErr!=0 && iErr !=-39)							{								makeStr255("\pCan't read file",theComment);								FSClose(refNum);								return false;							}						}						FSClose(refNum);					} /* 9 */								break;								default:										if (!GetFSSpecComment(mySpec, (StringPtr)theComment))						*theComment = 0;				break;				}			}		}	return true;}Boolean SetComment (FSSpec mySpec, short index, StringPtr theComment){		FInfo fndrInfo;	OSErr	iErr,iLErr;	short refNum, myRefNum, iRefNum;	Handle hRsrc;	long inOutCount, SCinpos, AIFFpos;	short SCFormat;		if (!isItOnLine(mySpec.vRefNum))		return false;					if (!folderSearch)	{		iErr = FSpGetFInfo(&mySpec,&fndrInfo);		if (iErr !=0)		{			makeStr255("\pCan't get comment",theComment);			return false;		} 	}	else	{		return false;	}			if (!folderSearch)		{						if (fndrInfo.fdCreator == 'CARI')			{				iErr = SetFSSpecComment(mySpec,theComment);			}			else			{			    switch(fndrInfo.fdType)			    { /* 13 */					case 'Sd2f':						iErr = SetFSSpecComment(mySpec,theComment);						iRefNum = CurResFile();					 	myRefNum = FSpOpenResFile(&mySpec,fsCurPerm);					 	if (myRefNum != -1)					 	{						 	hRsrc = Get1Resource('sdDD',1000);							if (!hRsrc)							{								hRsrc = GetResource('sdDD',900);								iErr = ResError();								if (iErr != 0)								{									CloseResFile(myRefNum);									UseResFile(iRefNum);									return 0;									}								DetachResource(hRsrc);								AddResource(hRsrc,'sdDD',1000,"\p");								iErr = ResError();								if (iErr != 0)								{									CloseResFile(myRefNum);									UseResFile(iRefNum);									return 0;									}							}							BlockMove(theComment,(*hRsrc)+10,(*theComment)+1L);								ChangedResource(hRsrc);							WriteResource(hRsrc);							ReleaseResource(hRsrc);								CloseResFile(myRefNum);							UseResFile(iRefNum);							iErr = ResError();							if (iErr!=0)								genError ("\pCan't close Resource file");						}						else						{							return 0;						}					 break;					 					 case 'SFIL':						iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);						if (iErr!=0)						{							return 0;						}						iErr = SetFPos(refNum,1,764L);						if (iErr != 0)						{							FSClose (refNum);							return 0;						}						inOutCount = *theComment+1;						iErr = FSWrite(refNum,&inOutCount,theComment);						FSClose (refNum);						 break;					 					 					  case 'AIFF':						iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);						if (iErr!=0)						{							return 0;						}						AIFFpos =  findAPPL(refNum);						AIFFpos = theAPPLReply;						if (AIFFpos)						{								if(isItTheLastChunk(refNum, AIFFpos))							{								if(!removeCommentFromChunkEnd(refNum, AIFFpos,'APPL'))								{																		iErr = FSClose(refNum);									return 0;								}								if (!addAIFFCommentToChunkEnd(refNum,theComment,'APPL'))								{																		iErr = FSClose(refNum);									return 0;								}							}							else							{								if (!zapAPPL(refNum))								{																		iErr = FSClose(refNum);									return 0;								}								if (!addAIFFCommentToChunkEnd(refNum,theComment,'APPL'))								{																		iErr = FSClose(refNum);									return 0;								}								}						}						else						{							if (!addAIFFCommentToChunkEnd(refNum,theComment,'APPL'))							{																iErr = FSClose(refNum);								return 0;							}						}								FSClose (refNum);						 break;					 					  case 'SCin': case 'MixD': case 'SCsi': case 'SCsd' : case 'SCss':					 	SCFormat = identifySCII(mySpec);					 	if (SCFormat !=2)					 	{					 		return 0;					 	}					 	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);						if (iErr!=0)						{							return 0;						}						SCinpos =  findANNO(refNum);						if (SCinpos)						{								if(isItTheLastChunk(refNum, SCinpos))							{								if(!removeCommentFromChunkEnd(refNum, SCinpos,'ANNO'))								{																	iErr = FSClose(refNum);									return 0;								}								if (!addCommentToChunkEnd(refNum,theComment,'ANNO'))								{																		iErr = FSClose(refNum);									return 0;								}							}							else							{								if (!zapANNO(refNum))								{																		iErr = FSClose(refNum);									return 0;								}								if (!addCommentToChunkEnd(refNum,theComment,'ANNO'))								{									iErr = FSClose(refNum);									return 0;								}								}						}						else						{							if (!addCommentToChunkEnd(refNum,theComment,'ANNO'))							{								iErr = FSClose(refNum);								return 0;							}						}								FSClose (refNum);						 break;					 					  default:						iErr = SetFSSpecComment(mySpec,theComment);					 break;				}			}		}		else		{			return false;		}	return true;}void checkForMPG(StringPtr theName,FInfo * theFinfo){	OSType theType;	BlockMove(theName + (*theName) - 3, &theType,4L);	if (theType == '.MPG' || theType == '.mpg' || theType == '.mp2' || theType == '.MP2'  || theType == '.mp3' || theType == '.MP3')	{		theFinfo->fdType = 'MPEG';	}}void checkForWAV(StringPtr theName,FInfo * theFinfo){	OSType theType;	BlockMove(theName + (*theName) - 3, &theType,4L);	if (theType == '.WAV' || theType == '.wav')	{		theFinfo->fdType = '.WAV';	}}void checkForKRZ(StringPtr theName,FInfo * theFinfo){	OSType theType;	BlockMove(theName + (*theName) - 3, &theType,4L);	if (theType == '.KRZ' || theType == '.krz')	{		theFinfo->fdType = '.KRZ';	}}void checkForREX(StringPtr theName,FInfo * theFinfo){	OSType theType;	BlockMove(theName + (*theName) - 3, &theType,4L);	if (theType == '.REX' || theType == '.rex')	{		theFinfo->fdType = 'AIFF';	}}