#include "SampleSearch.h"#include "Globals.h"#include <stdio.h>#include "prefs.h"extern newPrefsRec theNewPrefs;void creatorFilter(void);Boolean creatorSearch;#include "undoStuff.h"extern Boolean ExcludeDrives;Boolean GetSearchComment(FSSpec mySpec, Str255 theComment);OSType creatorSearchType;Boolean folderSearch;extern long theAPPLReply;extern Boolean optionDownWhenMouseDown;extern OSType	searchType;Boolean scanList(Str255	theDrive);extern Boolean freshSearch,commentSearch;extern Str255 commentSearchStr;extern Boolean searchBefore, searchAfter;extern unsigned long beforeDate, afterDate;extern Boolean mySearchBodge;extern Boolean ExactMatch;long theSubdirectoryToSearch;extern Boolean stickyInfo;Boolean subFolderSearch;pascal	OSErr	PBCatSearchSyncCompat(CSParamPtr paramBlock);pascal	OSErr	myPBCatSearchSyncCompat(CSParamPtr paramBlock);Boolean getFolder(FSSpec *theFolderSpec);pascal	OSErr	IndexedSearch(CSParamPtr pb, long dirID);long findANNO(short localRefNum);long findAPPL(short localRefNum);short identifySCII(FSSpec mySpec);OSErr nameFromVRefNum (short whichVol, StringPtr volName);extern Boolean overrideFolderPrompt;extern Str255 overrideFolderPromptStr;Boolean translateParentToChildFolder(FSSpec *mySpec);Boolean GetFSSpecComment(FSSpec mySpec, StringPtr theComment);/*static	OSErr	VerifyUserPB(CSParamPtr userPB,							 Boolean *includeFiles,							 Boolean *includeDirs,							 Boolean *includeNames);*/OSErr PBCatSearchIn(CSParamPtr pb, long parID);							 void searcher(void){	short duper;				/** counter for results list **/	short loopy;							/** loop control variable  **/	short sdone;   							/** set to true when all matches done **/	short z;										short coonti = 0;	short rubbish=0;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	StringHandle	hString;	//OSType	searchType;	float	myFloat;	short floatInt;	short tempGa,tempGb;	Str255 theFileComment;	OSType keepSearch;	OSErr	iErr;	char *occur;	Str255 Cstring,substring;	FSSpec tempSpec;	Boolean includeFiles;	Boolean includeDirs;	Boolean includeNames;							 		//	creatorSearch = false;	//	mySearchBodge = true;	//	creatorSearchType = 'MixA';				 	subFolderSearch	= false;	if (optionDownWhenMouseDown)	{		overrideFolderPrompt = true;		makeStr255("\pSearch within this folder and subfolders",overrideFolderPromptStr);		if (getFolder(&tempSpec))		{			translateParentToChildFolder(&tempSpec);			theSubdirectoryToSearch = tempSpec.parID;			subFolderSearch	= true;			nameFromVRefNum (tempSpec.vRefNum,volName[1]);				volumes[1] = tempSpec.vRefNum;		}		else		{			subFolderSearch	= false;		}		}	//freshSearch = true;		if (!stickyInfo)	{		DisplayComments = false;	}		CheckItem(GetMHandle(134), 2, DisplayComments);	DisplayedColumns = (3 * !DisplayComments )+ 1;		sdone = 0; 	totfindcounter = 0;	duper = 0;	typeRelevant = false;	hString = GetString(999+iCtlValue);	if (!hString)		genError("\pCouldn't get popup resource");		BlockMove(*hString +1,&searchType,4L);	numTypesToSearch = 0;	BlockMove(*hString +1,&Fiyltype[0],4L);	//creatorSearch = false;		numTypesToSearch = 0;	Fiyltype[0] = searchType; 		if (searchType == 'IIII')	{		creatorSearch = true;		mySearchBodge = false;		creatorSearchType = 'MixA';	}	if (searchType == 'XXXX')		{		numTypesToSearch = 1;		typeCounter = 0;		Fiyltype[0] = 'AIFF';		Fiyltype[1] = 'Sd2f';	}		if (searchType == 'UUUU')	{		numTypesToSearch = 2;		typeCounter = 0;		Fiyltype[0] = 'AIFF';		Fiyltype[1] = 'SFIL';		Fiyltype[2] = 'Sd2f';	}		if (searchType == 'AAAA')	{		typeRelevant = false;		mySearchBodge = false;	}	else	{		typeRelevant = true;	}	if (searchType == 'FFFF')	{		typeRelevant = false;		folderSearch = true;		mySearchBodge = false;	}	else	{		folderSearch = false;	}					EnableItem(GetMHandle(129),1);		if (**hString != 4 || *(*hString+1) != 65 || *(*hString+2) != 73 || *(*hString+3) != 70 || *(*hString+4) != 70)	{		DisableItem(GetMHandle(129),1);	}	ReleaseResource((Handle)hString);		progressCreate("\pSearching on Drives");		for (typeCounter = 0;typeCounter <= numTypesToSearch;typeCounter ++)	{		for (z=1;z<=dSearcharrayptr;z++)			/*** set up loop to go through all registered drives **/		{			myFloat = (((z*100)/dSearcharrayptr) * (((typeCounter+1)*100)/ (numTypesToSearch+1)))/100;			BlockMove (volName[z],Cstring,28L);			PtoCstr (Cstring);			makeStr255("\pAudio CD",substring);			PtoCstr (substring);			occur = strstr((const char *)Cstring,(const char *)substring);						if (!occur)			{				makeStr255("\pAudio-CD",substring);				PtoCstr (substring);				occur = strstr((const char *)Cstring,(const char *)substring);			}			  		  /*occur = false; */ /*   here bodge */		 	 /*if (!EqualString(volName[z],"\pAudio CD 1",true,true))*/			 			 			 if (!occur)			 {				if (!scanList(volName[z]))				{					gPb.csParam.ioVRefNum = volumes[z];		/** select relevant volume **/					SetupForFirstTime();				/** initialize data records  **/					HLock((Handle)gTheResults);					coonti=0;					watchcursor(TRUE);					/** display watch **/										/*	iErr = VerifyUserPB(&gPb,								 &includeFiles,								 &includeDirs,								 &includeNames);*/								 					do 					{						if (!subFolderSearch)						{							gErr = myPBCatSearchSyncCompat((CSParam *)&gPb);						}						else						{							gErr = PBCatSearchIn((CSParam *)&gPb, theSubdirectoryToSearch);						}												coonti++;						sdone = (gErr == eofErr); 		/**  eofErr returned when all done **/												if ((gPb.csParam.ioActMatchCount != 0) && ((gErr == noErr) || sdone))  /** ioActMatchCount contains the number of matches for this pass  **/						{									for ( loopy = 0;  loopy < gPb.csParam.ioActMatchCount; rubbish++) 	/** now enter the finds for this pass into our final results list **/							{								if (duper < kMaxMatches)															{										if (commentSearch)									{										/* get comment change to C str in get search string */										if(GetSearchComment((*gTheResults)[loopy] ,theFileComment) & (*theFileComment > 0))										{											PtoCstr (theFileComment);											if (strstr((const char *)theFileComment,(const char *)commentSearchStr))											{												(*therealResults)[duper] = (*gTheResults)[loopy];		/** results **/												duper++;											}										}									}									else									{										(*therealResults)[duper] = (*gTheResults)[loopy];		/** results **/										duper++;									}															}								loopy = loopy + 1;							}						}						floatInt = myFloat;						if (progressDisp(floatInt))						{							totfindcounter = 0;							HUnlock((Handle)gTheResults);							watchcursor(FALSE);							return;							}						} while (!sdone && (duper < kMaxMatches));										watchcursor(FALSE);										HUnlock((Handle)gTheResults);					floatInt = myFloat;					if (progressDisp(floatInt))					{						totfindcounter = 0;						return;						}					}			}		}	}		if (duper >= kMaxMatches)				genError("\pMore matches were found than could be stored");	progressDispos();	if (duper>0)	{	 	for (z=1;z<=volumearrayptr;z++)	 	{	 		BlockMove( volName[z],fvolName[z],28L);	 		fvolumes[z] = volumes[z];	 	}	 	fvolumearrayptr = volumearrayptr;	 	 }	keepSearch = searchType;	totfindcounter = duper;	FInfolistInMem = false;	if (ghostCounter >0)	{		if (totfindcounter > 0)		{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)				genError("\pCould not expand FInfo in Add Ghosts");								checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));											for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}			}		FInfolistInMem = true;		AddGhosts();	}	if (creatorSearch)	{		searchType = keepSearch;		creatorFilter();	}	}/****************/void creatorFilter(void){	Str255	sAgainName;	char	*tempName;	char	*CsAgainName;	OSErr	iErr;	short	listcounter;	char	*strResult;	short	newListCounter;	short		findStrLen;	char	tempstor[255];	char	tempstor2[255];	char	tempstor3[255];		short z;	StringHandle	hString;	FInfo	fndrInfo;	Boolean stillOK;		if (creatorSearchType != 'MixA')		return;	oldFindCounter = totfindcounter;							/** preserve for undo **/	tempName = tempstor;				CsAgainName = tempstor2;	strResult = tempstor3; 	newListCounter=0;		fChanged = true;		typeRelevant = true;	if (searchType = 'IIII')	{		numTypesToSearch = 3;		typeCounter = 0;		Fiyltype[0] = 'SCin';		Fiyltype[1] = 'SCsi';		Fiyltype[2] = 'SCsd';			/**** check these **/		Fiyltype[3] = 'SCss';	}			if 	(!FInfolistInMem && (typeRelevant || fdFldrMask))	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)				genError("\pCould not expand FInfo in Filterlist");								checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));											for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}		for(listcounter=0;listcounter< totfindcounter;listcounter++)	{		stillOK = true;				if(typeRelevant || searchType == 'IIII')			/** file type selected **/		{				BlockMove(&(*theFInfo)[listcounter],&fndrInfo,16L);			stillOK = false;			for (typeCounter = 0;typeCounter<= numTypesToSearch;typeCounter++)			{				if (fndrInfo.fdType == Fiyltype[typeCounter])		/** allow for all samples exception **/				{					stillOK = true;				}			}			if (fndrInfo.fdType == searchType)						{					stillOK = true;				}		}				if (stillOK)		{			if (listcounter != newListCounter)			{				BlockMove(&(*therealResults)[listcounter],&(*therealResults)[newListCounter],70L);				BlockMove(&(*theFInfo)[listcounter],&(*theFInfo)[newListCounter],16L);			}			newListCounter++;		}			}		reFound = true;		FInfoArrayPtr = newListCounter;	totfindcounter = newListCounter;	return;		}/********************************* *********************  **************************/void  SetupForFirstTime(void){	short vRefNum;    	/** volume on which to search **/	long dirID;     	/** ignored dir ID for HGetVol  **/	long FindParam;	FindParam = (ExactMatch) ? fsSBFullName : fsSBPartialName;	if (creatorSearch)	{		typeRelevant = true;	}	gPb.csParam.ioCompletion = nil;  				/** no completion routine **/	gPb.csParam.ioNamePtr = nil;   			 		/** no volume name;  use vRefNum **/	gPb.csParam.ioMatchPtr = (*gTheResults);  			/** points to results buffer **/	gPb.csParam.ioReqMatchCount = kMaxMatches;   	/** number of matches **/		/** search for name + file or directory + file TYPE  **/		gPb.csParam.ioSearchBits = (FindParam * textSearch) + fsSBFlAttrib + (fsSBFlFndrInfo * typeRelevant) + (fsSBFlMdDat * (searchBefore || searchAfter));								gPb.csParam.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/	gPb.csParam.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/	gPb.csParam.ioSearchTime = 0;              	/** don't time out on searches **/	gPb.csParam.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/	gPb.csParam.ioOptBuffer = gBuffer;    			/** point to search cache  **/	gPb.csParam.ioOptBufSize  = kOptBufferSize;		/** size of search cache **/	gSpec1.hFileInfo.ioNamePtr = gFileName;   		/** point to string to find **/	gSpec1.hFileInfo.ioFlAttrib = folderSearch * 0x10;     /** clear bit 4 to ask for files **/		if (!creatorSearch)	{		gSpec1.hFileInfo.ioFlFndrInfo.fdType = Fiyltype[typeCounter] ; //searchType;	/** just find ???? files **/		gSpec1.hFileInfo.ioFlFndrInfo.fdCreator = 0; 	}	else	{		if (mySearchBodge)		{			gSpec1.hFileInfo.ioFlFndrInfo.fdType = searchType;		}		else		{			gSpec1.hFileInfo.ioFlFndrInfo.fdType = 0 ; //searchType;		}			gSpec1.hFileInfo.ioFlFndrInfo.fdCreator = creatorSearchType ; 	}		gSpec1.hFileInfo.ioFlMdDat = afterDate;	gSpec2.hFileInfo.ioFlMdDat = beforeDate;	gSpec2.hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/	gSpec2.hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/		if (!creatorSearch)	{		gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  		gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0;   //searchMask;  	}	else	{		if (mySearchBodge)		{			gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;		}		else		{			gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0;   //searchMask;		}		gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0xFFFFFFFF;   //searchMask;  	}		gSpec1.hFileInfo.ioFlFndrInfo.fdFldr = fdFldrVal;		/** MFS folder number to search for **/	gSpec2.hFileInfo.ioFlFndrInfo.fdFldr = fdFldrMask;		/** This masks which bits to test. Set to 32767 for one type search **/		if (theNewPrefs.dontFindAliases)	{		gSpec1.hFileInfo.ioFlFndrInfo.fdFlags = 0;		gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;			}	else	{		gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;		}								}/********************************* *********************  **************************/Boolean scanList(Str255	theDrive){	FILE * Xstream;	short z;	Str255 textIn;			if (!ExcludeDrives)		return false;	Xstream = fopen("SampleSearch Excluded Drives","r");			if (Xstream)	{		while (!feof(Xstream))		{			fgets((Ptr)textIn,254,Xstream);			if (feof(Xstream))				break;			CtoPstr((Ptr)textIn);			*textIn -=1;			if(EqualString(textIn,theDrive,true,true)) 			{				if (*textIn == *theDrive)				{					fclose(Xstream);					return true;				}			}			}		fclose(Xstream);	}		return false;}Boolean GetSearchComment(FSSpec mySpec, Str255 theComment){	FInfo fndrInfo;	OSErr	iErr,iLErr;	short refNum,iRefNum;	Handle hRsrc;	long inOutCount, SCinpos, AIFFpos;	short SCFormat;	FSSpec	BUSpec;		*theComment = 0;					iErr = FSpGetFInfo(&mySpec,&fndrInfo);				if (fndrInfo.fdCreator == 'CARI')		{			if (!GetFSSpecComment(mySpec, (StringPtr)theComment))				*theComment = 0;		}		else		{			switch(fndrInfo.fdType)			{ /* 13 */			case 'SFIL':				iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);				if (iErr!=0)				{					*theComment = 0;					return false;				}				if( !iErr)				{ /* 9 */					iErr = SetFPos(refNum,1,764L);					if (iErr!=0)					{						*theComment = 0;						FSClose(refNum);						return false;					}					inOutCount = 255L;					iErr = FSRead(refNum,&inOutCount,theComment);					if (iErr!=0)					{						*theComment = 0;						FSClose(refNum);						return false;					}					FSClose(refNum);				} /* 9 */				else				{						*theComment = 0;					return false;				}			break;						case 'Sd2f':			iRefNum = CurResFile();				refNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);				if (refNum > 0)				{ 					hRsrc = Get1Resource('sdDD',1000);					iErr = ResError();					if(hRsrc)					{						BlockMove((*hRsrc)+10,theComment,256L);						ReleaseResource(hRsrc);					}					CloseResFile(refNum);					UseResFile(iRefNum);				}				else				{						*theComment = 0;					return false;  						}			break;						case 'SCin': case 'MixD': case 'SCsi' : case 'SCsd' : case 'SCss':				SCFormat = identifySCII(mySpec);			 	if (SCFormat !=2)			 	{					*theComment = 0;			 		return false;			 	}				iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);				if (iErr!=0)				{					*theComment = 0;					return false;				}				if( !iErr)				{ /* 9 */					SCinpos =  findANNO(refNum);					if (SCinpos)					{						iErr = SetFPos(refNum,1,SCinpos+4L);						if (iErr!=0)						{							*theComment = 0;							FSClose(refNum);							return false;						}													inOutCount = 4L;						iErr = FSRead(refNum,&inOutCount,&SCinpos);						if (iErr!=0)						{							*theComment = 0;							FSClose(refNum);							return false;						}						inOutCount = SCinpos;						if (SCinpos)						{							iErr = FSRead(refNum,&inOutCount,theComment);							if (iErr!=0)							{								*theComment = 0;								FSClose(refNum);								return false;							}						}					}					FSClose(refNum);				} /* 9 */			break;						case 'AIFF':				iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);				if (iErr!=0)				{						*theComment = 0;					return false;				}				if( !iErr)				{ /* 9 */					BlockMove (&mySpec,&BUSpec, 70L);					iLErr =  findAPPL(refNum);					BlockMove (&BUSpec,&mySpec, 70L);					if (iLErr)					{						AIFFpos = theAPPLReply;						iErr = SetFPos(refNum,1,AIFFpos+22L);						if (iErr!=0)						{							*theComment = 0;							FSClose(refNum);							return false;						}													inOutCount = 255L;						iErr = FSRead(refNum,&inOutCount,theComment);						if (iErr!=0 && iErr !=-39)						{							*theComment = 0;							FSClose(refNum);							return false;						}					}					FSClose(refNum);				} /* 9 */						break;						default:				if (!GetFSSpecComment(mySpec, (StringPtr)theComment))					*theComment = 0;			break;			}		}		UprString(theComment,false);	return true;}pascal	OSErr	myPBCatSearchSyncCompat(CSParamPtr paramBlock){	if (theNewPrefs.useMoreFiles)	{		return PBCatSearchSyncCompat(paramBlock);	}	else	{		return PBCatSearchSync(paramBlock);	}}