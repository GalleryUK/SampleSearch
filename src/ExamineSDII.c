Boolean SDIIRegionType;extern Boolean autoSustain;#include "SampleSearch.h"#include "Globals.h"Boolean NormaliseRegions;extern FSSpec theConvertDestLoc;short normaliseMaximum;extern Boolean;extern Boolean normalMode;Boolean normaliseFile(FSSpec mySpec,Boolean justRegion, long startPoint, long endPoint);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);pascal Boolean myRFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);pascal void RUserProc(WindowPtr theDialog, short theItem);Boolean ExamineSDII(FSSpec mySpec);void SDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos);ListHandle theRList;Point pp;Boolean	YesNo (Str255	myText);pascal Boolean mySDDlgFilter (DialogPtr theDialog, EventRecord *theEvent,short *itemHit);Boolean removeRegion (FSSpec theSpec, short theRegIndex);extern Boolean DialogPresent;Boolean rewriteOrig;void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);Str255 theRegionName;#include "prefs.h"Boolean addFileToList(FSSpec mySpec);extern newPrefsRec theNewPrefs;void writeLogS(Str255 theLogText);typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);Boolean addTimeStampRegion(FSSpec mySpec, long timeStamp);Boolean extractSMPTEFromFile (FSSpec theFile,short regionNum, long *timeStamp);short lastListItem;Boolean modifyRegionsList (Handle theRegionsRes, FSSpec theSpec, RegionRec theRegion, short theRegIndex);Boolean renameRegion (FSSpec theSpec, short theRegIndex, Str255 theCurrentName);Boolean editRegion(FSSpec mySpec,RegionRec** myRgnHdl);Boolean exportRegion (FSSpec source, FSSpec destination, RegionRec	myRgn);//pascal OSErr GetStdFilterProc(ProcPtr *theProc) = {0x303C, 0x0203, 0xAA68};FSSpec	theGlobSpec;Handle theFileRegions;typedef struct miniRegionRec {long	StartFrame;long	StopFrame;Str31 regionName;} miniRegionRec, *miniRegionRecPtr;miniRegionRec * theRegionPointsPtr;#define theRegionPoints theRegionPointsPtrshort theNumberOfRegions;Handle makeRegionsList(FSSpec mySpec);Boolean ExamineSD2A(void);Boolean ExamineSD2A(void){	Point theCell;	short theindex;	Boolean preserveSust;		SetPt( &theCell, 0,0 );		/* start at top of list  */	LGetSelect( TRUE, &theCell, myList) ;		if (theCell.h == 1 && DisplayedColumns == 1)	{		LNextCell( TRUE, TRUE, &theCell, myList );		LGetSelect( TRUE, &theCell, myList) ;	}			theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		//preserveSust = autoSustain;	//autoSustain = false;		ExamineSDII((*therealResults)[theindex]);	DisposPtr((Ptr)theRegionPointsPtr);		//autoSustain = preserveSust;	return true;}Boolean ExamineSDII(FSSpec mySpec){	short itemHit = 0;			/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	ListHandle	theExcList;	Rect	rView,rDataBnds;	Point	theXPoint;	short iInsRow;	Cell XlCellCoords, temporCell;	Str255 NewNameString;	short	dataLen,x;	OSErr	iErr;	short z, excCount = 0;	Handle	hRsrc;	Str255 myString;	Rect	itRect;	long theRate, theBytes;	Boolean stereo,doItAgain;	short theWordSize;	Cell theCell;	FSSpec destination;	RegionRec	myRgn;	StandardFileReply theDestReply;	Point where, thePoint;	RegionRec** myRgnHdl;	Str255 theNameCell,theCurCellName;	ModalFilterUPP xmySDDlgFilter = NewModalFilterProc(mySDDlgFilter);				rewriteOrig = true;	myRgnHdl = (RegionRec**)NewHandle(56L);	if (!myRgnHdl)	{		SysBeep (5);		return false;	}		theGlobSpec = mySpec;		getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes);	lastListItem = 0;here:	DialogPresent = true;	myDlg = GetNewDialog(11011,nil,(WindowPtr)-1);	if(!myDlg)	{		SysBeep(5);		return false;	}	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);//	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,4,&iType,&iHndl,&itRect);	SetDItem(myDlg,4,iType,(Handle)NewUserItemProc(RUserProc),&itRect);	ShowWindow(myDlg);	do	{			ModalDialog(xmySDDlgFilter,&itemHit);			switch (itemHit)		{			case 1:			break;						case 2:			break;						case 4:				LClick(pp,0,(ListHandle)theRList);			break;						case 5:				SetPt( &theCell, 0,0 );		/* start at top of list  */				LGetSelect( TRUE, &theCell, theRList);				//	mousePlay = true;					SDIIRegionPlay(mySpec, 0x3C,(theRegionPoints[theCell.v].StartFrame) * theWordSize * (stereo + 1),(theRegionPoints[theCell.v].StopFrame) * theWordSize * (stereo + 1));					//	mousePlay = false;			break;						case 12:				SetPt( &theCell, 0,0 );		/* start at top of list  */				LGetSelect( TRUE, &theCell, theRList) ;					LSetSelect(false,theCell,theRList);				theCell.v ++;				LSetSelect(true,theCell,theRList);				LAutoScroll(theRList);			break;									case 13:				SetPt( &theCell, 0,0 );		/* start at top of list  */				LGetSelect( TRUE, &theCell, theRList) ;					LSetSelect(false,theCell,theRList);				theCell.v --;				LSetSelect(true,theCell,theRList);				LAutoScroll(theRList);			break;						default:			break;		}	} while (itemHit !=11 && itemHit !=1 && itemHit !=2 && itemHit !=6 && itemHit != 8 && itemHit != 9  && itemHit != 10 && itemHit != 14);		if (itemHit == 11 || itemHit == 6 || itemHit == 8 || itemHit == 9 || itemHit == 10 || itemHit == 14)	{		doItAgain = true;		SetPt( &theCell, 0,0 );		/* start at top of list  */		LGetSelect( TRUE, &theCell, theRList) ;			/* what if nothing selected ? */		dataLen = 250;		LGetCell(theNameCell+1L,&dataLen,theCell,theRList);		*theNameCell = dataLen;					myRgn.StartFrame = theRegionPoints[theCell.v].StartFrame;		myRgn.StopFrame = theRegionPoints[theCell.v].StopFrame;			BlockMove (theNameCell, myRgn.RegionName ,32L);		LDispose(theRList);		DisposDialog(myDlg);		switch (itemHit)		{			case 6:				StandardPutFile("\pEnter Location for Region","\pUntitled",&theDestReply);				if (theDestReply.sfGood)				{					if (theDestReply.sfReplacing)					iErr = FSpDelete(&theDestReply.sfFile);						normalMode = false;								exportRegion (mySpec, theDestReply.sfFile, myRgn);					addFileToList(theDestReply.sfFile);					itemHit = -999;				}			break;						case 8: /* edit region */				if (theWordSize < 3)				{					BlockMove (&myRgn, *myRgnHdl ,56L);					if (editRegion(mySpec,myRgnHdl))					{						BlockMove (*myRgnHdl ,&myRgn, 56L);						modifyRegionsList (theFileRegions, mySpec, myRgn, theCell.v);					}				}				else				{					SysBeep(5);				}			break;						case 9: /* rename */				renameRegion (mySpec,(theCell.v),theNameCell);			break;						case 10:					removeRegion (mySpec,(theCell.v)+1);			break;						case 11:				normaliseMaximum = 128;				normaliseFile(mySpec,true, theRegionPoints[theCell.v].StartFrame, theRegionPoints[theCell.v].StopFrame);				/* normalise */			break;						case 14:				writeLogS((unsigned char *)"\pStarting normalise all regions for file :");				writeLogS(mySpec.name);				for (x=0;x<theNumberOfRegions;x++)				{					NumToString ((long)x, theRegionName);					normaliseMaximum = 128;					normaliseFile(mySpec,true, theRegionPoints[x].StartFrame, theRegionPoints[x].StopFrame);				}			break;		}	}	else	{		doItAgain = false;		LDispose(theRList);		DisposHandle(theFileRegions);		DisposDialog(myDlg);	}	lastListItem = theCell.v;	if (doItAgain)	{		doItAgain = false;		goto here;	}	DialogPresent = false;	return;}pascal void RUserProc(WindowPtr theDialog, short theItem){	Rect 	iRect,			rView,			rBounds;	short 	h,			v;	char 	s[25];	Point 	pCellSz,theCell;	Handle theHandle;	short 	itype;	Rect 	tempRect;	Str255	theCellText, textIn;	short		CellTextLen;	short myCount;	Cell	tempCell,xCel;	short iInsRow;			// Grab item information	GetDItem(theDialog,theItem,&itype,&theHandle,&iRect);	// Set up view for the list.  Notice that there is some	// margin left on all sides for the frame, and the verical scroll bar	rView = iRect;	rView.right -= 16;		rView.left +=2;	rView.bottom -=1;	rView.top += 1;	// list array is 1 column with 0 rows			// force auto calculations when displaying the cells.	pCellSz.h = 0;	pCellSz.v = 0;	// create list and draw it.				SetRect(&rBounds,0,0,1,0);		theRList = LNew (&rView, &rBounds, pCellSz, 0, theDialog, TRUE, TRUE, FALSE,						TRUE);				if (!theRList) {				SysBeep(5);				return;		}		(*theRList)->selFlags = 186-32;		makeRegionsList(theGlobSpec);	// Draw a frame around the user item		PenSize(1,1);	FrameRect (&iRect);	// associate the new list handle with this user item	SetDItem(theDialog,theItem,0,(Handle)NewUserItemProc(theRList),&iRect);	xCel.h = 0;	xCel.v = lastListItem;	LSetSelect(true,xCel,theRList);	LAutoScroll(theRList);}/***************/pascal Boolean myRFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	OSErr	myErr;	Boolean	returnVal = FALSE;	WindowPtr	temp;	ProcPtr	*standardProc;	Point thePoint;	Cell XlCellCoords;	short iType;	Handle iHndl;	Rect iRect;	GrafPtr	savePort;			if(theEventIn->what == 0)	{		(*theDialogItem == -999);		return false;	}			if(theEventIn->what==updateEvt &&				(WindowPtr) theEventIn->message!=currentDialog)	{		/* if the update is for the dialog box, ignore it since the regular			ModalDialog function will redraw it as necessary.		*/		(*theDialogItem == -999);		returnVal = false; //MyDrawProc((WindowPtr) theEventIn->message);	}	else	{		/* it wasn't an update, pass it on to the system filter */		/* necessary to track the edit cursor changes */		if (theEventIn->what==keyDown)		{			switch (theEventIn->message & keyCodeMask)			{				case 0x31:					*theDialogItem == 5;					return false;				break;								case 0x4C: case 0x24:					*theDialogItem == 1;					return false;					break;								case 0x0E:					*theDialogItem == 8;					return false;				break;								case 0x0F:					*theDialogItem == 9;					return false;				break;			}		}			return returnVal;	}}Boolean makeRegionsListFromFile(FSSpec mySpec);Boolean makeRegionsListFromFile(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow;		RgnHandle	theRgn;	theNumberOfRegions = 0;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		SysBeep(5);		return false;	}		if (fndrInfo.fdType != 'Sd2f')	{		genError ("\pRegions can be shown only from Sound Designer II files");		return false;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}		UseResFile(fRefNum);		theFileRegions = Get1Resource('ddRL',1000);		if (!theFileRegions)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		lByteCnt = SizeResource(theFileRegions);		if (lByteCnt < 74L)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(theFileRegions);	CloseResFile(fRefNum);	UseResFile(iRefNum);	theNumberOfRegions = regionCount;		if (regionCount>2500)	{		SysBeep (5);		SysBeep (5);				return false;	}		theRegionPointsPtr = (miniRegionRec *)NewPtr(regionCount * sizeof(miniRegionRec));	if (!theRegionPointsPtr)	{		genError("\pnotEnoughMemory");		return false;	}				for (z=regionCount-1;z>=0;z--)	{		BlockMove ((((*theFileRegions) +18)+(56L * z)), &tempRegRec, 56L);			theRegionPoints[z].StopFrame = tempRegRec.StopFrame;				theRegionPoints[z].StartFrame = tempRegRec.StartFrame;			BlockMove (tempRegRec.RegionName,theRegionPoints[z].regionName,32L);	}			return true;}Handle makeRegionsList(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow;		RgnHandle	theRgn;	theNumberOfRegions = 0;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		SysBeep(5);		return false;	}		if (fndrInfo.fdType != 'Sd2f')	{		genError ("\pRegions can be shown only from Sound Designer II files");		return false;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}		UseResFile(fRefNum);		theFileRegions = Get1Resource('ddRL',1000);		if (!theFileRegions)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		lByteCnt = SizeResource(theFileRegions);		if (lByteCnt < 74L)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(theFileRegions);	CloseResFile(fRefNum);	UseResFile(iRefNum);	theNumberOfRegions = regionCount;		if (regionCount>2500)	{		SysBeep (5);		SysBeep (5);				return false;	}		theRegionPointsPtr = (miniRegionRec *)NewPtr(regionCount * sizeof(miniRegionRec));	if (!theRegionPointsPtr)	{		genError("\pnotEnoughMemory");		return;	}			SetPt(&tempCell,0,0);	LSetCell(0,1,tempCell,theRList);	LDoDraw(false,theRList);	for (z=regionCount-1;z>=0;z--)	{		BlockMove ((((*theFileRegions) +18)+(56L * z)), &tempRegRec, 56L);		iInsRow = LAddRow(1,0,theRList);		SetPt(&tempCell,0,iInsRow);		LSetCell((tempRegRec.RegionName)+1,*(tempRegRec.RegionName),tempCell,theRList);				theRegionPoints[z].StopFrame = tempRegRec.StopFrame;				theRegionPoints[z].StartFrame = tempRegRec.StartFrame;		}	LDoDraw(true,theRList);	theRgn = NewRgn();	RectRgn(theRgn,&((*theRList)->rView));		LUpdate(theRgn,theRList);		return theFileRegions;}Boolean modifyRegionsList (Handle theRegionsRes, FSSpec theSpec, RegionRec theRegion, short theRegIndex){	Handle hRsrc;	short iRefNum,fRefNum;	OSErr	iErr;		iRefNum = CurResFile();	iErr = ResError();	fRefNum = FSpOpenResFile(&theSpec,fsWrPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}	iErr = ResError();	UseResFile(fRefNum);	iErr = ResError();	hRsrc = Get1Resource('ddRL',1000);	iErr = ResError();	if (!hRsrc)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}	BlockMove (&theRegion, (*theRegionsRes) + 18L + (56L * (long)(theRegIndex)), 56L);	RmveResource(hRsrc);	iErr = ResError();	AddResource(theRegionsRes,'ddRL',1000,"\pRegion List");	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);}Boolean removeRegion (FSSpec theSpec, short theRegIndex){	Handle hRsrc, newRes;	short iRefNum,fRefNum;	OSErr	iErr;	Size mySize;		iRefNum = CurResFile();	iErr = ResError();	fRefNum = FSpOpenResFile(&theSpec,fsWrPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}	iErr = ResError();	UseResFile(fRefNum);	iErr = ResError();	hRsrc = Get1Resource('ddRL',1000);	iErr = ResError();	if (!hRsrc)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}	newRes = NewHandle(mySize = GetHandleSize(hRsrc));	if (!newRes)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		if (((mySize - 18L) / 56L) < theRegIndex)	{		DisposHandle(newRes);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}		BlockMove (*hRsrc, *newRes, 18L + ((theRegIndex-1)*56L));		BlockMove (*hRsrc + 18L + ((theRegIndex)*56L), *newRes + 18L + ((theRegIndex-1)*56L),(mySize - 56L)-(18L + ((theRegIndex-1)*56L)));	//BlockMove (&theRegion, &theRegionsRes + 18L + (56L * (long)(theRegIndex)), 56L);		RmveResource(hRsrc);	iErr = ResError();	SetHandleSize(newRes,mySize - 56L);	if (mySize - 56L >= 74L)	{		AddResource(newRes,'ddRL',1000,"\pRegion List");	}	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);}Boolean renameRegion (FSSpec theSpec, short theRegIndex, Str255 theCurrentName){	Handle hRsrc, newRes;	short iRefNum,fRefNum;	OSErr	iErr;	Size mySize;	short itemHit = 0;			/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/		myDlg = GetNewDialog(8999,nil,(WindowPtr)-1);	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetIText(iHndl,theCurrentName);	ShowWindow(myDlg);		ModalDialog(xAlertFilter,&itemHit);	GetDItem(myDlg,7,&iType,&iHndl,&iRect);	GetIText(iHndl,theCurrentName);	DisposDialog(myDlg);		if (itemHit == 2)		return false;			iRefNum = CurResFile();	iErr = ResError();	fRefNum = FSpOpenResFile(&theSpec,fsWrPerm);	if (!fRefNum)	{		SysBeep (5);		return false;	}	iErr = ResError();	UseResFile(fRefNum);	iErr = ResError();	hRsrc = Get1Resource('ddRL',1000);	iErr = ResError();	if (!hRsrc)	{		SysBeep(5);		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}			BlockMove (theCurrentName, (*hRsrc + (18L + (theRegIndex * 56L) + 24L)),32L);	ChangedResource(hRsrc);	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);}pascal Boolean mySDDlgFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit){	Rect	iRect;	short	type,iType;	Handle	iHndle;	Handle	iHandle;	Point	theCell;	OSErr	iErr;	char theChar;	short theItem;	short 	itype;	Handle theHandle;	short theQuay;	Rect dragRect;	WindowPtr	whichWindow;	short thePart;	GrafPtr	savePort;		switch (theEvent->what) 	{		case keyDown:			// if key was pressed, handle return key			theQuay = (theEvent->message) & keyCodeMask;			theChar = (theEvent->message) & charCodeMask;			if ( (theChar == 0x0d) || (theChar == 0x03)) 			{					*itemHit = 1;					return TRUE;			}			if (theQuay == 0x7D00)			{				*itemHit = 12;					return TRUE;/** down arrow pressed **/			}			if (theQuay == 0x7E00)			{				*itemHit = 13;					return TRUE;/** up arrow pressed **/			}			if (theQuay == 0x3100)			{					*itemHit = 5;					return true;			}			if (theQuay == 0x0E00)			{					*itemHit = 8;					return true;			}						return FALSE;	break;		case mouseDown:			GetPort(&savePort);			SetPort(theDialog);			// Get where mouse click occured in global coordinates.			pp = theEvent->where;			GlobalToLocal(&pp);			SetPort(savePort);			GetDItem(theDialog,4,&type,&iHndle,&iRect);			if (PtInRect(pp,&iRect))			{				*itemHit = 4;				return FALSE;			}			else			{				return FALSE;			}					break;				case updateEvt:		 return false;		break;				case activateEvt:		 return FALSE;		break;				default :			return FALSE;		break;	}}Boolean normaliseFile(FSSpec mySpec,Boolean justRegion, long startPoint, long endPoint){	long theRate,theBytes,inOutCount;	short theWordSize;	unsigned long multiplierB;	unsigned long multiplierA;	Boolean stereo;	short refNum;	OSErr	iErr;	long theNumBytes, startBytes, endBytes, curPos, multiplier;	Handle	dataH;	short theSoundInt,theSoundInt2;	char theSoundByte;	short counterD;	long theSoundLong, beforeRead, afterRead;	unsigned short maxVolume;	unsigned short theSoundUInt;	long theKeepInt,theKeepInt2;	FInfo fndrInfo;	long z;	Str255 tempStr;	FSSpec theDestSpec;	short theDestRefNum;	Str255 sourceA,sourceB = "\pFinding Peak", sourceC = "\pNormalising";		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')		return false;		BlockMove(&mySpec,&theDestSpec,70L);	theDestSpec.parID = theConvertDestLoc.parID;	theDestSpec.vRefNum = theConvertDestLoc.vRefNum;		if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo,&theBytes))	{		SysBeep(5);		return false;	}	if (theWordSize == 1 || theWordSize > 2)	{		genError ("\pSampleSearch only supports 16-bit normalising");		return false;	}	if (!justRegion)	{		startBytes = 0L;		endBytes = theBytes;	}	else	{		startBytes =  (startPoint * (long)(stereo + 1) * (long)theWordSize);		endBytes =  (endPoint * (long)(stereo + 1) * (long)theWordSize);	}	theNumBytes = endBytes - startBytes;	if (theNumBytes <= 0L)	{		SysBeep(5);		return false;	}	iErr = FSpOpenDF(&mySpec,fsWrPerm,&refNum);	if (iErr != 0)	{		SysBeep(5);		return false;	}	iErr = SetFPos(refNum,1,(startPoint * (long)(stereo + 1) * (long)theWordSize));	if (iErr != 0)	{		SysBeep(5);		iErr = FSClose(refNum);		return false;	}	dataH = NewHandle(132000L);	if (!dataH)	{		SysBeep(5);		iErr = FSClose(refNum);		return false;	}	iErr = GetFPos(refNum,&curPos);	if (iErr != 0)	{		SysBeep(5);		iErr = FSClose(refNum);		return false;	}	maxVolume = (theWordSize == 2) ? 0 : 128;		BlockMove(theRegionName,sourceA,32L);	concatStrings(sourceA,sourceB,"\p - ");	progressCreate(sourceA);	while (curPos < (endBytes-1L))	{		inOutCount = endBytes - curPos;		if (inOutCount > 131072)		{			inOutCount = 131072;				}		iErr = FSRead(refNum,&inOutCount,*dataH);		if (iErr != 0)		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			progressDispos();			return false;		}		if (progressDisp(((curPos - startBytes)*100)/theNumBytes))		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			return false;		}		//counterD = 0L;		for (z = 0L;z< inOutCount;z += 2)		{			switch (theWordSize)			{				case 1:					theSoundInt = abs((*(*dataH + z))-128);					theSoundByte = theSoundInt;					if ((short)theSoundByte > maxVolume)						maxVolume = (short)theSoundByte;					theSoundByte = theSoundInt << 8;					if ((short)theSoundByte > maxVolume)						maxVolume = (short)theSoundByte;				break;								case 2:					//BlockMove(((*dataH) + z), &theSoundInt,2L);										theSoundInt = *(short *)((*dataH) + z);					if (theSoundInt < 0)					{						theSoundInt = -theSoundInt;					}										//theSoundUInt = abs(theSoundInt);										//if (theSoundUInt > maxVolume)										if (theSoundInt > maxVolume)						maxVolume = theSoundInt;				break;			}					}				//counterD ++;				if (true /*counterD >> */)		{			if (progressDisp((((curPos + z) - startBytes)*100)/theNumBytes))			{				SysBeep(5);				DisposHandle(dataH);				iErr = FSClose(refNum);				return false;			}			//counterD = 0L;		}				iErr = GetFPos(refNum,&curPos);		if (iErr != 0)		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			progressDispos();			return false;		}	}		iErr = SetFPos(refNum,1,startBytes);	if (iErr != 0)	{		SysBeep(5);	}	progressDispos();		multiplierB = (theWordSize == 2) ? 0x00007FFF : 0x0000007F;		multiplierB = (multiplierB * (long)normaliseMaximum) / 128L;			BlockMove(theRegionName,sourceA,32L);	concatStrings(sourceA,sourceC,"\p - ");	writeLogS(sourceA);	progressCreate(sourceA);		if (!rewriteOrig)	{		iErr = FSpCreate(&theDestSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theDestSpec);					iErr = FSpCreate(&theDestSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}		iErr = FSpOpenDF(&theDestSpec,fsWrPerm,&theDestRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}	} 	curPos = startBytes;	while (curPos < endBytes)	{		if (progressDisp(((curPos - startBytes)*100)/theNumBytes))		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			return false;		}		inOutCount = endBytes - curPos;		if (inOutCount > 131072L)		{			inOutCount = 131072L;				}		iErr = GetFPos(refNum,&beforeRead);		if (iErr != 0)		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			progressDispos();			return false;		}		iErr = FSRead(refNum,&inOutCount,*dataH);		if (iErr != 0)		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			progressDispos();			return false;		}				if (!maxVolume)			maxVolume = 1;					counterD = 0L;		for (z = 0L;z< inOutCount;z += 2)		{			switch (theWordSize)			{				case 1:				/*					theSoundInt = abs((*(*dataH + z))-128);					theSoundByte = theSoundInt;					if ((short)theSoundByte > maxVolume)						maxVolume = (short)theSoundByte;					theSoundByte = theSoundInt << 8;					if ((short)theSoundByte > maxVolume)						maxVolume = (short)theSoundByte;*/											BlockMove (*dataH + z,&theSoundInt,2L);					theKeepInt = theSoundInt;					theSoundInt = (theSoundInt & 0xFF00) >> 8;											theSoundLong = ((long)theSoundInt*multiplierB)/(long)maxVolume;										theSoundInt = LoWord (theSoundLong);										theSoundInt2 = theKeepInt;					theSoundInt2 = (theSoundInt2 & 0x00FF);											theSoundLong = ((long)theSoundInt2*multiplierB)/(long)maxVolume;										theSoundInt2 = LoWord (theSoundLong);										theSoundInt = ((theSoundInt<<8) & 0xFF00 )| (theSoundInt2 & 0x00FF);					BlockMove (&theSoundInt,*dataH + z,2L);				break;								case 2:															theSoundInt = *(short *)((*dataH) + z);					//BlockMove (*dataH + z,&theSoundInt,2L);										//theKeepInt = theSoundInt;									theSoundLong = ((long)theSoundInt*(long)multiplierB)/(long)maxVolume;											//theSoundInt = LoWord (theSoundLong);										theSoundInt = theSoundLong & 0x0000FFFF;   										//theSoundInt = LoWord (theSoundLong);										*(short *)((*dataH) + z) = theSoundInt;										//BlockMove (&theSoundInt,*dataH + z,2L);				break;			}					}				counterD ++;		if (true /*counterD >> 8*/)		{			if (progressDisp((((curPos + z) - startBytes)*100)/theNumBytes))			{				SysBeep(5);				DisposHandle(dataH);				iErr = FSClose(refNum);				return false;			}			counterD = 0L;		}		iErr = SetFPos(refNum,1,beforeRead);		if (iErr != 0)		{			SysBeep(5);			DisposHandle(dataH);			iErr = FSClose(refNum);			progressDispos();			return false;		}		if (rewriteOrig)		{			iErr = FSWrite(refNum,&inOutCount,*dataH);			/* write it again */			iErr = GetFPos(refNum,&curPos);			if (iErr != 0)			{				SysBeep(5);				DisposHandle(dataH);				iErr = FSClose(refNum);				progressDispos();				return false;			}		}		else		{			iErr = FSWrite(theDestRefNum,&inOutCount,*dataH);			/* write it again */			iErr = GetFPos(theDestRefNum,&curPos);			iErr = SetFPos(refNum,1,curPos);			if (iErr != 0)			{				SysBeep(5);				DisposHandle(dataH);				iErr = FSClose(refNum);				progressDispos();				return false;			}		}	}	progressDispos();	DisposHandle(dataH);	iErr = FSClose(refNum);	if (!rewriteOrig)	{		iErr = FSClose(theDestRefNum);		writeSDIIResources(theDestSpec,theRate,stereo,theWordSize);		addFileToList(theDestSpec);	}	return true;}void getConvertDest(void);void normaliseMany(void);void normaliseMany(void){	Cell theCell;	short theindex;		short itemHit,iCtlVal,iCtlPart;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 theText,theText2;	long theTextConv;	Point localPt;	GrafPtr savePort;	float theDbs;	long theWholes, thebits;		rewriteOrig = true;	getConvertDest();	GetPort(&savePort);	NormaliseRegions = false;	normaliseMaximum = 128;	myDlg = GetNewDialog(1799,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,4,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	/*	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	HiliteControl((ControlHandle)iHndl,255);	*/		GetDItem(myDlg,6,&iType,&iHndl,&iRect);	if (theNewPrefs.normaliseLevel > 128 || theNewPrefs.normaliseLevel < 1)		theNewPrefs.normaliseLevel = 128;	SetCtlValue((ControlHandle)iHndl,theNewPrefs.normaliseLevel);		theDbs =  ((float)128 / (float)theNewPrefs.normaliseLevel) * 1.5;	theWholes = (long)theDbs;	thebits = (long)((theDbs - (float)theWholes) * 100);	NumToString (theWholes, theText);	NumToString (thebits, theText2);	concatStrings(theText,theText2,"\p.");	GetDItem(myDlg,13,&iType,&iHndl,&iRect);	SetIText(iHndl,theText);		GetDItem(myDlg,12,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,theNewPrefs.normaliseRewriteOrig);		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	NumToString (theNewPrefs.normaliseLevel, theText);	SetIText(iHndl,theText);		ShowWindow(myDlg);		SetPort(myDlg); 			itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;						case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;						case 6:				GetMouse(&localPt);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				iCtlPart = TestControl((ControlHandle)iHndl,localPt);				switch (iCtlPart)				{					case inUpButton:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);						iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<1) ? 1 : iCtlVal;					break;										case inDownButton:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>128) ? 128 : iCtlVal;					break;										case inPageUp:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<1) ? 1 : iCtlVal;											break;										case inPageDown:						GetDItem(myDlg,6,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>128) ? 128 : iCtlVal;					break;										default:					break;				}				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				iCtlVal = GetCtlValue((ControlHandle)iHndl);				NumToString((long)iCtlVal,theText);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetIText(iHndl,theText);								if (iCtlVal == 0)					iCtlVal = 1;									theDbs =  ((float)128 / (float)iCtlVal) * 1.5;								theWholes = (long)theDbs;				thebits = (long)((theDbs - (float)theWholes) * 100);				NumToString (theWholes, theText);				NumToString (thebits, theText2);								concatStrings(theText,theText2,"\p." );				GetDItem(myDlg,13,&iType,&iHndl,&iRect);				SetIText(iHndl,theText);							break;						case 1:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					NormaliseRegions = false;				}				else				{					NormaliseRegions = true;				}				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				theNewPrefs.normaliseRewriteOrig = rewriteOrig = GetCtlValue((ControlHandle)iHndl);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);					GetIText(iHndl,theText);				StringToNum(theText,&theTextConv);				normaliseMaximum = LoWord(theTextConv);				theNewPrefs.normaliseLevel = normaliseMaximum;			break;						case 11:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,120);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetIText(iHndl,"\p120");			break;						case 12:				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;		}	}		DisposDialog(myDlg);	SetPort(savePort); 	if (itemHit == 2)		return;				SetPt( &theCell, 0,0 );		/* start at top of list  */	watchcursor(true);	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}				theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				if (!NormaliseRegions)			normaliseFile((*therealResults)[theindex],NormaliseRegions,0L, 0L);		else		{			short x;			if (makeRegionsListFromFile((*therealResults)[theindex]))			{				writeLogS((unsigned char *)"\pStarting normalise all regions for file :");				writeLogS((*therealResults)[theindex].name);				for (x=0;x<theNumberOfRegions;x++)				{					normaliseFile((*therealResults)[theindex],true, theRegionPoints[x].StartFrame, theRegionPoints[x].StopFrame);				}				DisposPtr((Ptr)theRegionPointsPtr);			}								}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	return;}typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;/* this sucks the SMPTE time stamp from an SDII file */Boolean extractSMPTEFromFile (FSSpec theFile,short regionNum, long * timeStamp){	long theTimeStamp;	short rfRefNum,iRefNum;	Handle theRegions;	ddRLHeader theHeader;	RegionRec theRegion;	OSErr	iErr;	long Thours,Tmins,Tsecs, Tframes, TRemainder, TMarker;		iRefNum = CurResFile();		rfRefNum = FSpOpenResFile(&theFile,fsRdPerm);	iErr = ResError();	if (iErr)	{		return false;		}		UseResFile(rfRefNum);		theRegions = Get1Resource('ddRL',1000);	if (!theRegions)	{		CloseResFile(rfRefNum);		UseResFile(iRefNum);		return false;	}		BlockMove(*theRegions, &theHeader, sizeof(ddRLHeader));	BlockMove(*theRegions + sizeof(ddRLHeader) + (regionNum * sizeof(RegionRec)),&theRegion, sizeof(RegionRec));		CloseResFile(rfRefNum);	UseResFile(iRefNum);	*timeStamp = theRegion.TimeStampLS;	//theTimeStamp = theRegion.TimeStampLS;		return true;}