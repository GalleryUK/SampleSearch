#include "SampleSearch.h"#include "Globals.h"#include "prefs.h"extern newPrefsRec theNewPrefs;void writeLogP(Str255 theLogTextPtr);#define kNoSCIIData -5void archiveList(void);OSType theOrigami;extern FSSpec theLastThingFound;Boolean burnSampToInst (FSSpec theInstSpec,FSSpec theSampSpec,short theSampIndex);OSErr getNumOfEntries (FSSpec	mySpec);FSSpec ResolveSCIIFSSpec2(Str31	myFileName, long	catHint, short driveHint, OSType	theType);Boolean VgetvolName(short theVRefNum, StringPtr myString);long BanksDirID, InstsDirID,SamplesDirID;short theGResultsCtr;StringPtr getSCIIfile2(FSSpec	mySpec,short	index);Boolean ResolveSCIIFSSpecLocal(Str31	myFileName, long	catHint, short driveHint, OSType	theType, FSSpecPtr mySpecPtr);OSType theEnqRetType;void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);Boolean archiveSCII(FSSpec theSpec,short index, OSType theType, StandardFileReply theReply);Boolean archiveDawn(FSSpec theSpec,short index, StandardFileReply theReply);Boolean resolveInstToMem(FSSpec theSpec,short index);Boolean resolveBankToMem(FSSpec theSpec,short index);Boolean resolveInstsInPlace(FSSpec theInst);Boolean archiveInstsFromGTheResults(StandardFileReply reply);Boolean resolveBanksInPlace(FSSpec theBank);FSSpec archiveBanksFromGTheResults(StandardFileReply reply);Boolean resolveDawnToMem(FSSpec mySpec,short index);Boolean makeASubFolders, reResolveAtDest;FSSpec archiveDataFromGTheResults(StandardFileReply reply, Boolean isDawn, Boolean isBank);Boolean burnInstToBank (FSSpec theBankSpec,FSSpec theInstSpec,short theInstIndex);pascal	OSErr	myPBCatSearchSyncCompat(CSParamPtr paramBlock);pascal	OSErr	PBCatSearchSyncCompat(CSParamPtr paramBlock);void progressWindowCreate(Str255	theText);OSErr progressWinDisp(short percent);void progressWindowDispose(void);Boolean resolveDawnEDLInPlace(StandardFileReply reply);Boolean archiveDawnEDLFromGTheResults(StandardFileReply reply);Boolean aProb;Boolean ARcMoveOnSame;Boolean ARcDeleteOriginal;Boolean errorOccurred;void archiveList(void){	StandardFileReply	reply;	long 	newDirID, instDirID, sampDirID, bankDirID;	short z;	FSSpec	mySpecA, mySpecB;	OSErr	iErr;	CopyParam	pb;	Str255	myStr = "\pkjhgadf";	FSSpec	spec, instFolderSpec, sampFolderSpec, bankFolderSpec;	short	theSource, theDestination;	OSErr	theErr;	long inOutCount;	Ptr	copyBuff;	short numchars;	Str255 theLogText;	FInfo fndrInfo;	Boolean instFound, sampleFound, bankFound;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Cell theCell;			Boolean deleteOnSame = false;	Boolean deleteOnDifferent = false;	Boolean makeFolder = false;	Boolean onlySelected = true;	Boolean problemOccurred = false;	Boolean makeSubFolders = false;		instFound = false;	sampleFound = false;	bankFound = false;		myDlg = GetNewDialog(12000,0L,(WindowPtr)-1);	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)(ControlHandle)iHndl,true);	GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);				ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;			case 14:				GetDItem(myDlg,14,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;			case 7:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 9:				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;						case 1:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					onlySelected = false;				}				else				{					onlySelected = true;				}																GetDItem(myDlg,6,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					makeFolder = true;				}				else				{					makeFolder = false;				}								GetDItem(myDlg,14,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					makeSubFolders = true;				}				else				{					makeSubFolders = false;				}								GetDItem(myDlg,7,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					deleteOnSame = false;					deleteOnDifferent = false;				}				GetDItem(myDlg,8,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					deleteOnSame = true; /* problem here maybe if same folder chosen */					deleteOnDifferent = true;				}				GetDItem(myDlg,9,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					deleteOnSame = true;					deleteOnDifferent = false;				}			break;					case 2:			break;		}	}	DisposDialog(myDlg);	if (itemHit == 2)		return;			StandardPutFile("\pEnter Location for Archive","\pArchive Folder",&reply);	if (reply.sfGood)	{		progressWindowCreate("\pArchiving List");				if (reply.sfReplacing)					iErr = FSpDelete(&reply.sfFile);					if (makeFolder)		{				iErr = FSpDirCreate(&(reply.sfFile),0,&newDirID);			if (iErr !=0)			{				genError ("\pCan't create folder");				progressWindowDispose();				return;			}			writeLogS((unsigned char *)"Created archive directory ");			writeLog((Ptr)reply.sfFile.name);		}		else		{			newDirID = reply.sfFile.parID;		}				bankFolderSpec.vRefNum = reply.sfFile.vRefNum;		bankFolderSpec.parID = newDirID;		makeStr255 ("\pBANK ",bankFolderSpec.name);				BlockMove (reply.sfFile.name + 1,bankFolderSpec.name + *bankFolderSpec.name +1,64L);		*bankFolderSpec.name = *bankFolderSpec.name + *reply.sfFile.name;				if (makeSubFolders)		{			iErr = FSpDirCreate(&bankFolderSpec,0,&bankDirID);			if (iErr !=0)			{				genError ("\pCan't create folder");				progressWindowDispose();				return;			}							instFolderSpec.vRefNum = reply.sfFile.vRefNum;			instFolderSpec.parID = newDirID;			makeStr255 ("\pINST ",instFolderSpec.name);						BlockMove (reply.sfFile.name + 1,instFolderSpec.name + *instFolderSpec.name +1, 64L);			*instFolderSpec.name = *instFolderSpec.name + *reply.sfFile.name;						iErr = FSpDirCreate(&instFolderSpec,0,&instDirID);			if (iErr !=0)			{				genError ("\pCan't create folder");				progressWindowDispose();				return;			}					sampFolderSpec.vRefNum = reply.sfFile.vRefNum;			sampFolderSpec.parID = newDirID;			makeStr255 ("\pSAMPLES ", sampFolderSpec.name);			BlockMove (reply.sfFile.name + 1,sampFolderSpec.name + *sampFolderSpec.name +1,64L);			*sampFolderSpec.name = *sampFolderSpec.name + *reply.sfFile.name;			iErr = FSpDirCreate(&sampFolderSpec,0,&sampDirID);			if (iErr !=0)			{				genError ("\pCan't create folder");				progressWindowDispose();				return;			}		}		copyBuff = NewPtr(65535L);		if (!copyBuff)		{			genError ("\pNot enough memory for copy buffer");			progressWindowDispose();			return;		}				theCell.h = 0;		theCell.v = 0;		/* doesn't make last one selected */						for (z=0;z<totfindcounter;z++)		{		  theCell.h = (DisplayedColumns == 1) ? 0 : z - ((z/4)*4);		  theCell.v = (DisplayedColumns == 1) ? z : z/4;		 	if (!totfindcounter)		 		return;		  if(LGetSelect(false,&theCell,myList) || !onlySelected)		  {					if (progressWinDisp((z*100 / totfindcounter)))			{			 	writeLogS((unsigned char *)(unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"archive function terminated by user");				writeLogS((unsigned char *)" ");				DisposPtr(copyBuff);				return;			}			if (-(((*therealResults)[z]).vRefNum) <=(maxVRef))			{								iErr = FSpGetFInfo(&((*therealResults)[z]),&fndrInfo);				if (iErr!=0)					break;				switch (fndrInfo.fdType)				{					case 'AIFF': case 'Sd2f' : case 'SFIL':						sampleFound = true;						iErr = FSMakeFSSpec(reply.sfFile.vRefNum,(makeSubFolders) ? sampDirID : newDirID,((*therealResults)[z]).name,&spec);						if (iErr!=0 && iErr !=-43)						{							genError("\pCan't make FSSpec for new file");							progressWindowDispose();							DisposPtr(copyBuff);							return;						}					break;										case 'SCin': case 'SCsi' : case 'SCss': case 'SCsd' :						instFound = true;						iErr = FSMakeFSSpec(reply.sfFile.vRefNum,(makeSubFolders) ? instDirID : newDirID,((*therealResults)[z]).name,&spec);						if (iErr!=0 && iErr !=-43)						{							genError("\pCan't make FSSpec for new file");							progressWindowDispose();							DisposPtr(copyBuff);							return;						}					break;										case 'MixD':						bankFound = true;						iErr = FSMakeFSSpec(reply.sfFile.vRefNum,(makeSubFolders) ? bankDirID : newDirID,((*therealResults)[z]).name,&spec);						if (iErr!=0 && iErr !=-43)						{							genError("\pCan't make FSSpec for new file");							progressWindowDispose();							DisposPtr(copyBuff);							return;						}					break;										default:					iErr = FSMakeFSSpec(reply.sfFile.vRefNum,newDirID,((*therealResults)[z]).name,&spec);						if (iErr!=0 && iErr !=-43)						{							genError("\pCan't make FSSpec for new file");							progressWindowDispose();							DisposPtr(copyBuff);							return;						}					break;					}												if ((*therealResults)[z].vRefNum == spec.vRefNum && (*therealResults)[z].parID == spec.parID && !((sampleFound || instFound || bankFound) && makeFolder))				{					/* already in the target folder */				}				else				{									if ((*therealResults)[z].vRefNum == spec.vRefNum && deleteOnSame)					{						iErr = CatMove((*therealResults)[z].vRefNum,(*therealResults)[z].parID,(*therealResults)[z].name,spec.parID,0);						if (iErr != 0)						genError ("\pA problem occured during CatMove");						writeLogS((unsigned char *)"Sucessfully moved");						writeLog((Ptr)(*therealResults)[z].name);						problemOccurred = false;					}					else					{						iErr =1;						while (iErr !=0)						{							iErr = FSpCreate(&spec,fndrInfo.fdCreator,fndrInfo.fdType,0);							if (iErr == -48) 	/** file exists **/							{								*spec.name += 1;								*(spec.name+(*spec.name)) = 32;							}						}						iErr = FSpOpenDF(&((*therealResults)[z]),fsCurPerm,&theSource);						if (!iErr)						{							iErr = FSpOpenDF(&spec,fsCurPerm,&theDestination);							if (iErr!=0)							{								genError("\pCan't open DF of new file");								writeLogS((unsigned char *)"*********** ERROR ************");								writeLogS((unsigned char *)"a problem occurred opening the data fork of the new file: ");								writeLog((Ptr)(*therealResults)[z].name);								writeLogS((unsigned char *)"abandoning archive function");								writeLogS((unsigned char *)" ");								progressWindowDispose();								DisposPtr(copyBuff);								return;							}							theErr = 0;							while(theErr!= eofErr)							{								if (progressWinDisp((z*100 / totfindcounter)))								{								 	writeLogS((unsigned char *)"*********** ERROR ************");									writeLogS((unsigned char *)"archive function terminated by user");									writeLogS((unsigned char *)" ");									DisposPtr(copyBuff);									return;								}								inOutCount = 65000L;								theErr = FSRead(theSource,&inOutCount,copyBuff);								iErr = FSWrite(theDestination,&inOutCount,copyBuff);								if (iErr!=0)								{									genError("\pCan't write to DF of new file");									writeLogS((unsigned char *)"*********** ERROR ************");									writeLogS((unsigned char *)"a problem occurred writing to the data fork of the new file: ");									writeLog((Ptr)(*therealResults)[z].name);									writeLogS((unsigned char *)"abandoning archive function");									writeLogS((unsigned char *)" ");									progressWindowDispose();									DisposPtr(copyBuff);									return;								}							}							FSClose(theSource);							FSClose(theDestination);						}						FSpCreateResFile(&spec,fndrInfo.fdCreator,fndrInfo.fdType,0);						iErr = ResError();						if (iErr!=0)						{							genError("\pCan't create RF of new file");							writeLogS((unsigned char *)"*********** ERROR ************");							writeLogS((unsigned char *)"a problem occurred creating the Res fork of the new file: ");							writeLog((Ptr)(*therealResults)[z].name);							writeLogS((unsigned char *)"abandoning archive function");							writeLogS((unsigned char *)" ");							progressWindowDispose();							DisposPtr(copyBuff);							return;						}						iErr = FSpOpenRF(&((*therealResults)[z]),fsCurPerm,&theSource);						if (iErr!=0 && iErr != -43)						{							genError("\pCan't open RF of source file");							writeLogS((unsigned char *)"*********** ERROR ************");							writeLogS((unsigned char *)"a problem occurred opening the Res fork of the source file: ");							writeLog((Ptr)(*therealResults)[z].name);							writeLogS((unsigned char *)"abandoning archive function");							writeLogS((unsigned char *)" ");							progressWindowDispose();							DisposPtr(copyBuff);							return;						}						if (!iErr)						{							iErr = FSpOpenRF(&spec,fsCurPerm,&theDestination);							if (iErr!=0)							{								genError("\pCan't open RF of new file");								writeLogS((unsigned char *)"*********** ERROR ************");								writeLogS((unsigned char *)"a problem occurred opening the Res fork of the new file: ");								writeLog((Ptr)(*therealResults)[z].name);								writeLogS((unsigned char *)"abandoning archive function");								writeLogS((unsigned char *)" ");								progressWindowDispose();								DisposPtr(copyBuff);								return;							}							theErr = 0;							while(theErr!= eofErr)							{								inOutCount = 65000L;								theErr = FSRead(theSource,&inOutCount,copyBuff);								iErr = FSWrite(theDestination,&inOutCount,copyBuff);								if (iErr!=0)								{									genError("\pCan't write to RF of new file");									writeLogS((unsigned char *)"*********** ERROR ************");									writeLogS((unsigned char *)"a problem occurred writing data to the new file: ");									writeLog((Ptr)(*therealResults)[z].name);									writeLogS((unsigned char *)"abandoning archive function");									writeLogS((unsigned char *)" ");									progressWindowDispose();									FSClose(theSource);									FSClose(theDestination);									DisposPtr(copyBuff);									return;								}							}							FSClose(theSource);							FSClose(theDestination);						}						writeLogS((unsigned char *)"Sucessfully archived");						writeLog((Ptr)(*therealResults)[z].name);						addFileToList(spec);						/* copy FInfo */						problemOccurred = false;					}										FSpSetFInfo(&spec,&fndrInfo);									}			}			else			{				writeLogS((unsigned char *)"*********** ERROR ************");				 writeLogS((unsigned char *)"Could not archive the file shown below as it is on an unmounted Ghost Volume) ");				 writeLog((Ptr)(*therealResults)[z].name);				 writeLogS((unsigned char *)" ");				 problemOccurred = true;			}						if ((*therealResults)[z].vRefNum == spec.vRefNum && (*therealResults)[z].parID == spec.parID && !((sampleFound || instFound || bankFound) && makeFolder))			{							}			else			{					if (deleteOnSame && ((*therealResults)[z].vRefNum == spec.vRefNum) && !problemOccurred)				{					FSpDelete(&(*therealResults)[z]);					BlockMove (&spec, &(*therealResults)[z], 70L);				}				if (deleteOnDifferent && ((*therealResults)[z].vRefNum != spec.vRefNum) && !problemOccurred)				{					FSpDelete(&(*therealResults)[z]);					BlockMove (&spec, &(*therealResults)[z], 70L);				}			}		  }		}		if (!instFound && makeSubFolders)		{			iErr = FSpDelete(&instFolderSpec);			}		if (!sampleFound && makeSubFolders)		{			iErr = FSpDelete(&sampFolderSpec);		}		if (!bankFound && makeSubFolders)		{			iErr = FSpDelete(&bankFolderSpec);		}		progressWindowDispose();	}	DisposPtr(copyBuff);}void writeLog(Ptr theLogTextPtr){	Str255	theLogText;	short numchars;		sessionLog = fopen( "SampleSearchª Log", "a" );	BlockMove (theLogTextPtr,theLogText,*theLogTextPtr+1);	PtoCstr (theLogText);	numchars = fprintf(sessionLog,"%s\n",theLogText);	fclose (sessionLog);	}void writeLogP(Str255 theLogTextPtr){	Str255	theLogText;	short numchars;		sessionLog = fopen( "SampleSearchª Log", "a" );	BlockMove (theLogTextPtr,theLogText,*theLogTextPtr+1);	PtoCstr (theLogText);	numchars = fprintf(sessionLog,"%s\n",theLogText);	fclose (sessionLog);	}void writeLogS(Str255 theLogText){	short numchars;	sessionLog = fopen( "SampleSearchª Log", "a" );	//PtoCstr (theLogText);	numchars = fprintf(sessionLog,"%s\n",theLogText);	fclose (sessionLog);}void archiveMany(void);void archiveMany(void){	Cell theCell;	short theindex;	FInfo fndrInfo;	Str255 theErrorText;	OSErr	iErr;	StandardFileReply reply;	FSSpec	theTempSpec;	Str255 temporB = "\pBANKS ";	Str255 temporI = "\pINSTS ";	Str255 temporS = "\pSAMPLES ";	long newDirID;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/			errorOccurred = false;	writeLogS((unsigned char *)"Beginning Intelligent Archive");		StandardPutFile("\pEnter the location for the Archive","\pArchive Folder",&reply);	if (!reply.sfGood)	{		return;	}	if (reply.sfReplacing)		iErr = FSpDelete(&reply.sfFile);			myDlg = GetNewDialog(12001,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,4,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	HiliteControl((ControlHandle)iHndl,255);	GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);			ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				//SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;			case 7:				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 9:				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,7,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);			break;			case 1:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					makeASubFolders = false;				}				else				{					makeASubFolders = true;				}								GetDItem(myDlg,5,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					reResolveAtDest = true;				}				else				{					reResolveAtDest = false;				}					GetDItem(myDlg,9,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					ARcMoveOnSame = true;					ARcDeleteOriginal = false;				}								GetDItem(myDlg,7,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					ARcMoveOnSame = false;					ARcDeleteOriginal = false;				}								GetDItem(myDlg,8,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					ARcMoveOnSame = true;					ARcDeleteOriginal = true;				}				break;				case 2:			break;		}	}	DisposDialog(myDlg);	if (itemHit == 2)		return;		iErr = FSpDirCreate(&(reply.sfFile),0,&newDirID);	if (iErr !=0)	{		genError ("\pCan't create folder");		return;	}	writeLogS((unsigned char *)"Created archive directory ");	writeLog((Ptr)(reply.sfFile.name));			reply.sfFile.parID = newDirID;		BlockMove (&(reply.sfFile),&theTempSpec,70L);	concatStrings(temporB,theTempSpec.name,"\p");	BlockMove (temporB,theTempSpec.name,64L);		iErr = FSpDirCreate(&(theTempSpec),0,&BanksDirID);	if (iErr !=0 &&  iErr != -48)	{		return;	}		BlockMove (&(reply.sfFile),&theTempSpec,70L);	concatStrings(temporI,theTempSpec.name,"\p");	BlockMove (temporI,theTempSpec.name,64L);	iErr = FSpDirCreate(&(theTempSpec),0,&InstsDirID);	if (iErr !=0  && iErr != -48)	{		return;	}		BlockMove (&(reply.sfFile),&theTempSpec,70L);	concatStrings(temporS,theTempSpec.name,"\p");	BlockMove (temporS,theTempSpec.name,64L);	iErr = FSpDirCreate(&(theTempSpec),0,&SamplesDirID);	if (iErr !=0 && iErr != -48)	{		return;	}					//progressWindowCreate("\pArchiving List");			SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		iErr = FSpGetFInfo(&(*therealResults)[theindex],&fndrInfo);		if (iErr != 0)		{			SysBeep(5);			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"Could not archive the file below:");			writeLog((Ptr)(*therealResults)[theindex].name);			writeLogS((unsigned char *)" ");			errorOccurred = true;		}		else		{					theOrigami = fndrInfo.fdType;			switch (fndrInfo.fdType)			{				case 'SCin':case 'SCsi':case 'SCsd':case 'SCss':case 'MixD':					archiveSCII((*therealResults)[theindex],theindex,fndrInfo.fdType, reply);				break;								case 'CR02':					archiveDawn((*therealResults)[theindex],theindex,reply);				break;			}			}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	writeLogS((unsigned char *)"Intelligent Archive Function Completed");	if (errorOccurred)	{		genError ("\pErrors occurred during this procedure - consult the SampleSearchª Log for details");	}	return;}Boolean archiveSCII(FSSpec theSpec,short index, OSType theType, StandardFileReply theReply){		FSSpec TheArchBank, TheArchInst;		short z;	OSErr	iErr;			switch (theType)		{			case 'MixD':				aProb = false;				resolveBankToMem(theSpec,index);				TheArchBank = archiveDataFromGTheResults(theReply,0,1);				if (reResolveAtDest)					resolveBanksInPlace(TheArchBank);				addFileToList(TheArchBank);			break;						case 'SCin':case 'SCsi':case 'SCss':case 'SCsd':				aProb = false;				resolveInstToMem(theSpec,index);				TheArchInst = archiveDataFromGTheResults(theReply,0,0);				if (reResolveAtDest)					resolveInstsInPlace(TheArchInst);				addFileToList(TheArchInst);			break;		}		return true;}Boolean archiveDawn(FSSpec theSpec,short index, StandardFileReply theReply){			resolveDawnToMem(theSpec,index);	archiveDataFromGTheResults(theReply,1,0);	resolveDawnEDLInPlace(theReply);	archiveDawnEDLFromGTheResults(theReply);		return true;}typedef struct resolveRec {Str27	driveName;long	dirID;Str31	fileName;OSType	type;Boolean	found;} resRec, *resRecPtr;void	getSCIIfile(FSSpec	mySpec,short	index,resRecPtr myRec);Boolean rRectoFSSpec(resRecPtr myResRecPtr, FSSpecPtr mySpecPtr);Boolean resolveInstToMem(FSSpec mySpec,short index){		FInfo **	myInstanceTypeH;	FSSpec ** myInstanceH;	Ptr	myInstancePtr;	Ptr	myInstanceTypePtr;	resRecPtr	tempRRecPtr, nullRec;	struct resolveRec myTempRec;	short inst,samp,instTot,sampTot;	long	memSize, memtypeSize;	FSSpec theSpeccy, anotherSpec;		short 	arrayPointer = 0;	StandardFileReply	reply;	OSErr  iErr;	short	itemHit, refNum;	FInfo	fndrInfo;	long	fileLength;	long inOutCount;	FSSpec	myTempSpec;	short iRefNum, myRefNum;	short z;	Handle hString[28];	Handle volumeRef[28];	short dispFar;	short dispFarSeg;	FSSpec	myPSpec;	FSSpec	myInstSpec;	Str31	theDefName;	Str31	resText = "\p resolved";	Boolean burnData = false;	Boolean makeNewList = true;		burnData = false;	makeNewList = true;		if 	(!FInfolistInMem)	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)			{				genError("\pCould not expand FInfo in Resolve");				return false;			}						checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));									for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}	if (-(mySpec.vRefNum) > (maxVRef))	{		genError("\pCan't resolve a ghost bank");		return false;	}		tempRRecPtr = &myTempRec;	instTot = 1;				/** how many instruments ? **/		myInstanceH = (FSSpec **)NewHandle(70L * 1000);				/** make mem **/	memSize = 70000L;	if (!myInstanceH)	{		genError ("\pNot enough memory to allocate Handle");		return;	}	myInstanceTypeH = (FInfo **)NewHandle(16L * 1000);				/** make mem **/	memtypeSize = 16000L;	if (!myInstanceTypeH)	{		genError ("\pNot enough memory to allocate type Handle");		return;	}	writeLogS((unsigned char *)"Began Resolve of File");	writeLog((Ptr)(mySpec.name));	progressWindowCreate("\pResolving Instrument");	   				inst = 0;		iErr = VgetvolName(mySpec.vRefNum, myTempRec.driveName);		myTempRec.dirID = mySpec.parID;		BlockMove (mySpec.name,myTempRec.fileName,32L);		//myTempRec.type = 		myTempRec.found = true;				//tempSpecPtr = &myTempSpec;				iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/		BlockMove (&myTempSpec,&anotherSpec,70L);		if (!iErr && (myTempSpec.vRefNum == 0))		{			genError ("\pThis shouldn't happen");			anotherSpec = ResolveSCIIFSSpec2(tempRRecPtr->fileName,0,0,tempRRecPtr->type);			//tempSpecPtr = &anotherSpec;			}		 if (anotherSpec.vRefNum == -999)	/** abort this inst **/		 {		    genError ("\pThis shouldn't happen");		    writeLogS((unsigned char *)"*********** ERROR ************");		    writeLogS((unsigned char *)"Could not find the instrument file below, which has been ignored as has it's samples");		    writeLog((Ptr)(tempRRecPtr->fileName));		    writeLogS((unsigned char *)" ");			errorOccurred = true;		 }		 else		{			if (arrayPointer >= (memSize / 70))			{				memSize += 70000L;								SetHandleSize((Handle)myInstanceH, memSize);				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize pointer");					progressWindowDispose();					return;				}				memtypeSize += 16000L;								SetHandleSize((Handle)myInstanceTypeH, memtypeSize);				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize type pointer");					progressWindowDispose();					return;				}			}			BlockMove (&anotherSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/				iErr = FSpGetFInfo(&anotherSpec,&fndrInfo);			if (iErr!=0)			{				genError("\pProblem getting FInfo");				progressWindowDispose();				return false;			}			BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/						arrayPointer ++;					sampTot = getNumOfEntries (anotherSpec);			/** find out how many samples it has **/			if (sampTot == 0)			{				genError ("\pThat instrument is empty");				progressWindowDispose();				return;			}						if (sampTot == kNoSCIIData)			{				progressWindowDispose();				genError ("\pCant Resolve SampleCell I files, only SampleCell II files");				return;			}						if ((arrayPointer + sampTot + 1) >= (memSize / 70))			{				memSize += (70L*(sampTot+1));								SetHandleSize((Handle)myInstanceH,memSize);				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize pointer");					progressWindowDispose();					return;				}									memtypeSize += (16L*(sampTot+1));								SetHandleSize((Handle)myInstanceTypeH,memtypeSize);				iErr = MemError();				if (iErr!=0)				{					genError ("\pNot enough memory to resize type pointer");					progressWindowDispose();					return;				}				}			if (instTot>1)			{				dispFar = ((inst+1) * 100)/(instTot);				dispFarSeg = 100/(instTot-1);			}			else			{				dispFar =0;				dispFarSeg =100;			}			if (progressWinDisp(dispFar))				return;			BlockMove (&anotherSpec,&myInstSpec,70L);			for (samp = 0;samp < sampTot;samp ++)			{				if (sampTot)				{					short progressAmount;					progressAmount = ((float)(samp+1) / (float)(sampTot)) * dispFarSeg;//					if(progressWinDisp(dispFar+((((samp+1) * 100)/(sampTot)*dispFarSeg)/100)))					if(progressWinDisp(progressAmount))					{						return;					}				}				getSCIIfile(myInstSpec,samp, tempRRecPtr);		/** get a name from bank **/				if (!tempRRecPtr->found)				{					genError ("\pA problem occurred getting a sample name");					progressWindowDispose();					return false;				}				iErr = rRectoFSSpec(tempRRecPtr, &anotherSpec);	/** make it into an FSSpec **/				if (!iErr && (anotherSpec.vRefNum == -999))				{					genError("\pCan't make FSSpec");					progressWindowDispose();					return false;				}				//BlockMove(&anotherSpec,&anotherSpec,70L);				if (!iErr && (anotherSpec.vRefNum == 0))				{					anotherSpec = ResolveSCIIFSSpec2(tempRRecPtr->fileName,0L, 0,tempRRecPtr->type);					//tempSpecPtr = &anotherSpec;						if (anotherSpec.vRefNum == -999)					{						iErr = 0;					}					else					{						iErr = 1;					}				}												if (!iErr)				{						writeLogS((unsigned char *)"*********** ERROR ************");					 writeLogS((unsigned char *)"Could not find the sample file below, which has been ignored");		   			 writeLog((Ptr)(anotherSpec.name));		   			 writeLogS((unsigned char *)" ");		   			 errorOccurred = true;				}				else				{								BlockMove (&anotherSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/													iErr = FSpGetFInfo(&anotherSpec,&fndrInfo);						if (iErr!=0)						{							genError("\pProblem getting FInfo");							progressWindowDispose();							return false;						}					BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/		/***************************************/					arrayPointer ++;				}			}		}	progressWindowDispose();		BlockMove(mySpec.name,theDefName,32L);	BlockMove(resText + 1,theDefName + (*theDefName) + 1,31L - (long)(*theDefName));	*theDefName = *(mySpec.name) + *resText;	theGResultsCtr = arrayPointer;	BlockMove (*myInstanceH,*gTheResults,arrayPointer*70L);	DisposHandle((Handle)myInstanceH);	DisposHandle((Handle)myInstanceTypeH);	writeLogS((unsigned char *)"Finished Resolve");	 /* We must check that this result does what we want */}Boolean resolveBankToMem(FSSpec mySpec,short index){		FInfo **	myInstanceTypeH;	FSSpec ** myInstanceH;	Ptr	myInstancePtr;	Ptr	myInstanceTypePtr;	resRecPtr	tempRRecPtr, nullRec;	struct resolveRec myTempRec;	long inst,samp,instTot,sampTot;	long	memSize, memtypeSize;	FSSpec theSpeccy, anotherSpec;		short 	arrayPointer = 0;	StandardFileReply	reply;	OSErr  iErr;	short	itemHit, refNum;	FInfo	fndrInfo;	long	fileLength;	long inOutCount;	FSSpec	myTempSpec;	short iRefNum, myRefNum;	short z;	Handle hString[28];	Handle volumeRef[28];	short dispFar;	short dispFarSeg;	FSSpec	myPSpec;	FSSpec	myInstSpec;	Str31	theDefName;	Str31	resText = "\p resolved";	Boolean burnData = false;	Boolean makeNewList = true;		burnData = false;	makeNewList = true;		if 	(!FInfolistInMem)	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)			{				genError("\pCould not expand FInfo in Resolve");				return false;			}						checkHandleSize((Handle)theFInfo,totfindcounter,sizeof(FInfo));			for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}	if (-(mySpec.vRefNum) > (maxVRef))	{		genError("\pCan't resolve a ghost bank");		return false;	}		tempRRecPtr = &myTempRec;	instTot = getNumOfEntries (mySpec);				/** how many instruments ? **/	if (!instTot)	{		genError ("\pThat file is empty");		return false;	}			if (instTot == kNoSCIIData)	{		genError ("\pCant Resolve SampleCell I files, only SampleCell II files");		return;	}					myInstanceH = (FSSpec **)NewHandle(70L);				/** make mem **/	memSize = 70L;	if (!myInstanceH)	{		genError ("\pNot enough memory to allocate Handle");		return;	}	//MoveHHi(myInstanceH);	myInstanceTypeH = (FInfo **)NewHandle(16L);				/** make mem **/	memtypeSize = 16L;	if (!myInstanceTypeH)	{		genError ("\pNot enough memory to allocate type Handle");		return;	}	//MoveHHi(myInstanceTypeH);	BlockMove (&mySpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/	BlockMove (&((*theFInfo)[index]),((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/	arrayPointer++;	progressWindowCreate("\pResolving Bank");	writeLogS((unsigned char *)"Began Resolve of File");	writeLog((Ptr)(mySpec.name));		   				for (inst = 0;inst < instTot;inst ++)	{		getSCIIfile(mySpec,inst,&myTempRec);		/** get a name from bank **/		if (!(myTempRec.found))		{			genError("\pCannot complete the instruction because an unexpected error occured");			progressWindowDispose();			return false;		}		//tempSpecPtr = &myTempSpec;		iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/		BlockMove (&myTempSpec,&anotherSpec,70L);		if (!iErr && (myTempSpec.vRefNum == 0))		{			anotherSpec = ResolveSCIIFSSpec2(tempRRecPtr->fileName,0,0,tempRRecPtr->type);			//tempSpecPtr = &anotherSpec;			}		 if (anotherSpec.vRefNum == -999)	/** abort this inst **/		 {		 	writeLogS((unsigned char *)"*********** ERROR ************");		    writeLogS((unsigned char *)"Could not find the instrument file below, which has been ignored as has it's samples");		    writeLog((Ptr)(tempRRecPtr->fileName));		    writeLogS((unsigned char *)" ");		    errorOccurred = true;		 }		 else		{			memSize += 70L;							SetHandleSize((Handle)myInstanceH, memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}			memtypeSize += 16L;							SetHandleSize((Handle)myInstanceTypeH, memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}						BlockMove (&anotherSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/				iErr = FSpGetFInfo(&anotherSpec,&fndrInfo);			if (iErr!=0)			{				genError("\pProblem getting FInfo");				progressWindowDispose();				return false;			}			BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/						arrayPointer ++;					sampTot = getNumOfEntries (anotherSpec);			/** find out how many samples it has **/						if (sampTot == kNoSCIIData)		{			progressWindowDispose();			genError ("\pCant Resolve SampleCell I files, only SampleCell II files");			return;		}					memSize += (70L*(sampTot+1));							SetHandleSize((Handle)myInstanceH,memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}							memtypeSize += (16L*(sampTot+1));							SetHandleSize((Handle)myInstanceTypeH,memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}				if (instTot>1)			{				dispFar = ((inst+1) * 100)/(instTot);				dispFarSeg = 100/(instTot-1);			}			else			{				dispFar =0;				dispFarSeg =100;			}			if (progressWinDisp(dispFar))				return;			BlockMove (&anotherSpec,&myInstSpec,70L);			for (samp = 0;samp < sampTot;samp ++)			{				if(progressWinDisp(dispFar+((((samp+1) * 100)/(sampTot)*dispFarSeg)/100)))					return;				getSCIIfile(myInstSpec,samp, tempRRecPtr);		/** get a name from bank **/				if (!tempRRecPtr->found)				{					genError ("\pA problem occurred getting a sample name");					progressWindowDispose();					return false;				}				iErr = rRectoFSSpec(tempRRecPtr, &anotherSpec);	/** make it into an FSSpec **/				if (!iErr && (anotherSpec.vRefNum == -999))				{					genError("\pCan't make FSSpec");					progressWindowDispose();					return false;				}				//BlockMove(&anotherSpec,&anotherSpec,70L);				if (!iErr && (anotherSpec.vRefNum == 0))				{					anotherSpec = ResolveSCIIFSSpec2(tempRRecPtr->fileName,0L, 0,tempRRecPtr->type);					//tempSpecPtr = &anotherSpec;						if (anotherSpec.vRefNum == -999)					{						iErr = 0;					}					else					{						iErr = 1;					}				}												if (!iErr)				{					writeLogS((unsigned char *)"*********** ERROR ************");					 writeLogS((unsigned char *)"Could not find the sample file below, which has been ignored");		   			 writeLog((Ptr)(anotherSpec.name));		   			 writeLogS((unsigned char *)" ");		   			 errorOccurred = true;				}				else				{								BlockMove (&anotherSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/													iErr = FSpGetFInfo(&anotherSpec,&fndrInfo);						if (iErr!=0)						{							genError("\pProblem getting FInfo");							progressWindowDispose();							return false;						}					BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/		/***************************************/					arrayPointer ++;				}			}		}	}	progressWindowDispose();		BlockMove(mySpec.name,theDefName,32L);	BlockMove(resText + 1,theDefName + (*theDefName) + 1,31L - (long)(*theDefName));	*theDefName = *(mySpec.name) + *resText;	theGResultsCtr = arrayPointer;	BlockMove (*myInstanceH,*gTheResults,arrayPointer*70L);	DisposHandle((Handle)myInstanceH);	DisposHandle((Handle)myInstanceTypeH);	writeLogS((unsigned char *)"Finished Resolve");	 /* We must check that this result does what we want */}/********************/Boolean resolveInstsInPlace(FSSpec mySpec){	short z,y;	OSErr	iErr;	FSSpec tempSpec;	StringPtr theSampName;	short theNumberOfSamples;	FInfo fndrInfo;	Boolean copyIt;	short dispFar;	short dispFarSeg;		for (z=0;z<theGResultsCtr;z++)	{					iErr = FSpGetFInfo(&((*gTheResults)[z]),&fndrInfo);		if (!iErr)		{			copyIt = false;			switch (fndrInfo.fdType)			{				case'SCin':case 'SCsi':case 'SCss':case 'SCsd':						theNumberOfSamples = getNumOfEntries (((*gTheResults)[z]));											if (theNumberOfSamples == kNoSCIIData)						{							progressWindowDispose();							genError ("\pCant Resolve SampleCell I files, only SampleCell II files");							return;						}											progressWindowCreate("\pRe-Resolving Instrument");							writeLogS((unsigned char *)"Began Re-Resolve of File");							writeLog((Ptr)(*gTheResults)[z].name);					for (y = 0;y<theNumberOfSamples;y++)					{						if (theSampName = getSCIIfile2((*gTheResults)[z],y))						{							BlockMove (theSampName,tempSpec.name,64L);							tempSpec.vRefNum = mySpec.vRefNum;							tempSpec.parID = SamplesDirID;							burnSampToInst (mySpec,tempSpec,y);						}						else						{							SysBeep(5);						}												dispFar = ((y*100)/theNumberOfSamples);						if (progressWinDisp(dispFar))							return;					}					progressWindowDispose();				break;												default:				break;			}		}	}					}Boolean InstsFromGTheResults(StandardFileReply reply);Boolean InstsFromGTheResults(StandardFileReply reply){		/* archive samples of gtheresults to destination */		/* if same name AND type don't arch		/* if different types append type */}Boolean resolveBanksInPlace(FSSpec mySpec){		FInfo **	myInstanceTypeH;	FSSpec ** myInstanceH;	Ptr	myInstancePtr;	Ptr	myInstanceTypePtr;	resRecPtr	tempRRecPtr, nullRec;	struct resolveRec myTempRec;	short inst,samp,instTot,sampTot;	long	memSize, memtypeSize;	short 	arrayPointer = 0;	StandardFileReply	reply;	OSErr  iErr;	short	itemHit, refNum;	FInfo	fndrInfo;	long	fileLength;	long inOutCount;	FSSpec	myTempSpec;	short iRefNum, myRefNum;	short z;	Handle hString[28];	Handle volumeRef[28];	short dispFar;	short dispFarSeg;	FSSpec	myPSpec;	FSSpec	myInstSpec;	Str31	theDefName;	Str31	resText = "\p resolved";	Boolean burnData = true;	Boolean makeNewList = false;				tempRRecPtr = &myTempRec;	instTot = getNumOfEntries (mySpec);				/** how many instruments ? **/	if (!instTot)	{		genError ("\pThat file is empty");		return false;	}		if (instTot == kNoSCIIData)	{		genError ("\pCant Resolve SampleCell I files, only SampleCell II files");		return;	}		myInstanceH = (FSSpec **)NewHandle(70L);				/** make mem **/	memSize = 70L;	if (!myInstanceH)	{		genError ("\pNot enough memory to allocate Handle");		return;	}	myInstanceTypeH = (FInfo **)NewHandle(16L);				/** make mem **/	memtypeSize = 16L;	if (!myInstanceTypeH)	{		genError ("\pNot enough memory to allocate type Handle");		return;	}	arrayPointer++;	progressWindowCreate("\pRe-Resolving Bank");	writeLogS((unsigned char *)"Began Re-Resolve of File");	writeLog((Ptr)(mySpec.name));		   				for (inst = 0;inst < instTot;inst ++)	{		getSCIIfile(mySpec,inst,&myTempRec);		/** get a name from bank **/		if (!(myTempRec.found))		{			genError("\pCannot complete the instruction because an unexpected error occured");			progressWindowDispose();			return false;		}				iErr = VgetvolName(mySpec.vRefNum, myTempRec.driveName);		myTempRec.dirID = InstsDirID;		iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/		if (!iErr && (myTempSpec.vRefNum == 0))		{			// genError ("\pIt hasn't found it in the new folder");			SysBeep(5);			// iErr = ResolveSCIIFSSpec(tempRRecPtr->fileName,0,1,tempRRecPtr->type,&myTempSpec);		}		 if (myTempSpec.vRefNum == -999)	/** abort this inst **/		 {		 	writeLogS((unsigned char *)"*********** ERROR ************");		    writeLogS((unsigned char *)"Could not find the instrument file below, which has been ignored as has it's samples");		    writeLog((Ptr)(tempRRecPtr->fileName));		    writeLogS((unsigned char *)" ");		    errorOccurred = true;		 }		 else		{			memSize += 70L;							SetHandleSize((Handle)myInstanceH, memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}			memtypeSize += 16L;							SetHandleSize((Handle)myInstanceTypeH, memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}							iErr = FSpGetFInfo(&myTempSpec,&fndrInfo);			if (iErr!=0)			{				SysBeep(5);				//genError("\pProblem getting FInfo");				//progressWindowDispose();				//return false;			}			//BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/				/** burn instrument in to bank here **/						if (burnData)			{				burnInstToBank (mySpec,myTempSpec,inst);			}				/************************************/			arrayPointer ++;					sampTot = getNumOfEntries (myTempSpec);			/** find out how many samples it has **/							if (sampTot == kNoSCIIData)			{				progressWindowDispose();				genError ("\pCant Resolve SampleCell I files, only SampleCell II files");				return;			}				memSize += (70L*(sampTot+1));							SetHandleSize((Handle)myInstanceH,memSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize pointer");				progressWindowDispose();				return;			}							memtypeSize += (16L*(sampTot+1));							SetHandleSize((Handle)myInstanceTypeH,memtypeSize);			iErr = MemError();			if (iErr!=0)			{				genError ("\pNot enough memory to resize type pointer");				progressWindowDispose();				return;			}				if (instTot>1)			{				dispFar = ((inst+1) * 100)/(instTot);				dispFarSeg = 100/(instTot-1);			}			else			{				dispFar =0;				dispFarSeg =100;			}			if (progressWinDisp(dispFar))				return;			BlockMove (&myTempSpec,&myInstSpec,70L);			for (samp = 0;samp < sampTot;samp ++)			{				if(progressWinDisp(dispFar+((((samp+1) * 100)/(sampTot)*dispFarSeg)/100)))					return;				getSCIIfile(myInstSpec,samp, tempRRecPtr);		/** get a name from bank **/				if (!tempRRecPtr->found)				{					genError ("\pA problem occurred getting a sample name");					progressWindowDispose();					return false;				}				iErr = VgetvolName(mySpec.vRefNum, tempRRecPtr->driveName);				tempRRecPtr->dirID = SamplesDirID;				iErr = rRectoFSSpec(tempRRecPtr, &myTempSpec);	/** make it into an FSSpec **/				if (!iErr && (myTempSpec.vRefNum == -999))				{					genError("\pCouldn't find a file in the samples folder");					progressWindowDispose();					return false;				}				if (!iErr && (myTempSpec.vRefNum == 0))				{					SysBeep(5);					//genError("\pCouldn't find a file in the samples folder");					//iErr = ResolveSCIIFSSpec(myTempSpec.name,0,1,tempRRecPtr->type, &myTempSpec);				}				if (!iErr)				{					writeLogS((unsigned char *)"*********** ERROR ************");					 writeLogS((unsigned char *)"Could not find the sample file below, which has been ignored");		   			 writeLog((Ptr)(myTempSpec.name));		   			 writeLogS((unsigned char *)" ");		   			 errorOccurred = true;				}				else				{								BlockMove (&myTempSpec,((*myInstanceH)+(70L*arrayPointer)),70L);	/** put it into our array **/													iErr = FSpGetFInfo(&myTempSpec,&fndrInfo);						if (iErr!=0)						{							genError("\pProblem getting FInfo");							progressWindowDispose();							return false;						}					BlockMove (&fndrInfo,((*myInstanceTypeH)+(16L*arrayPointer)),16L);	/** put it into our array **/				/** burn sample in to instrument here **/					if (burnData)					{						burnSampToInst (myInstSpec,myTempSpec,samp);					}		/***************************************/					arrayPointer ++;				}			}		}	}	progressWindowDispose();	}FSSpec archiveBanksFromGTheResults(StandardFileReply reply){		/* archive samples of gtheresults to destination */		/* if same name AND type don't arch		/* if different types append type */}Boolean resolveDawnToMem(FSSpec theSpec,short index){}FSSpec archiveDataFromGTheResults(StandardFileReply reply, Boolean isDawn, Boolean isBank){	short z = 0;	FInfo	fndrInfo, destType;	OSErr	iErr, theErr;	FSSpec spec;	Str255 typeStr;	short theSource, theDestination;	Boolean copyIt;	long inOutCount;	Ptr	copyBuff;	Boolean problemOccurred = false;	FSSpec theReturnObject;	short dispFar;	FInfo fundrInfo;		copyBuff = NewPtr(65535L);		progressWindowCreate("\pCopying Files");	writeLogS((unsigned char *)"Began Re-Resolve of File");	writeLog((Ptr)(reply.sfFile.name));	for (z=0;z<theGResultsCtr;z++)	{			dispFar = ((z*100)/theGResultsCtr);		if (progressWinDisp(dispFar))			return;		copyIt = false;				iErr = FSpGetFInfo(&((*gTheResults)[z]),&fndrInfo);		if (!iErr)		{			copyIt = false;			switch (fndrInfo.fdType)			{				case'AIFF':case 'Sd2f':case 'SFIL':					iErr = FSMakeFSSpec(reply.sfFile.vRefNum,SamplesDirID,(*gTheResults)[z].name,&spec);					if (!iErr)					{						/* it exists */						iErr = FSpGetFInfo(&spec,&destType);						if (destType.fdType == fndrInfo.fdType)						{							copyIt = false;						}						else						{							BlockMove (&fndrInfo.fdType, typeStr + 1,4L);							*typeStr = 4;							concatStrings((*gTheResults)[z].name,typeStr,"\p-");							iErr = FSMakeFSSpec(reply.sfFile.vRefNum,SamplesDirID,(*gTheResults)[z].name,&spec);							if (!iErr)							{								copyIt = false;							}							else							{								copyIt = true;							}						}					}					else					{						copyIt = true;					}				break;								case'MixD':					iErr = FSMakeFSSpec(reply.sfFile.vRefNum,BanksDirID,(*gTheResults)[z].name,&spec);					if (!iErr)					{						/* it exists */						iErr = FSpGetFInfo(&spec,&destType);						if (destType.fdType == fndrInfo.fdType)						{							copyIt = false;						}						else						{							BlockMove (&fndrInfo.fdType, typeStr + 1,4L);							*typeStr = 4;							concatStrings((*gTheResults)[z].name,typeStr,"\p-");							iErr = FSMakeFSSpec(reply.sfFile.vRefNum,BanksDirID,(*gTheResults)[z].name,&spec);														FSpGetFInfo(&spec,&fundrInfo);							if (theOrigami == fundrInfo.fdType)							{								BlockMove (&spec,&theReturnObject,70L);							}							if (!iErr)							{								copyIt = false;							}							else							{								copyIt = true;							}						}					}					else					{						copyIt = true;						FSpGetFInfo(&spec,&fundrInfo);						if (theOrigami == fundrInfo.fdType)						{							BlockMove (&spec,&theReturnObject,70L);						}					}				break;								case'SCin':case 'SCsi':case 'SCss':case 'SCsd':					iErr = FSMakeFSSpec(reply.sfFile.vRefNum,InstsDirID,(*gTheResults)[z].name,&spec);					if (!iErr)					{						/* it exists */						iErr = FSpGetFInfo(&spec,&destType);						if (destType.fdType == fndrInfo.fdType)						{							copyIt = false;						}						else						{							BlockMove (&fndrInfo.fdType, typeStr + 1,4L);							*typeStr = 4;							concatStrings((*gTheResults)[z].name,typeStr,"\p-");							iErr = FSMakeFSSpec(reply.sfFile.vRefNum,InstsDirID,(*gTheResults)[z].name,&spec);														FSpGetFInfo(&spec,&fundrInfo);							if (theOrigami == fundrInfo.fdType)							{								BlockMove (&spec,&theReturnObject,70L);							}							if (!iErr)							{								copyIt = false;							}							else							{								copyIt = true;							}						}					}					else					{						FSpGetFInfo(&spec,&fundrInfo);						if (theOrigami == fundrInfo.fdType)						{							BlockMove (&spec,&theReturnObject,70L);						}						copyIt = true;					}				break;								default:				break;					}						if (copyIt == true)			{				if ((spec.vRefNum != ((*gTheResults)[z]).vRefNum) || !ARcMoveOnSame)				{					iErr = FSpCreate(&spec,fndrInfo.fdCreator,fndrInfo.fdType,0);					if (iErr == -48) 	/** file exists **/					{						SysBeep(5);						/* maybe put in a replace option here */						DisposPtr(copyBuff);						progressWindowDispose();						return theReturnObject;					}					iErr = FSpOpenDF(&((*gTheResults)[z]),fsCurPerm,&theSource);					if (!iErr)					{						iErr = FSpOpenDF(&spec,fsCurPerm,&theDestination);						if (iErr!=0)						{							genError("\pCan't open DF of new file");							writeLogS((unsigned char *)"*********** ERROR ************");							writeLogS((unsigned char *)"a problem occurred opening the data fork of the new file: ");							writeLog((Ptr)((*gTheResults)[z].name));							writeLogS((unsigned char *)"abandoning archive function");							writeLogS((unsigned char *)" ");							errorOccurred = true;							progressWindowDispose();							DisposPtr(copyBuff);							aProb = true;							return theReturnObject;						}						theErr = 0;   /* copy here  */						while(theErr!= eofErr)						{							inOutCount = 65000L;							theErr = FSRead(theSource,&inOutCount,copyBuff);							iErr = FSWrite(theDestination,&inOutCount,copyBuff);							if (iErr!=0)							{								genError("\pCan't write to DF of new file");								writeLogS((unsigned char *)"*********** ERROR ************");								writeLogS((unsigned char *)"a problem occurred writing to the data fork of the new file: ");								writeLog((Ptr)((*gTheResults)[z].name));								writeLogS((unsigned char *)"abandoning archive function");								writeLogS((unsigned char *)" ");								errorOccurred = true;								progressWindowDispose();								DisposPtr(copyBuff);								aProb = true;								return theReturnObject;							}						}						FSClose(theSource);						FSClose(theDestination);					}					FSpCreateResFile(&spec,fndrInfo.fdCreator,fndrInfo.fdType,0);					iErr = ResError();					if (iErr!=0)					{						genError("\pCan't create RF of new file");						writeLogS((unsigned char *)"*********** ERROR ************");						writeLogS((unsigned char *)"a problem occurred creating the Res fork of the new file: ");						writeLog((Ptr)((*gTheResults)[z].name));						writeLogS((unsigned char *)"abandoning archive function");						writeLogS((unsigned char *)" ");						errorOccurred = true;						progressWindowDispose();						DisposPtr(copyBuff);						aProb = true;						return theReturnObject;					}					iErr = FSpOpenRF(&((*gTheResults)[z]),fsCurPerm,&theSource);					if (iErr!=0 && iErr != -43)					{						genError("\pCan't open RF of source file");						writeLogS((unsigned char *)"*********** ERROR ************");						writeLogS((unsigned char *)"a problem occurred opening the Res fork of the source file: ");						writeLog((Ptr)((*gTheResults)[z].name));						writeLogS((unsigned char *)"abandoning archive function");						writeLogS((unsigned char *)" ");						errorOccurred = true;						progressWindowDispose();						DisposPtr(copyBuff);						aProb = true;						return theReturnObject;					}					if (!iErr)					{						iErr = FSpOpenRF(&spec,fsCurPerm,&theDestination);						if (iErr!=0)						{							genError("\pCan't open RF of new file");							writeLogS((unsigned char *)"*********** ERROR ************");							writeLogS((unsigned char *)"a problem occurred opening the Res fork of the new file: ");							writeLog((Ptr)((*gTheResults)[z].name));							writeLogS((unsigned char *)"abandoning archive function");							writeLogS((unsigned char *)" ");							errorOccurred = true;							progressWindowDispose();							DisposPtr(copyBuff);							aProb = true;							return theReturnObject;						}						theErr = 0;						while(theErr!= eofErr)						{							inOutCount = 65000L;  /*  and here  */							theErr = FSRead(theSource,&inOutCount,copyBuff);							iErr = FSWrite(theDestination,&inOutCount,copyBuff);							if (iErr!=0)							{								genError("\pCan't write to RF of new file");								writeLogS((unsigned char *)"*********** ERROR ************");								writeLogS((unsigned char *)"a problem occurred writing data to the new file: ");								writeLog((Ptr)((*gTheResults)[z].name));								writeLogS((unsigned char *)"abandoning archive function");								writeLogS((unsigned char *)" ");								errorOccurred = true;								progressWindowDispose();								DisposPtr(copyBuff);								aProb = true;								return theReturnObject;							}						}						FSClose(theSource);						FSClose(theDestination);					}					if (ARcDeleteOriginal && !aProb)					{							iErr = FSpDelete(&((*gTheResults)[z]));					}										iErr = FSpSetFInfo(&spec,&fndrInfo);									}				else				{					iErr = CatMove((*gTheResults)[z].vRefNum,(*gTheResults)[z].parID,(*gTheResults)[z].name,spec.parID,0);					if (iErr != 0)					{						genError ("\pA problem occured during CatMove");						aProb = true;					}					if (ARcDeleteOriginal && !aProb)					{							iErr = FSpDelete(&((*gTheResults)[z]));					}					BlockMove (&spec,&((*gTheResults)[z]),70L);					FSpGetFInfo(&spec,&fundrInfo);					if (theOrigami == fundrInfo.fdType)					{						BlockMove (&spec,&theReturnObject,70L);					}									}											writeLogS((unsigned char *)"Sucessfully archived");				writeLog((Ptr)((*gTheResults)[z].name));				problemOccurred = false;			}			}	}	DisposPtr(copyBuff);	progressWindowDispose();	return theReturnObject;}Boolean resolveDawnEDLInPlace(StandardFileReply reply){}Boolean archiveDawnEDLFromGTheResults(StandardFileReply reply){}Boolean archiveInstsFromGTheResults(StandardFileReply reply){}Boolean ResolveSCIIFSSpecLocal(Str31	myFileName, long	catHint, short driveHint, OSType	theType, FSSpecPtr mySpecPtr){	HParamBlockRec RPb; 				/** parameter block for PBCatSearch **/	short z;	FSSpec	theResolveSpec[2];	OSErr	gErr;		char *occur;	Str255 Cstring,substring;		(*mySpecPtr).vRefNum = -999;		gogetvolref();		/**********************/	/**********************/				z = driveHint;		    BlockMove (volName[z],Cstring,28L);		    PtoCstr (Cstring);		    makeStr255("\pAudio CD",substring);		    PtoCstr (substring);		    occur = strstr((const char *)Cstring,(const char *)substring);		    if (occur)		    {				return false;			}			RPb.csParam.ioVRefNum = volumes[z];		/** select relevant volume **/						RPb.csParam.ioCompletion = nil;  				/** no completion routine **/			RPb.csParam.ioNamePtr = nil;   			 		/** no volume name;  use vRefNum **/			RPb.csParam.ioMatchPtr = &theResolveSpec[0];  			/** points to results buffer **/			RPb.csParam.ioReqMatchCount = 1;   	/** number of matches **/												/** search for name + file or directory + file TYPE  **/			RPb.csParam.ioSearchBits = fsSBFullName + fsSBFlAttrib + fsSBFlFndrInfo;												RPb.csParam.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/			RPb.csParam.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/			RPb.csParam.ioSearchTime = 0;              	/** don't time out on searches **/			RPb.csParam.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/			RPb.csParam.ioOptBuffer = gBuffer;    			/** point to search cache  **/			RPb.csParam.ioOptBufSize  = kOptBufferSize;		/** size of search cache **/					gSpec1.hFileInfo.ioNamePtr = myFileName;   		/** point to string to find **/			gSpec1.hFileInfo.ioFlAttrib = 0x00;      		/** clear bit 4 to ask for files **/			gSpec1.hFileInfo.ioFlFndrInfo.fdType = theType ; //searchType;	/** just find ???? files **/			gSpec1.hFileInfo.ioFlFndrInfo.fdCreator = 0;						gSpec2.hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/			gSpec2.hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/			gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  			gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0;									if (theNewPrefs.dontFindAliases)			{				gSpec1.hFileInfo.ioFlFndrInfo.fdFlags = 0;				gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;					}			else			{				gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;				}									watchcursor(TRUE);					/** display watch **/			do 			{				gErr = myPBCatSearchSyncCompat((CSParam *)&RPb);	/** get some files returns error 0 (noErr) if it returns without finishing **/			} while ( RPb.csParam.ioActMatchCount == 0 && gErr == 0);	 		watchcursor(FALSE);	if ( RPb.csParam.ioActMatchCount == 0)	{		SysBeep(5);		return false;	}	else	{			if ( RPb.csParam.ioActMatchCount > 0)		{			BlockMove(&(theResolveSpec[0]),mySpecPtr,70L); 			BlockMove(&(theResolveSpec[0]),&theLastThingFound,70L);			return true;		}	}	return true;}StringPtr getSCIIfile2(FSSpec	mySpec,short	index){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern theFNameListLen;	short z;	long filpPOS;	Str255 driveName, theFileName;	long myDirID;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if(iErr!=0)	{		return 0;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{		FSClose(refNum);		return 0;	}		iErr = SetFPos(refNum,1,(filpPOS+16L) + ((long)index * 68L));	if(iErr!=0)	{		FSClose(refNum);		return 0;	}	inOutCount = 28;	iErr = FSRead(refNum,&inOutCount,driveName);		if(iErr!=0)		{			FSClose(refNum);			return 0;		}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&myDirID);		if(iErr!=0)		{			FSClose(refNum);			return 0;		}	inOutCount = 32;	iErr = FSRead(refNum,&inOutCount,theFileName);		if(iErr!=0)		{			FSClose(refNum);			return 0;		}	inOutCount = 4;	iErr = FSRead(refNum,&inOutCount,&theEnqRetType);		if(iErr!=0)		{			FSClose(refNum);			return 0;		}		FSClose(refNum);	return theFileName;}