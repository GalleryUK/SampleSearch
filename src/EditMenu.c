#include "SampleSearch.h"#include "Globals.h"#include "undoStuff.h"void saveForUndo (void);void loadUndoFile(void);short cutSoFar;extern FSSpec theApplSpec;void cleanUpFVolumeGaps(void);OSErr copyVolsListToFVolsList(void);OSErr translateVRefNum(short * theVRef);void mergeFile(FSSpec theMergeSource);void mergeFile(FSSpec theTempFileSpec){	short 	myRefNum;	long	myInOutCounter;	Size	TempmyInOutCounter;	short preservedtotfindcounter;	short z;	short iCnt;	Handle hRsrc;	short iRefNum;	short preservefvolumearrayptr;	OSErr	iErr;	long totfindlen;	//FSSpec theTempFileSpec;	preservefvolumearrayptr = fvolumearrayptr;	preservedtotfindcounter = totfindcounter;	/*******/		//	iErr = FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFClipboard",&theTempFileSpec);		copyVolsListToFVolsList();			gogetoldrefs(theTempFileSpec,0);		iErr = FSpOpenDF(&theTempFileSpec,fsCurPerm,&myRefNum);		if (!iErr)		{			totfindlen = 4L;			iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);		/** read # of FSSpec entries **/			iErr = SetFPos(myRefNum,1,myInOutCounter+4L);				/** set to FInfo entries pointer	**/			iErr = FSRead(myRefNum,&totfindlen,&TempmyInOutCounter);		/** read no of Finfo's 	**/			//SetHandleSize(theFInfo,(totfindcounter *16L) + TempmyInOutCounter*16L);			iErr = MemError();			if (iErr != 0)			{				genError("\pNot enough memory to expand list");				iErr = FSClose(myRefNum);				return;			}						iErr = SetFPos(myRefNum,1,4L);								/** set file to start of FSSpecs **/			if (totfindcounter + (myInOutCounter/70L) >= kMaxMatches)			{				TempmyInOutCounter = (kMaxMatches - totfindcounter) * 70L;				genError("\pCan not append entire new list");				iErr = FSRead(myRefNum,&TempmyInOutCounter,(*therealResults)+totfindcounter);				if (iErr!=0)					genError("\pCould not read new data");				totfindcounter += (TempmyInOutCounter/70L);			}			else			{				iErr = FSRead(myRefNum,&myInOutCounter,(*therealResults)+totfindcounter);				if (iErr!=0)					genError("\pCould not read new data");				totfindcounter += (myInOutCounter/70L);			}			/** expand (*therealResults) to fit new file add **/						iErr = SetFPos(myRefNum,1,myInOutCounter+8L);			totfindlen = (totfindcounter-preservedtotfindcounter) *16L;			/** set it to read the same no as FSSpecs **/			iErr = FSRead(myRefNum,&totfindlen,(*theFInfo)+preservedtotfindcounter);		/** read no of Finfo's 	**/			if (iErr!=0)					genError("\pCould not use read new data");			FInfoArrayPtr = totfindcounter; 			iErr = FSClose(myRefNum);									for (z=preservedtotfindcounter;z<totfindcounter;z++)			{				translateVRefNum(&(*therealResults)[z].vRefNum);			}			resolveOVols(); 			cleanUpFVolumeGaps(); 						reFound = true;					}	}void copySelectedToFile(void);void copySelectedToFile(void){	short z;	Boolean	theCellCheck;	Cell theCell;	short	theindex,theCount=0;	OSErr	iErr;	FInfo ** theSpareInfo;	FSSpec	theTempFileSpec;	short refNum;	long inOutCount;	long	headerData;	short iRefNum,myRefNum;	Handle hString[32],vRefRes[32];	short iFlags;	Size lBytesFree;		theSpareInfo = (FInfo **)NewHandle(totfindcounter * 16L);	if (!theSpareInfo)	{		genError ("\pNot Enough Memory available for that operation");		return;	}			SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		BlockMove (&((*therealResults)[theindex]),&((*gTheResults)[theCount]),70L);		BlockMove (&((*theFInfo)[theindex]),&((*theSpareInfo)[theCount]),70L);		theCount ++;		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (theCount == 0)	{		DisposHandle ((Handle)theSpareInfo);		return;	}				iErr = FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFClipboard",&theTempFileSpec);	if (iErr != -43)	{		iErr = FSpDelete(&theTempFileSpec);		if (iErr !=0)			genError ("\pCan't delete old clipboard");	}				iErr = FSpCreate(&theTempFileSpec,'MgAl','SFcb',0);	if (iErr!=0)	{		genError ("\pCan't Create Clipboard");		DisposHandle ((Handle)theSpareInfo);		return;	}		iErr = FSpOpenDF(&theTempFileSpec,fsCurPerm,&refNum);	if (iErr!=0)	{		genError ("\pCan't Open Clipboard file");		DisposHandle ((Handle)theSpareInfo);		return;	}	inOutCount = 4;	headerData = (long)(theCount * 70L); 	iErr = FSWrite(refNum,&inOutCount,&headerData);	if (iErr!=0)	{		genError ("\pCan't write to Clipboard file");		DisposHandle ((Handle)theSpareInfo);		return;	}	inOutCount = theCount * 70L;	iErr = FSWrite(refNum,&inOutCount,(*gTheResults));	if (iErr!=0)	{		genError ("\pCan't write data 1 to Clipboard file");		DisposHandle ((Handle)theSpareInfo);		return;	}	inOutCount = 4;	headerData = (long)(theCount); 	iErr = FSWrite(refNum,&inOutCount,&headerData);	if (iErr!=0)	{		genError ("\pCan't write header 2 to Clipboard file");		DisposHandle ((Handle)theSpareInfo);		return;	}	inOutCount = theCount * 16L;	iErr = FSWrite(refNum,&inOutCount,(*theSpareInfo));	if (iErr!=0)	{		genError ("\pCan't write data 2 to Clipboard file");		DisposHandle ((Handle)theSpareInfo);		return;	}	iErr = FSClose (refNum);	/**************/		gogetvolref();		iRefNum = CurResFile();			FSpCreateResFile(&theTempFileSpec,'MgAl','SFcb',0);		iErr = ResError();		if (iErr!=0)			genError("\pCould not create resource file");		myRefNum = FSpOpenResFile(&theTempFileSpec,fsCurPerm);		if (myRefNum == -1)			genError("\pCould not open new resource fork");			UseResFile(myRefNum);		iErr = ResError();		if (iErr!=0)			genError("\pCould not use new resource fork");							for (z=1;z<=volumearrayptr;z++)		{				lBytesFree = CompactMem(64);			if (lBytesFree < 64)			{					genError ("\pHeap too full for that operation");				CloseResFile(myRefNum);				UseResFile(iRefNum);				iErr = ResError();				if (iErr!=0)					genError("\pCould not use old resource file");					/***************/				DisposHandle ((Handle)theSpareInfo);				SysBeep(5);				SysBeep(5);				return;			}			hString[z] = NewHandle(63);			iErr = MemError();			if (!hString[z])				genError("\pCan't create handle");			BlockMove(volName[z],*(hString[z]),28L);			AddResource(hString[z],'oVOL',z,"\pVolume Name for list");			iFlags = GetResAttrs(hString[z]);			iErr = ResError();			if (iErr!=0)			{								CloseResFile(myRefNum);				for (z=1;z<=fvolumearrayptr;z++)				{					ReleaseResource(hString[z]);					iErr = ResError();					if (iErr !=0)						genError ("\pCan't Release Resource");					/*DisposHandle(hString[z]);					iErr = MemError();					if (iErr !=0)						genError ("\pCan't Release handle");*/				}				UseResFile(iRefNum);				iErr = ResError();				if (iErr!=0)					genError("\pCould not use old resource file");					/***************/				DisposHandle ((Handle)theSpareInfo);								return;			}			vRefRes[z] = NewHandle(2);			**vRefRes[z] = volumes[z];			AddResource(vRefRes[z],'oREF',z,"\pvRefNum for list");			iErr = ResError();			if (iErr!=0)			{								CloseResFile(myRefNum);				for (z=1;z<=fvolumearrayptr;z++)				{					ReleaseResource(hString[z]);					ReleaseResource(vRefRes[z]);				}				UseResFile(iRefNum);				iErr = ResError();				if (iErr!=0)					genError("\pCould not use old resource file");					/***************/				DisposHandle ((Handle)theSpareInfo);								return;			}		}				for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)		{				lBytesFree = CompactMem(64);			if (lBytesFree < 64)			{					genError ("\pHeap too full for that operation");				CloseResFile(myRefNum);				UseResFile(iRefNum);				iErr = ResError();				if (iErr!=0)					genError("\pCould not use old resource file");					/***************/				DisposHandle ((Handle)theSpareInfo);								return;			}			hString[z] = NewHandle(63);			iErr = MemError();			if (!hString[z])				genError("\pCan't create handle");			BlockMove(fvolName[z],*(hString[z]),28L);			AddResource(hString[z],'oVOL',z,"\pVolume Name for list");			iErr = ResError();			if (iErr!=0)			{								CloseResFile(myRefNum);				for (z=1;z<=fvolumearrayptr;z++)				{					ReleaseResource(hString[z]);					iErr = ResError();					if (iErr !=0)						genError ("\pCan't Release Resource");					/*DisposHandle(hString[z]);					iErr = MemError();					if (iErr !=0)						genError ("\pCan't Release handle");*/				}				UseResFile(iRefNum);				iErr = ResError();				if (iErr!=0)					genError("\pCould not use old resource file");					/***************/				DisposHandle ((Handle)theSpareInfo);								return;			}			vRefRes[z] = NewHandle(2);			**vRefRes[z] = volumes[z];			AddResource(vRefRes[z],'oREF',z,"\pvRefNum for list");			iErr = ResError();			if (iErr!=0)			{								CloseResFile(myRefNum);				for (z=1;z<=fvolumearrayptr;z++)				{					ReleaseResource(hString[z]);					ReleaseResource(vRefRes[z]);				//	DisposHandle(hString[z]);				}				UseResFile(iRefNum);				iErr = ResError();				if (iErr!=0)					genError("\pCould not use old resource file");					/***************/				DisposHandle ((Handle)theSpareInfo);								return;			}		}				CloseResFile(myRefNum);		for (z=1;z<=fvolumearrayptr;z++)		{			ReleaseResource(hString[z]);			iErr = ResError();			if (iErr !=0)				genError ("\pCan't Release Resource");			/*DisposHandle(hString[z]);			iErr = MemError();			if (iErr !=0)				genError ("\pCan't Release handle");*/		}		UseResFile(iRefNum);		iErr = ResError();		if (iErr!=0)			genError("\pCould not use old resource file");		/***************/	DisposHandle ((Handle)theSpareInfo);	return;}void removeItemFromList(short index);void cutSelection(void);void cutSelection(void){	Cell theCell;	short theindex;		cutSoFar = 0;	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			break;		}		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		removeItemFromList(theindex);		cutSoFar ++;		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	return;}void pasteSelection(void);void pasteSelection(void){	short 	myRefNum;	long	myInOutCounter;	Size	TempmyInOutCounter;	short preservedtotfindcounter;	short z;	short iCnt;	Handle hRsrc;	short iRefNum;	short preservefvolumearrayptr;	OSErr	iErr;	long totfindlen;	FSSpec theTempFileSpec;	preservefvolumearrayptr = fvolumearrayptr;	preservedtotfindcounter = totfindcounter;	/*******/			iErr = FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFClipboard",&theTempFileSpec);		copyVolsListToFVolsList();			gogetoldrefs(theTempFileSpec,0);		iErr = FSpOpenDF(&theTempFileSpec,fsCurPerm,&myRefNum);		if (!iErr)		{			totfindlen = 4L;			iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);		/** read # of FSSpec entries **/			iErr = SetFPos(myRefNum,1,myInOutCounter+4L);				/** set to FInfo entries pointer	**/			iErr = FSRead(myRefNum,&totfindlen,&TempmyInOutCounter);		/** read no of Finfo's 	**/			//SetHandleSize(theFInfo,(totfindcounter *16L) + TempmyInOutCounter*16L);			iErr = MemError();			if (iErr != 0)			{				genError("\pNot enough memory to expand list");				iErr = FSClose(myRefNum);				return;			}						iErr = SetFPos(myRefNum,1,4L);								/** set file to start of FSSpecs **/			if (totfindcounter + (myInOutCounter/70L) >= kMaxMatches)			{				TempmyInOutCounter = (kMaxMatches - totfindcounter) * 70L;				genError("\pCan not append entire new list");				iErr = FSRead(myRefNum,&TempmyInOutCounter,(*therealResults)+totfindcounter);				if (iErr!=0)					genError("\pCould not read new data");				totfindcounter += (TempmyInOutCounter/70L);			}			else			{				iErr = FSRead(myRefNum,&myInOutCounter,(*therealResults)+totfindcounter);				if (iErr!=0)					genError("\pCould not read new data");				totfindcounter += (myInOutCounter/70L);			}			/** expand (*therealResults) to fit new file add **/						iErr = SetFPos(myRefNum,1,myInOutCounter+8L);			totfindlen = (totfindcounter-preservedtotfindcounter) *16L;			/** set it to read the same no as FSSpecs **/			iErr = FSRead(myRefNum,&totfindlen,(*theFInfo)+preservedtotfindcounter);		/** read no of Finfo's 	**/			if (iErr!=0)					genError("\pCould not use read new data");			FInfoArrayPtr = totfindcounter; 			iErr = FSClose(myRefNum);									for (z=preservedtotfindcounter;z<totfindcounter;z++)			{				translateVRefNum(&(*therealResults)[z].vRefNum);			}			resolveOVols(); 			cleanUpFVolumeGaps(); 						reFound = true;					}	}void selectAllItems(void);void selectAllItems(void){ short z,xpos,ypos; Cell theCell;  for (z=0;z<totfindcounter;z++) { 	ypos = z / (((DisplayedColumns==4)*4)+(DisplayedColumns == 1)); 	if (DisplayedColumns== 4) 		xpos = z - (ypos * 4); 	else 		xpos = 0; 	SetPt(&theCell,xpos,ypos); 	LSetSelect(true,theCell,myList); } return;}