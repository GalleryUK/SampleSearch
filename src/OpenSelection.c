#include "SampleSearch.h"#include "Globals.h"#define kAEFinderEvents	'FNDR'#define kAEOpenSelection	'sope'#define keySelection	'fsel'#include "undoStuff.h"extern Boolean isSample;void saveForUndo (void);OSType  myeventFileType = 'FNDR';    //	'APPL'OSType  myeventCreatorType = 'MACS';   //'WILD'unsigned long myEventID	= kAEOpenSelection;	//kAEOpenDocumentsunsigned long myEventClass = kAEFinderEvents ;  //kCoreEventClass						extern Boolean DialogPresent;extern Boolean divertIt;void LaunchAnApplication (FSSpec mySpec); Boolean screwedUp;extern Boolean optionKeyHeld;OSErr sendMultipleEvent(void);extern FSSpec theSpecs[60];extern short theNumberOfSpecs;OSErr xOpenSelection(FSSpec theDoc);extern Boolean divertIt;OSErr LaunchAnApplicationII (FSSpec	mySpec);OSErr OpenSelection(FSSpec theDoc) {	FInfo fndrInfo;	OSType Fiyltype[3];	OSErr myErr;//	Boolean isSample;	short z;			FSpGetFInfo(&theDoc,&fndrInfo);		numTypesToSearch = 3;			Fiyltype[0] = 'AIFF';			Fiyltype[1] = 'SFIL';			Fiyltype[2] = 'Sd2f';			Fiyltype[3] = 'REX ';				/******** here *********/		isSample = false;		for (z =0 ;z<=numTypesToSearch;z++)		{			if (fndrInfo.fdType == Fiyltype[z])			{				isSample = true;			}		}					if ((divertSamples && isSample) || optionKeyHeld || divertIt)	{		theSpecs[0] = theDoc;		theNumberOfSpecs = 1;		sendMultipleEvent();	}	else		xOpenSelection(theDoc);}OSErr xOpenSelection(FSSpec theDoc){	AppleEvent	aeEvent;	/* the event to create*/	AEDesc	myAddressDesc;	/* descriptors for the */	AEDesc	aeDirDesc;	AEDesc	listElem;	AEDesc	fileList;		/*our list*/	FSSpec	dirSpec;	AliasHandle	dirAlias;		/* alias to directory with our file*/	AliasHandle	fileAlias;		/* alias of the file itself*/	AliasHandle	theAliasH;	ProcessSerialNumber process;	/* the finder's psn*/	OSErr		myErr;				/* duh*/	FSSpec	mySpec;	FInfo	fndrInfo;	Boolean	CreatorChanged;	OSType	preserveCreator;	//Boolean	isSample;	short z;	CInfoPBRec	pb;	StandardFileReply	reply;	short temprefNum;	OSErr	iErr;	short switchCount;	char	myChar;	long	theParID;	EventRecord	theEvent;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/			iErr = FSpGetFInfo(&theDoc,&fndrInfo);	if (iErr != 0)	{		genError ("\pA file could not be opened because it does not exist");		return iErr;	}		CreatorChanged = false;		isSample = false;	BlockMove(&theDoc,&mySpec,70L);	if (divertSamples)	{			numTypesToSearch = 2;			Fiyltype[0] = 'AIFF';			Fiyltype[1] = 'SFIL';			Fiyltype[2] = 'Sd2f';				myErr = FSpGetFInfo(&theDoc,&fndrInfo);		if (myErr!=0)			genError("\pCould not get file info");		/******** here *********/		isSample = false;		for (z =0 ;z<=numTypesToSearch;z++)		{			if (fndrInfo.fdType == Fiyltype[z])			{				isSample = true;			}		}			if (isSample || divertIt)		{			myeventFileType = 'APPL';			myeventCreatorType = divertDocCreator;			myEventID = kAEOpenDocuments;			myEventClass = kCoreEventClass;		}		else		{			myeventFileType = 'FNDR';			myeventCreatorType = 'MACS';			myEventID = kAEOpenSelection;			myEventClass = kAEFinderEvents;		}	}	else	{		if (divertIt)		{			myeventFileType = 'APPL';			myeventCreatorType = divertDocCreator;			myEventID = kAEOpenDocuments;			myEventClass = kCoreEventClass;		}		else		{			myeventFileType = 'FNDR';			myeventCreatorType = 'MACS';			myEventID = kAEOpenSelection;			myEventClass = kAEFinderEvents;		}	}		if(FindAProcess(myeventFileType,myeventCreatorType,&process))	{			genError ("\pProcess not found");			return;	}	myErr = AECreateDesc(typeProcessSerialNumber,(Ptr) &process,sizeof(process), &myAddressDesc);	if(myErr)		{		genError("\pAppleEvent error");		return;	}	myErr = AECreateAppleEvent (myEventClass, myEventID,&myAddressDesc, kAutoGenerateReturnID, kAnyTransactionID,&aeEvent);	if(myErr)	{		genError("\pAppleEvent error");		return;	}	myErr = FSMakeFSSpec(theDoc.vRefNum,theDoc.parID,nil,&dirSpec);	NewAlias(nil,&dirSpec,&dirAlias);	NewAlias(nil,&theDoc,&fileAlias);		if (isSample && divertSamples)	{		theAliasH = fileAlias;	}	else	{		if (divertIt)			theAliasH = fileAlias;		else			theAliasH = dirAlias;	}	if(myErr=AECreateList(nil,0,false,&fileList))	{		genError("\pAppleEvent error");		return;	}	/* Create the folder descriptor	*/	HLock((Handle)theAliasH);	AECreateDesc(typeAlias, (Ptr) *theAliasH, GetHandleSize((Handle) theAliasH), &aeDirDesc);	HUnlock((Handle)theAliasH);	DisposHandle((Handle)dirAlias);	if((myErr = AEPutParamDesc(&aeEvent,keyDirectObject,&aeDirDesc)) ==			noErr)	{			AEDisposeDesc(&aeDirDesc);			HLock((Handle)fileAlias);			AECreateDesc(typeAlias, (Ptr)*fileAlias,					GetHandleSize((Handle)fileAlias), &listElem);			HUnlock((Handle)fileAlias);			DisposHandle((Handle)fileAlias);			myErr = AEPutDesc(&fileList,0,&listElem);	}	if(myErr)	{		genError("\pAppleEvent error");		return;	}	AEDisposeDesc(&listElem);	if(myErr = AEPutParamDesc(&aeEvent,keySelection,&fileList))			return myErr;	myErr = AEDisposeDesc(&fileList);	myErr = AESend(&aeEvent, nil,kAENoReply+kAEAlwaysInteract+kAECanSwitchLayer,kAEHighPriority, kAEDefaultTimeout, nil, nil);	AEDisposeDesc(&aeEvent);	}/* Search through the current process list to find the given application. See Using the Process Manager for a similar way of doing this.*/ OSErr PFindAProcess(OSType typeToFind, OSType creatorToFind,ProcessSerialNumberPtr processSN);OSErr PFindAProcess(OSType typeToFind, OSType creatorToFind,ProcessSerialNumberPtr processSN){	ProcessInfoRec	tempInfo;	FSSpec	procSpec;	Str31		processName;	OSErr		myErr = noErr;	OSErr	iErr;	StandardFileReply	reply;	EventRecord	theEvent;	FInfo fndrInfo;	// start at the beginning of the process list	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = kNoProcess;	// initialize the process information record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;			while(tempInfo.processSignature != creatorToFind || tempInfo.processType != typeToFind)	{		myErr = GetNextProcess(processSN);		if (myErr == noErr)		{				iErr = GetProcessInformation(processSN, &tempInfo);				if (iErr!=0)				{					genError("\pProcess manager error 1");					return(iErr);				}		}		else		{			return 99;		}		}	return(myErr);}OSErr FindAProcess(OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN){	ProcessInfoRec	tempInfo;	FSSpec	procSpec;	Str31		processName;	OSErr		myErr = noErr;	OSErr	iErr;	StandardFileReply	reply;	EventRecord	theEvent;	FInfo fndrInfo;	// start at the beginning of the process list	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = kNoProcess;	// initialize the process information record	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = (StringPtr)&processName;	tempInfo.processAppSpec = &procSpec;	screwedUp = false;		iErr = FSpGetFInfo(&divertSpec,&fndrInfo);	if ((iErr != 0 && divertIt) || (creatorToFind == 'MgAl'))	{		genError("\pthe The Switch launch application has not been correctly specified");		return iErr;		}	if (divertIt)	{		if ((fndrInfo.fdType != typeToFind & fndrInfo.fdType != 'FNDR') || (fndrInfo.fdCreator != creatorToFind && fndrInfo.fdCreator != 'MACS'))		{			genError("\pthe The Switch launch application has not been correctly specified");			return iErr;			}	}		myErr = noErr;			while(((tempInfo.processSignature != creatorToFind || tempInfo.processType != typeToFind) && (myErr == noErr)))	{			myErr = GetNextProcess(processSN);			if (myErr == noErr)			{					iErr = GetProcessInformation(processSN, &tempInfo);					if (iErr!=0)					{						genError("\pProcess manager error 1");						return(iErr);					}			}			else 			{				if (DialogPresent)				{					return 1;				}				/*OpenSelection (divertSpec);					genError("\pthe The Switch launch application needs to be running for a switch launch. Please find it");				StandardGetFile(0,-1,0,&reply);				if (!reply.sfGood)					return(iErr);*/				if (LaunchAnApplicationII (divertSpec))				{					myErr = -1;					break;				}				if (screwedUp)					break;				/*EventAvail(everyEvent,&theEvent);*/				processSN->lowLongOfPSN = kNoProcess;				processSN->highLongOfPSN = kNoProcess;				myErr = noErr;			}	}	return(myErr);}/*********************************************************/void doRichardsThing(void);void OpenMany(void);void OpenMany(void){	Cell theCell;	short theindex;		if (divertSamples)	{		doRichardsThing();	}	else	{		SetPt( &theCell, 0,0 );				while ( LGetSelect( TRUE, &theCell, myList) ) 		{			theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));												if (checkReference (theindex))				OpenSelection(((*therealResults)[theindex]));			LNextCell( TRUE, TRUE, &theCell, myList ); 		}	}}/**********************************************/void openFolderList(FSSpec mySpec, short theKey);void openFolderList(FSSpec mySpec, short theKey){	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	OSErr	iErr;	Str255 zfilename;	long	dirID,myDrDir;	short Fcounter = 0;			/*****save for undo*****/			oldFindCounter = totfindcounter;							/** preserve for undo **/			//SetHandleSize(theUndoResults,(totfindcounter+10)*70);			//iErr = MemError();			////if (iErr !=0)			//{			//	if (Alert (1110,0) == 2)								/** not enough mem to undo **/			//		return;			//	fChanged = false;			//}			//else			//{				//	BlockMove((*therealResults),(*theUndoResults),totfindcounter*70L);	/** make undo copy **/				undoFolderSearch = folderSearch;			//	EnableItem(GetMHandle(129),1);									/** enable undo menu item **/			//}			saveForUndo ();	/***********/	if (!theKey)	{					dpb->ioVRefNum = mySpec.vRefNum;		/* default volume */		dpb->ioNamePtr = mySpec.name;	/* buffer to receive name */		dpb->ioFDirIndex = 0;		dpb->ioDrDirID = mySpec.parID;		rc = PBGetCatInfo( &cipbr, FALSE );				dirID = dpb->ioDrDirID;				fpb->ioVRefNum = mySpec.vRefNum;		/* default volume */		fpb->ioNamePtr = zfilename;	/* buffer to receive name */				for( idx=1; TRUE; idx++) 		{	/* indexing loop */			fpb->ioDirID = dirID;		/* must set on each loop */			myDrDir = dirID;			fpb->ioFDirIndex = idx;					rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) 				break;	/* exit when no more entries */				if (!(fpb->ioFlAttrib & 16)) 			{			/** i.e it is a file **/					iErr = FSMakeFSSpec(fpb->ioVRefNum,myDrDir,fpb->ioNamePtr,&((*therealResults)[Fcounter]));										if (iErr!= 0 )											genErrorN("\pMake FSSpec Failed",iErr);											Fcounter++;			}		} // end of for idx		FInfolistInMem = false;		reFound = true;		totfindcounter = Fcounter;		folderSearch = false;	}	else	{		dpb->ioVRefNum = mySpec.vRefNum;		/* default volume */		dpb->ioNamePtr = mySpec.name;	/* buffer to receive name */		dpb->ioFDirIndex = 0;		dpb->ioDrDirID = mySpec.parID;		rc = PBGetCatInfo( &cipbr, FALSE );				dirID = dpb->ioDrDirID;				dpb->ioCompletion = 0;		dpb->ioVRefNum = mySpec.vRefNum;		/* default volume */		dpb->ioNamePtr = zfilename;	/* buffer to receive name */				for( idx=1; TRUE; idx++) 		{	/* indexing loop */			dpb->ioDrDirID = dirID;		/* must set on each loop */			myDrDir = dirID;			dpb->ioFDirIndex = idx;					rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) 				break;	/* exit when no more entries */				if ((dpb->ioFlAttrib & 16)) 			{			/** i.e it is a folder **/					iErr = FSMakeFSSpec(dpb->ioVRefNum,myDrDir,dpb->ioNamePtr,&((*therealResults)[Fcounter]));										if (iErr!= 0 )											genErrorN("\pMake FSSpec Failed",iErr);											Fcounter++;			}		} // end of for idx		FInfolistInMem = false;		reFound = true;		totfindcounter = Fcounter;	}}