#include "SampleSearch.h"#include "Globals.h"Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);extern Boolean normalMode;extern Boolean editRegionCancelled;typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;#define containsNoRegions	-1#define errorInFile			-2#define regionReturned		0#define noMoreRegions		-3short getARegion(FSSpec mySpec, short theIndex,RegionRecPtr	theReturnRegion);Boolean editRegion(FSSpec mySpec,RegionRec** myRgnHdl);Boolean removeRegion (FSSpec theSpec, short theRegIndex);Boolean makeSD2intoRegion(FSSpec mySpec);Boolean viewAudio (FSSpec mySpec);Boolean exportRegion (FSSpec source, FSSpec destination, RegionRec	myRgn);Str31  newName;Boolean editFile(void);Boolean editFile(void){	Point theCell;	short theindex;		SetPt( &theCell, 0,0 );		/* start at top of list  */	if (LGetSelect( TRUE, &theCell, myList))	{		if (theCell.h == 1 && DisplayedColumns == 1)		{			LNextCell( TRUE, TRUE, &theCell, myList );			LGetSelect( TRUE, &theCell, myList) ;		}					theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				if(viewAudio ((*therealResults)[theindex]))		{			if (*newName && !editRegionCancelled)			{				LSetCell(newName+1,*newName,theCell,myList);				BlockMove(newName,(*therealResults)[theindex].name,64L);			}			return true;		}		else			return false;	}	else		return false;}Boolean viewAudio(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	RegionRec myFirstRegion;	RegionRec** myFirstRegionHdl;	short retCode;	FSSpec mySpec2;	short regIndex;	Boolean retVal;		getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes);	if (theWordSize > 2){	genError ("\pCant crop 24-bit files");	return 0;}	iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		genError ("\pNot a Sound Designer II file");		color.red = 0xFFFF;		color.green = 0xFFFF;		color.blue = 0xFFFF;		RGBBackColor(&color);		return false;	}		myFirstRegionHdl = (RegionRec**)NewHandle(sizeof(RegionRec));	if (!myFirstRegionHdl)	{		genError ("\pCan't allocate memory");		return false;	}	HLock ((Handle)myFirstRegionHdl);		retCode = getARegion(mySpec, 0,(RegionRecPtr)*myFirstRegionHdl);	if (retCode == containsNoRegions || retCode == noMoreRegions)	{		makeSD2intoRegion(mySpec);	}		retCode = getARegion(mySpec, 0, (RegionRecPtr)*myFirstRegionHdl);	BlockMove(mySpec.name,((RegionRecPtr)(*myFirstRegionHdl))->RegionName,32L);//	BlockMove (&myFirstRegion, *myFirstRegionHdl, sizeof(RegionRec));	HUnlock ((Handle)myFirstRegionHdl);	BlockMove (&mySpec, &mySpec2,70L);	*(mySpec2.name) += 1;		if (editRegion(mySpec,myFirstRegionHdl))	{		regIndex = 1;		while (retVal)		{			retVal = removeRegion (mySpec, regIndex);		}		normalMode = false;				progressCreate("\pCropping Soundfile");		if (exportRegion (mySpec, mySpec2, *(RegionRec*)(*myFirstRegionHdl)))		{			iErr = FSpDelete (&mySpec);			iErr = FSpRename(&mySpec2,(*(RegionRec*)(*myFirstRegionHdl)).RegionName);			BlockMove ((*(RegionRec*)(*myFirstRegionHdl)).RegionName,newName,32L);		}		else			*newName = 0;		progressDispos();	}	return true;	}short getARegion(FSSpec mySpec, short theIndex,RegionRecPtr	theReturnRegion){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle hRsrc;	short iRefNum;	long lByteCnt;	short regionCount;	short z;	Handle horseRsrc;		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (fRefNum == -1)	{		iErr = ResError();		if (iErr == -193)		{			return containsNoRegions;		}		else		{			return errorInFile;		}	}		UseResFile(fRefNum);		horseRsrc = Get1Resource('ddRL',1000);		if (!horseRsrc)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return containsNoRegions;	}		lByteCnt = SizeResource(horseRsrc);		if (lByteCnt < 74L)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return containsNoRegions;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(horseRsrc);	CloseResFile(fRefNum);	UseResFile(iRefNum);		if (theIndex > regionCount)	{		return noMoreRegions;	}		BlockMove ((((*horseRsrc) +18)+(56L * theIndex)), theReturnRegion, 56L);	return regionReturned;}Boolean makeSD2intoRegion(FSSpec mySpec){	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	short fRefNum;	Handle hRsrc;	ddRLHeader theHeader;	RegionRec theRegRec;	unsigned long secs;	short iRefNum;	long templong;	OSErr	iErr;		getSDIIData (mySpec, &theRate,&theWordSize,&stereo, &theBytes);		theHeader.VersionNumber = 1;	theHeader.HeaderSize = 12L;	theHeader.RegionSize = (long)sizeof(RegionRec);	theHeader.ResourceDate = 0x00000000;	theHeader.NextID = 2L;			theRegRec.RegionID = 1L;	theRegRec.StartFrame = 0L;	templong = (theBytes / (long)(stereo+1));	if (!templong)		templong = 2L;	theRegRec.StopFrame = templong / (long)theWordSize;	theRegRec.SynchFrame = 0L;	GetDateTime(&secs);	theRegRec.TimeStampMS = secs;	theRegRec.TimeStampLS = secs;	BlockMove (mySpec.name,theRegRec.RegionName,32L);		iRefNum = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (fRefNum == -1)	{		FSpCreateResFile(&mySpec,'Sd2a','Sd2f',0);		iErr = ResError();		fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);		iErr = ResError();	}		UseResFile(fRefNum);	hRsrc = Get1Resource('ddRL',1000);	if (hRsrc)	{		RmveResource(hRsrc);		DisposHandle(hRsrc);	}		hRsrc = NewHandle(sizeof(ddRLHeader) + sizeof (RegionRec));	iErr = ResError();	if (!hRsrc)	{		genError ("\pCan't allocate memory for new region");		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}	BlockMove (&theHeader,*hRsrc,sizeof (ddRLHeader));	BlockMove (&theRegRec,(*hRsrc)+sizeof (ddRLHeader),sizeof (RegionRec));		iErr = ResError();		AddResource(hRsrc,'ddRL',1000,"\pRegion List");	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	iErr = ResError();	return true;}Boolean addTimeStampRegion(FSSpec mySpec, long timeStamp);Boolean addTimeStampRegion(FSSpec mySpec, long timeStamp){	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	short fRefNum;	Handle hRsrc;	ddRLHeader theHeader;	RegionRec theRegRec;	unsigned long secs;	short iRefNum;	long templong;	OSErr	iErr;		getSDIIData (mySpec, &theRate,&theWordSize,&stereo, &theBytes);		theHeader.VersionNumber = 1;	theHeader.HeaderSize = 12L;	theHeader.RegionSize = (long)sizeof(RegionRec);	theHeader.ResourceDate = 0x00000000;	theHeader.NextID = 2L;			theRegRec.RegionID = 1L;	theRegRec.StartFrame = 0L;	templong = (theBytes / (long)(stereo+1));	if (!templong)		templong = 2L;	theRegRec.StopFrame = templong / (long)theWordSize;	theRegRec.SynchFrame = 0L;	GetDateTime(&secs);	theRegRec.TimeStampMS = timeStamp;	theRegRec.TimeStampLS = timeStamp;	BlockMove (mySpec.name,theRegRec.RegionName,32L);		iRefNum = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (fRefNum == -1)	{		FSpCreateResFile(&mySpec,'Sd2a','Sd2f',0);		iErr = ResError();		fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);		iErr = ResError();	}		UseResFile(fRefNum);	hRsrc = Get1Resource('ddRL',1000);	if (hRsrc)	{		RmveResource(hRsrc);		DisposHandle(hRsrc);	}		hRsrc = NewHandle(sizeof(ddRLHeader) + sizeof (RegionRec));	iErr = ResError();	if (!hRsrc)	{		genError ("\pCan't allocate memory for new region");		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}	BlockMove (&theHeader,*hRsrc,sizeof (ddRLHeader));	BlockMove (&theRegRec,(*hRsrc)+sizeof (ddRLHeader),sizeof (RegionRec));		iErr = ResError();		AddResource(hRsrc,'ddRL',1000,"\pRegion List");	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	iErr = ResError();	return true;}