#include "SampleSearch.h"#include "Globals.h"#include "Files.h"#include "Fonts.h"#include <Drag.h>#ifdef powerc	#include "Sound.h"#else	#include "3Sound.h"#endif#include <Packages.h>#include "prefs.h"extern newPrefsRec theNewPrefs;extern pascal OSErr MyTrackingHandler(short message, WindowPtr theWindow,							   		  void *handlerRefCon, DragReference theDrag);extern pascal OSErr MyReceiveDropHandler(WindowPtr theWindow, void *handlerRefCon,									 DragReference theDrag);void getOptionDefaults(short * myMenus);extern Cell rememberCell;extern Boolean	rememberSelection;extern Boolean listOpen;short isPressed(unsigned short k );extern Boolean selectLast;#ifdef powerc#elsetypedef unsigned long UnsignedFixed;extern pascal OSErr ParseAIFFHeader(short fRefNum, SoundComponentData *sndInfo, unsigned long *numFrames, unsigned long *dataOffset)  = {0x203C, 0x0758, 0x0014, 0xA800};#endif// extern pascal OSErr ParseAIFFHeader(short fRefNum, SoundComponentData *sndInfo, unsigned long *numFrames, unsigned long *dataOffset)// FOURWORDINLINE(0x203C, 0x0758, 0x0014, 0xA800);  DragTrackingHandlerUPP xMyTrackingHandler;DragReceiveHandlerUPP xMyReceiveDropHandler;Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes){	short refNum;	SoundComponentData sndInfo;	unsigned long curPos;	OSErr iErr;	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)		return 1;			iErr = ParseAIFFHeader(refNum, &sndInfo, (unsigned long*)theBytes,  (unsigned long*)&curPos);	if (iErr)	{		*theWordSize = 1;		*theRate = 1;		*chans = 1;		*theBytes = 1;	}	else	{		*theWordSize = sndInfo.sampleSize >> 3;		*theRate = (sndInfo.sampleRate >> 16) & 0x0000FFFF;		*chans = sndInfo.numChannels;				*theBytes = (*theBytes << (*chans - 1) << (*theWordSize - 1));	}	FSClose (refNum);	return 0;}Boolean getAIFFDataIII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes, long  *headerSize);Boolean getAIFFDataIII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes, long  *headerSize){	short refNum;	SoundComponentData sndInfo;	unsigned long curPos;	OSErr iErr;	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)		return 1;			iErr = ParseAIFFHeader(refNum, &sndInfo, (unsigned long*)theBytes,  (unsigned long*)&curPos);	if (iErr)	{		*theWordSize = 1;		*theRate = 1;		*chans = 1;		*theBytes = 1;	}	else	{		*theWordSize = sndInfo.sampleSize >> 3;		*theRate = (sndInfo.sampleRate >> 16) & 0x0000FFFF;		*chans = sndInfo.numChannels;		*headerSize = curPos;			*theBytes = (*theBytes << (*chans - 1) << (*theWordSize - 1));	}	FSClose (refNum);	return 0;}extern Boolean regionSelected;extern waveFormSelected;extern Boolean dragAvailable;extern Rect myOverViewButtonRect;typedef struct GlobDragDat {short refnum;} GlobDragDat;extern ListHandle myList;void	drawColourIcon4(short left,short top,short cicnResID);GlobDragDat theGlobalDragData;void zGetFontInfo(FontInfo * fInfoPtr);extern Boolean dontQuery;extern FSSpec theApplSpec;Boolean SetFSSpecComment(FSSpec mySpec, Str255 theComment);Boolean GetFSSpecComment(FSSpec mySpec, StringPtr theComment);Boolean GetSizeDate (FSSpec mySpec, short index, long* theSize, long* theDate);extern long theAPPLReply;void controlsCreate(void);void showCommentinWin(short mode, Cell theCell);extern Boolean displayTypes;extern Boolean AutoLaunchDivert;extern Boolean firstTime;extern Boolean folderSearch;extern short SCFormat;short identifySCII(FSSpec mySpec);long findANNO(short localRefNum);long findAPPL(short localRefNum);void genErrorN(Str255 myText,long Errno);extern short DispMenuCheck;extern Boolean DblBuffAudition;extern Boolean autoSustain;short ListFontHite;extern short presTop;	extern short presLeft;extern short presvertsize;extern short prestempor;extern Boolean stickyInfo;extern Boolean freshSearch;extern short presSize,presFont;typedef struct listFontRec {Str255 fontName;short fontSize;} listFontRec, *listFontRecPtr;extern WindowPtr	myWindow;extern Boolean discontigVolumes;extern listFontRec  theFontRec;				void DrawList(void){	Rect	tempR, dataBounds;			/** Rects for our list window **/	long	i;	short dummy;						short hory,verty;	Rect screeny,myRect;	short vertsize;	short listvsize;	short tempor;	Str255 totfindStr;	Str255	tecstr = "\p:Found:";	Str255	winStr;	Str255	theConvStr;	Handle	hRsrc,newCommentH;	Str255	myComment,vrefnumStr,blankStr = " ";	short myRefNum, refNum;	short	iCnt,z;	OSErr	iErr;	FontInfo fontInfo;	long	listlength=0L;	long inOutCount;	Str255  myTempString = "\p";	CInfoPBRec	Zpb;	DirInfo	*dZpb=(DirInfo *)&Zpb;	long AIFFpos, SCinpos;	Cell zCell;	div_t	fdDiv;	short fontNum;	short fdFldrGroup;	short fdFldrMember;	RGBColor	myColor;	CWindowPeek	myPeek;	short	theOptions[5];	SFTypeList mytypeList;	StandardFileReply	reply;	StringHandle	myhString;	FInfo	fndrInfo;	Str255	theFolderTitleText = "\p Folders";	Str255	theTypeText;	Rect infoRect;	long windSize;	short numberOfColumns;	long theSize, theDate;	short dataLen, iRefNum;	Str255 theSizeStr, theDateStr;	GrafPtr	savePort;	Ptr theMemberPointer,theGroupPointer;	FMetricRec theInfo;	RGBColor theCol;	Rect windowRect;	long theRate;	short theWordSize;	Boolean stereo;	Cell lastDrawnCell;	short theChans;		long theBytes;	regionSelected = waveFormSelected = false;	watchcursor(true);		GetPort (&savePort);	presFont =  savePort->txFont;	presSize = savePort->txSize;							theCol.red = 0;	theCol.green = 0;	theCol.blue = 0;	RGBForeColor(&theCol);			theCol.red = 0xFFFF;	theCol.green = 0xFFFF;	theCol.blue = 0xFFFF;	RGBBackColor(&theCol);						mytypeList[0] = 'APPL';	myColor.red = 0xFFFF;	myColor.blue = 0xFFFF;	myColor.green = 0xFFFF;		if (FInfolistInMem == false && DisplayComments)	{		watchcursor(true);		FInfoArrayPtr = totfindcounter;		//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));		gErr = MemError();		if (gErr != 0 )			genError("\pCould not resize theFInfo in searcher");					gErr = 0;		for (z=0;(z<totfindcounter);z++)			{			gErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);		}			FInfolistInMem = true;		watchcursor(false);	}	GetFNum(theFontRec.fontName,&fontNum);	/*TextFont(fontNum);							TextSize(theFontRec.fontSize);	TextFace(0);*/	zGetFontInfo(&fontInfo);		if (freshSearch)	{		//FontMetrics(&theInfo);				Point thePoint;								ListFontHite = fontInfo.leading + fontInfo.ascent + fontInfo.descent;		if (!ListFontHite)		{			genError("\pList font hite problem");			ListFontHite = 12;		}		vertsize = 175+15+(((totfindcounter / DisplayedColumns)+1)*ListFontHite);		screeny = qd.screenBits.bounds;				if (vertsize > screeny.bottom-40)		{			vertsize = screeny.bottom-40;		}		if (vertsize < 175)		{			vertsize = 175;		}		tempor = screeny.right-10;				if (tempor > defScreenWid) 			tempor = defScreenWid;		presLeft = 20;					presTop = 100;		presvertsize = vertsize;		prestempor = tempor;		freshSearch = false;						presTop = theNewPrefs.windowLocation.top +19;		presLeft = theNewPrefs.windowLocation.left + 1;		tempor = theNewPrefs.windowLocation.right - 2;		vertsize = theNewPrefs.windowLocation.bottom - 57 - 19 + 19;				thePoint.v = presTop;		thePoint.h = presLeft;				myRect = qd.screenBits.bounds;		myRect.top += 25;		if(!PtInRect(thePoint,&myRect)) 		{			presTop = theNewPrefs.windowLocation.top = 50;			presLeft = theNewPrefs.windowLocation.left = 50;			tempor = theNewPrefs.windowLocation.right = 600;			vertsize = theNewPrefs.windowLocation.bottom = 350;		}		presvertsize = vertsize;		prestempor = tempor;	}	else	{		vertsize = presvertsize;		tempor = prestempor;			}		/*TextFont (presFont);	TextSize (presSize);*/	/*	TextFont (0);	TextSize (12);*/	SetRect(&tempR, presLeft, presTop, tempor,vertsize+55);  		/** open a new window for our list **/	if (tempR.bottom-tempR.top < (145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0)))	{		if (tempR.top + (145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0)) > qd.screenBits.bounds.bottom)		{			tempR.bottom = qd.screenBits.bounds.bottom;			tempR.top = tempR.bottom - (145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0)) > qd.screenBits.bounds.bottom;		}		else		{			tempR.bottom = tempR.top + (145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0));				}		}					NumToString(totfindcounter,totfindStr);	BlockMove(gFileName+1,winStr+1,64L);	BlockMove(tecstr+1,winStr+ *gFileName +1,7L);	BlockMove(totfindStr+1,winStr+ *gFileName +8,16L);	winStr[0] = *gFileName + 7 + *totfindStr;	if (folderSearch)	{		BlockMove (theFolderTitleText +1,winStr + *winStr +1,64L);		winStr[0]+=*theFolderTitleText;	}		myWindow = NewCWindow(nil, &tempR, winStr,true, 8, (WindowPtr) -1,true, 0);	if (!myWindow)	{		Debugger();			}	myPeek = (CWindowPeek)myWindow;	myPeek->port.rgbBkColor = myColor;	SetPort((GrafPtr)myWindow);			color.red = 0xFFFF;	color.blue = 0xFFFF;	color.green = 0xFFFF;	RGBBackColor(&color);		GetFNum(theFontRec.fontName,&fontNum);	TextFont(fontNum);						/** font for list - chicago **/	TextSize(theFontRec.fontSize);	TextFace(0);		listvsize = totfindcounter/DisplayedColumns +1;				SetRect(&dataBounds, 0, 0, DisplayedColumns + DisplayComments, listvsize);					/** this RECT is used to tell the Listmanager what dimensions the list has - we don't know them all yet hence 0's **/	SetPt(&cSize, 0, ListFontHite);			if (dragAvailable)	{		InstallTrackingHandler(xMyTrackingHandler = NewDragTrackingHandlerProc(MyTrackingHandler), myWindow, (void *) &theGlobalDragData);		InstallReceiveHandler(xMyReceiveDropHandler = NewDragReceiveHandlerProc(MyReceiveDropHandler), myWindow, (void *) &theGlobalDragData);	}		SetRect (&tempR, 0, 80,myWindow->portRect.right - 15,myWindow->portRect.bottom - 15 - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) - ((theNewPrefs.SDIIToolBar) ?  theNewPrefs.toolsHeight : 0));	numberOfColumns = (tempor-presLeft)/150;	if (numberOfColumns == 0)	{		numberOfColumns = 1;	}	if (squashColumns == 1)	{		numberOfColumns = DisplayedColumns + DisplayComments;	}	cSize.h = ((tempor-presLeft)-15)/numberOfColumns;	cSize.v = ListFontHite;		SetPort(myWindow);		TextFont(fontNum);						/** font for list - chicago **/	TextSize(theFontRec.fontSize);	/* this list has never been disposed...!!! */	if (myList)	{		LDispose(myList);		listOpen = false;		myList = 0;	}	myList = LNew(&tempR, &dataBounds, cSize, 0,(WindowPtr)myWindow,true, true, true,true);	SetRect(&myOverViewButtonRect,(*myList)->rView.right - 15,(*myList)->rView.bottom - 15,(*myList)->rView.right,(*myList)->rView.bottom);	listOpen = true;							if (!myList)	{		genError ("\pError creating list");	}		(*myList)->selFlags = lNoNilHilite | lNoExtend | lUseSense;	cSize = (*myList)->cellSize;   				/** Save cellSize so we can use it later to resize the cells  **/	SetRect(&tempR, tempR.left - 1, tempR.top - 1,tempR.right + 16, tempR.bottom + 16);		LCellSize (cSize,myList);	DrawGrowIcon ((WindowPtr) myWindow);		SetRect (&infoRect, 0, 0,tempor-presLeft, 49);		/** this is the display region of our window **/	PenSize(1,1);		MoveTo(0,80);	LineTo(infoRect.right,80);		watchcursor(true);							/** set cursor to busywatch **/	LDoDraw(false,myList);			i=0;										/** turn off auto listdraw for speed **/	for (verty = 0; verty <=listvsize; verty++)	{		for (hory = 0;hory <DisplayedColumns;hory++)		{			SetPt(&cSize, hory,verty);					/** set up to point to new cell : point = x,y of cell in list **/			if (i< totfindcounter && listlength <31500L)			{					LAddToCell(((*therealResults)[i].name)+1, *(*therealResults)[i].name, cSize, myList);  	/** add the data to the list **/						listlength += *(*therealResults)[i].name;				lastDrawnCell = cSize;			}		i++;		}	}			watchcursor(true);			if (DispMode == 5)	{		FSSpec theGroupSpec,theMemberSpec;		short groupRefNum,memberRefNum;		short soFar = 0;		IOParam GMpb;		Str255 theReadText;				theMemberPointer = NewPtrClear(17000L);		if (!theMemberPointer)		{			SetPort (savePort);			return;		}		theGroupPointer = NewPtrClear(17000L);		if (!theGroupPointer)		{			DisposPtr(theMemberPointer);			SetPort (savePort);			return;		}				BlockMove (&theApplSpec,&theGroupSpec,70L);		BlockMove (&theApplSpec,&theMemberSpec,70L);				makeStr255("\pSampleSearchª Category Groups",theGroupSpec.name);		iErr = FSpOpenDF(&theGroupSpec,fsCurPerm,&groupRefNum);		if (iErr == -43)		{			iErr = FSpCreate(&theGroupSpec,'ttxt','TEXT',0);			if (iErr)			{				genError("\pCan't make categories file");				SetPort (savePort);				return;			}			iErr = FSpOpenDF(&theGroupSpec,fsCurPerm,&groupRefNum);			if (iErr)			{				genError("\pCan't open categories file");				SetPort (savePort);				return;			}			}				makeStr255("\pSampleSearchª Category Members",theMemberSpec.name);		iErr = FSpOpenDF(&theMemberSpec,fsCurPerm,&memberRefNum);		if (iErr == -43)		{			iErr = FSpCreate(&theMemberSpec,'ttxt','TEXT',0);			if (iErr)			{				genError("\pCan't make categories file");				SetPort (savePort);				return;			}			iErr = FSpOpenDF(&theMemberSpec,fsCurPerm,&memberRefNum);			if (iErr)			{				genError("\pCan't open categories file");				SetPort (savePort);				return;			}			}						makeStr255 ("\pNone",theReadText);		BlockMove (theReadText,theGroupPointer + ((long)soFar * 64L),(*theReadText) + 1L);		*(theGroupPointer + ((long)soFar * 64L)) = 4;		soFar++;				GMpb.ioRefNum = groupRefNum;		GMpb.ioReqCount = 253;		GMpb.ioPosMode = 0x0D80 | fsAtMark;		GMpb.ioBuffer = (Ptr)theReadText;		iErr = 0;				while (!iErr)		{			iErr = PBRead((union ParamBlockRec *)&GMpb,false);			*(theReadText + GMpb.ioActCount) = 0;			CtoPstr ((Ptr)theReadText);			if (!iErr && GMpb.ioActCount > 0)			{				BlockMove (theReadText,theGroupPointer + ((long)soFar * 64L),(*theReadText) + 1L);				*(theGroupPointer + ((long)soFar * 64L)) = GMpb.ioActCount - 1;				soFar++;			}		}		iErr = FSClose(groupRefNum);				soFar = 0;		makeStr255 ("\pNone",theReadText);		BlockMove (theReadText,theMemberPointer + ((long)soFar * 64L),(*theReadText) + 1L);		*(theMemberPointer + ((long)soFar * 64L)) = 4;		soFar++;		GMpb.ioRefNum = memberRefNum;		GMpb.ioReqCount = 253;		GMpb.ioPosMode = 0x0D80 | fsAtMark;		GMpb.ioBuffer = (Ptr)theReadText;		iErr = 0;		while (!iErr)		{			iErr = PBRead((union ParamBlockRec *)&GMpb,false);			*(theReadText + GMpb.ioActCount) = 0;			CtoPstr ((Ptr)theReadText);			if (!iErr && GMpb.ioActCount > 0)			{				BlockMove (theReadText,theMemberPointer + ((long)soFar * 64L),(*theReadText) + 1L);				*(theMemberPointer + ((long)soFar * 64L)) = GMpb.ioActCount - 1;				soFar++;			}		}		iErr = FSClose(memberRefNum);		/* fill pointers */			}		LDoDraw(true,myList);	if (DisplayComments)	{	 for (verty = 0; verty <listvsize-1; verty++)	 { /* 11 */		SetPt(&cSize, 1,verty);					/** set up to point to new cell : point = x,y of cell in list **/		switch (DispMode)		{ /* 12 */			case 0:  /** show the comment **/				switch((*theFInfo)[verty].fdType)				{ /* 13 */									case 'SFIL':						iErr = FSpOpenDF(&((*therealResults)[verty]),fsCurPerm,&refNum);						if (iErr!=0)							genError("\pCouldn't open data forkj");						if( !iErr)						{ /* 9 */							iErr = SetFPos(refNum,1,764L);							if (iErr!=0)								genError("\pCouldn't move file pointer");							inOutCount = 255L;							iErr = FSRead(refNum,&inOutCount,myComment);							if (iErr!=0)								genError("\pCouldn't read from file pointer");								if (!DispMode)								{									if (listlength< 31600L)									{										LAddToCell(myComment+1, *myComment, cSize, myList);  	/** add the data to the list **/												listlength += *myComment;										lastDrawnCell = cSize;									}								}							FSClose(refNum);						} /* 9 */						else						{								LAddToCell(blankStr+1,*blankStr, cSize, myList);  	/** add the data to the list **/									lastDrawnCell = cSize;						}					break;										case 'Sd2f':						iRefNum = CurResFile();						myRefNum = HOpenResFile((*therealResults)[verty].vRefNum,(*therealResults)[verty].parID,(*therealResults)[verty].name,fsCurPerm);						if (myRefNum > 0)						{ 							hRsrc = Get1Resource('sdDD',1000);							iErr = ResError();							if(hRsrc)							{																BlockMove((*hRsrc)+10,myComment,256L);								//HUnlock(hRsrc);								ReleaseResource(hRsrc);								if (!DispMode)								if (listlength< 31600L)								{									LAddToCell(myComment+1, *myComment, cSize, myList);  										listlength += *myComment;									lastDrawnCell = cSize;								}							}							CloseResFile(myRefNum);							UseResFile(iRefNum);						}						else						{								LAddToCell(blankStr+1,*blankStr, cSize, myList);  					lastDrawnCell = cSize;							}					break;										case 'SCin': case 'MixD': case 'SCsi' : case 'SCsd' : case 'SCss':						SCFormat = identifySCII(((*therealResults)[verty]));					 	if (SCFormat !=2)					 	{					 		break;					 	}						iErr = FSpOpenDF(&((*therealResults)[verty]),fsCurPerm,&refNum);						if (iErr!=0)							genError("\pCouldn't open data forkj");						if( !iErr)						{ /* 9 */							SCinpos =  findANNO(refNum);							if (SCinpos)							{								iErr = SetFPos(refNum,1,SCinpos+4L);								if (iErr!=0)									genError("\pCouldn't move file pointer");																	inOutCount = 4L;								iErr = FSRead(refNum,&inOutCount,&SCinpos);								if (iErr!=0)									genError("\pCouldn't read from file pointer");								inOutCount = SCinpos;								if (SCinpos)								{									iErr = FSRead(refNum,&inOutCount,myComment);									if (iErr!=0)										genError("\pCouldn't read from file pointer");									if (!DispMode)									{										if (listlength< 31600L)										{											LAddToCell(myComment+1, *myComment, cSize, myList);  	/** add the data to the list **/													listlength += *myComment;														lastDrawnCell = cSize;										}									}								}							}							FSClose(refNum);						} /* 9 */					break;										case 'AIFF':						if ((*theFInfo)[verty].fdCreator == 'CARI')						{							if (GetFSSpecComment(((*therealResults)[verty]),(StringPtr) myComment))							{								if (!DispMode)								{									if (listlength< 31600)									{										LAddToCell(myComment+1, *myComment, cSize, myList);  	/** add the data to the list **/												listlength += *myComment;										lastDrawnCell = cSize;									}								}							}							else							{									if (!DispMode)									LAddToCell(blankStr+1,*blankStr, cSize, myList);  	/** add the data to the list **/													lastDrawnCell = cSize;							}						}						else						{						iErr = FSpOpenDF(&((*therealResults)[verty]),fsCurPerm,&refNum);						/*if (iErr!=0)							genError("\pCouldn't open data forkj");*/						if( !iErr)						{ /* 9 */							AIFFpos =  findAPPL(refNum);							if (AIFFpos)							{								iErr = SetFPos(refNum,1,AIFFpos+22L);								if (iErr!=0)								{									genError("\pCouldn't move file pointer");									FSClose(refNum);									break;								}								inOutCount = 255L;								iErr = FSRead(refNum,&inOutCount,myComment);								if (iErr!=0)								{									if (iErr != -39)									{										genError("\pCouldn't read from file pointer");										FSClose(refNum);										break;									}																}								if (!DispMode)								{									if (listlength< 31600L)									{										LAddToCell(myComment+1, *myComment, cSize, myList);  	/** add the data to the list **/												listlength += *myComment;										lastDrawnCell = cSize;									}								}							}							FSClose(refNum);						} /* 9 */						}					break;										default:						if (GetFSSpecComment(((*therealResults)[verty]),(StringPtr) myComment))						{							if (!DispMode)							{								if (listlength< 31600)								{									LAddToCell(myComment+1, *myComment, cSize, myList);  	/** add the data to the list **/											listlength += *myComment;										lastDrawnCell = cSize;								}							}						}						else						{								if (!DispMode)								LAddToCell(blankStr+1,*blankStr, cSize, myList);  	/** add the data to the list **/												lastDrawnCell = cSize;						}					break;				} /* 13 */			break;						case 1:				if (isPressed (0x3A))				{					NumToString((*therealResults)[verty].parID,vrefnumStr);					if (listlength< 31600)					{						LAddToCell(vrefnumStr+1,*vrefnumStr, cSize, myList);						listlength += *vrefnumStr;										lastDrawnCell = cSize;					}				}				else				{					NumToString((*therealResults)[verty].vRefNum,vrefnumStr);					if (listlength< 31600)					{						LAddToCell(vrefnumStr+1,*vrefnumStr, cSize, myList);						listlength += *vrefnumStr;										lastDrawnCell = cSize;					}				}			break;						case 2:				if (displayTypes)				{					if (listlength< 31600)					{						switch ((*theFInfo)[verty].fdType)						{							case 'SCin':								makeStr255("\pSampleCell mono Instrument", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'SCsi':								makeStr255("\pSampleCell stereo Instrument", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'MixD':								makeStr255("\pSampleCell Bank", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'SCss':								makeStr255("\pSampleCell thingy instrument", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'SCsd':								makeStr255("\pSampleCell thingy 2 instrument", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'Sd2f':								makeStr255("\pSound Designer II sample", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'SFIL':								makeStr255("\pSound Designer I sample", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'AIFF':								makeStr255("\pAIFF sample", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'scSG':								makeStr255("\pCubase Audio Song", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;														case 'WDBN':								makeStr255("\pMicrosoft Word File", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							break;													default:								LAddToCell(&(*theFInfo)[verty].fdType,4, cSize, myList);								listlength += 4;											lastDrawnCell = cSize;						break;						}					}				}				else				{					if (listlength< 31600)					{						LAddToCell(&(*theFInfo)[verty].fdType,4, cSize, myList);						listlength += 4;										lastDrawnCell = cSize;					}				}			break;						case 3:				if (listlength< 31600)				{					LAddToCell(&(*theFInfo)[verty].fdCreator,4, cSize, myList);										lastDrawnCell = cSize;					listlength += 4;				}			break;						case 4:				if (listlength< 31600)				{					*myTempString = 0;					PathNameFromDirID((*therealResults)[verty].parID, (*therealResults)[verty].vRefNum,(StringPtr)myTempString);					LAddToCell(myTempString+1,*myTempString, cSize, myList);					listlength += *myTempString;										lastDrawnCell = cSize;				}			break;						case 5:				iErr = FSpGetFInfo (&(*therealResults)[verty],&fndrInfo);				fdFldrGroup = (unsigned long)((fndrInfo.fdFldr>>8) & 0x00FF);				fdFldrMember = (unsigned long)(fndrInfo.fdFldr & 0x00FF);				BlockMove (theGroupPointer + ((long)fdFldrGroup * 64L),vrefnumStr,*(theGroupPointer + ((long)fdFldrGroup * 64L))+1L);				if (*vrefnumStr == 0)					NumToString((unsigned long)fdFldrGroup,vrefnumStr);								if (listlength< 31600)				{					if (iErr != 0)						*vrefnumStr = 0;					LAddToCell(vrefnumStr+1,*vrefnumStr, cSize, myList);					listlength += *vrefnumStr;										lastDrawnCell = cSize;				}				*vrefnumStr = 2;				*(vrefnumStr + 1) = 32;				*(vrefnumStr + 2) = 32;				if (listlength< 31600)				{					LAddToCell(vrefnumStr+1,*vrefnumStr, cSize, myList);					listlength += *vrefnumStr;										lastDrawnCell = cSize;				}				BlockMove (theMemberPointer + ((long)fdFldrMember * 64L),vrefnumStr,*(theMemberPointer + ((long)fdFldrMember * 64L))+1L);				if (*vrefnumStr == 0)					NumToString((unsigned long)fdFldrMember,vrefnumStr);				if (listlength< 31600)				{					if (iErr != 0)						*vrefnumStr = 0;					LAddToCell(vrefnumStr+1,*vrefnumStr, cSize, myList);					listlength += *vrefnumStr;										lastDrawnCell = cSize;				}			break;						case 6:				if (GetSizeDate (((*therealResults)[verty]),verty, &theSize, &theDate))				{					IUDateString(theDate,0,theDateStr);					dataLen = *theDateStr;					PtoCstr(theDateStr);					LAddToCell(theDateStr,dataLen,cSize,myList);											lastDrawnCell = cSize;			}			break;						case 7:				if (GetSizeDate (((*therealResults)[verty]),verty, &theSize, &theDate))				{					theSize /= 1000L;					if (theSize < 1L)					theSize = 1L;					NumToString(theSize,theSizeStr);					dataLen = *(theSizeStr)+1;					*(theSizeStr + *theSizeStr + 1) = 'k';					*theSizeStr += 1;					PtoCstr(theSizeStr);					LAddToCell(theSizeStr,dataLen,cSize,myList);										lastDrawnCell = cSize;				}			break;									case 8:					switch ((*theFInfo)[verty].fdType)					{						case 'AIFF':							if (getAIFFDataII (((*therealResults)[verty]), &theRate, &theWordSize, &theChans, &theBytes))							{								/* not SDII */								makeStr255("\pNot an Sample File", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							}							else							{								stereo = (theChans == 2);								NumToString (theRate, theTypeText);								concatStrings(theTypeText, "\pkHz", "\p");								if (theWordSize == 2)								{									concatStrings(theTypeText, "\p16Bit", "\p  ");								}								else								{									concatStrings(theTypeText, "\p8Bit", "\p  ");								}								if (stereo)								{									concatStrings(theTypeText, "\pStereo", "\p  ");								}								else								{									concatStrings(theTypeText, "\pMono", "\p  ");								}								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;															lastDrawnCell = cSize;							}						break;												case 'Sd2f':							if (getSDIIData (((*therealResults)[verty]), &theRate, &theWordSize, &stereo, &theBytes))							{								/* not SDII */								makeStr255("\pNot an Sample File", theTypeText);								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;										lastDrawnCell = cSize;							}							else							{								NumToString (theRate, theTypeText);								concatStrings(theTypeText, "\pkHz", "\p");								switch (theWordSize)								{									case 2:										concatStrings(theTypeText, "\p16Bit", "\p  ");									break;									case 1:										concatStrings(theTypeText, "\p8Bit", "\p  ");									break;									case 3:										concatStrings(theTypeText, "\p24Bit", "\p  ");									break;								}								if (stereo)								{									concatStrings(theTypeText, "\pStereo", "\p  ");								}								else								{									concatStrings(theTypeText, "\pMono", "\p  ");								}								LAddToCell(theTypeText+1,*theTypeText, cSize, myList);								listlength += *theTypeText;																lastDrawnCell = cSize;						}						break;														}			break;						case 9: /* show nothing */			//	if (GetSizeDate (((*therealResults)[verty]),verty, &theSize, &theDate))			//	{			//		IUDateString(theDate,0,theDateStr);			//	dataLen = *theDateStr;			//		PtoCstr(theDateStr);			//		LAddToCell(theDateStr,dataLen,cSize,myList);			//	}			break;					default:			break;					} /* 12 */			} /* 11 */  }  LDoDraw(true,myList);						/** turn on auto listdraw **/	if (selectLast)	{		LSetSelect(true,lastDrawnCell,myList);		LAutoScroll(myList);		selectLast = false;	}	else	{		if (rememberSelection)		{			LSetSelect(true,rememberCell,myList);			LAutoScroll(myList);		}		else		{			zCell.h = 0;			zCell.v = 0;			LSetSelect(true,zCell,myList);			LAutoScroll(myList);		}	}	DrawGrowIcon ((WindowPtr) myWindow);	if (listlength	>=31500)		genError("\pToo many files were found to display in the list");  watchcursor(false);  lCellCoords.h = 0;   lCellCoords.v = 0;         if  (discontigVolumes)   {   		//Alert(1814,0);   	}   	   	   /******* restore prefs **********/   	getOptionDefaults(theOptions);   //	squashColumns = (Boolean)theOptions[0];	//DisplayComments = (Boolean)theOptions[1];	divertSamples = (Boolean)theOptions[2];	DblBuffAudition = (Boolean)theOptions[3];	autoSustain = (Boolean)theOptions[4];	dontQuery = (Boolean)theOptions[5];		CheckItem(GetMHandle(135), 3, divertSamples);		if (divertSamples && (divertSpec.vRefNum== 0)) /** not yet selected **/		{			genError ("\pPlease select the switch launch application");			StandardGetFile(0,1,mytypeList,&reply);			if (reply.sfGood)  				{				BlockMove(&(reply.sfFile),&divertSpec,70L);				setDivertAppSpec(reply.sfFile);				iErr = FSpGetFInfo(&(reply.sfFile),&fndrInfo);  					myhString = GetString(998);				BlockMove(&(fndrInfo.fdCreator),(*myhString)+1,4L);				ChangedResource((Handle)myhString);				WriteResource((Handle)myhString);				divertDocCreator = fndrInfo.fdCreator;			}			}		if (divertSamples && firstTime && !AutoLaunchDivert)		{			if (OpenSelection (divertSpec) < 0)			{				genError ("\pPlease re-select the switch launch application with from the 'Special' menu");			}			firstTime = false;		}				CheckItem(GetMHandle(135), 10, theNewPrefs.modernDblBufferAudition);	CheckItem(GetMHandle(135), 11, autoSustain);	CheckItem(GetMHandle(135), 13, dontQuery);	//showCommentinWin(kFirstSelected,nullCell);			/*******************************/	if (DispMode == 5)	{		DisposPtr(theMemberPointer);		DisposPtr(theGroupPointer);	}		SetPort (savePort);   return;}long findANNO(short localRefNum){	OSErr	iErr;	Handle	myTempStore;	long inOutCount;	long lOffset;	OSType	filpType = 'ANNO';	short passes = 0;	myTempStore = NewHandle(500);	if (!myTempStore)	{		genError ("\pCannot allocate memory for ANNO handle");		return 0;	}	//MoveHHi(myTempStore);	iErr = SetFPos(localRefNum,1,0L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}	while (iErr != eofErr)	{		inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			return lOffset + (passes*490);		}		passes ++;	}	DisposHandle(myTempStore);	return 0;}long findAPPL(short localRefNum){	OSErr	iErr;	Handle	myTempStore;	long inOutCount,filePos;	long lOffset;	OSType	filpType = 'APPL';	short passes = 0;	EventRecord	theEvent;		theAPPLReply = 0L;	myTempStore = NewHandle(500);	if (!myTempStore)		return 0;	//MoveHHi(myTempStore);	iErr = SetFPos(localRefNum,1,0L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}	inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}				lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			inOutCount = 4;			iErr = SetFPos(localRefNum,1,lOffset + 8L);			iErr = FSRead(localRefNum,&inOutCount,*myTempStore);			if ((*(OSType *)*myTempStore == 'Sd2a') || (*(OSType *)*myTempStore == 'Sd2x')) 			{				DisposHandle(myTempStore);				theAPPLReply = lOffset;				return lOffset;			}			else			{				iErr = SetFPos(localRefNum,3,-12L);			}		}		iErr = SetFPos(localRefNum,2,-490L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}	iErr = GetFPos(localRefNum,&filePos);			inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			lOffset += filePos;						inOutCount = 4;			iErr = SetFPos(localRefNum,1,lOffset + 8L);			iErr = FSRead(localRefNum,&inOutCount,*myTempStore);			if ((*(OSType *)*myTempStore == 'Sd2a') || (*(OSType *)*myTempStore == 'Sd2x')) 			{				DisposHandle(myTempStore);				theAPPLReply = lOffset;				return lOffset;			}						else			{				iErr = SetFPos(localRefNum,3,-12L);			}		}			iErr = SetFPos(localRefNum,1,490L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}				passes = 1;		while (false /*iErr != eofErr*/)  /* this line determines a thorough look for the comment */	{		inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			inOutCount = 4;			iErr = SetFPos(localRefNum,1,lOffset + ((long)passes*490L) + 8L);			iErr = FSRead(localRefNum,&inOutCount,*myTempStore);			if ((*(OSType *)*myTempStore == 'Sd2a') || (*(OSType *)*myTempStore == 'Sd2x')) 			{				DisposHandle(myTempStore);				theAPPLReply = lOffset + (passes*490);				return lOffset + (passes*490);			}			else			{				iErr = SetFPos(localRefNum,3,-12L);			}		}		if(EventAvail(everyEvent,&theEvent))  		{			DisposHandle(myTempStore);			return 0;		}		passes ++;	}	DisposHandle(myTempStore);	return 0;}void makeStr255(Str255 theString, StringPtr thePtr){	BlockMove (theString,thePtr,*theString+1L);	return;}void zGetFontInfo(FontInfo * fInfoPtr){	GrafPtr savePort;	FMetricRec theInfo;	short fSize;		GetPort(&savePort);	/*fSize = savePort->txSize;*/	fSize = theFontRec.fontSize;	//FontMetrics(&theInfo);	/*fInfoPtr->ascent = HiWord(theInfo.ascent);	fInfoPtr->descent = HiWord(theInfo.descent);	fInfoPtr->widMax = HiWord(theInfo.widMax);	fInfoPtr->leading =  HiWord(theInfo.leading);*/		fInfoPtr->ascent = fSize;	fInfoPtr->descent = 0;	fInfoPtr->widMax = 0;	fInfoPtr->leading = (fSize * 4) / 10;		}