#include "SampleSearch.h"#include "Globals.h"//#include "fp.h"#include <stdio.h>#include <AIFF.h>#include <FixMath.h>#include <Movies.h>#include <String.h>#include "wav.h"#include <SoundInput.h>#include "convertFormat.h"#include "prefs.h"extern newPrefsRec theNewPrefs;OSErr convertBuffer16To24 (Ptr theSourceData,Ptr theDestData, long *Length);Boolean SDIIStereoToMonoLR24(FSSpec theSpec);Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);Boolean SetFSSpecComment(FSSpec mySpec, Str255 theComment);Boolean GetFSSpecComment(FSSpec mySpec, StringPtr theComment); OSErr GetFileGray(FSSpec *myFSSpec);short identifySCII(FSSpec mySpec);OSErr playIMAWAV (FSSpec mySpec);FSSpec theConvertDestLoc;OSErr convertBuffer24To16 (Ptr theSoundData, long *sourceLength);Boolean GeffenToSDII(FSSpec mySpec);Str255 leftSuffixStr = "\p.L" ,rightSuffixStr = "\p.R";Boolean isOdd(long theLong);long findANNO(short localRefNum);long findAPPL(short localRefNum);Boolean isItTheLastChunk(short localRefNum, long theFPos);Boolean removeCommentFromChunkEnd(short localRefNum, long theFPos, OSType theType);Boolean addAIFFCommentToChunkEnd(short localRefNum, Str255 theComment, OSType theType);Boolean zapAPPL(short localRefNum);Boolean addCommentToChunkEnd(short localRefNum, Str255 theComment, OSType theType);Boolean zapANNO(short localRefNum);Boolean translateParentToChildFolder(FSSpec *mySpec);Boolean SDIIStereoToMonoMix24(FSSpec theSpec);Boolean flattenIt = true;Boolean SetComment (FSSpec mySpec, short index, StringPtr theComment);Boolean createSDIIOverview(FSSpec mySpec, long decimation);Boolean pcConv24(Ptr theBuff, long inOutCount);Boolean radar24BitMode = false;short GetBWaveInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);OSErr copySDIIRegionsNoConversion (FSSpec sourceFile, FSSpec destFile);short GetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length){	OSErr	iErr;	short refNum;	long inOutCount;	WavFmtHeaderExt theWAVHeader;	//WavFmtHeader theWAVHeader;	long tempLong;	short tempShort;	Boolean isIMA = false;	OSType myIMATest;	long mylong;	unsigned long filePos, sndLength;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		return false;	}	inOutCount = sizeof(theWAVHeader);	iErr = FSRead(refNum,&inOutCount,&theWAVHeader);	if (iErr!=0)	{		iErr = FSClose(refNum);		return false;	}		if (theWAVHeader.fmtHead == 'fact')	{		isIMA = true;	/*	iErr = FSClose(refNum);		playIMAWAV(mySpec);		return 0;*/	}			if (isIMA)	{		if (theWAVHeader.RIFFhead != 'RIFF' || theWAVHeader.WAVEHead != 'WAVE')		{			iErr = FSClose(refNum);			return 0;		}	}	else	{		if (theWAVHeader.RIFFhead != 'RIFF' || theWAVHeader.WAVEHead != 'WAVE' || theWAVHeader.fmtHead != 'fmt ')		{			/* it could be digi broadcast wave */			iErr = FSClose(refNum);			return GetBWaveInfo (mySpec,theSRate, theWordSize,theDuration, isStereo, length);		}	}		/* get the real audio data size */		iErr = SetFPos(refNum,1,0);	filePos = findCOMM(refNum,'data');	if (!filePos)	{		genError ("\pCan't find data chunk");		iErr = FSClose(refNum);		return false;	}		iErr = SetFPos(refNum,1,filePos + 4L);	inOutCount = 4L;	iErr = FSRead(refNum,&inOutCount,&sndLength);//	sndLength = swapBytesL(sndLength);			*length = swapBytesL(sndLength/*theWAVHeader.fileSize*/);	*isStereo = (swapBytesI(theWAVHeader.channels) == 2);	*theSRate = swapBytesL(theWAVHeader.sampleRate);	tempLong = swapBytesL(theWAVHeader.bytesPerSec);		switch(swapBytesI(theWAVHeader.blockAlign))	{		case 1:			*theWordSize = 8;		break;				case 2:			if (*isStereo)			{				*theWordSize = 8;			}			else			{				*theWordSize = 16;			}		break;				case 4:			*theWordSize = 16;		break;	}		 if (!( *theSRate))	 {		 *theSRate = 1L;	 }	 *theDuration = (swapBytesL(sndLength/*theWAVHeader.fileSize*/) >> *isStereo >> (*theWordSize == 16)) / *theSRate;	 	 mylong = (long)(&theWAVHeader.RIFFhead) + 20 + swapBytesL(theWAVHeader.formatChunkSize);	 BlockMove ((Ptr)mylong, &myIMATest, 4L);	 if (myIMATest == 'fact')	 {		 isIMA = true;	 }	 	 	 iErr = FSClose(refNum);	 	 if (isIMA)	 {	 	return 2;	 }	 else		return 1;}typedef struct BWaveHeader {	OSType riffHeader;	long fileSize;	OSType WAVEHead;	OSType bextHead;	long bextCnkSize;} BWaveHeader;typedef struct bwavFmt {	OSType fmtHead;	long formatChunkSize; /* excludes fmtHead and formatChunkSize */	short formatTag;	short channels;	long sampleRate;	long bytesPerSec;	short bytesPerSample;	short bitsPerSample;} bwavFmt;typedef struct elmoCnkHeader {	OSType elmoHeader; /* 'Elmo' */	long elmoCnkSize;} elmoCnkHeader;short GetBWaveInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length){	OSErr	iErr;	short refNum;	long inOutCount;	WavFmtHeaderExt theWAVHeader;	//WavFmtHeader theWAVHeader;	long tempLong;	short tempShort;	Boolean isIMA = false;	OSType myIMATest;	long mylong;	unsigned long filePos, sndLength;	BWaveHeader theBWAVHeader;	bwavFmt mybwavFmt;	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr!=0)	{		return false;	}	inOutCount = sizeof(theBWAVHeader);	iErr = FSRead(refNum,&inOutCount,&theBWAVHeader);	if (iErr!=0)	{		iErr = FSClose(refNum);		return false;	}		if (theBWAVHeader.riffHeader != 'RIFF' || theBWAVHeader.WAVEHead != 'WAVE')	{		iErr = FSClose(refNum);		return 0;	}		iErr = SetFPos(refNum,fsFromMark,swapBytesL(theBWAVHeader.bextCnkSize));	/* get the real audio data size */		inOutCount = sizeof(bwavFmt);	iErr = FSRead(refNum,&inOutCount,&mybwavFmt);	if (iErr!=0)	{		iErr = FSClose(refNum);		return false;	}	if (mybwavFmt.fmtHead != 'fmt ')	{			iErr = FSClose(refNum);			return false;	}	iErr = SetFPos(refNum,1,0);	filePos = findCOMM(refNum,'data');	if (!filePos)	{		genError ("\pCan't find data chunk");		iErr = FSClose(refNum);		return false;	}		iErr = SetFPos(refNum,1,filePos + 4L);	inOutCount = 4L;	iErr = FSRead(refNum,&inOutCount,&sndLength);//	sndLength = swapBytesL(sndLength);			*length = swapBytesL(sndLength/*theBWAVHeader.fileSize*/);	*isStereo = (swapBytesI(mybwavFmt.channels) == 2);	*theSRate = swapBytesL(mybwavFmt.sampleRate);	tempLong = swapBytesL(mybwavFmt.bytesPerSec);		switch(swapBytesI(mybwavFmt.bitsPerSample))	{		case 8:			*theWordSize = 8;		break;				case 16:			*theWordSize = 16;		break;		case 24:			*theWordSize = 24;		break;	}		 if (!( *theSRate))	 {		 *theSRate = 1L;	 }	 *theDuration = (swapBytesL(sndLength/*theWAVHeader.fileSize*/) >> *isStereo >> (((*theWordSize) / 8)-1) / *theSRate);	 	 iErr = FSClose(refNum);	 		return 1;}short xGetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);short xGetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length){	OSErr	iErr;	short refNum;	long inOutCount;	WavFmtHeaderExt theWAVHeader;	//WavFmtHeader theWAVHeader;	long tempLong;	short tempShort;	Boolean isIMA = false;	OSType myIMATest;	long mylong;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		return false;	}	inOutCount = sizeof(theWAVHeader);	iErr = FSRead(refNum,&inOutCount,&theWAVHeader);	if (iErr!=0)	{		iErr = FSClose(refNum);		return false;	}		if (theWAVHeader.fmtHead == 'fact')	{		isIMA = true;	/*	iErr = FSClose(refNum);		playIMAWAV(mySpec);		return 0;*/	}			if (isIMA)	{		if (theWAVHeader.RIFFhead != 'RIFF' || theWAVHeader.WAVEHead != 'WAVE')		{			iErr = FSClose(refNum);			return 0;		}	}	else	{		if (theWAVHeader.RIFFhead != 'RIFF' || theWAVHeader.WAVEHead != 'WAVE' || theWAVHeader.fmtHead != 'fmt ')		{			iErr = FSClose(refNum);			return 0;		}	}	*length = swapBytesL(theWAVHeader.fileSize);	*isStereo = (swapBytesI(theWAVHeader.channels) == 2);	*theSRate = swapBytesL(theWAVHeader.sampleRate);	tempLong = swapBytesL(theWAVHeader.bytesPerSec);		switch(swapBytesI(theWAVHeader.blockAlign))	{		case 1:			*theWordSize = 8;		break;				case 2:			if (*isStereo)			{				*theWordSize = 8;			}			else			{				*theWordSize = 16;			}		break;				case 4:			*theWordSize = 16;		break;	}		 if (!( *theSRate))	 {		 *theSRate = 1L;	 }	 *theDuration = (swapBytesL(theWAVHeader.fileSize) >> *isStereo >> (*theWordSize == 16)) / *theSRate;	 	 mylong = (long)(&theWAVHeader.RIFFhead) + 20 + swapBytesL(theWAVHeader.formatChunkSize);	 BlockMove ((Ptr)mylong, &myIMATest, 4L);	 if (myIMATest == 'fact')	 {		 isIMA = true;	 }	 	 	 iErr = FSClose(refNum);	 	 if (isIMA)	 {	 	return 2;	 }	 else		return 1;}Boolean WAVToSDII(FSSpec mySpec){	Fixed theRate;	short numBits,numChans;	Boolean stereo;	short sourceRef, destRef, rfRefNum, iRefNum,theWordSize;	OSErr	iErr;	long filePos,bytesTilEnd,theTote;	long inOutCount;	long audiosize,AOffset;	FSSpec theNewFile;	Str255 theComment;	Ptr mySndH;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	Boolean notDone = true;	long bytes,bytesRead = 0;		float theFloat;    short thePercent;        	if (!GetWAVInfo (mySpec,&theSRate, &theWordSize,&theDuration, &isStereo, &bytes))	{		return false;	}	iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}		filePos = findCOMM(sourceRef,'data');	if (!filePos)	{		genError ("\pCan't find data chunk");		iErr = FSClose(sourceRef);		return false;	}	iErr = SetFPos(sourceRef,1,filePos + 8L);		mySndH = NewPtr(262146L);					/** buffer a **/	if (!mySndH)	{		genError("\pNot enough memory, increase partition size, or reduce buffer in prefs");		FSClose(sourceRef);		return false;	}		stereo = isStereo;		theRate = (unsigned long)theSRate;		BlockMove (&mySpec,&theNewFile,70L);	theNewFile.parID = theConvertDestLoc.parID;	theNewFile.vRefNum = theConvertDestLoc.vRefNum;		/* strip .WAV if present */		iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)	{		if (iErr == dupFNErr)		{			if (YesNo ("\pFile Exists, overwrite ?"))			{				FSpDelete (&theNewFile);				iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);			}			else			{				return false;			}		}	}	FSpCreateResFile(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)	{		genError("\pCan't create new res file");		FSClose(sourceRef);		DisposPtr(mySndH);		return false;	}	iErr = FSpOpenDF(&theNewFile,fsWrPerm,&destRef);	if (iErr != 0)	{		genError("\pCan't create new file");		FSClose(sourceRef);		DisposPtr(mySndH);		return false;	}		progressCreate("\pConverting File");		while (notDone)	{		inOutCount = 262146L;		if (!bytes)		{			bytes = 1L;		}				if (bytesRead + inOutCount >= bytes)		{			inOutCount = bytes - bytesRead;			notDone = false;		}		theFloat = ((float)bytesRead / (float)bytes) * 100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			FSClose(sourceRef);			FSClose(destRef);			DisposPtr(mySndH);			return false;		}			iErr = FSRead(sourceRef,&inOutCount,mySndH);				if (iErr != 0 && iErr != eofErr)		{			progressDispos();			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destRef);			DisposPtr(mySndH);			return false;		}		if (iErr == eofErr)		{			notDone = false;		}				if (theWordSize == 24)			pcConv24(mySndH,inOutCount);		if (theWordSize == 16)			pcConv(mySndH,inOutCount);		if (theWordSize == 8)			pcConv8(mySndH,inOutCount);								bytesRead += inOutCount;		iErr = FSWrite(destRef,&inOutCount,mySndH);		if (iErr != 0)		{						progressDispos();			genError("\pCan't write dest file");			FSClose(sourceRef);			FSClose(destRef);			DisposPtr(mySndH);			return false;		}	}	FSClose (sourceRef);	FSClose (destRef);	progressDispos();	DisposPtr(mySndH);		writeSDIIResources(theNewFile,theSRate,isStereo,theWordSize >> 3);	/*	if (theWordSize == 24)	{		OSType wavSuff;		BlockMove (mySpec.name + (*mySpec.name - 3L), &wavSuff,4L);		if (wavSuff == '.wav' || wavSuff == '.WAV')		{			Str255 newName;			makeStr255 (theNewFile.name, newName);			*newName = *newName - 4;			iErr = FSpRename(&theNewFile,newName);			makeStr255 (newName,theNewFile.name);		}	}*/	createSDIIOverview(theNewFile,0x00000100);	addFileToList(theNewFile);	GetFSComment(mySpec, theComment);	SetComment (theNewFile,0, theComment);	return true;	}Boolean AIFFToSDII(FSSpec mySpec){	Fixed theRate;	short numBits,numChans;	Boolean stereo;	short sourceRef, destRef, rfRefNum, iRefNum;	OSErr	iErr;	long filePos,bytesTilEnd,theTote;	CommonChunk	myCommCnk;	long inOutCount;	long audiosize,AOffset;	FSSpec theNewFile;	Str255 theComment;	Handle mySndH;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	long theXRate;	short theWordSize;	short channels; 	long theBytes;	getAIFFDataII (mySpec,&theXRate, &theWordSize,&channels, &theBytes);	extraA = 0x00010000;	extraB = 0x00000000;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'AIFF')	{		SysBeep(5);		return false;	}			GetSampleRateTime (mySpec,0,0L,&theSRate, &theDuration, &isStereo,'AIFF');	iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}		filePos = findCOMM(sourceRef,'COMM');	filePos = theTXFERLong;	if (!filePos)	{		genError ("\pCan't find common chunk");		iErr = FSClose(sourceRef);		if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	inOutCount = sizeof (CommonChunk);	iErr = SetFPos(sourceRef,1,filePos);	iErr = FSRead(sourceRef,&inOutCount,&myCommCnk);	if (iErr!=0)	{		genError ("\pCan't read comm chunk from file");		iErr = FSClose(sourceRef);		if (iErr!=0)			genErrorN("\pError closing DF",iErr);		return false;	}	iErr = SetFPos(sourceRef,1,0L);		filePos = findCOMM(sourceRef,'SSND');	if (!filePos)	{		genError ("\pCan't find SSND chunk");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	filePos += 4L;	inOutCount = 4L;	iErr = SetFPos(sourceRef,1,filePos);	iErr = FSRead(sourceRef,&inOutCount,&audiosize);	if (iErr!=0)	{		genError ("\pCan't read audio size from file");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	iErr = FSRead(sourceRef,&inOutCount,&AOffset);	if (iErr!=0)	{		genError ("\pCan't read AOffset from file");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	if (false /*AOffset*/)	{		genError ("\pThis type of AIFF is not yet supported");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	filePos += 4L;	iErr = SetFPos(sourceRef,1,filePos);		mySndH = NewHandle(32768L);					/** buffer a **/	if (!mySndH)	{		genError("\pNot enough memory, increase partition size, or reduce buffer in prefs");		FSClose(sourceRef);		return false;	}		stereo = (myCommCnk.numChannels == 2);	numBits = myCommCnk.sampleSize / 8;	bytesTilEnd = audiosize;			theRate = (unsigned long)theXRate; //myCommCnk.sampleRate;		BlockMove (&mySpec,&theNewFile,70L);		theNewFile.parID = theConvertDestLoc.parID;	theNewFile.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theNewFile);					iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}	FSpCreateResFile(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)	{		genError("\pCan't create new res file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	iErr = FSpOpenDF(&theNewFile,fsWrPerm,&destRef);	if (iErr != 0)	{		genError("\pCan't create new file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	theTote = bytesTilEnd;	progressCreate("\pConverting File");	while (bytesTilEnd> 0L)	{		inOutCount = 32000L;		if (inOutCount > bytesTilEnd)			inOutCount = bytesTilEnd;		if (progressDisp(((theTote - bytesTilEnd)*100)/theTote))		{			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}			iErr = FSRead(sourceRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}		iErr = FSWrite(destRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't write dest file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}		bytesTilEnd -= inOutCount;	}	FSClose (sourceRef);	FSClose (destRef);	progressDispos();	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&theNewFile,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		DisposHandle(mySndH);		return false;	}	UseResFile (rfRefNum);	DisposHandle(mySndH);		theRate = theRate << 16;		NumToString((long)(stereo+1),theStringa);	NumToString((long)numBits,theStringb);	thefirstbit = ((unsigned long)theRate >> 16L);	thesecondbit = (unsigned long)(theRate & 0x0000FFFF);	NumToString(thefirstbit,theStringc);	NumToString(thesecondbit,theStringd);	if (*theStringd == 1 && *(theStringd+1) == '0')	{		makeStr255("\p0000",theStringd);	}	concatStrings(theStringc,theStringd,"\p.");	h1 = NewString(theStringa);	h2 = NewString(theStringb);	h3 = NewString(theStringc);		AddResource((Handle)h2,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h1,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add str 1002");		UseResFile(iRefNum);		return false;	}		theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile(rfRefNum);	UseResFile(iRefNum);	/*FSpDelete(&mySpec);	iErr = FSpRename(&theNewFile,mySpec.name);*/		addFileToList(theNewFile);	GetFSComment(mySpec, theComment);	SetComment (theNewFile,0,  theComment);	return true;	}Boolean ConvertAIFFToSDII(FSSpec mySpec, FSSpec destSpec);Boolean ConvertAIFFToSDII(FSSpec mySpec, FSSpec destSpec){	Fixed theRate;	short numBits,numChans;	Boolean stereo;	short sourceRef, destRef, rfRefNum, iRefNum;	OSErr	iErr;	long filePos,bytesTilEnd,theTote;	CommonChunk	myCommCnk;	long inOutCount;	long audiosize,AOffset;	FSSpec theNewFile;	Str255 theComment;	Handle mySndH;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	long theXRate;	short theWordSize;	short channels; 	long theBytes;	getAIFFDataII (mySpec,&theXRate, &theWordSize,&channels, &theBytes);	extraA = 0x00010000;	extraB = 0x00000000;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (fndrInfo.fdType != 'AIFF')	{		SysBeep(5);		return false;	}			GetSampleRateTime (mySpec,0,0L,&theSRate, &theDuration, &isStereo,'AIFF');	iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}		filePos = findCOMM(sourceRef,'COMM');	filePos = theTXFERLong;	if (!filePos)	{		genError ("\pCan't find common chunk");		iErr = FSClose(sourceRef);		if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	inOutCount = sizeof (CommonChunk);	iErr = SetFPos(sourceRef,1,filePos);	iErr = FSRead(sourceRef,&inOutCount,&myCommCnk);	if (iErr!=0)	{		genError ("\pCan't read comm chunk from file");		iErr = FSClose(sourceRef);		if (iErr!=0)			genErrorN("\pError closing DF",iErr);		return false;	}	iErr = SetFPos(sourceRef,1,0L);		filePos = findCOMM(sourceRef,'SSND');	if (!filePos)	{		genError ("\pCan't find SSND chunk");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	filePos += 4L;	inOutCount = 4L;	iErr = SetFPos(sourceRef,1,filePos);	iErr = FSRead(sourceRef,&inOutCount,&audiosize);	if (iErr!=0)	{		genError ("\pCan't read audio size from file");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	iErr = FSRead(sourceRef,&inOutCount,&AOffset);	if (iErr!=0)	{		genError ("\pCan't read AOffset from file");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	if (false /*AOffset*/)	{		genError ("\pThis type of AIFF is not yet supported");		iErr = FSClose(sourceRef);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return false;	}	filePos += 4L;	iErr = SetFPos(sourceRef,1,filePos);		mySndH = NewHandle(32768L);					/** buffer a **/	if (!mySndH)	{		genError("\pNot enough memory, increase partition size, or reduce buffer in prefs");		FSClose(sourceRef);		return false;	}		stereo = (myCommCnk.numChannels == 2);	numBits = myCommCnk.sampleSize / 8;	bytesTilEnd = audiosize;			theRate = (unsigned long)theXRate; //myCommCnk.sampleRate;		BlockMove (destSpec.name,theNewFile.name,*destSpec.name + 1);	theNewFile.parID = destSpec.parID;	theNewFile.vRefNum = destSpec.vRefNum;		iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theNewFile);					iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}	FSpCreateResFile(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)	{		genError("\pCan't create new res file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	iErr = FSpOpenDF(&theNewFile,fsWrPerm,&destRef);	if (iErr != 0)	{		genError("\pCan't create new file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	theTote = bytesTilEnd;	progressCreate("\pConverting File");	while (bytesTilEnd> 0L)	{		inOutCount = 32000L;		if (inOutCount > bytesTilEnd)			inOutCount = bytesTilEnd;		if (progressDisp(((theTote - bytesTilEnd)*100)/theTote))		{			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}			iErr = FSRead(sourceRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}		iErr = FSWrite(destRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't write dest file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}		bytesTilEnd -= inOutCount;	}	FSClose (sourceRef);	FSClose (destRef);	progressDispos();	iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&theNewFile,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		DisposHandle(mySndH);		return false;	}	UseResFile (rfRefNum);	DisposHandle(mySndH);		theRate = theRate << 16;		NumToString((long)(stereo+1),theStringa);	NumToString((long)numBits,theStringb);	thefirstbit = ((unsigned long)theRate >> 16L);	thesecondbit = (unsigned long)(theRate & 0x0000FFFF);	NumToString(thefirstbit,theStringc);	NumToString(thesecondbit,theStringd);	if (*theStringd == 1 && *(theStringd+1) == '0')	{		makeStr255("\p0000",theStringd);	}	concatStrings(theStringc,theStringd,"\p.");	h1 = NewString(theStringa);	h2 = NewString(theStringb);	h3 = NewString(theStringc);		AddResource((Handle)h2,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h1,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add str 1002");		UseResFile(iRefNum);		return false;	}		theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile(rfRefNum);	UseResFile(iRefNum);	/*FSpDelete(&mySpec);	iErr = FSpRename(&theNewFile,mySpec.name);*/	//	addFileToList(theNewFile);	GetFSComment(mySpec, theComment);	SetComment (theNewFile, 0, theComment);	return true;	}void getConvertDest(void);Boolean convertInPlace;Boolean ConvertMany(void){	Cell theCell;	short theindex;	short myshort;		Boolean memoryError = false;			getConvertDest();	SetPt( &theCell, 0,0 );		writeLogS((unsigned char *)"Began AIFFtoSDII Convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (AIFFToSDII((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean WAVtoSDIIMany(void){	Cell theCell;	short theindex;	short myshort;		Boolean memoryError = false;			getConvertDest();	SetPt( &theCell, 0,0 );		writeLogS((unsigned char *)"Began WAVtoSDII Convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (WAVToSDII((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean truncateFilenames;void SDIItoWavMany(void){	Cell theCell;	short theindex;	Boolean writeName = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean memoryError = false;	truncateFilenames = true;		/****************/	myDlg = GetNewDialog(11115,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				writeName = false;			break;						case 4:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				writeName = true;			break;						case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;		}	}while (itemHit != 1 && itemHit != 2);		GetDItem(myDlg,5,&iType,&iHndl,&iRect);	truncateFilenames = GetCtlValue((ControlHandle)iHndl);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;					getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting SDII to WAV convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDIItoWAV((*therealResults)[theindex], writeName))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}void SDIItoPCRawMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;		getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting SDII to RAW convert");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDIItoPCRaw((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean SDIItoPCRaw(FSSpec sourceSpec){	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destRef;	FSSpec destSpec;	Str255 destName;	long theSourcePos;	long theDestPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType fileExt = '.RAW';	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer;	long z, infoLength, theTempLong;	Boolean addFill;		iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return ;	}	if (getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;			if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	BlockMove (&sourceSpec,&destSpec,70L);	/*	if (*destSpec.name < 12)	{		for (z= *destSpec.name;z<=12L;z++)		{			*(destSpec.name + z + 1L) = ' ';		}	}		*destSpec.name = 12;	BlockMove (&fileExt, destSpec.name + 9L,4L);*/			BlockMove (&fileExt, destSpec.name + *destSpec.name + 1,4L);		*destSpec.name += 4L;			iErr = -1;	escCount = 0;		destSpec.parID = theConvertDestLoc.parID;	destSpec.vRefNum = theConvertDestLoc.vRefNum;	while (iErr != 0 && escCount<254)	{		iErr = FSpCreate(&destSpec,'MgAl','raw ',0);		if (iErr)		{			//(*(destSpec.name + 8L))++;			(*(destSpec.name + (*destSpec.name - 4)))++;			escCount ++;		}	}	if (escCount>=254)		return false;		iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRef);		if (iErr != 0)		return false;	iErr = FSpOpenDF(&sourceSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(32768L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 32000L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		if (theWordSize == 2)			pcConv(theBuffer,inOutCount);		if (theWordSize == 1)			pcConv8(theBuffer,inOutCount);		eErr = FSWrite(destRef,&inOutCount,theBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destRef);	DisposPtr(theBuffer);		addFileToList(destSpec);	return true;}Boolean SDIItoWAV(FSSpec sourceSpec, Boolean writeName){	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destRef;	FSSpec destSpec;	Str255 destName;	long theSourcePos;	long theDestPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType fileExt = '.WAV';	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer;	long z, infoLength, theTempLong;	Boolean addFill;		iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}	if (getSDIIData (sourceSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	BlockMove (&sourceSpec,&destSpec,70L);		if (truncateFilenames)	{		if (*destSpec.name < 12)		{			for (z= *destSpec.name;z<=12L;z++)			{				*(destSpec.name + z + 1L) = ' ';			}		}				*destSpec.name = 12;		BlockMove (&fileExt, destSpec.name + 9L,4L);	}	else	{		BlockMove (&fileExt, destSpec.name + *(destSpec.name) + 1,4L);		*(destSpec.name) += 4;	}		iErr = -1;	escCount = 0;	destSpec.parID = theConvertDestLoc.parID;	destSpec.vRefNum = theConvertDestLoc.vRefNum;		while (iErr != 0 && escCount<254)	{		iErr = FSpCreate(&destSpec,writeName ? 'BSnd' : 'Sd2a',writeName ? 'bin ' : '.WAV',0);		if (iErr)		{			(*(destSpec.name + 8L))++;			escCount ++;		}	}	if (escCount>=254)		return false;		iErr = FSpOpenDF(&destSpec,fsWrPerm,&destRef);		if (iErr != 0)		return false;	iErr = FSpOpenDF(&sourceSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	infoLength = 16L + *(sourceSpec.name) + 1L;	if (!((infoLength / 2L) * 2L == infoLength))	{		infoLength++;		addFill = true;	}	else	{		addFill = false;	}			theChars = 'RIFF';	inOutCount = 4L;	iErr = FSWrite(destRef,&inOutCount,&theChars);	if (iErr != 0)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteL(destRef,theBytes + (writeName ? (36L + infoLength) : 36L)))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	theChars = 'WAVE';	inOutCount = 4L;	iErr = FSWrite(destRef,&inOutCount,&theChars);	if (iErr != 0)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	theChars = 'fmt ';	inOutCount = 4L;	iErr = FSWrite(destRef,&inOutCount,&theChars);	if (iErr != 0)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteL(destRef,16L))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteI(destRef,1))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteI(destRef,(short)(stereo+1)))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteL(destRef,theRate))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteL(destRef,theRate * (long)(stereo+1) * (long)theWordSize))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteI(destRef,((stereo + 1) * (theWordSize * 8))/8))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteI(destRef,theWordSize * 8))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (writeName)	{		theChars = 'INFO';		inOutCount = 4L;		iErr = FSWrite(destRef,&inOutCount,&theChars);		if (iErr != 0)		{			FSClose (sourceRef);			FSClose (destRef);			FSpDelete (&destSpec);			return false;		}		if (!PCWriteL(destRef,infoLength-8L))		{			FSClose (sourceRef);			FSClose (destRef);			FSpDelete (&destSpec);			return false;		}		theChars = 'INAM';		inOutCount = 4L;		iErr = FSWrite(destRef,&inOutCount,&theChars);		if (iErr != 0)		{			FSClose (sourceRef);			FSClose (destRef);			FSpDelete (&destSpec);			return false;		}		if (!PCWriteL(destRef,infoLength-16L))		{			FSClose (sourceRef);			FSClose (destRef);			FSpDelete (&destSpec);			return false;		}		theTempLong = (long)(&(sourceSpec.name)) + (long)(*(sourceSpec.name)) + 1L;		*((char *)theTempLong) = 0x00;		if (addFill)		{			theTempLong = (long)(&(sourceSpec.name)) + (long)(*(sourceSpec.name)) + 2L;			*((char *)theTempLong) = 0x1A;		}		inOutCount = *(sourceSpec.name) + 1L + (long)addFill;		iErr = FSWrite(destRef,&inOutCount,sourceSpec.name + 1L);		if (iErr != 0)		{			FSClose (sourceRef);			FSClose (destRef);			FSpDelete (&destSpec);			return false;		}	}		theChars = 'data';	inOutCount = 4L;	iErr = FSWrite(destRef,&inOutCount,&theChars);	if (iErr != 0)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	if (!PCWriteL(destRef,theBytes))	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	/* now enter the data */	theBuffer = NewPtr(262144L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destRef);		FSpDelete (&destSpec);		return false;	}	iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 262144L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		if (theWordSize == 2)			pcConv(theBuffer,inOutCount);		if (theWordSize == 1)			pcConv8(theBuffer,inOutCount);		eErr = FSWrite(destRef,&inOutCount,theBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destRef);	DisposPtr(theBuffer);		addFileToList(destSpec);	return true;}OSErr data24to16(Ptr theBuff, long * inOutCount){	long theSrcCount, destCount;	Byte tempStor;	destCount = 0;	for (theSrcCount = 0;theSrcCount< *inOutCount;theSrcCount+=3L)	{		theBuff[destCount] = theBuff[theSrcCount];		theBuff[destCount+1] = theBuff[theSrcCount+1];		destCount += 2;	}	*inOutCount = destCount;	return true;}Boolean pcConv24(Ptr theBuff, long inOutCount){	long theCount;	Byte tempStor;	for (theCount = 0;theCount< inOutCount;theCount+=3L)	{		tempStor = theBuff[theCount + 2];		theBuff[theCount + 2] = theBuff[theCount];		theBuff[theCount] = tempStor;	}	return true;}Boolean pcConv(Ptr theBuff, long inOutCount){	long theCount;		for (theCount = (long)theBuff;theCount< ((long)theBuff + inOutCount);theCount+=2L)   {     	*(short *)(theCount) = *(Byte *)(theCount) | (*(Byte *)(theCount + 1) << 8);   }   return true;}Boolean pcConv8(Ptr theBuff,long inOutCount){		long thePos;	short theSample;		for (thePos = 0L;thePos < inOutCount;thePos ++)	{		*((char *)(theBuff+thePos)) += (char)0x80;	}	return true;}unsigned short swapBytesI(unsigned short theInt){	return (theInt << 8) | (theInt >> 8);}unsigned long swapBytesL(unsigned long inLong){		return ((long)(swapBytesI(HiWord(inLong))) | (((long)(swapBytesI(LoWord(inLong))))<<16));}Boolean PCWriteL(short destRef,long theBytes){	long inOutCount = 4L;	OSErr	iErr;		theBytes = swapBytesL(theBytes);	iErr = FSWrite (destRef,&inOutCount,&theBytes);	return (!iErr);}Boolean PCWriteI(short destRef,short theBytes){	long inOutCount = 2L;	OSErr	iErr;		theBytes = swapBytesI(theBytes);	iErr = FSWrite (destRef,&inOutCount,&theBytes);	return (!iErr);}Boolean SDIIStereoToMonoLR(FSSpec theSpec);Boolean SDIIStereoToMonoMix(FSSpec theSpec);Str255 theNewName;Boolean RemoveNameChars(FSSpec theSpec, Str255 theText){	char* occur;	Str255 theOtherString;	long offset;	long theTextLen = *theText;		BlockMove(theSpec.name,theOtherString,*(theSpec.name)+1);	P2CStr (theText);	P2CStr(theOtherString);	occur = strstr((const char *)theOtherString,(const char *)theText);	if (!occur)		return false;	offset = (long)occur - (long)theOtherString;	BlockMove (theOtherString,theNewName,offset);	BlockMove (theOtherString+offset+theTextLen,theNewName+offset,120L);	*(theNewName+offset+118) = 0;	C2PStr((Ptr)theNewName);	*theNewName = *theSpec.name - theTextLen;	FSpRename(&theSpec,theNewName);	return true;}void RemoveNameCharsMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr, presText;	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(1806,0L,(WindowPtr)-1);	SetPort (myDlg);		ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);	}while (itemHit != 1 && itemHit != 2);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,textStr);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;	writeLogS((unsigned char *)"Starting Remove name chars");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		BlockMove (textStr,presText,(*textStr)+1);		if(RemoveNameChars((*therealResults)[theindex],textStr))		{			short theTextLength = *theNewName;			P2CStr(theNewName);			LDoDraw(true,myList);			LSetCell(theNewName,theTextLength,theCell,myList);			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Rename :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		BlockMove (presText,textStr,(*presText)+1);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}void SDIIStereoToMonoMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(11111,0L,(WindowPtr)-1);	SetPort (myDlg);	switch (theNewPrefs.theStereoMonoXLatePrefs.mixOrDeinterleave)	{		case kDeinterleaveStereoToSplit:			GetDItem(myDlg,3,&iType,&iHndl,&iRect);			SetCtlValue((ControlHandle)iHndl,true);				mixMode = false;		break;		case kMixStereoToMono:			GetDItem(myDlg,4,&iType,&iHndl,&iRect);			SetCtlValue((ControlHandle)iHndl,true);				mixMode = true;		break;		default:		break;	}			GetDItem(myDlg,8,&iType,&iHndl,&iRect);	SetIText(iHndl,theNewPrefs.theStereoMonoXLatePrefs.leftSuffix);			GetDItem(myDlg,9,&iType,&iHndl,&iRect);	SetIText(iHndl,theNewPrefs.theStereoMonoXLatePrefs.rightSuffix);				ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				mixMode = false;				theNewPrefs.theStereoMonoXLatePrefs.mixOrDeinterleave = kDeinterleaveStereoToSplit;			break;						case 4:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				mixMode = true;				theNewPrefs.theStereoMonoXLatePrefs.mixOrDeinterleave = kMixStereoToMono;			break;		}	}while (itemHit != 1 && itemHit != 2);				GetDItem(myDlg,8,&iType,&iHndl,&iRect);	GetIText(iHndl,leftSuffixStr);		GetIText(iHndl,theNewPrefs.theStereoMonoXLatePrefs.leftSuffix);			GetDItem(myDlg,9,&iType,&iHndl,&iRect);	GetIText(iHndl,rightSuffixStr);		GetIText(iHndl,theNewPrefs.theStereoMonoXLatePrefs.rightSuffix);			DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;						getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	writeLogS((unsigned char *)"Starting SDII Stereo to Mono");	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (!mixMode)		{			if (SDIIStereoToMonoLR((*therealResults)[theindex]))			{				writeLog((Ptr)(*therealResults)[theindex].name);				}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}		}		else		{			if (SDIIStereoToMonoMix((*therealResults)[theindex]))			{				writeLog((Ptr)(*therealResults)[theindex].name);				}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}extern FSSpec theNewFileLeft, theNewFileRight;typedef struct Word24Bit {	Byte MSB;	Byte Middle;	Byte LSB;} Word24Bit;Boolean SDIIStereoToMonoLR24(FSSpec theSpec){	FSSpec destLSpec, destRSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, destRRef, iRefNum, rfRefNum;	long theSourcePos;	long theDestLPos, theDestRPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount,bytesWritten = 0;	Ptr theBuffer, theLBuffer,theRBuffer;	long z, infoLength, theTempLong;	float theFloat;    short thePercent;	Str255 theComment;	Word24Bit sourceWord, leftWord, rightWord;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;	if (!stereo)		return false;		BlockMove (&theSpec,&destLSpec,70L);	BlockMove (&theSpec,&destRSpec,70L);	*destLSpec.name = ((*destLSpec.name + *leftSuffixStr) > 31) ? (31 - (*leftSuffixStr)) : *destLSpec.name;concatStrings (destLSpec.name,leftSuffixStr,"\p");*destRSpec.name = ((*destRSpec.name + *rightSuffixStr) > 31) ? (31 - (*rightSuffixStr)) : *destRSpec.name;concatStrings (destRSpec.name,rightSuffixStr,"\p");	/*if (*destLSpec.name < 27)		concatStrings (destLSpec.name,leftSuffixStr,"\p");	else		*(destLSpec.name+1) = '~';			if (*destRSpec.name < 26)		concatStrings (destRSpec.name,rightSuffixStr,"\p");	else		*(destLSpec.name+1) = '*';*/			destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;	destRSpec.parID = theConvertDestLoc.parID;	destRSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}			iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destRSpec);					iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}				BlockMove (&destLSpec,&theNewFileLeft,70L);	BlockMove (&destRSpec,&theNewFileRight,70L);	iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;			iErr = FSpOpenDF(&destRSpec,fsWrPerm,&destRRef);		if (iErr != 0)		return false;					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(131070L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}	theLBuffer = NewPtr(65535L);	if (!theLBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}	theRBuffer = NewPtr(65535L);	if (!theRBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}	iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 131070L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		for (z=0;z<=inOutCount;z+=6L)		{			//	leftWord = *(Word24Bit *)(theBuffer + z);			//	rightWord = *(Word24Bit *)(theBuffer + z + 3L);			*(Word24Bit *)(theLBuffer + (z>>1)) = *(Word24Bit *)(theBuffer + z);			*(Word24Bit *)(theRBuffer + (z>>1)) = *(Word24Bit *)(theBuffer + z + 3L);		}		inOutCount = inOutCount >> 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);		bytesWritten += inOutCount;		eErr = FSWrite(destRRef,&inOutCount,theRBuffer);		bytesWritten += inOutCount;				theFloat = ((float)bytesWritten / (float)theBytes) * 100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			watchcursor(false);			FSClose (sourceRef);			FSClose (destLRef);			FSClose (destRRef);			DisposPtr(theBuffer);			DisposPtr(theLBuffer);			DisposPtr(theRBuffer);						return false;		}	}		watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	FSClose (destRRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	DisposPtr(theRBuffer);	progressDispos();	writeSDIIResources(destLSpec,theRate,false,theWordSize);	writeSDIILoopsMarkers(destLSpec);	writeSDIIResources(destRSpec,theRate,false,theWordSize);	writeSDIILoopsMarkers(destRSpec);	copySDIIRegionsNoConversion (theSpec,destLSpec);	copySDIIRegionsNoConversion (theSpec,destRSpec);		GetFSComment(theSpec, theComment);		SetComment (destLSpec,0,  theComment);		SetComment (destRSpec,0,  theComment);	addFileToList(destLSpec);	addFileToList(destRSpec);	return true;}						Boolean SDIIStereoToMonoLR(FSSpec theSpec){	FSSpec destLSpec, destRSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, destRRef, iRefNum, rfRefNum;	Str255 destLName, destRName, num8Bits = "\p1", num16Bits = "\p2",rate,StereoMono = "\p1";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos, theDestRPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount,bytesWritten = 0;	Ptr theBuffer, theLBuffer,theRBuffer;	long z, infoLength, theTempLong;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	float theFloat;    short thePercent;	Str255 theComment;	extraA = 0x00010000;	extraB = 0x00000000;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;	if (!stereo)		return false;		if (theWordSize == 3)	{		return SDIIStereoToMonoLR24(theSpec);	}	BlockMove (&theSpec,&destLSpec,70L);	BlockMove (&theSpec,&destRSpec,70L);		/*if (*destLSpec.name < 27)		concatStrings (destLSpec.name,leftSuffixStr,"\p");	else		*(destLSpec.name+1) = '~';			if (*destRSpec.name < 26)		concatStrings (destRSpec.name,rightSuffixStr,"\p");	else		*(destLSpec.name+1) = '*';*/*destLSpec.name = ((*destLSpec.name + *leftSuffixStr) > 31) ? (31 - (*leftSuffixStr)) : *destLSpec.name;concatStrings (destLSpec.name,leftSuffixStr,"\p");*destRSpec.name = ((*destRSpec.name + *rightSuffixStr) > 31) ? (31 - (*rightSuffixStr)) : *destRSpec.name;concatStrings (destRSpec.name,rightSuffixStr,"\p");			destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;	destRSpec.parID = theConvertDestLoc.parID;	destRSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}			iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destRSpec);					iErr = FSpCreate(&destRSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}				BlockMove (&destLSpec,&theNewFileLeft,70L);	BlockMove (&destRSpec,&theNewFileRight,70L);	iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;			iErr = FSpOpenDF(&destRSpec,fsWrPerm,&destRRef);		if (iErr != 0)		return false;					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(131072L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}	theLBuffer = NewPtr(65536L);	if (!theLBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}	theRBuffer = NewPtr(65536L);	if (!theRBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		FSClose (destRRef);		FSpDelete (&destRSpec);		return false;	}	iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 131072L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		for (z=0;z<inOutCount;z+=4L)		{			switch (theWordSize)			{				case 2:					*(short *)(theLBuffer + (z>>1)) = *(short *)(theBuffer + z);					*(short *)(theRBuffer + (z>>1)) = *(short *)(theBuffer + z + 2L);				break;				case 1:					*(Byte *)(theLBuffer + (z>>2)) = *(Byte *)(theBuffer + z);					*(Byte *)(theRBuffer + (z>>2)) = *(Byte *)(theBuffer + z + 1L);					*(Byte *)(theLBuffer + (z>>2) + 1L) = *(Byte *)(theBuffer + z + 2L);					*(Byte *)(theRBuffer + (z>>2) + 1L) = *(Byte *)(theBuffer + z + 3L);				break;			}		}		inOutCount = inOutCount >> 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);		bytesWritten += inOutCount;		eErr = FSWrite(destRRef,&inOutCount,theRBuffer);		bytesWritten += inOutCount;				theFloat = ((float)bytesWritten / (float)theBytes) * 100;    	thePercent = theFloat;		if (progressDisp(thePercent))		{			watchcursor(false);			FSClose (sourceRef);			FSClose (destLRef);			FSClose (destRRef);			DisposPtr(theBuffer);			DisposPtr(theLBuffer);			DisposPtr(theRBuffer);						return false;		}	}		watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	FSClose (destRRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	DisposPtr(theRBuffer);	progressDispos();	NumToString (theRate, rate);	concatStrings(rate,"\p0000","\p.");		FSpCreateResFile(&destLSpec,'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr != 0)	{		genError("\pCan't create new res file");		return false;	}	FSpCreateResFile(&destRSpec,'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr != 0)	{		genError("\pCan't create new res file");		return false;	}		iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&destLSpec,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		return false;	}	UseResFile (rfRefNum);		h1 = NewString((theWordSize == 2) ? num16Bits : num8Bits);	h2 = NewString(rate);	*(StereoMono + 1) = '1';	h3 = NewString(StereoMono);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{			genError ("\pCan't Add str 1002");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile (rfRefNum);	rfRefNum = FSpOpenResFile(&destRSpec,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");				return false;	}	UseResFile (rfRefNum);	h1 = NewString((theWordSize == 2) ? num16Bits : num8Bits);	h2 = NewString(rate);	h3 = NewString(StereoMono);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");				CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add str 1002");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}		theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile (rfRefNum);	UseResFile (iRefNum);	copySDIIRegionsNoConversion (theSpec,destLSpec);	copySDIIRegionsNoConversion (theSpec,destRSpec);		GetFSComment(theSpec, theComment);		SetComment (destLSpec, 0, theComment);		SetComment (destRSpec, 0, theComment);	addFileToList(destLSpec);	addFileToList(destRSpec);	return true;}Boolean SDIIStereoToMonoMix24(FSSpec theSpec){	FSSpec destLSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, iRefNum, rfRefNum;	long theSourcePos;	long theDestLPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer, theLBuffer;	long z, infoLength, theTempLong;	Word24Bit sourceWord, leftWord, rightWord;	long myLLong,myRLong,myMixLong;	Str255 theComment;	iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')		return false;	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))	{		genError("\pCan't Get Info");		return false;	}			if (!stereo)	{		genError("\pNot a stereo file");		return false;	}			BlockMove (&theSpec,&destLSpec,70L);		if (*destLSpec.name < 26)		concatStrings (destLSpec.name,"\p[Mix]","\p");	else		*(destLSpec.name + 1L) = '~';			destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}						iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)	{		return false;	}					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(131070L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}	theLBuffer = NewPtr(65535L);	if (!theLBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 131070L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		for (z=0;z<inOutCount;z+=6L)		{							//Word24Bit sourceWord, leftWord, rightWord;			leftWord = *(Word24Bit *)(theBuffer + z);			rightWord = *(Word24Bit *)(theBuffer + z + 3L);						/*BlockMove(theBuffer + z,&the16Left,2L);			BlockMove(theBuffer + z + 2L,&the16Right,2L);*/						myLLong = (long)(leftWord.MSB << 16) + (leftWord.Middle << 8) + (leftWord.LSB);			myRLong = (long)(rightWord.MSB << 16) + (rightWord.Middle << 8) + (rightWord.LSB);			myMixLong = (myLLong + myRLong) >> 1;						//*(short *)(theLBuffer + (z>>1)) = the16Mono;						//BlockMove(&the16Mono,theLBuffer + (z>>1), 2L);		}		inOutCount = inOutCount >> 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	copySDIIRegionsNoConversion (theSpec,destLSpec);		GetFSComment(theSpec, theComment);		SetComment (destLSpec,0, theComment);	addFileToList(destLSpec);	return true;}Boolean SDIIStereoToMonoMix(FSSpec theSpec){	FSSpec destLSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, iRefNum, rfRefNum;	Str255 destLName, num8Bits = "\p1",  num16Bits = "\p2", rate,StereoMono = "\p1";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer, theLBuffer;	long z, infoLength, theTempLong;	short the16Left,the16Right, the16Mono;	SignedByte the8Left,the8Right, the8Mono;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	Handle theLoops = 0;	Handle theMarkers = 0;	Str255 theComment;		extraA = 0x00010000;	extraB = 0x00000000;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')		return false;	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))	{		genError("\pCan't Get Info");		return false;	}	if (theWordSize == 3)	{		return SDIIStereoToMonoMix24(theSpec);	}			if (!stereo)	{		genError("\pNot a stereo file");		return false;	}			BlockMove (&theSpec,&destLSpec,70L);		if (*destLSpec.name < 26)		concatStrings (destLSpec.name,"\p[Mix]","\p");	else		*(destLSpec.name + 1L) = '~';			destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}						iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)	{		return false;	}					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(32768L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}	theLBuffer = NewPtr(17000L);	if (!theLBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 32000L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		for (z=0;z<inOutCount;z+=4L)		{				if (theWordSize == 2)				{					the16Left = *(short *)(theBuffer + z);					the16Right = *(short *)(theBuffer + z + 2L);										/*BlockMove(theBuffer + z,&the16Left,2L);					BlockMove(theBuffer + z + 2L,&the16Right,2L);*/										the16Mono = (short)(((long)the16Left + (long)the16Right) >> 1);										*(short *)(theLBuffer + (z>>1)) = the16Mono;										//BlockMove(&the16Mono,theLBuffer + (z>>1), 2L);				}				else				{					the8Left = *(Byte *)(theBuffer + z);					the8Right = *(Byte *)(theBuffer + z + 1L);										/*BlockMove(theBuffer + z,&the8Left,1L);					BlockMove(theBuffer + z + 1L,&the8Right,1L);*/										the8Mono = (Byte)(((short)the8Left + (short)the8Right) >> 1);										*(Byte *)(theLBuffer + (z>>1)) = the8Mono;										//BlockMove(&the8Mono,theLBuffer + (z>>1), 1L);										the8Left = *(Byte *)(theBuffer + z + 2L);					the8Right = *(Byte *)(theBuffer + z + 3L);					*(Byte *)(theLBuffer + (z>>1)) = the8Mono;					/*BlockMove(theBuffer + z + 2L,&the8Left,1L);					BlockMove(theBuffer + z + 3L,&the8Right,1L);*/										the8Mono = (Byte)(((short)the8Left + (short)the8Right) >> 1);					*(Byte *)(theLBuffer + (z>>1) + 1L) = the8Mono;					//BlockMove(&the8Mono,theLBuffer + (z>>1) + 1L, 1L);				}		}		inOutCount = inOutCount >> 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	NumToString (theRate, rate);	concatStrings(rate,"\p0000","\p.");		iRefNum = CurResFile();			rfRefNum = FSpOpenResFile(&theSpec,fsRdPerm);	if (rfRefNum == -1)	{		genError("\pCan't open source res file");		return false;	}		theLoops = Get1Resource('sdLL',1000);	if (theLoops)	{		DetachResource(theLoops);	}	theMarkers = Get1Resource('sdML',1000);	if (theMarkers)	{		DetachResource(theMarkers);	}	CloseResFile(rfRefNum);			FSpCreateResFile(&destLSpec,'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr != 0)	{		genError("\pCan't create new res file");		return false;	}		rfRefNum = FSpOpenResFile(&destLSpec,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		return false;	}	UseResFile (rfRefNum);	h1 = NewString((theWordSize == 2) ? num16Bits : num8Bits);	h2 = NewString(rate);	*(StereoMono +1L) = '1';	h3 = NewString(StereoMono);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{			genError ("\pCan't Add str 1002");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);		if (theMarkers)	{		AddResource((Handle)theMarkers,'sdML',1000,"\p");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't Add markers");			UseResFile(iRefNum);			return false;		}		DisposHandle(theExtraHandleA);	}	else	{		AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't Add markers");			UseResFile(iRefNum);			return false;		}	}			if (theLoops)	{		AddResource((Handle)theLoops,'sdLL',1000,"\p");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't Add loops");			UseResFile(iRefNum);			return false;		}		DisposHandle(theExtraHandleB);	}	else	{		AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't Add loops");			UseResFile(iRefNum);			return false;		}	}	CloseResFile (rfRefNum);	UseResFile (iRefNum);	copySDIIRegionsNoConversion (theSpec,destLSpec);	GetFSComment(theSpec, theComment);	SetComment (destLSpec, 0, theComment);	addFileToList(destLSpec);	return true;}OSErr QuickTimetoAIFFMany(void){	Cell theCell;	short theindex;	OSErr	iErr;	Boolean memoryError = false;		getConvertDest();	writeLogS((unsigned char *)"Starting QT to AIFF convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		iErr = EnterMovies();		if (iErr) return;		if (QuickTimetoAIFF((*therealResults)[theindex]))		{				writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		ExitMovies();		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean QuickTimetoAIFF(FSSpec theSpec){	OSErr err,iErr;	StandardFileReply reply, putFile;	OSType movieType = MovieFileType;	MenuHandle mh = GetMenu(kExportMenu);	ComponentDescription cd;	Component c = 0;	Point where = {0,0};	Str255 newName,theComment;	short convertItem = 1;	Component **exportComponents;	Movie theMovie = nil;	short resRef;	OSType creator;	SFTypeList myTypes = {'TRAK','MooV'};	FInfo fndrInfo;	OSErr anErr;	/*StandardGetFilePreview(0,2, myTypes, &reply);	if (!reply.sfGood) return false;*/	iErr = FSpGetFInfo(&theSpec,&fndrInfo);	//if (fndrInfo.fdType != 'MooV')	//	return false;			BlockMove (&theSpec, &reply.sfFile,70L);		// get the movie.anErr = OpenMovieFile(&reply.sfFile, &resRef, fsRdPerm);if (anErr){	return false;}anErr = NewMovieFromFile(&theMovie, resRef, nil, nil,	0, nil);if (anErr){	anErr = NewMovieFromDataFork (&theMovie, resRef, nil, 0, nil);	if (anErr)	{		CloseMovieFile(resRef);		return false;	}}	CloseMovieFile(resRef);	if (!theMovie) return false;		//SetMovieProgressProc(theMovie, (MovieProgressUPP)-1, 0);	// build a list of all export components which are applicable to this movie	exportComponents = (Component **)NewHandle(0);	cd.componentType = MovieExportType;	cd.componentSubType = 0;	cd.componentManufacturer = 0;	cd.componentFlags = canMovieExportFiles;	cd.componentFlagsMask = canMovieExportFiles;	while (c = FindNextComponent(c, &cd)) {		Handle h = NewHandle(4);		ComponentDescription exportCD;		if (GetComponentInfo(c, &exportCD, h, nil, nil) == noErr) {			Str255 s;			Handle h2 = NewHandle(4);			ComponentDescription mhcd;			Component mediaHandler;			mhcd.componentType = MediaHandlerType;			mhcd.componentSubType = exportCD.componentManufacturer;			mhcd.componentManufacturer = 0;			mhcd.componentFlags = 0;			mhcd.componentFlagsMask = 0;			if (mediaHandler = FindNextComponent(0, &mhcd)) {				long trackCount = GetMovieTrackCount(theMovie);				long i;				Boolean foundMedia = true;				// make sure the media type the component can export is in the movie				if (exportCD.componentManufacturer) {					foundMedia = false;					for (i=1; i<=trackCount; i++) {						Track t = GetMovieIndTrack(theMovie, i);						OSType mediaType;							GetMediaHandlerDescription(GetTrackMedia(t), &mediaType, nil, nil);						foundMedia = (mediaType == exportCD.componentManufacturer);						if (foundMedia) break;					}				}				if (foundMedia && (GetComponentInfo(mediaHandler, nil, h2, nil, nil) == noErr)) {					Str255 s;					// build menu name in un-international friendly way					if (exportCD.componentManufacturer) {						BlockMove(*h2, s, sizeof(s));						s[++s[0]] = ' ';						s[++s[0]] = 't';						s[++s[0]] = 'o';						s[++s[0]] = ' ';					}					else						s[0] = 0;					BlockMove(*h + 1, &s[s[0] + 1], **h);					s[0] += **h;					AppendMenu(mh, s);					PtrAndHand((Ptr)&c, (Handle)exportComponents, sizeof(c));					DisposHandle(h); /* maybe lose this */				}			}		}		/* DisposHandle(h);  maybe lose this */	}	InsertMenu(mh, -1);	if (GetHandleSize((Handle)exportComponents) == 0) {		// no export components for this movie are available		err = -50;		SysBeep(1);		goto bail;	}	BlockMove(reply.sfFile.name, newName, 255L);	//newName[++newName[0]] = '~';		/******************************/	/*CustomPutFile("\pExport a file", newName, &putFile,					kMyCustomSaveDialog, where, (DlgHookYDProcPtr)xmyDlgHook, 					nil, nil, nil, (void *)&convertItem);	if (!putFile.sfGood) goto bail;*/	convertItem = 1;			err = FSMakeFSSpec(reply.sfFile.vRefNum,reply.sfFile.parID,newName,&(putFile.sfFile));			putFile.sfFile.parID = theConvertDestLoc.parID;	putFile.sfFile.vRefNum = theConvertDestLoc.vRefNum;			GetComponentInfo((*exportComponents)[convertItem - 1], &cd, nil, nil, nil);	// cheap map in the application to allow us to chose the file creator	{	Handle h = GetResource('fMap', 128);	short count = GetHandleSize(h) / (sizeof(OSType) * 2);	OSType *creators = *(OSType **)h;	creator = '????';	while (count-- > 0) {		if (*creators++ == cd.componentSubType) {			creator = *creators;			break;		}		creators++;	}	}	if (cd.componentFlags & hasMovieExportUserInterface) {		MovieExportComponent exporter;		Boolean canceled = false;		exporter = OpenComponent((*exportComponents)[convertItem - 1]);		//err = MovieExportDoUserDialog(exporter, &reply.sfFile, nil, &canceled);		/*if (err || canceled) {			CloseComponent(exporter);			return false;		}*/  		err = ConvertMovieToFile(theMovie, nil, &putFile.sfFile,			cd.componentSubType, creator, putFile.sfScript, nil, createMovieFileDeleteCurFile,			exporter);		CloseComponent(exporter);	}	else {		// no user interface available. let the movie toolbox do the hard part	err = ConvertMovieToFile(theMovie, nil, &putFile.sfFile,			cd.componentSubType, creator, putFile.sfScript, nil, createMovieFileDeleteCurFile,			(ComponentInstance)(*exportComponents)[convertItem - 1]);	}	if (err) 	{		SysBeep(1);		goto bail;	}		addFileToList(putFile.sfFile);	GetFSComment(theSpec, theComment);	SetComment (putFile.sfFile, 0, theComment);bail:	DeleteMenu(kExportMenu);	DisposeMenu(mh);	DisposeMovie(theMovie);	DisposHandle((Handle)exportComponents);	return (err) ? false : true;}Boolean contMode;Boolean deFragMany(void){	Cell theCell;	short theindex;	OSErr	iErr;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean memoryError = false;	Boolean partialError = false;	contMode = true;	/****************/	myDlg = GetNewDialog(11121,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);			ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				contMode = true;			break;						case 4:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				contMode = false;			break;		}	}while (itemHit != 1 && itemHit != 2);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;	partialError = false;		getConvertDest();	writeLogS((unsigned char *)"Starting Defragment");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		switch (defragFile((*therealResults)[theindex]))		{			case kDeFragComplete:				writeLog((Ptr)(*therealResults)[theindex].name);				break;						case kDeFragWithDiscon:				writeLogS((unsigned char *)"Rewrote with partial allocation :");				writeLog((Ptr)(*therealResults)[theindex].name);					partialError = true;			break;						case kDeFragImpossible:				writeLogS((unsigned char *)"Failed to defrag :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			break;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}						if (memoryError)			genError("\pSome files could not be defragmented, consult the SampleSearchª Log for details");		else		{			if (partialError)				genError("\pSome files could not be fully defragmented, consult the SampleSearchª Log for details");		}		}short defragFile(FSSpec sourceSpec){	OSErr	iErr,theErr;	FSSpec destspec;	Str255 theStrTemp,newName;	FInfo fndrInfo;	//Boolean problemOccurred;	short theSource, theDestination;	Ptr copyBuff;	long inOutCount;	long bytesToCopy, bytesToCopyR, bytesCopied = 0L,checkLength;	HFileInfo pb;	long theRate;	short theWordSize;	Boolean stereo,compromise = false;	long theBytes;			pb.ioFDirIndex = 0;	pb.ioNamePtr = sourceSpec.name;	pb.ioVRefNum = sourceSpec.vRefNum;	pb.ioDirID = sourceSpec.parID;	iErr = PBGetCatInfo((CInfoPBRec *)&pb,false);	if (iErr)	{			genError("\pCan't get info for source file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred : Can't get info for source file : ");			writeLog((Ptr)sourceSpec.name);			writeLogS((unsigned char *)"abandoning defrag function");			writeLogS((unsigned char *)" ");			return;	}		bytesToCopy = pb.ioFlLgLen;	bytesToCopyR =  pb.ioFlRLgLen;		/* maybe add the opyion to copy it locally  and make it a pref */	/* add a global preference to control file automatic deletion */			copyBuff = NewPtrClear(65535L);		if (!copyBuff)		{			genError("\pNot Enough memory");			problemOccurred = true;			return false;		}		problemOccurred = false;				iErr = FSpGetFInfo(&sourceSpec,&fndrInfo);\		BlockMove(sourceSpec.name,newName,64L);		*newName += 1;				iErr = FSMakeFSSpec(sourceSpec.vRefNum,sourceSpec.parID,newName,&destspec);		iErr =1;		while (iErr !=0)		{			iErr = FSpCreate(&destspec,fndrInfo.fdCreator,fndrInfo.fdType,0);			if (iErr == -48) 	/** file exists **/			{				*destspec.name += 1;				*(destspec.name+(*destspec.name)) = '~';			}		}								makeStr255 ("\pDefragmenting:", theStrTemp);		concatStrings(theStrTemp,sourceSpec.name,"\p");		progressCreate (theStrTemp);				iErr = FSpOpenDF(&sourceSpec,fsRdPerm,&theSource);		if (!iErr)		{			iErr = FSpOpenDF(&destspec,fsCurPerm,&theDestination);			if (iErr!=0)			{				progressDispos();				genError("\pCan't open DF of new file");				writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"a problem occurred opening the data fork of the new file: ");				writeLog((Ptr)destspec.name);				writeLogS((unsigned char *)"abandoning transfer function");				writeLogS((unsigned char *)" ");				DisposPtr(copyBuff);				return;			}						checkLength = bytesToCopy;			iErr = AllocContig(theDestination,&checkLength);			if (iErr)			{				if (contMode)				{					SysBeep(5);					progressDispos();					DisposPtr(copyBuff);					return kDeFragImpossible;				} 				else				{					checkLength = bytesToCopy;					iErr = Allocate(theDestination,&checkLength);					if (iErr)					{						if (iErr == -34)						{							writeLogS((unsigned char *)"*********** ERROR ************");							writeLogS((unsigned char *)"the disk was full during defragment of the file: ");							writeLog((Ptr)destspec.name);							writeLogS((unsigned char *)"abandoning defragment function");							writeLogS((unsigned char *)" ");						}						SysBeep(5);						SysBeep(5);						progressDispos();						DisposPtr(copyBuff);						return kDeFragImpossible;					}					if (checkLength < bytesToCopy)						compromise = true;				}			}						theErr = 0;			while(theErr!= eofErr)			{				inOutCount = 65000L;				theErr = FSRead(theSource,&inOutCount,copyBuff);				if (theErr!=0 && theErr != eofErr)				{					progressDispos();					genError("\pCan't read from DF of source file");					writeLogS((unsigned char *)"*********** ERROR ************");					writeLogS((unsigned char *)"a problem occurred read the data fork of the source file: ");					writeLog((Ptr)destspec.name);					writeLogS((unsigned char *)"abandoning transfer function");					writeLogS((unsigned char *)" ");					DisposPtr(copyBuff);					return;				}				iErr = FSWrite(theDestination,&inOutCount,copyBuff);				if (iErr!=0)				{					progressDispos();					genError("\pCan't write to DF of new file, disk may be full");					writeLogS((unsigned char *)"*********** ERROR ************");					writeLogS((unsigned char *)"a problem occurred writing to the data fork of the new file: ");					writeLog((Ptr)destspec.name);					writeLogS((unsigned char *)"abandoning transfer function");					writeLogS((unsigned char *)" ");										DisposPtr(copyBuff);					return;				}				bytesCopied += inOutCount;				if (!bytesToCopy)					bytesToCopy  = 10L; 				if (progressDisp(LoWord (bytesCopied * 100L / bytesToCopy)))				{				 	writeLogS((unsigned char *)"*********** ERROR ************");					writeLogS((unsigned char *)"protools transfer function terminated by user");					writeLogS((unsigned char *)" ");					DisposPtr(copyBuff);					return;				}			}			FSClose(theSource);			FSClose(theDestination);		}						FSpCreateResFile(&destspec,fndrInfo.fdCreator,fndrInfo.fdType,0);		iErr = ResError();		if (iErr!=0)		{			genError("\pCan't create RF of new file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred creating the Res fork of the new file: ");			writeLog((Ptr)destspec.name);			writeLogS((unsigned char *)"abandoning transfer function");			writeLogS((unsigned char *)" ");						DisposPtr(copyBuff);			return;		}		iErr = FSpOpenRF(&sourceSpec,fsCurPerm,&theSource);		if (iErr!=0 && iErr != -43)		{			genError("\pCan't open RF of source file");			writeLogS((unsigned char *)"*********** ERROR ************");			writeLogS((unsigned char *)"a problem occurred opening the Res fork of the source file: ");			writeLog((Ptr)destspec.name);			writeLogS((unsigned char *)"abandoning transfer function");			writeLogS((unsigned char *)" ");						DisposPtr(copyBuff);			return;		}		if (!iErr)		{			iErr = FSpOpenRF(&destspec,fsCurPerm,&theDestination);			if (iErr!=0)			{				genError("\pCan't open RF of new file");				writeLogS((unsigned char *)"*********** ERROR ************");				writeLogS((unsigned char *)"a problem occurred opening the Res fork of the new file: ");				writeLog((Ptr)destspec.name);				writeLogS((unsigned char *)"abandoning transfer function");				writeLogS((unsigned char *)" ");								DisposPtr(copyBuff);				return;			}			checkLength = bytesToCopyR;			iErr = AllocContig(theDestination,&checkLength);			if (iErr)			{				if (contMode)				{					SysBeep(5);					progressDispos();					DisposPtr(copyBuff);					return kDeFragImpossible;				} 				else				{					checkLength = bytesToCopyR;					iErr = Allocate(theDestination,&checkLength);					if (iErr)					{						if (iErr == -34)						{							writeLogS((unsigned char *)"*********** ERROR ************");							writeLogS((unsigned char *)"the disk was full during defragment of the file: ");							writeLog((Ptr)destspec.name);							writeLogS((unsigned char *)"abandoning defragment function");							writeLogS((unsigned char *)" ");						}						SysBeep(5);						SysBeep(5);						progressDispos();						DisposPtr(copyBuff);						return kDeFragImpossible;					}					if (checkLength < bytesToCopy)						compromise = true;				}			}			theErr = 0;			while(theErr!= eofErr)			{				inOutCount = 65000L;				theErr = FSRead(theSource,&inOutCount,copyBuff);				iErr = FSWrite(theDestination,&inOutCount,copyBuff);				if (iErr!=0)				{					genError("\pCan't write to RF of new file, disk may be full");					writeLogS((unsigned char *)"*********** ERROR ************");					writeLogS((unsigned char *)"a problem occurred writing data to the new file: ");					writeLog((Ptr)destspec.name);					writeLogS((unsigned char *)"abandoning transfer function");					writeLogS((unsigned char *)" ");										DisposPtr(copyBuff);					return;				}			}			FSClose(theSource);			FSClose(theDestination);		}				progressDispos();		if (compromise)		{			iErr = FSpDelete(&sourceSpec);			iErr = FSpRename(&destspec,sourceSpec.name);			writeLogS((unsigned char *)"File defragged but not 100% contiguous :");			writeLog((Ptr)destspec.name);			DisposPtr(copyBuff);			problemOccurred = false;			return kDeFragWithDiscon;		}		else		{			iErr = FSpDelete(&sourceSpec);			iErr = FSpRename(&destspec,sourceSpec.name);			writeLogS((unsigned char *)"File completely defragged :");			writeLog((Ptr)destspec.name);			DisposPtr(copyBuff);			problemOccurred = false;			return kDeFragComplete;		}}Boolean pcMode,skipDialogs = false;Boolean AIFFtoQuickTimeMany(void) /* actually, anything to QuickTime */{	Cell theCell;	short theindex;	OSErr	iErr;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean memoryError = false;	pcMode = false;	flattenIt = true;	/****************/	myDlg = GetNewDialog(11120,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,skipDialogs);			ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				flattenIt = false;			break;						case 3:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				pcMode = false;				flattenIt = true;			break;						case 4:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				flattenIt = true;				pcMode = true;			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;		}	}while (itemHit != 1 && itemHit != 2);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	skipDialogs = GetCtlValue((ControlHandle)iHndl);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;		getConvertDest();	writeLogS((unsigned char *)"Starting AIFF to QT Convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		iErr = EnterMovies();		if (iErr) 			return;		if (AIFFtoQuickTime((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		ExitMovies();		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean AIFFtoQuickTime(FSSpec theSpec){	return importMovie(theSpec);	}OSErr SDIItoAIFFMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	short myshort; 		myshort = isPressed(0x3A);		/** 3b 3a 37 **/		if(myshort)	{		genError ("\pConverting Files in Place !!!");		convertInPlace = true;	}	else	{		convertInPlace = false;	}	getConvertDest();	watchcursor(true);	writeLogS((unsigned char *)"Starting SDII to AIFF Convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDIItoAIFF((*therealResults)[theindex]))		{				writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}OSErr SDII16To24Many(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	short myshort; 		getConvertDest();	watchcursor(true);	writeLogS((unsigned char *)"Starting SDII 16 to 24-bit convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDII16To24((*therealResults)[theindex]))		{				writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}OSErr copySDIIRegionsNoConversion (FSSpec sourceFile, FSSpec destFile);Boolean SDII24to16(FSSpec theSourceSpec, FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Ptr theData, theData2;//	FSSpec theSourceSpec;	Str255 theComment;	long theSSNDSize;	Boolean renamedDupe = false;	//	BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSourceSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize != 3)	{		return;	}		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}						theData2 = NewPtrClear(100000L);		if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\pConverting File");		while (err != eofErr)		{			inOutCount = 98304L;			err = FSRead(sRefNum,&inOutCount,theData2);			convertBuffer24To16 (theData2, &inOutCount);			iErr = FSWrite(RefNum,&inOutCount,theData2);			if (iErr )			{				genError ("\pDisk Full");				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				DisposPtr (theData2);				watchcursor(false);				return false;			}		}		progressDispos();		watchcursor(false);				FSClose (RefNum);		FSClose(sRefNum);		writeSDIIResources(theSpec,theRate,stereo,2);/* copy the ddRL */		copySDIIRegionsNoConversion (theSourceSpec,theSpec);		DisposPtr (theData2);				GetFSComment(theSourceSpec, theComment);		SetComment (theSpec, 0, theComment);			addFileToList(theSpec);		return true;}Boolean SDII16To24(FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Ptr theData, theData2;	FSSpec theSourceSpec;	Str255 theComment;	long theSSNDSize;	Boolean renamedDupe = false;		BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize != 2)	{		genError ("\pThis function only supports 16-bit files");		return;	}		theSpec.parID = theConvertDestLoc.parID;	theSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}						theData = NewPtrClear(67000L);		if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}		theData2 = NewPtrClear(132000L);		if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\pConverting File");		while (err != eofErr)		{			inOutCount = 65536L;			err = FSRead(sRefNum,&inOutCount,theData);			convertBuffer16To24 (theData,theData2, &inOutCount);			iErr = FSWrite(RefNum,&inOutCount,theData2);			if (iErr )			{				genError ("\pDisk Full");				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				DisposPtr (theData);				DisposPtr (theData2);				watchcursor(false);				return false;			}		}		progressDispos();		watchcursor(false);				FSClose (RefNum);		FSClose(sRefNum);		writeSDIIResources(theSpec,theRate,stereo,3);/* copy the ddRL */		copySDIIRegionsNoConversion (theSourceSpec,theSpec);		DisposPtr (theData);		DisposPtr (theData2);				GetFSComment(theSourceSpec, theComment);		SetComment (theSpec, 0, theComment);			addFileToList(theSpec);		return true;}Boolean SDII16To24II(FSSpec theSourceSpec, FSSpec theSpec);Boolean SDII16To24II(FSSpec theSourceSpec, FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Ptr theData, theData2;//	FSSpec theSourceSpec;	Str255 theComment;	long theSSNDSize;	Boolean renamedDupe = false;	//	BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSourceSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize != 2)	{		genError ("\pThis function only supports 16-bit files");		return;	}	//	theSpec.parID = theConvertDestLoc.parID;//	theSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}						theData = NewPtrClear(100000L);		if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}		theData2 = NewPtrClear(132000L);		if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\pConverting File");		while (err != eofErr)		{			inOutCount = 65536L;			err = FSRead(sRefNum,&inOutCount,theData);			convertBuffer16To24 (theData,theData2, &inOutCount);			iErr = FSWrite(RefNum,&inOutCount,theData2);			if (iErr )			{				genError ("\pDisk Full");				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				DisposPtr (theData);				DisposPtr (theData2);				watchcursor(false);				return false;			}		}		progressDispos();		watchcursor(false);				FSClose (RefNum);		FSClose(sRefNum);		writeSDIIResources(theSpec,theRate,stereo,3);/* copy the ddRL */		copySDIIRegionsNoConversion (theSourceSpec,theSpec);		DisposPtr (theData);		DisposPtr (theData2);				GetFSComment(theSourceSpec, theComment);		SetComment (theSpec, 0, theComment);	//		addFileToList(theSpec);		return true;}Boolean SDIItoAIFF(FSSpec theSpec){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Handle theData;	FSSpec theSourceSpec;	Str255 theComment;	long theSSNDSize;	Boolean renamedDupe = false;		BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	if (!convertInPlace)	{		theSpec.parID = theConvertDestLoc.parID;		theSpec.vRefNum = theConvertDestLoc.vRefNum;	}	iErr = FSpCreate(&theSpec,'Sd2a','AIFF',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (convertInPlace)				{					Str255 theNewNameZ = "\p";						concatStrings (theNewNameZ,theSpec.name,"\p~");					iErr = FSpRename(&theSpec,theNewNameZ);					iErr = FSpCreate(&theSpec,'Sd2a','AIFF',0);					BlockMove (&theSpec,&theSourceSpec,70L);					BlockMove (theNewNameZ,theSourceSpec.name,64L);					renamedDupe = true;				}				else				{					if (YesNo ("\pFile Exists, overwrite ?"))					{						FSpDelete (&theSpec);						iErr = FSpCreate(&theSpec,'Sd2a','AIFF',0);					}					else					{						return false;					}				}			}		}		iErr = FSpOpenDF(&theSpec,fsWrPerm,&RefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			return false;		}						iErr = SetupAIFFHeader(RefNum,(short)stereo+1,(Fixed)(theRate<<16),theWordSize*8,'NONE',theBytes,0);		if (iErr != 0)		{			genError("\pProblem setting up file");			FSClose (RefNum);			return false;		}				iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}						theData = NewHandleClear(33000L);				if (!theData)		{			genError ("\pNot enough memory");			FSClose (RefNum);			FSClose(sRefNum);			return false;		}				err = 0;		watchcursor(true);		progressCreate("\pConverting File");		while (err != eofErr)		{			inOutCount = 32768L;			err = FSRead(sRefNum,&inOutCount,*theData);			iErr = FSWrite(RefNum,&inOutCount,*theData);			if (iErr )			{				SysBeep(5);				FSClose (RefNum);				FSClose(sRefNum);				progressDispos();				watchcursor(false);				return false;			}		}		progressDispos();		watchcursor(false);				if (isOdd((long)theBytes))		{			inOutCount = 4L;			iErr = SetFPos(RefNum,1,42);			err = FSRead(RefNum,&inOutCount,&theSSNDSize);			theSSNDSize ++;			iErr = SetFPos(RefNum,1,42);			iErr = FSWrite(RefNum,&inOutCount,&theSSNDSize);			iErr = SetFPos(RefNum,2,0);			inOutCount = 1L;			theSSNDSize = 0L;			iErr = FSWrite(RefNum,&inOutCount,&theSSNDSize);		}				FSClose (RefNum);		FSClose(sRefNum);		DisposHandle(theData);				GetFSComment(theSourceSpec, theComment);		SetComment (theSpec,0,  theComment);			addFileToList(theSpec);		/* maybe delete theSourceSpec if necessary and if renamedDupe == true */		return true;/* copy comment */}Boolean importMovie(FSSpec mySpec){	OSErr err;	StandardFileReply reply;	SFReply putFile;	FSSpec newFile;	Str255 newName, theComment;	Point where = {100,100};	Component c;	ComponentDescription cd;	FInfo fndrInfo;	BlockMove (&mySpec,&reply.sfFile,70L);	newName[++newName[0]] = '!';	BlockMove (&mySpec,&newFile,70L);		newFile.parID = theConvertDestLoc.parID;	newFile.vRefNum = theConvertDestLoc.vRefNum;	FSpGetFInfo(&mySpec,&fndrInfo);	//reply.sfType = 'AIFF';	reply.sfType = fndrInfo.fdType;	cd.componentType = MovieImportType;	cd.componentSubType = reply.sfType;	cd.componentManufacturer = 0;	cd.componentFlags = canMovieImportFiles;	cd.componentFlagsMask = canMovieImportFiles;		c = FindNextComponent(nil, &cd);	if (!c) return false;						// too weird. no import component exists		GetComponentInfo(c, &cd, nil, nil, nil);	if ((cd.componentFlags & hasMovieImportUserInterface) && !skipDialogs)  /* make this work as a batch process */	{		MovieImportComponent importer;		Boolean canceled = false;		importer = OpenComponent(c);		err = MovieImportDoUserDialog(importer, &reply.sfFile, nil, &canceled);		if (err || canceled) {			CloseComponent(importer);			return false;		}		err = ConvertFileToMovieFile(&reply.sfFile, &newFile, 'TVOD', -1, nil,			0, importer, (MovieProgressUPP)/*(struct RoutineDescriptor *)*/-1, 0);		CloseComponent(importer);			} 	else 	{		// no import user interface option, so let the toolbox open the component		err = ConvertFileToMovieFile(&reply.sfFile, &newFile, 'TVOD', -1, nil,			0, 0 /*(ComponentInstanceRecord *)&c*/ /*nil*/, (MovieProgressUPP)/*(struct RoutineDescriptor *)*/-1, 0);	}	if (err) 	{		SysBeep(1);		DeleteMovieFile(&newFile);	}	else	/* flatten it */	{		if (flattenIt)		{				short resId  =1000, zerores=0;			Movie theMovie = 0;			short resRef;			OpenMovieFile(&newFile, &resRef, fsWrPerm);			NewMovieFromFile(&theMovie, resRef, &zerores, nil,				 	0, nil);			CloseMovieFile(resRef);			if (!theMovie) return false;										FlattenMovie (theMovie, (flattenAddMovieToDataFork & pcMode) | flattenDontInterleaveFlatten, 											&newFile,'TVOD', smSystemScript,											createMovieFileDeleteCurFile,&resId,0);		}									//FlattenMovie (theMovie, 0,&newFile,'TVOD', -1,createMovieFileDeleteCurFile,0, 0);	}	GetFSComment(mySpec, theComment);	SetComment (newFile, 0, theComment);	addFileToList(newFile);	return true;}Boolean GetFSComment(FSSpec mySpec, Str255 theComment){	FInfo fndrInfo;	OSErr	iErr,iLErr;	short refNum,iRefNum;	Handle hRsrc;	long inOutCount, SCinpos, AIFFpos;	short SCFormat;	FSSpec	BUSpec;		*theComment = 0;					iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		*theComment = 0;		return false;	} 		if (-(mySpec.vRefNum) <= maxVRef)		{			if (fndrInfo.fdCreator == 'CARI')			{				if (!GetFSSpecComment(mySpec, (StringPtr)theComment))				*theComment = 0;			}			else			{				switch(fndrInfo.fdType)				{ /* 13 */				case 'SFIL':					iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);					if (iErr!=0)					{						*theComment = 0;						return false;					}					if( !iErr)					{ /* 9 */						iErr = SetFPos(refNum,1,764L);						if (iErr!=0)						{							*theComment = 0;							FSClose(refNum);							return false;						}						inOutCount = 255L;						iErr = FSRead(refNum,&inOutCount,theComment);						if (iErr!=0)						{							*theComment = 0;							FSClose(refNum);							return false;						}						FSClose(refNum);					} /* 9 */					else					{							*theComment = 0;						return false;					}				break;								case 'Sd2f':				iRefNum = CurResFile();					refNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);					if (refNum > 0)					{ 						hRsrc = Get1Resource('sdDD',1000);						iErr = ResError();						if(hRsrc)						{							BlockMove((*hRsrc)+10,theComment,256L);							ReleaseResource(hRsrc);						}						CloseResFile(refNum);						UseResFile(iRefNum);						return true;											}					else					{							*theComment = 0;						return false;  							}				break;								case 'SCin': case 'MixD': case 'SCsi' : case 'SCsd' : case 'SCss':					SCFormat = identifySCII(mySpec);				 	if (SCFormat !=2)				 	{				 		*theComment = 0;				 		return false;				 	}					iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);					if (iErr!=0)					{						*theComment = 0;						return false;					}					if( !iErr)					{ /* 9 */						SCinpos =  findANNO(refNum);						if (SCinpos)						{							iErr = SetFPos(refNum,1,SCinpos+4L);							if (iErr!=0)							{								*theComment = 0;								FSClose(refNum);								return false;							}															inOutCount = 4L;							iErr = FSRead(refNum,&inOutCount,&SCinpos);							if (iErr!=0)							{								*theComment = 0;								FSClose(refNum);								return false;							}							inOutCount = SCinpos;							if (SCinpos)							{								iErr = FSRead(refNum,&inOutCount,theComment);								if (iErr!=0)								{									*theComment = 0;									FSClose(refNum);									return false;								}							}						}						FSClose(refNum);					} /* 9 */				break;								case 'AIFF':					iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);					if (iErr!=0)					{							*theComment = 0;						return false;					}					if( !iErr)					{ /* 9 */						BlockMove (&mySpec,&BUSpec, 70L);						iLErr =  findAPPL(refNum);						BlockMove (&BUSpec,&mySpec, 70L);						if (iLErr)						{							AIFFpos = theAPPLReply;							iErr = SetFPos(refNum,1,AIFFpos+22L);							if (iErr!=0)							{								*theComment = 0;								FSClose(refNum);								return false;							}															inOutCount = 255L;							iErr = FSRead(refNum,&inOutCount,theComment);							if (iErr!=0 && iErr !=-39)							{								*theComment = 0;								FSClose(refNum);								return false;							}						}						FSClose(refNum);					} /* 9 */								break;								default:										if (!GetFSSpecComment(mySpec, (StringPtr)theComment))						*theComment = 0;				break;				}			}		}	return true;}Boolean SetFSComment (FSSpec mySpec, StringPtr theComment){		FInfo fndrInfo;	OSErr	iErr,iLErr;	short refNum, myRefNum, iRefNum;	Handle hRsrc;	long inOutCount, SCinpos, AIFFpos;	short SCFormat;						iErr = FSpGetFInfo(&mySpec,&fndrInfo);			if (iErr !=0)			{				makeStr255("\pCan't get comment",theComment);				return false;			} 		if (-(mySpec.vRefNum) <= maxVRef)		{						if (fndrInfo.fdCreator == 'CARI')			{				iErr = SetFSSpecComment(mySpec,theComment);			}			else			{			    switch(fndrInfo.fdType)			    { /* 13 */					case 'Sd2f':					iRefNum = CurResFile();					 	myRefNum = FSpOpenResFile(&mySpec,fsCurPerm);					 	if (myRefNum != -1)					 	{						 	hRsrc = Get1Resource('sdDD',1000);							if (!hRsrc)							{								hRsrc = GetResource('sdDD',900);								iErr = ResError();								if (iErr != 0)								{									CloseResFile(myRefNum);									UseResFile(iRefNum);									return 0;									}								DetachResource(hRsrc);								AddResource((Handle)hRsrc,'sdDD',1000,"\p");								iErr = ResError();								if (iErr != 0)								{									CloseResFile(myRefNum);									UseResFile(iRefNum);									return 0;									}							}							BlockMove(theComment,(*hRsrc)+10,(*theComment)+1L);								ChangedResource(hRsrc);							WriteResource(hRsrc);							ReleaseResource(hRsrc);								CloseResFile(myRefNum);							UseResFile(iRefNum);							iErr = ResError();							if (iErr!=0)								genError ("\pCan't close Resource file");						}						else						{							return 0;						}					 break;					 					 case 'SFIL':						iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);						if (iErr!=0)						{							return 0;						}						iErr = SetFPos(refNum,1,764L);						if (iErr != 0)						{							FSClose (refNum);							return 0;						}						inOutCount = *theComment+1;						iErr = FSWrite(refNum,&inOutCount,theComment);						FSClose (refNum);						 break;					 					 					  case 'AIFF':						iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);						if (iErr!=0)						{							return 0;						}						AIFFpos =  findAPPL(refNum);						AIFFpos = theAPPLReply;						if (AIFFpos)						{								if(isItTheLastChunk(refNum, AIFFpos))							{								if(!removeCommentFromChunkEnd(refNum, AIFFpos,'APPL'))								{																		iErr = FSClose(refNum);									return 0;								}								if (!addAIFFCommentToChunkEnd(refNum,theComment,'APPL'))								{																		iErr = FSClose(refNum);									return 0;								}							}							else							{								if (!zapAPPL(refNum))								{																		iErr = FSClose(refNum);									return 0;								}								if (!addAIFFCommentToChunkEnd(refNum,theComment,'APPL'))								{																		iErr = FSClose(refNum);									return 0;								}								}						}						else						{							if (!addAIFFCommentToChunkEnd(refNum,theComment,'APPL'))							{																iErr = FSClose(refNum);								return 0;							}						}								FSClose (refNum);						 break;					 					  case 'SCin': case 'MixD': case 'SCsi': case 'SCsd' : case 'SCss':					 	SCFormat = identifySCII(mySpec);					 	if (SCFormat !=2)					 	{					 		return 0;					 	}					 	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);						if (iErr!=0)						{							return 0;						}						SCinpos =  findANNO(refNum);						if (SCinpos)						{								if(isItTheLastChunk(refNum, SCinpos))							{								if(!removeCommentFromChunkEnd(refNum, SCinpos,'ANNO'))								{																	iErr = FSClose(refNum);									return 0;								}								if (!addCommentToChunkEnd(refNum,theComment,'ANNO'))								{																		iErr = FSClose(refNum);									return 0;								}							}							else							{								if (!zapANNO(refNum))								{																		iErr = FSClose(refNum);									return 0;								}								if (!addCommentToChunkEnd(refNum,theComment,'ANNO'))								{									iErr = FSClose(refNum);									return 0;								}								}						}						else						{							if (!addCommentToChunkEnd(refNum,theComment,'ANNO'))							{								iErr = FSClose(refNum);								return 0;							}						}								FSClose (refNum);						 break;					 					  default:						iErr = SetFSSpecComment(mySpec,theComment);					 break;				}			}		}		else		{			return false;		}	return true;}OSType writeResToPrefs(Handle rpHandle, OSType thePrefType, short prefID,  long handleSize);OSErr readResFromPrefs(Handle rpHandle, OSType thePrefType, short prefID, long handleSize);void getConvertDest(void){	OSErr iErr;	Handle theTempH;	FSSpec testSpec;		FSSpec tempSpec;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;		theTempH = NewHandle(70L);	if ( readResFromPrefs(theTempH, 'CoFS', 128, 70L))	{		setConvertDest();		readResFromPrefs(theTempH, 'CoFS', 128, 70L);	}	BlockMove (*theTempH , &theConvertDestLoc, 70L);	iErr = FSMakeFSSpec(theConvertDestLoc.vRefNum,theConvertDestLoc.parID,theConvertDestLoc.name,&tempSpec);	/*if (iErr != 0 && iErr != )	{		setConvertDest();		readResFromPrefs(theTempH, 'CoFS', 128, 70L);		BlockMove (*theTempH , &theConvertDestLoc, 70L);	}*/	DisposHandle (theTempH);		dpb->ioVRefNum = theConvertDestLoc.vRefNum;		/* default volume */	dpb->ioNamePtr = theConvertDestLoc.name;	/* buffer to receive name */	dpb->ioFDirIndex = 0;	dpb->ioDrDirID = theConvertDestLoc.parID;	iErr = PBGetCatInfo( &cipbr, FALSE );	//iErr = FSMakeFSSpec(theConvertDestLoc.vRefNum,theConvertDestLoc.parID,theConvertDestLoc.name,&spec);	theConvertDestLoc.parID = dpb->ioDrDirID;		BlockMove (&theConvertDestLoc, &testSpec,70L);	makeStr255 ("\p~@@@~~@@",testSpec.name);	iErr = FSpCreate(&testSpec,'test','test',0);	switch (iErr)	{		case noErr:				break;				case -48:				break;				default:			genError ("\pYour target folder is not valid, please choose a new folder");			setConvertDest();		/*	iErr = GetFileGray(&theConvertDestLoc);			if (iErr)			{				theConvertDestLoc.vRefNum = -1;				theConvertDestLoc.parID = 2;				return;			}			else			{				translateParentToChildFolder(&theConvertDestLoc);			}*/		break;				}	iErr = FSpDelete(&testSpec);	}Boolean getFolder(FSSpec *theFolderSpec); void setConvertDest(void){	Handle theTempH;	OSErr	iErr;		iErr = GetFileGray(&theConvertDestLoc);	if(iErr)	{		theConvertDestLoc.vRefNum = -1;		theConvertDestLoc.parID = 2;		theTempH = NewHandle(70L);		BlockMove (&theConvertDestLoc, *theTempH , 70L);		writeResToPrefs(theTempH,'CoFS', 128,  70L);		DisposHandle (theTempH);		return;	}		translateParentToChildFolder(&theConvertDestLoc);	theTempH = NewHandle(70L);	BlockMove (&theConvertDestLoc, *theTempH , 70L);	writeResToPrefs(theTempH,'CoFS', 128,  70L);	DisposHandle (theTempH);					/*	if (getFolder(&theConvertDestLoc))	{		theTempH = NewHandle(70L);		BlockMove (&theConvertDestLoc, *theTempH , 70L);		writeResToPrefs(theTempH,'CoFS', 128,  70L);		DisposHandle (theTempH);	}	else	{		theConvertDestLoc.vRefNum = -1;		theConvertDestLoc.parID = 2;		theTempH = NewHandle(70L);		BlockMove (&theConvertDestLoc, *theTempH , 70L);		writeResToPrefs(theTempH,'CoFS', 128,  70L);		DisposHandle (theTempH);	}*/}void SDII16to8Many(void){	Cell theCell;	short theindex;	Boolean memoryError = false;		getConvertDest();	writeLogS((unsigned char *)"Starting 16 to 8 convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDII16to8((*therealResults)[theindex]))		{				writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError= true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean SDII16to8(FSSpec theSpec){	FSSpec destLSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, iRefNum, rfRefNum;	Str255 destLName, num8Bits = "\p1",rate,StereoMono = "\p1";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer, theLBuffer;	long z, infoLength, theTempLong;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;			if (theWordSize == 1)		return false;		if (theWordSize == 3)	{		return false;	}	BlockMove (&theSpec,&destLSpec,70L);		concatStrings (destLSpec.name,"\p[8]","\p");		destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}						iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(32768L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}	theLBuffer = NewPtr(17000L);	if (!theLBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 32000L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		for (z=0;z<inOutCount;z+=2L)		{				BlockMove(theBuffer + z,theLBuffer + (z>>1), 1L);		}		inOutCount = inOutCount >> 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	NumToString (theRate, rate);	concatStrings(rate,"\p0000","\p.");		FSpCreateResFile(&destLSpec,'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr != 0)	{		genError("\pCan't create new res file");		return false;	}			iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&destLSpec,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		return false;	}	UseResFile (rfRefNum);	h1 = NewString(num8Bits);	h2 = NewString(rate);	*(StereoMono +1L) = (stereo) ? '2' : '1';	h3 = NewString(StereoMono);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{			genError ("\pCan't Add str 1002");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	CloseResFile (rfRefNum);	UseResFile (iRefNum);	addFileToList(destLSpec);	return true;}void SDIIMonoToStereoMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(11112,0L,(WindowPtr)-1);	SetPort (myDlg);	switch (theNewPrefs.theStereoMonoXLatePrefs.interleaveOrDouble)	{		case kInterleaveSplitToStereo:			GetDItem(myDlg,4,&iType,&iHndl,&iRect);			SetCtlValue((ControlHandle)iHndl,true);				mixMode = true;		break;				case kDoubleMonoToStereo:			GetDItem(myDlg,3,&iType,&iHndl,&iRect);			SetCtlValue((ControlHandle)iHndl,true);				mixMode = false;		break;		default:		break;	}	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	SetIText(iHndl,	theNewPrefs.theStereoMonoXLatePrefs.leftSuffix);			GetDItem(myDlg,9,&iType,&iHndl,&iRect);	SetIText(iHndl,	theNewPrefs.theStereoMonoXLatePrefs.rightSuffix);		ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 3:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				mixMode = false;				theNewPrefs.theStereoMonoXLatePrefs.interleaveOrDouble = kDoubleMonoToStereo;			break;						case 4:				GetDItem(myDlg,3,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				mixMode = true;				theNewPrefs.theStereoMonoXLatePrefs.interleaveOrDouble = kInterleaveSplitToStereo;			break;		}	}while (itemHit != 1 && itemHit != 2);	GetDItem(myDlg,8,&iType,&iHndl,&iRect);	GetIText(iHndl,leftSuffixStr);		GetIText(iHndl,theNewPrefs.theStereoMonoXLatePrefs.leftSuffix);			GetDItem(myDlg,9,&iType,&iHndl,&iRect);	GetIText(iHndl,rightSuffixStr);		GetIText(iHndl,theNewPrefs.theStereoMonoXLatePrefs.rightSuffix);			DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;		getConvertDest();	writeLogS((unsigned char *)"Starting SDII mono to Stereo convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (mixMode)		{			if (SDIIMonoToStereoLR((*therealResults)[theindex]))			{				writeLog((Ptr)(*therealResults)[theindex].name);				}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}		}		else		{			if (SDIIMonoToStereoSplit((*therealResults)[theindex]))			{				writeLog((Ptr)(*therealResults)[theindex].name);				}			else			{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;			}					}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}Boolean SDIIMonoToStereoLR(FSSpec destLSpec){	FSSpec theSpec, destRSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, destRRef, iRefNum, rfRefNum;	Str255 destLName, tempstring, destRName, num8Bits = "\p1", num16Bits = "\p2",rate,StereoMono = "\p1";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos, theDestRPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	OSErr oErr = 0;	long inOutCount;	Str255 theNewName;	Ptr theBuffer, theLBuffer,theRBuffer;	long z, infoLength, theTempLong;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	long leftSuffixLen, rightSuffixLen;	Str255 theComment;		extraA = 0x00010000;	extraB = 0x00000000;		iErr = FSpGetFInfo(&destLSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')	{		return false;	}	if (getSDIIData (destLSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;			if (stereo)		return false;		leftSuffixLen = *leftSuffixStr;	rightSuffixLen = *rightSuffixStr;			BlockMove (((destLSpec.name + (*destLSpec.name)) - (leftSuffixLen - 1)), tempstring+1L, leftSuffixLen);	*tempstring = leftSuffixLen;		if(!EqualString(tempstring,leftSuffixStr,false,true)) 	{		return false;	}				BlockMove (destLSpec.name, tempstring, (*destLSpec.name) - (leftSuffixLen - 1));	*tempstring -= leftSuffixLen;	BlockMove (tempstring,theSpec.name,(*tempstring)+1);	concatStrings (tempstring,rightSuffixStr,"\p");			iErr = FSMakeFSSpec(destLSpec.vRefNum,destLSpec.parID,tempstring,&destRSpec);	if (iErr == - 43)		return false;					theSpec.parID = theConvertDestLoc.parID;	theSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					iErr = FSpCreate(&theSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}					iErr = FSpOpenDF(&theSpec,fsWrPerm,&sourceRef);		if (iErr != 0)		return false;							iErr = FSpOpenDF(&destLSpec,fsCurPerm,&destLRef);	if (iErr != 0)	{		FSClose (sourceRef);		FSpDelete (&theSpec);		return false;	}		iErr = FSpOpenDF(&destRSpec,fsCurPerm,&destRRef);	if (iErr != 0)	{		FSClose (destLRef);		FSClose (sourceRef);		FSpDelete (&theSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(70000L);	if (!theBuffer)	{		FSClose (destLRef);		FSClose (destRRef);		FSClose (sourceRef);		FSpDelete (&theSpec);		return false;	}	theLBuffer = NewPtr(34000L);	if (!theLBuffer)	{		FSClose (destLRef);		FSClose (destRRef);		FSClose (sourceRef);		FSpDelete (&theSpec);				return false;	}	theRBuffer = NewPtr(34000L);	if (!theRBuffer)	{		FSClose (destLRef);		FSClose (destRRef);		FSClose (sourceRef);		FSpDelete (&theSpec);		return false;	}	iErr = 0;	eErr = 0;	oErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (((iErr != eofErr) && (oErr != eofErr)) && !eErr)	{		inOutCount = 32768L;		iErr = FSRead(destLRef,&inOutCount,theLBuffer);		inOutCount = 32768L;		iErr = FSRead(destRRef,&inOutCount,theRBuffer);		//inOutCount = inOutCount << 1;		for (z=0;z<inOutCount;z+=2L)		{			if (theWordSize == 2)		 	{				*(short *)(theBuffer + (z << 1)) = *(short *)(theLBuffer + z);				*(short *)(theBuffer + (z << 1) + 2L) = *(short *)(theRBuffer + z);				/*BlockMove(theLBuffer + (z), theBuffer + (z << 1), 2L);				BlockMove(theRBuffer + (z), theBuffer + (z << 1) + 2L, 2L);*/			}			else			{				*(Byte *)(theBuffer + (z << 1)) = *(Byte *)(theLBuffer + z);				*(Byte *)(theBuffer + (z << 1) + 1L) = *(Byte *)(theRBuffer + z);				*(Byte *)(theBuffer + (z << 1) + 2L) = *(Byte *)(theLBuffer + z + 1L);				*(Byte *)(theBuffer + (z << 1) + 3L) = *(Byte *)(theRBuffer + z + 1L);				/*BlockMove(theLBuffer + z, theBuffer + (z << 1), 1L);				BlockMove(theRBuffer + z, theBuffer + (z << 1) + 1L, 1L);				BlockMove(theLBuffer + z + 1L, theBuffer + (z << 1) + 2L, 1L);				BlockMove(theRBuffer + z + 1L, theBuffer + (z << 1) + 3L, 1L);*/			}		}		inOutCount = inOutCount << 1;		eErr = FSWrite(sourceRef,&inOutCount,theBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	FSClose (destRRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	DisposPtr(theRBuffer);	NumToString (theRate, rate);	concatStrings(rate,"\p0000","\p.");		FSpCreateResFile(&theSpec,'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr != 0)	{		genError("\pCan't create new res file");		return false;	}		iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&theSpec,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		return false;	}	UseResFile (rfRefNum);	h1 = NewString((theWordSize == 2) ? num16Bits : num8Bits);	h2 = NewString(rate);	*(StereoMono + 1) = '2';	h3 = NewString(StereoMono);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{			genError ("\pCan't Add str 1002");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile (rfRefNum);		UseResFile (iRefNum);	copySDIIRegionsNoConversion (destLSpec,theSpec);	GetFSComment (destLSpec, theComment);	SetComment(theSpec, 0, theComment);	addFileToList(theSpec);	return true;}Boolean SDIIMonoToStereoSplit(FSSpec theSpec){	FSSpec destLSpec;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	Fixed theSRate;	short sourceRef, destLRef, iRefNum, rfRefNum;	Str255 destLName, num8Bits = "\p1",  num16Bits = "\p2", rate,StereoMono = "\p2";	long theSourcePos;	StringHandle	h1,h2,h3;	long theDestLPos;	OSErr	iErr,eErr;	FInfo fndrInfo;	OSType theChars;	short escCount;	long inOutCount;	Ptr theBuffer, theLBuffer;	long z, infoLength, theTempLong;	short the16Left,the16Right, the16Mono;	Byte the8Left,the8Right, the8Mono;	long extraA,extraB;	Handle theExtraHandleA,theExtraHandleB;	Str255 theComment;	extraA = 0x00010000;	extraB = 0x00000000;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (fndrInfo.fdType != 'Sd2f')		return false;	if (getSDIIData (theSpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;			if (stereo)	{		return false;	}			BlockMove (&theSpec,&destLSpec,70L);		if (*destLSpec.name < 24)		concatStrings (destLSpec.name,"\p[Stereo]","\p");	else		*(destLSpec.name + 1) = '~';			destLSpec.parID = theConvertDestLoc.parID;	destLSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&destLSpec);					iErr = FSpCreate(&destLSpec,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}						iErr = FSpOpenDF(&destLSpec,fsWrPerm,&destLRef);		if (iErr != 0)		return false;					iErr = FSpOpenDF(&theSpec,fsCurPerm,&sourceRef);	if (iErr != 0)	{		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		/* now enter the data */	theBuffer = NewPtr(32768L);	if (!theBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}	theLBuffer = NewPtr(65000L);	if (!theLBuffer)	{		FSClose (sourceRef);		FSClose (destLRef);		FSpDelete (&destLSpec);		return false;	}		iErr = 0;	eErr = 0;	watchcursor(true);	progressCreate("\pConverting File");	while (iErr != eofErr && !eErr)	{		inOutCount = 32000L;		iErr = FSRead(sourceRef,&inOutCount,theBuffer);		for (z=0;z<inOutCount;z+=2L)		{			if (theWordSize == 2)			{				*(short *)(theLBuffer + (z << 1)) = *(short *)(theBuffer + z);				*(short *)(theLBuffer + (z << 1) + 2L) = *(short *)(theBuffer + z);			}			else			{				*(Byte *)(theLBuffer + (z << 1)) = *(Byte *)(theBuffer + z);				*(Byte *)(theLBuffer + (z << 1) + 1L) = *(Byte *)(theBuffer + z);				*(Byte *)(theLBuffer + (z << 1) + 2L) = *(Byte *)(theBuffer + z + 1L);				*(Byte *)(theLBuffer + (z << 1) + 3L) = *(Byte *)(theBuffer + z + 1L);			}		}		inOutCount = inOutCount << 1;		eErr = FSWrite(destLRef,&inOutCount,theLBuffer);	}	progressDispos();	watchcursor(false);	FSClose (sourceRef);	FSClose (destLRef);	DisposPtr(theBuffer);	DisposPtr(theLBuffer);	NumToString (theRate, rate);	concatStrings(rate,"\p0000","\p.");		FSpCreateResFile(&destLSpec,'Sd2a','Sd2f',0);	iErr = ResError();	if (iErr != 0)	{		genError("\pCan't create new res file");		return false;	}			iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&destLSpec,fsWrPerm);	if (rfRefNum == -1)	{		genError("\pCan't open dest res file");		return false;	}	UseResFile (rfRefNum);	h1 = NewString((theWordSize == 2) ? num16Bits : num8Bits);	h2 = NewString(rate);	*(StereoMono +1L) = '2';	h3 = NewString(StereoMono);	AddResource((Handle)h1,'STR ',1000,"\psample-size");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1000");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h2,'STR ',1001,"\psample-rate");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't add str 1001");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	AddResource((Handle)h3,'STR ',1002,"\pchannels");	iErr = ResError();	if (iErr != 0)	{			genError ("\pCan't Add str 1002");		CloseResFile (rfRefNum);		UseResFile(iRefNum);		return false;	}	theExtraHandleA = NewHandle(8L);	theExtraHandleB = NewHandle(8L);		BlockMove (&extraA, *theExtraHandleA,4L);	BlockMove (&extraA, *theExtraHandleB,4L);	BlockMove (&extraB, (*theExtraHandleA)+4L,4L);	BlockMove (&extraB, (*theExtraHandleB)+4L,4L);	AddResource((Handle)theExtraHandleA,'sdML',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add markers");		UseResFile(iRefNum);		return false;	}	AddResource((Handle)theExtraHandleB,'sdLL',1000,"\p");	iErr = ResError();	if (iErr != 0)	{		genError ("\pCan't Add loops");		UseResFile(iRefNum);		return false;	}	CloseResFile (rfRefNum);	UseResFile (iRefNum);	copySDIIRegionsNoConversion (theSpec,destLSpec);	GetFSComment (destLSpec, theComment);	SetComment(theSpec, 0, theComment);	addFileToList(destLSpec);	return true;}long theMilliseconds;	void SDIITrimEndMany(void){	Cell theCell;	short theindex;	long theTrimBytes;	Boolean mixMode = true;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr;	long newEOF,curEOF;	short myRefNum;	Boolean memoryError = false;	OSErr	iErr;			/****************/	myDlg = GetNewDialog(9876,0L,(WindowPtr)-1);	SetPort (myDlg);	NumToString(theNewPrefs.trimEndValue,textStr);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetIText(iHndl,textStr);		ModalDialog(0,&itemHit);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,textStr);		DisposDialog(myDlg);	/***********/	memoryError = false;	if (itemHit == 2)		return;				StringToNum(textStr,&theTrimBytes);	theNewPrefs.trimEndValue = 	theTrimBytes;	writeLogS((unsigned char *)"Starting trim audio");		SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));						iErr = FSpOpenDF(&(*therealResults)[theindex],fsWrPerm,&myRefNum);		if (iErr)		{				writeLogS((unsigned char *)"Failed to Convert :");				writeLog((Ptr)(*therealResults)[theindex].name);					writeLogS((unsigned char *)"Continuing.....");				memoryError = true;				break;		}		writeLog((Ptr)(*therealResults)[theindex].name);			iErr = GetEOF(myRefNum,&curEOF);		newEOF = curEOF - theTrimBytes;		iErr = SetEOF(myRefNum,newEOF);		FSClose(myRefNum);				LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}void ConvertSound(Ptr sndPtr, long datasize){   long theCount;   short* theCurint;      for (theCount = 0L;theCount<datasize;theCount+=2L)   {      theCurint = (short *)(sndPtr + theCount);   	  *theCurint = (((*theCurint) << 8) & 0xFF00) | (((*theCurint) >> 8) & 0x00FF);   }}void GeffenToSDIIMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 theRateText;	long theRate;	short theNumberOfBits;	long theHeaderSize;	Boolean intelFormat;	Str255 theHeaderText;	Boolean Stereo, memoryError = false;		/****************/		getConvertDest();	writeLogS((unsigned char *)"Starting Geffen to SDII convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (GeffenToSDII((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}void PCRAWToSDIIMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 theRateText;	long theRate;	short theNumberOfBits;	long theHeaderSize;	Boolean intelFormat;	Str255 theHeaderText;	Boolean Stereo, memoryError = false;			/****************/	myDlg = GetNewDialog(14000,0L,(WindowPtr)-1);	SetPort (myDlg);	GetDItem(myDlg,10,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	intelFormat = true;	ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 10:				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;				}	}while (itemHit != 1 && itemHit != 2);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,theRateText);	if (*theRateText>5)		*theRateText = 5;	GetDItem(myDlg,4,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			Stereo = false;		break;				case 2:			Stereo = true;		break;	}	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	switch (GetCtlValue((ControlHandle)iHndl))	{		case 1:			theNumberOfBits = 2;		break;				case 2:			theNumberOfBits = 1;		break;		case 3:			theNumberOfBits = 3;		break;	}	GetDItem(myDlg,10,&iType,&iHndl,&iRect);	intelFormat = GetCtlValue((ControlHandle)iHndl);	GetDItem(myDlg,11,&iType,&iHndl,&iRect);	GetIText(iHndl,theHeaderText);	StringToNum(theHeaderText,&theHeaderSize);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;		if (isPressed(0x3A)){	radar24BitMode = true;	genError("\pRadar 24-bit Mode enabled");}else{	radar24BitMode = false;}	StringToNum(theRateText,&theRate);			getConvertDest();	writeLogS((unsigned char *)"Starting PCRam to SDII convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (PCRAWToSDII((*therealResults)[theindex],Stereo,theNumberOfBits,theRate, intelFormat,theHeaderSize))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		if (memoryError)		genError("\pSome files could not be converted, consult the SampleSearchª Log for details");}#define geffenChunkSize 17640L#define kGeffenHeaderSize 16LBoolean GeffenToSDII(FSSpec mySpec){	short sourceRef, destRef, rfRefNum, iRefNum;	OSErr	iErr,err;	long filePos,bytesTilEnd,theTote;	long inOutCount;	long audiosize,AOffset;	FSSpec theNewFile;	Str255 theComment;	Handle mySndH;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo, stereo;	long numBits,theHeaderSize = kGeffenHeaderSize;	long theRate = 44100;  /* for now */	Boolean Stereo = true;  /* for now */	short theNumberOfBits = 2; /* for now */	long chunkNumber = 1,nextPos;	Boolean stopNextTime,stopNow;	long bytesToGo, bytesCopied, totalBytes,theDate;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;				fpb->ioVRefNum = mySpec.vRefNum;		/* default volume */	fpb->ioNamePtr = mySpec.name;	/* buffer to receive name */	fpb->ioFDirIndex = 0; 	fpb->ioDirID = mySpec.parID;	rc = PBGetCatInfo( &cipbr, FALSE );		bytesToGo = totalBytes = fpb->ioFlLgLen;	bytesCopied = 0;	iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}			mySndH = NewHandle(geffenChunkSize * 2L);					/** buffer a **/	if (!mySndH)	{		genError("\pNot enough memory, increase partition size, or reduce buffer in prefs");		FSClose(sourceRef);		return false;	}	BlockMove (&mySpec,&theNewFile,70L);		theNewFile.parID = theConvertDestLoc.parID;	theNewFile.vRefNum = theConvertDestLoc.vRefNum;		concatStrings(theNewFile.name,"\pSD2","\p-");	iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theNewFile);					iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}	FSpCreateResFile(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)	{		genError("\pCan't create new res file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	iErr = FSpOpenDF(&theNewFile,fsWrPerm,&destRef);	if (iErr != 0)	{		genError("\pCan't create new file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}/*	if (theHeaderSize > 0L)	{		iErr = SetFPos(sourceRef,1,theHeaderSize);	}*/		progressCreate("\pConverting File");	err = 0;		stopNextTime = false;	stopNow = false;			while (!stopNow)	{		inOutCount = geffenChunkSize;		if (progressDisp(0))		{			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}					nextPos = (chunkNumber * geffenChunkSize) + kGeffenHeaderSize;		if (((nextPos + 17640) > totalBytes))		{			inOutCount = totalBytes - bytesCopied;			chunkNumber --;			nextPos = (chunkNumber * geffenChunkSize) + kGeffenHeaderSize;		}		iErr = SetFPos(sourceRef,1,nextPos);				err = FSRead(sourceRef,&inOutCount,*mySndH);		/*if (err != 0)		{			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}*/		if (stopNextTime)		{			stopNow = true;		}		if (err || iErr)		{			if (((chunkNumber >> 1) << 1) == chunkNumber) /* it is even */			{				stopNow = true;			}			else			{				stopNextTime = true;			}		}		iErr = FSWrite(destRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't write dest file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			progressDispos();			return false;		}		bytesCopied += inOutCount;		if (((chunkNumber >> 1) << 1) == chunkNumber) /* it is even */		{			chunkNumber += 3;		}		else		{				chunkNumber --;		}	}	FSClose (sourceRef);	FSClose (destRef);	progressDispos();			writeSDIIResources(theNewFile,theRate,Stereo,theNumberOfBits);		addFileToList(theNewFile);	GetFSComment(mySpec, theComment);	SetComment (theNewFile,0,  theComment);	return true;	}Boolean PCRAWToSDII(FSSpec mySpec,Boolean Stereo,short theNumberOfBits,long theRate, Boolean intelFormat, long theHeaderSize){	short sourceRef, destRef, rfRefNum, iRefNum;	OSErr	iErr,err;	long filePos,bytesTilEnd,theTote;	long inOutCount;	long audiosize,AOffset;	FSSpec theNewFile;	Str255 theComment;	Handle mySndH;	StringHandle h1,h2,h3;	Str255 theStringa,theStringb,theStringc,theStringd;	long thefirstbit, thesecondbit;	FInfo	fndrInfo;	Boolean changeSign;	long theSRate;	long theDuration;	Boolean isStereo, stereo;	long numBits;		iErr = FSpOpenDF(&mySpec,fsCurPerm,&sourceRef);	if (iErr!=0)	{		genError ("\pCan't open file");		return false;	}			mySndH = NewHandle(131072L);					/** buffer a **/	if (!mySndH)	{		genError("\pNot enough memory, increase partition size, or reduce buffer in prefs");		FSClose(sourceRef);		return false;	}	BlockMove (&mySpec,&theNewFile,70L);		theNewFile.parID = theConvertDestLoc.parID;	theNewFile.vRefNum = theConvertDestLoc.vRefNum;		concatStrings(theNewFile.name,"\pSD2","\p-");	iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theNewFile);					iErr = FSpCreate(&theNewFile,'Sd2a','Sd2f',0);				}				else				{					return false;				}			}		}	FSpCreateResFile(&theNewFile,'Sd2a','Sd2f',0);	if (iErr != 0)	{		genError("\pCan't create new res file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	iErr = FSpOpenDF(&theNewFile,fsWrPerm,&destRef);	if (iErr != 0)	{		genError("\pCan't create new file");		FSClose(sourceRef);		DisposHandle(mySndH);		return false;	}	if (theHeaderSize > 0L)	{		iErr = SetFPos(sourceRef,1,theHeaderSize);	}		progressCreate("\pConverting File");	err = 0;	while (err != eofErr)	{		inOutCount = 131072L;		if (progressDisp(0))		{			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}			err = FSRead(sourceRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't read source file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			return false;		}if (radar24BitMode){	if(inOutCount > 131040L)	{		inOutCount = 131040L;	}}		if (intelFormat & (theNumberOfBits == 3L))		{			pcConv24(*mySndH, inOutCount);		}		if (intelFormat & (theNumberOfBits == 2L))		{			ConvertSound(*mySndH,inOutCount);		}		if (intelFormat & (theNumberOfBits == 1L))		{			pcConv8(*mySndH,inOutCount);		}					iErr = FSWrite(destRef,&inOutCount,*mySndH);		if (iErr != 0)		{			genError("\pCan't write dest file");			FSClose(sourceRef);			FSClose(destRef);			DisposHandle(mySndH);			progressDispos();			return false;		}	}	FSClose (sourceRef);	FSClose (destRef);	progressDispos();			writeSDIIResources(theNewFile,theRate,Stereo,theNumberOfBits);		addFileToList(theNewFile);	GetFSComment(mySpec, theComment);	SetComment (theNewFile,0,  theComment);	return true;	}void ChangeFInfoMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	OSType theType,theCreator;	Str255 textStr;	Boolean memoryError = false;		/****************/	myDlg = GetNewDialog(22000,0L,(WindowPtr)-1);	SetPort (myDlg);		ShowWindow(myDlg);	do	{		ModalDialog(0,&itemHit);		switch (itemHit)		{			case 4:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 1:				GetDItem(myDlg,4,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					GetDItem(myDlg,6,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);					BlockMove (textStr+1,&theType,4L);				}				else				{					theType = '....';				}				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))				{					GetDItem(myDlg,7,&iType,&iHndl,&iRect);					GetIText(iHndl,textStr);					BlockMove (textStr+1,&theCreator,4L);				}				else				{					theCreator = '....';				}		}	}while (itemHit != 1 && itemHit != 2);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;		getConvertDest();	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));			ChangeFInfo((*therealResults)[theindex], theType, theCreator);			(*theFInfo)[theindex].fdType = theType;			(*theFInfo)[theindex].fdCreator = theCreator;		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}Boolean ChangeFInfo(FSSpec theSpec, OSType theType, OSType theCreator){	short RefNum,sRefNum;	OSErr	iErr;	FInfo fndrInfo;		iErr = FSpGetFInfo(&theSpec,&fndrInfo);	if (theType != '....')		fndrInfo.fdType = theType;	if (theCreator != '....')		fndrInfo.fdCreator = theCreator;	iErr = FSpSetFInfo(&theSpec,&fndrInfo);	return true;}void SDIItoSNDMany(void){	Cell theCell;	short theindex;	Boolean mixMode = false;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr;	short resID;	long tempLong;	Boolean memoryError = false;			/****************/	myDlg = GetNewDialog(16000,0L,(WindowPtr)-1);	SetPort (myDlg);		ShowWindow(myDlg);	ModalDialog(0,&itemHit);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,textStr);	StringToNum(textStr,&tempLong);	resID = LoWord(tempLong);	DisposDialog(myDlg);	/***********/		if (itemHit == 2)		return;					getConvertDest();	watchcursor(true);	writeLogS((unsigned char *)"Starting SDII to SND convert");	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (SDIItoSND((*therealResults)[theindex],resID))		{			writeLog((Ptr)(*therealResults)[theindex].name);			}		else		{			writeLogS((unsigned char *)"Failed to Convert :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}					LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	watchcursor(false);	if (memoryError)		genError("\pSome files could not be converted because there was not enough memory available");}Boolean SDIItoSND(FSSpec theSpec, short resourceID){	short RefNum,sRefNum;	OSErr iErr,err;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes,z, inOutCount;	Handle theData;	FSSpec theSourceSpec;	Str255 theComment;	short headerLen;	Handle theSndHandle;	short iRefNum;	BlockMove (&theSpec,&theSourceSpec,70L);		if (getSDIIData (theSpec, &theRate,&theWordSize,&stereo,&theBytes))		return false;		if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	theSndHandle =  NewHandle(theBytes + 100L);	if (!theSndHandle)	{		SysBeep(5);		return false;	}			theSpec.parID = theConvertDestLoc.parID;	theSpec.vRefNum = theConvertDestLoc.vRefNum;		FSpCreateResFile(&theSpec,'movr','sfil',0);	iErr = ResError();		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theSpec);					FSpCreateResFile(&theSpec,'movr','sfil',0);					iErr = ResError();				}				else				{					return false;				}			}		}				iRefNum = CurResFile();				RefNum = FSpOpenResFile(&theSpec,fsRdWrPerm);		iErr = ResError();		UseResFile(RefNum);						iErr = SetupSndHeader((SndListResource **)theSndHandle,stereo+1,(Fixed)(theRate<<16),theWordSize*8,'NONE',0x3C,theBytes,&headerLen);			if (iErr)		{			DisposHandle(theSndHandle);			return false;		}				iErr = FSpOpenDF(&theSourceSpec,fsRdPerm,&sRefNum);		if (iErr != 0)		{			genError("\pProblem opening file");			FSClose (RefNum);			return false;		}				watchcursor(true);		progressCreate("\pConverting File");			inOutCount = theBytes;			err = FSRead(sRefNum,&inOutCount,(*theSndHandle)+(long)headerLen);			if (iErr )			{				SysBeep(5);				FSClose(sRefNum);				DisposHandle(theSndHandle);				progressDispos();				CloseResFile(RefNum);				watchcursor(false);				UseResFile(iRefNum);				return false;			}		progressDispos();		watchcursor(false);		 if (theWordSize == 1)		 {		 	for (z=(long)((*theSndHandle)+(long)headerLen);z<(long)((*theSndHandle)+(long)headerLen + theBytes);z++)		 	{		 		*(Byte *)z += 0x80;		 	}		 		 }		AddResource((Handle)theSndHandle,'snd ',resourceID,theSourceSpec.name);		WriteResource(theSndHandle);				FSClose(sRefNum);		CloseResFile(RefNum);				UseResFile(iRefNum);				//DisposHandle(theSndHandle);				addFileToList(theSpec);		return true;/* copy comment */}Boolean RecoverSDII(FSSpec theSpec, short numBits, short channels, Str255 srate);