#include "SampleSearch.h"#include "Globals.h"#include <Memory.h>#include <Resources.h>#include <QuickDraw.h>#define SFSaveDisk 	0x214#define CurDirStore 0x398#include <Fonts.h>#include <StandardFile.h>#include <ToolUtils.h>#include <Gestalt.h>#include <Movies.h>#include <QuickTimeComponents.h>#define kExportMenu 155#define kMyCustomSaveDialog 2121Boolean addFileToList(FSSpec mySpec);pascal Boolean myExportFileFilter(ParmBlkPtr PB);pascal Boolean myExportFileFilter(ParmBlkPtr PB){	FSSpec fss;	FInfo info;	FSMakeFSSpec(-*(short *)SFSaveDisk, *(long *)CurDirStore, PB->fileParam.ioNamePtr, &fss);	FSpGetFInfo(&fss, &info);	if (info.fdType == MovieFileType)		return false;	else		return true;}/*	This skanky hook just constantly (and stupidly) watches the value of the export		types menu and jams it back into our local variable below.*/pascal short xmyDlgHook(short item, DialogPtr theDialog, short *whichConverter);pascal short xmyDlgHook(short item, DialogPtr theDialog, short *whichConverter){	short kind;	Handle h;	Rect r;	if (GetWRefCon(theDialog) != sfMainDialogRefCon)		return item;	GetDItem(theDialog, sfItemNewFolderUser+1, &kind, &h, &r); // first custom item	*whichConverter = GetCtlValue((ControlHandle)h);	return item;}void CDImportII (void);void CDImportII (void){	OSErr err;	StandardFileReply reply, putFile;	OSType movieType = MovieFileType;	MenuHandle mh = GetMenu(kExportMenu);	ComponentDescription cd;	Component c = 0;	Point where = {0,0};	Str255 newName;	short convertItem = 1;	Component **exportComponents;	Movie theMovie = nil;	short resRef;	OSType creator;	SFTypeList myTypes = {'TRAK','MooV'};	FInfo fndrInfo;	StandardGetFilePreview(0,2, myTypes, &reply);	if (!reply.sfGood) return;	// get the movie.	OpenMovieFile(&reply.sfFile, &resRef, fsRdPerm);		NewMovieFromFile(&theMovie, resRef, nil, nil,			 	0, nil);	CloseMovieFile(resRef);	if (theMovie)	{		addFileToList(reply.sfFile);		DisposeMovie(theMovie);	}	return;}void exportMovie(void);void exportMovie(void){	OSErr err;	StandardFileReply reply, putFile;	OSType movieType = MovieFileType;	MenuHandle mh = GetMenu(kExportMenu);	ComponentDescription cd;	Component c = 0;	Point where = {0,0};	Str255 newName;	short convertItem = 1;	Component **exportComponents;	Movie theMovie = nil;	short resRef;	OSType creator;	SFTypeList myTypes = {'TRAK','MooV'};	FInfo fndrInfo;	StandardGetFilePreview(0,2, myTypes, &reply);	if (!reply.sfGood) return;	// get the movie.	OpenMovieFile(&reply.sfFile, &resRef, fsRdPerm);		NewMovieFromFile(&theMovie, resRef, nil, nil,			 	0, nil);	CloseMovieFile(resRef);	if (!theMovie) return;	#ifdef powerc	SetMovieProgressProc(theMovie,(RoutineDescriptor *) -1, 0);#else	SetMovieProgressProc(theMovie, (MovieProgressUPP)-1, 0);#endif	// build a list of all export components which are applicable to this movie	exportComponents = (Component **)NewHandle(0);	cd.componentType = MovieExportType;	cd.componentSubType = 0;	cd.componentManufacturer = 0;	cd.componentFlags = canMovieExportFiles;	cd.componentFlagsMask = canMovieExportFiles;	while (c = FindNextComponent(c, &cd)) {		Handle h = NewHandle(4);		ComponentDescription exportCD;		if (GetComponentInfo(c, &exportCD, h, nil, nil) == noErr) {			Str255 s;			Handle h2 = NewHandle(4);			ComponentDescription mhcd;			Component mediaHandler;			mhcd.componentType = MediaHandlerType;			mhcd.componentSubType = exportCD.componentManufacturer;			mhcd.componentManufacturer = 0;			mhcd.componentFlags = 0;			mhcd.componentFlagsMask = 0;			if (mediaHandler = FindNextComponent(0, &mhcd)) {				long trackCount = GetMovieTrackCount(theMovie);				long i;				Boolean foundMedia = true;				// make sure the media type the component can export is in the movie				if (exportCD.componentManufacturer) {					foundMedia = false;					for (i=1; i<=trackCount; i++) {						Track t = GetMovieIndTrack(theMovie, i);						OSType mediaType;							GetMediaHandlerDescription(GetTrackMedia(t), &mediaType, nil, nil);						foundMedia = (mediaType == exportCD.componentManufacturer);						if (foundMedia) break;					}				}				if (foundMedia && (GetComponentInfo(mediaHandler, nil, h2, nil, nil) == noErr)) {					Str255 s;					// build menu name in un-international friendly way					if (exportCD.componentManufacturer) {						BlockMove(*h2, s, sizeof(s));						s[++s[0]] = ' ';						s[++s[0]] = 't';						s[++s[0]] = 'o';						s[++s[0]] = ' ';					}					else						s[0] = 0;					BlockMove(*h + 1, &s[s[0] + 1], **h);					s[0] += **h;					AppendMenu(mh, s);					PtrAndHand((Ptr)&c, (Handle)exportComponents, sizeof(c));					DisposHandle(h);				}			}		}		DisposHandle(h);	}	InsertMenu(mh, -1);	if (GetHandleSize((Handle)exportComponents) == 0) {		// no export components for this movie are available		SysBeep(1);		goto bail;	}	BlockMove(reply.sfFile.name, newName, 255L);	newName[++newName[0]] = '!';	convertItem = 1;			err = FSMakeFSSpec(reply.sfFile.vRefNum,reply.sfFile.parID,newName,&(putFile.sfFile));		GetComponentInfo((*exportComponents)[convertItem - 1], &cd, nil, nil, nil);	// cheap map in the application to allow us to chose the file creator	{		Handle h = GetResource('fMap', 128);		short count = GetHandleSize(h) / (sizeof(OSType) * 2);		OSType *creators = *(OSType **)h;		creator = '????';		while (count-- > 0) 		{			if (*creators++ == cd.componentSubType) 			{				creator = *creators;				break;			}			creators++;		}	}	if (cd.componentFlags & hasMovieExportUserInterface) 	{		MovieExportComponent exporter;		Boolean canceled = false;		exporter = OpenComponent((*exportComponents)[convertItem - 1]);		err = MovieExportDoUserDialog(exporter, (Movie)&reply.sfFile, 0, 0, 0, &canceled);		if (err || canceled) 		{			CloseComponent(exporter);			return;		}		err = ConvertMovieToFile(theMovie, nil, &putFile.sfFile,			cd.componentSubType, creator, putFile.sfScript, nil, createMovieFileDeleteCurFile,			exporter);		CloseComponent(exporter);	}	else 	{		// no user interface available. let the movie toolbox do the hard part			err = ConvertMovieToFile(theMovie, nil, &putFile.sfFile,			cd.componentSubType, creator, putFile.sfScript, nil, createMovieFileDeleteCurFile,			(ComponentInstance)(*exportComponents)[convertItem - 1]);	}	if (err)		SysBeep(1);		addFileToList(putFile.sfFile);bail:	DeleteMenu(kExportMenu);	DisposeMenu(mh);	DisposeMovie(theMovie);	DisposHandle((Handle)exportComponents);		err = FSpDelete(&(reply.sfFile));}