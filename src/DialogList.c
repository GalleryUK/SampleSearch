#include "SampleSearch.h"#include "Globals.h"extern Boolean InstExamine;#include <stdio.h>#include <string.h>#include "prefs.h"extern newPrefsRec theNewPrefs;#define LISTITEM	2#define LISTITEM2	4Boolean scanList(Str255	theDrive);#define OKITEM	1#define DUMMYITEM	3	// used so that one can set up the default item.short theUpdated;short the2Updated;Boolean renameSCII(Str255  theoldname,  Ptr thePtr);#define DIALOGID	11000short list1Len;short	list2Len;extern Boolean DialogPresent;Point	p;Boolean alreadydone;pascal void UserProc(WindowPtr theDialog, short theItem);pascal void UserProc2(WindowPtr theDialog, short theItem);Boolean addFileToList(FSSpec mySpec);pascal void ButtonProc(WindowPtr theDialog,short theItem);pascal Boolean zmyDlgFilter (DialogPtr theDialog, EventRecord *theEvent,							short *itemHit);pascal	OSErr	myPBCatSearchSyncCompat(CSParamPtr paramBlock);pascal	OSErr	PBCatSearchSyncCompat(CSParamPtr paramBlock);ListHandle theList, theList2;typedef struct	examineRec {	Str31	theFName;	Str27	theVName;	long	theDirID;	OSType	theType;	}ERec;Boolean GetComment(FSSpec mySpec, short index, Str255 theComment);Boolean SetComment (FSSpec mySpec, short index, StringPtr theComment);Boolean GetSizeDate (FSSpec mySpec, short index, long* theSize, long* theDate);	extern struct examineRec	*myERPtr,*mySERPtr;extern short 	theFNameListLen;extern short	theSFNameListLen;Boolean dblDog1=FALSE,dblDog2=FALSE;short fillStruct(ERec *  myERecPtr, FSSpec	mySpec);Boolean ResolveSCIIFile(ERec *  myERecPtr,short	theIndex, short* AtheUpdated);void DialogList(FSSpec theSelFile){	DialogPtr 	theDialog;  	short	type;	Handle	theHandle;	Rect	iRect,ERect;	short whichList, myCount;	short myvRefNum,SampvRefNum,SampBvRefNum;	FSSpec	myTempSpec,myTempSpec2;	OSErr	iErr;	short	CellTextLen;	Str255	theCellText,newNamer;	Cell	myCell, theSCell, testCell, the2Cell,theXCell;	Str255 theComment;	short	itemHit;		Point	theCell; 		char	s[90];		short	len; 		Rect	aRect;	long theSize, theDate;	ModalFilterUPP xmyDlgFilter = NewModalFilterProc(zmyDlgFilter);	short q;	EventRecord	theEvent;	alreadydone = false;		theUpdated = -1; /** to tell Burn which member has been resolved **/	the2Updated = -1;	DialogPresent = true;		theDialog = GetNewDialog(DIALOGID,nil,(WindowPtr)-1);	SetPort (theDialog);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);		GetDItem(theDialog,LISTITEM,&type,&theHandle,&iRect);	SetDItem(theDialog,LISTITEM,type,(Handle)NewUserItemProc(UserProc),&iRect);		GetDItem(theDialog,LISTITEM2,&type,&theHandle,&iRect);	SetDItem(theDialog,LISTITEM2,type,(Handle)NewUserItemProc(UserProc2),&iRect);		GetDItem(theDialog,DUMMYITEM,&type,&theHandle,&iRect);	SetDItem(theDialog,DUMMYITEM,type,(Handle)NewUserItemProc(MyItemProc),&iRect);	if (InstExamine)	{		HideDItem(theDialog,7);		HideDItem(theDialog,10);		HideDItem(theDialog,13);		HideDItem(theDialog,15);			}		ShowWindow(theDialog);SetPort(theDialog);	do {				ModalDialog(xmyDlgFilter,&itemHit);			alreadydone = true;		 if (itemHit == LISTITEM) 		 {			dblDog1 = LClick(p,0,(ListHandle)theList);						theUpdated = -1;			theCell.h = theCell.v = 0;			if (iErr = LGetSelect(TRUE,&theCell,theList)) 			{				/** maybe look for dbl -click to open */				theSCell.h = theSCell.v = 0;				if (iErr = LGetSelect(TRUE,&theSCell,theList2)) 				{					LSetSelect(FALSE,theSCell,theList2);				}				myvRefNum = FgetVRefNum((myERPtr[theCell.v]).theVName);												/* when examining instrument, this code makes the right list disappear */				/* disable this bit whenexamining instruments */				for (myCount = 0;myCount<=theSFNameListLen;myCount++)    /** maybe this should be just <theSFNameListLen **/				{					SetPt(&myCell,0,myCount);					LSetCell("\p",0,myCell,theList2);				}								//list2Len = 0;				theSFNameListLen=0;				/* display info in item 17 info about file */												if (myvRefNum)				{					iErr = FSMakeFSSpec(myvRefNum,(myERPtr[theCell.v]).theDirID,((myERPtr)[theCell.v]).theFName,&myTempSpec);					if (!iErr)					{																								theSFNameListLen=fillStruct(mySERPtr,myTempSpec);						for (myCount=0; myCount < theSFNameListLen; myCount++) 						{							CellTextLen = *(((mySERPtr)[myCount]).theFName);							BlockMove (&(((mySERPtr)[myCount]).theFName),theCellText,32L);							PtoCstr(theCellText);							if (list2Len <= myCount)							{								LAddRow(1,myCount,theList2);								list2Len ++;							}							SetPt(&theCell,0,myCount);							LSetCell(theCellText,CellTextLen,theCell,theList2);						}						if (dblDog1)						{								iErr = OpenSelection(myTempSpec);												}						}				}			}		}		if (itemHit == LISTITEM2) 		{			dblDog2 = LClick(p,0,(ListHandle)theList2);			the2Updated = -1;			if (dblDog2)			{				myCell.h = myCell.v = 0;				if (LGetSelect(TRUE,&myCell,theList2)) 				{					SampvRefNum = FgetVRefNum(((mySERPtr)[myCell.v]).theVName);					if (SampvRefNum)					{						iErr = FSMakeFSSpec(SampvRefNum,(mySERPtr[myCell.v]).theDirID,((mySERPtr)[myCell.v]).theFName,&myTempSpec);						if (iErr== 0)						{							/********************/							GetComment (myTempSpec, 0, theComment);							GetSizeDate (myTempSpec, 0, &theSize, &theDate);														GetDItem(theDialog,17,&type,&theHandle,&iRect);							SetIText(theHandle,theComment);														NumToString(theSize,theComment);							GetDItem(theDialog,18,&type,&theHandle,&iRect);							SetIText(theHandle,theComment);							/********************/							iErr = OpenSelection(myTempSpec);						}					}				}			}		}		if (itemHit == 7) /*** resolve left **/		{			theCell.h = theCell.v = 0;				if (LGetSelect(TRUE,&theCell,theList)) 			{				if (ResolveSCIIFile(myERPtr,(short)(theCell.v),&theUpdated))				{					myvRefNum = FgetVRefNum(((myERPtr)[theCell.v]).theVName);					theSFNameListLen=0;					if (myvRefNum)					{						iErr = FSMakeFSSpec(myvRefNum,(myERPtr[theCell.v]).theDirID,((myERPtr)[theCell.v]).theFName,&myTempSpec);						theSFNameListLen=fillStruct(mySERPtr,myTempSpec);					}					for (myCount=0; myCount < theSFNameListLen; myCount++) 					{						CellTextLen = *(((mySERPtr)[myCount]).theFName);						BlockMove (&(((mySERPtr)[myCount]).theFName),theCellText,32L);						PtoCstr(theCellText);						if (list2Len <= myCount)						{							LAddRow(1,myCount,theList2);							list2Len ++;						}						SetPt(&theCell,0,myCount);						LSetCell(theCellText,CellTextLen,theCell,theList2);					}					if (theSFNameListLen <=  list2Len)					{						for (myCount = theSFNameListLen;myCount<=list2Len;myCount++)						{							SetPt(&theCell,0,myCount);							LSetCell("\p",0,theCell,theList2);						}					}				}				else				{					SysBeep(5);				}			}				}				if (itemHit == 13) /*** resolve all left **/		{			theCell.h = theCell.v = 0;			for (theCell.v = 0; theCell.v < list1Len ;theCell.v ++)				{				for (q = 0;q<list1Len;q++)				{					testCell.h = 0;					testCell.v = q;					LSetSelect(false,testCell,theList);				}				testCell.h = 0;				testCell.v = theCell.v;				LSetSelect(true,testCell,theList);				if (ResolveSCIIFile(myERPtr,(short)(theCell.v),&theUpdated))				{					myvRefNum = FgetVRefNum(((myERPtr)[theCell.v]).theVName);					theSFNameListLen=0;					if (myvRefNum)					{						iErr = FSMakeFSSpec(myvRefNum,(myERPtr[theCell.v]).theDirID,((myERPtr)[theCell.v]).theFName,&myTempSpec);						theSFNameListLen=fillStruct(mySERPtr,myTempSpec);					}					for (myCount=0; myCount < theSFNameListLen; myCount++) 					{						CellTextLen = *(((mySERPtr)[myCount]).theFName);						BlockMove (&(((mySERPtr)[myCount]).theFName),theCellText,32L);						PtoCstr(theCellText);						if (list2Len <= myCount)						{							LAddRow(1,myCount,theList2);							list2Len ++;						}						SetPt(&the2Cell,0,myCount);						LSetCell(theCellText,CellTextLen,the2Cell,theList2);					}					if (theSFNameListLen <=  list2Len)					{						for (myCount = theSFNameListLen;myCount<=list2Len;myCount++)						{							SetPt(&the2Cell,0,myCount);							LSetCell("\p",0,the2Cell,theList2);						}					}				}				else				{					SysBeep(5);				}			}				}		if (itemHit == 11) /** resolve right **/		{			theCell.h = theCell.v = 0;				if (LGetSelect(TRUE,&theCell,theList2)) 			{				if (!(ResolveSCIIFile(mySERPtr,(short)(theCell.v),&the2Updated)))					SysBeep(5);			}				}				if (itemHit == 14) /** resolve all right **/		{			theCell.h = theCell.v = 0;				for (theCell.v = 0;theCell.v < theSFNameListLen; theCell.v ++)			{				for (q = 0;q<list2Len;q++)				{					testCell.h = 0;					testCell.v = q;					LSetSelect(false,testCell,theList2);									}				testCell.v = theCell.v;				LSetSelect(true,testCell,theList2);				if (!(ResolveSCIIFile(mySERPtr,(short)(theCell.v),&the2Updated)))					SysBeep(5);			}				}				if (itemHit == 20) /** add all right **/		{			theCell.h = theCell.v = 0;				for (theCell.v = 0;theCell.v < theSFNameListLen; theCell.v ++)			{				for (q = 0;q<list2Len;q++)				{					testCell.h = 0;					testCell.v = q;					LSetSelect(false,testCell,theList2);				}				testCell.v = theCell.v;				LSetSelect(true,testCell,theList2);				SampBvRefNum = FgetVRefNum(((mySERPtr)[theCell.v]).theVName);				iErr = FSMakeFSSpec(SampBvRefNum,(mySERPtr[theCell.v]).theDirID,((mySERPtr)[theCell.v]).theFName,&myTempSpec);				if (!iErr)				{					addFileToList(myTempSpec);				}				else					SysBeep(5);			}										}				if (itemHit == 5)   /** play one **/		{			theCell.h = theCell.v = 0;			if (LGetSelect(TRUE,&theCell,theList2)) 			{				SampvRefNum = FgetVRefNum(((mySERPtr)[theCell.v]).theVName);				if (SampvRefNum)				{					iErr = FSMakeFSSpec(SampvRefNum,(mySERPtr[theCell.v]).theDirID,((mySERPtr)[theCell.v]).theFName,&myTempSpec);					if (iErr == 0)						Audition(myTempSpec, 0x3C);				}			}			}		if (itemHit == 6)   /** play all **/		{			for (theCell.v=0;theCell.v < theSFNameListLen;theCell.v++)			{				for (q = 0;q<theSFNameListLen;q++)				{					testCell.h = 0;					testCell.v = q;					LSetSelect(false,testCell,theList2);									}				testCell.v = theCell.v;				LSetSelect(true,testCell,theList2);				SampvRefNum = FgetVRefNum(((mySERPtr)[theCell.v]).theVName);				if (SampvRefNum)				{					iErr = FSMakeFSSpec(SampvRefNum,(mySERPtr[theCell.v]).theDirID,((mySERPtr)[theCell.v]).theFName,&myTempSpec);					if (iErr == 0)						Audition(myTempSpec, 0x3C);				}			}			}				if (itemHit == 10)  /** update left **/		{							for (theUpdated=0;theUpdated < list1Len;theUpdated++)				{					burnData(theSelFile,theUpdated);				}					}		if (itemHit == 12)  /* update right **/		{				theCell.h = theCell.v = 0;				LGetSelect(TRUE,&theCell,theList);				SampBvRefNum = FgetVRefNum(((myERPtr)[theCell.v]).theVName);				iErr = FSMakeFSSpec(SampBvRefNum,(myERPtr[theCell.v]).theDirID,((myERPtr)[theCell.v]).theFName,&myTempSpec);				for (the2Updated=0;the2Updated < list2Len;the2Updated++)				{					burnSData(myTempSpec,the2Updated);				}		}				if (itemHit == 19) /* add */		{			theCell.h = theCell.v = 0;				if (LGetSelect(TRUE,&theCell,theList2)) 			{				SampBvRefNum = FgetVRefNum(((mySERPtr)[theCell.v]).theVName);				iErr = FSMakeFSSpec(SampBvRefNum,(mySERPtr[theCell.v]).theDirID,((mySERPtr)[theCell.v]).theFName,&myTempSpec);				if (!iErr)				{					addFileToList(myTempSpec);				}				else					SysBeep(5);			}		}						if (itemHit == 15)  /* rename left **/		{			theCell.h = theCell.v = 0;				if (LGetSelect(TRUE,&theCell,theList)) 			{				SampBvRefNum = FgetVRefNum(((myERPtr)[theCell.v]).theVName);				iErr = FSMakeFSSpec(SampBvRefNum,(myERPtr[theCell.v]).theDirID,((myERPtr)[theCell.v]).theFName,&myTempSpec);				if (!iErr)				{					if (renameSCII(((myERPtr)[theCell.v]).theFName,(char *)newNamer))					{						BlockMove (newNamer,((myERPtr)[theCell.v]).theFName,32L);					theUpdated = theCell.v;						burnData(theSelFile,theUpdated);						iErr = FSpRename(&myTempSpec,newNamer);						LSetCell(newNamer+1L,*newNamer,theCell,theList);					}				}				else					SysBeep(5);			}		}				if (itemHit == 16)  /* rename right **/		{			theCell.h = theCell.v = 0;				if (LGetSelect(TRUE,&theCell,theList2)) 			{				SampBvRefNum = FgetVRefNum(((mySERPtr)[theCell.v]).theVName);				iErr = FSMakeFSSpec(SampBvRefNum,(mySERPtr[theCell.v]).theDirID,((mySERPtr)[theCell.v]).theFName,&myTempSpec);				if (iErr == 0)				{						if (renameSCII(((mySERPtr)[theCell.v]).theFName,(char *)newNamer))					{						BlockMove (newNamer,((mySERPtr)[theCell.v]).theFName,32L);					theUpdated = theCell.v;						theXCell.h = theXCell.v = 0;						if (!InstExamine)						{							LGetSelect(TRUE,&theXCell,theList);						}						SampBvRefNum = FgetVRefNum(((myERPtr)[theXCell.v]).theVName);						iErr = FSMakeFSSpec(SampBvRefNum,(myERPtr[theXCell.v]).theDirID,((myERPtr)[theXCell.v]).theFName,&myTempSpec2);						if (!iErr)						{							burnSData(myTempSpec2,theCell.v);							iErr = FSpRename(&myTempSpec,newNamer);							LSetCell(newNamer+1L,*newNamer,theCell,theList2);						}						else							SysBeep(5);					}				}				else 					SysBeep(5);			}		}	 	} while (itemHit != OKITEM);		LDispose(theList);	LDispose(theList2);	DisposPtr((Ptr)myERPtr);	iErr = MemError();	if (iErr !=0)		genError ("\p Can't dispose myERPtr");	DisposPtr((Ptr)mySERPtr);	iErr = MemError();	if (iErr !=0)		genError ("\p Can't dispose mySERPtr");	DisposDialog(theDialog);	DialogPresent = false;	return;}pascal Boolean zmyDlgFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit){	Rect	iRect,rView,rBounds;	short	type,iType;	Handle	iHndle;	Rect	iRect2,iRect3,newLRect,imRect;	short	type2,type3;	Handle	iHndle2,iHndle3,iHandle;	char	theChar;	Point	theCell,pCellSz,myCell;	short myvRefNum;	FSSpec	myTempSpec;	short 	myCount;	OSErr	iErr;	short	CellTextLen;	Str255	theCellText;	short theItem;	short 	itype, SampvRefNum;	Handle theHandle;	short theQuay;	Rect dragRect;	WindowPtr	whichWindow;	short thePart;		SetPort(theDialog);	dragRect = qd.screenBits.bounds;	// case on the event	switch (theEvent->what) {	case keyDown:			// if key was pressed, handle return key			theQuay = (theEvent->message) & keyCodeMask;			theChar = (theEvent->message) & charCodeMask;			if ( (theChar == 0x0d) || (theChar == 0x03)) 			{					*itemHit = OKITEM;					return TRUE;			}			if (theQuay == 0x7D)			{				/** down arrow pressed **/			}			if (theQuay == 0x7E)			{				/** up arrow pressed **/			}			if (theChar == 0x20){					*itemHit = 5;					{						GetDItem(theDialog,5,&iType,&iHandle,&imRect);						HiliteControl((ControlHandle)iHandle,253);						theCell.h = theCell.v = 0;						if (LGetSelect(TRUE,&theCell,theList2)) 						{							SampvRefNum = FgetVRefNum(((mySERPtr)[theCell.v]).theVName);							if (SampvRefNum)							{								iErr = FSMakeFSSpec(SampvRefNum,(mySERPtr[theCell.v]).theDirID,((mySERPtr)[theCell.v]).theFName,&myTempSpec);								if (iErr == 0)									Audition(myTempSpec, 0x3C);							}						}						HiliteControl((ControlHandle)iHandle,0);						}					return FALSE;			}			return FALSE;			break;	case mouseDown:								// Get where mouse click occured in global coordinates.			p = theEvent->where;			GlobalToLocal(&p);						GetDItem(theDialog,LISTITEM,&type,&iHndle,&iRect);			GetDItem(theDialog,LISTITEM2,&type2,&iHndle2,&iRect2);			GetDItem(theDialog,7,&type3,&iHndle3,&iRect3);			// If the mouse click was not in LISTITEM, then let ModalDialog handle			// it.			if (!PtInRect(p,&iRect) && !PtInRect(p,&iRect2) && !PtInRect(p,&iRect3)) 			{					return FALSE;			}			// Mouse Click was in list item,			// Set the itemHit to be the LISTITEM,			// and call LClick on itemhandle (the list).			if (PtInRect(p,&iRect))			{				*itemHit = LISTITEM;				return FALSE;			}			if (PtInRect(p,&iRect2))			{				*itemHit = LISTITEM2;				return FALSE;			}			if (PtInRect(p,&iRect3))			{				*itemHit = 7;				return FALSE;			}			break;						case updateEvt:			 //return FALSE;			 return false;			break;						case activateEvt:			 return FALSE;			break;						default :				return FALSE;			break;	}}/*	This is the proc that the I use to draw a border around	the OK Button to mark it as the default item.*/pascal void ButtonProc(WindowPtr theDialog,short theItem){	Rect	iRect;	Handle	iHndl;	short	iType;	//  Grab Information for OKITEM out of the Dialog	GetDItem(theDialog,OKITEM,&iType,&iHndl,&iRect);	// Now frame it	PenSize(1,1);	InsetRect(&iRect,2,2);	FrameRect(&iRect);}/*	This proc is used to create the list for the LISTITEM,	and then "install" it into the dialog item list*/pascal void UserProc(WindowPtr theDialog, short theItem){	Rect 	iRect,			rView,			rBounds;	short 	h,			v;	char 	s[25];	Point 	pCellSz,theCell;	Handle theHandle;	short 	itype;	Rect 	tempRect;	Str255	theCellText;	short		CellTextLen;	short myCount;	// Grab item information		if (alreadydone)		return;	GetDItem(theDialog,theItem,&itype,&theHandle,&iRect);	// Set up view for the list.  Notice that there is some	// margin left on all sides for the frame, and the verical scroll bar	rView = iRect;	rView.right -= 16;	rView.left +=2;	rView.bottom -=1;	rView.top += 1;	// list array is 1 colume with 25 rows	list1Len = theFNameListLen;	SetRect(&rBounds,0,0,1,theFNameListLen);	// force auto calculations when displaying the cells.	pCellSz.h = 0;	pCellSz.v = 0;	// create list and draw it.	theList = LNew (&rView, &rBounds, pCellSz, 0, theDialog, TRUE, TRUE, FALSE,					TRUE);		if (!theList) {			SysBeep(5);			return;	}	(*theList)->selFlags = 186-32;	// Now initialize the cells	for (myCount=0; myCount < theFNameListLen; myCount++) 	{			CellTextLen = *(((myERPtr)[myCount]).theFName);			BlockMove (&(((myERPtr)[myCount]).theFName),theCellText,32L);			PtoCstr(theCellText);			SetPt(&theCell,0,myCount);			LSetCell(theCellText,CellTextLen,theCell,theList);	}	// Draw a frame around the user item	FrameRect (&iRect);	// associate the new list handle with this user item	SetDItem(theDialog,theItem,0,(Handle)NewUserItemProc(theList),&iRect);}pascal void UserProc2(WindowPtr theDialog, short theItem){	Rect 	iRect,			rView,			rBounds;	short 	h,			v;	char 	s[25];	Point 	pCellSz,theCell;	Handle theHandle;	short 	itype;	Rect 	tempRect;	Str255	theCellText;	short		CellTextLen;	short myCount;	if (alreadydone)		return;	// Grab item information	GetDItem(theDialog,theItem,&itype,&theHandle,&iRect);		// Set up view for the list.  Notice that there is some	// margin left on all sides for the frame, and the verical scroll bar	rView = iRect;	rView.right -= 16;	rView.left +=2;	rView.bottom -=1;	rView.top += 1;	// list array is 1 colume with 25 rows	list2Len = theSFNameListLen;	SetRect(&rBounds,0,0,1,theSFNameListLen);	// force auto calculations when displaying the cells.	pCellSz.h = 0;	pCellSz.v = 0;	// create list and draw it.	theList2 = LNew (&rView, &rBounds, pCellSz, 0, theDialog, TRUE, TRUE, FALSE,					TRUE);	if (!theList2) {			SysBeep(5);			return;	}	(*theList2)->selFlags = 186;	// Now initialize the cells	for (myCount=0; myCount < theSFNameListLen; myCount++) 	{			CellTextLen = *(((mySERPtr)[myCount]).theFName);			BlockMove (&(((mySERPtr)[myCount]).theFName),theCellText,32L);			PtoCstr(theCellText);			SetPt(&theCell,0,myCount);			LSetCell(theCellText,CellTextLen,theCell,theList2);	}		// Draw a frame around the user item	PenSize(1,1);		FrameRect (&iRect);	// associate the new list handle with this user item	SetDItem(theDialog,theItem,0,(Handle)NewUserItemProc(theList2),&iRect);}Boolean ResolveSCIIFile(ERec *  myERecPtr,short	theIndex, short* AtheUpdated){	HParamBlockRec RPb; 				/** parameter block for PBCatSearch **/	short z;	FSSpec testSpec;	FSSpec	theResolveSpec[2];	OSErr	gErr,iErr;			char *occur;	Str255 Cstring,substring;	FInfo fndrInfo;		gogetvolref();		iErr = FSMakeFSSpec(FgetVRefNum((myERecPtr[theIndex]).theVName),(myERecPtr[theIndex]).theDirID,(myERecPtr[theIndex]).theFName,&testSpec);	if (iErr == 0)	{		iErr = FSpGetFInfo(&testSpec, &fndrInfo);		if (!iErr)		{			switch ((myERecPtr[theIndex]).theType)			{				case 'SCin':case 'SCsi':case 'SCss':case 'SCsd':					switch (fndrInfo.fdType)					{						case 'SCin':case 'SCsi':case 'SCss':case 'SCsd':							(myERecPtr[theIndex]).theType = fndrInfo.fdType;							*AtheUpdated = theIndex;							return true;						break;					}				break;				case 'AIFF':case 'Sd2f':case 'SFIL':					switch (fndrInfo.fdType)					{						case 'AIFF':case 'Sd2f':case 'SFIL':							(myERecPtr[theIndex]).theType = fndrInfo.fdType;							*AtheUpdated = theIndex;							return true;						break;					}				break;			}		}	}	for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/	{		 BlockMove (volName[z],Cstring,28L);		  PtoCstr (Cstring);		  makeStr255("\pAudio CD",substring);		  PtoCstr (substring);		  occur = strstr((const char *)Cstring,(const char *)substring);		if (!(*volName[z]))		{			occur = (Ptr)1;		}		  if (!occur)		 {			if (!scanList(volName[z]))					{				RPb.csParam.ioVRefNum = volumes[z];		/** select relevant volume **/								RPb.csParam.ioCompletion = nil;  				/** no completion routine **/				RPb.csParam.ioNamePtr = nil;   			 		/** no volume name;  use vRefNum **/				RPb.csParam.ioMatchPtr = &theResolveSpec[0];  			/** points to results buffer **/				RPb.csParam.ioReqMatchCount = 1;   	/** number of matches **/														/** search for name + file or directory + file TYPE  **/				RPb.csParam.ioSearchBits = fsSBPartialName + fsSBFlAttrib + fsSBFlFndrInfo;														RPb.csParam.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/				RPb.csParam.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/				RPb.csParam.ioSearchTime = 0;              	/** don't time out on searches **/				RPb.csParam.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/				RPb.csParam.ioOptBuffer = gBuffer;    			/** point to search cache  **/				RPb.csParam.ioOptBufSize  = kOptBufferSize;		/** size of search cache **/							gSpec1.hFileInfo.ioNamePtr = (myERecPtr[theIndex]).theFName;   		/** point to string to find **/				gSpec1.hFileInfo.ioFlAttrib = 0x00;      		/** clear bit 4 to ask for files **/				gSpec1.hFileInfo.ioFlFndrInfo.fdType = (myERecPtr[theIndex]).theType ; //searchType;	/** just find ???? files **/												gSpec2.hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/				gSpec2.hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/				gSpec2.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  				gSpec2.hFileInfo.ioFlFndrInfo.fdCreator = 0x00000000;														if (theNewPrefs.dontFindAliases)				{					gSpec1.hFileInfo.ioFlFndrInfo.fdFlags = 0;					gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;						}				else				{					gSpec2.hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;					}					watchcursor(TRUE);					/** display watch **/				do 				{					gErr = myPBCatSearchSyncCompat((CSParam *)&RPb);	/** get some files returns error 0 (noErr) if it returns without finishing **/					} while ( RPb.csParam.ioActMatchCount == 0 && gErr == 0);				if ( RPb.csParam.ioActMatchCount > 0)				{						break;					}														/** display arrow **/			}			}		}	watchcursor(FALSE);	if ( RPb.csParam.ioActMatchCount == 0)	{		SysBeep(5);		SysBeep(5);//		genError("\pCouldn't find that Instrument");		return false;	}	else	{		BlockMove(&(volName[-(theResolveSpec[0].vRefNum)]),&((myERecPtr[theIndex]).theVName),28L);  		((myERecPtr)[theIndex]).theDirID = theResolveSpec[0].parID;		*AtheUpdated = theIndex;		return true;	}	return false;}void burnData(FSSpec theSelFile,short myUpdated){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern short theFNameListLen;	short z;	long filpPOS;		iErr = FSpOpenDF(&theSelFile,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		SysBeep(5);		genError ("\p Can't open that file");		return ;	}			filpPOS = findFILP(refNum);	if (!filpPOS)	{		genError ("\p FILP failed");		FSClose(refNum);		return ;	}	iErr = SetFPos(refNum,1,(filpPOS+16)+(myUpdated * 68L));	if(iErr!=0)	{		genError ("\p Can't set pos in that file");		FSClose(refNum);		return ;	}	inOutCount = 28;	iErr = FSWrite(refNum,&inOutCount,&((myERPtr)[myUpdated].theVName));	if(iErr!=0)	{		genError ("\p Can't write a volume name in that file");		FSClose(refNum);		return ;	}	inOutCount = 4;	iErr = FSWrite(refNum,&inOutCount,&(((myERPtr)[myUpdated]).theDirID));	if(iErr!=0)	{		genError ("\p Can't write a DirID in that file");		FSClose(refNum);		return;	}		/* here is the rename */	inOutCount = 32;	iErr = FSWrite(refNum,&inOutCount,&(((myERPtr)[myUpdated]).theFName));	if(iErr!=0)	{		genError ("\p Can't write a Filename in that file");		FSClose(refNum);		return;	}	/* here is the rename */		FSClose(refNum);		if(iErr!=0)		{			genError("\p Can't close that file");		}	iErr = FlushVol(0,theSelFile.vRefNum);		if(iErr!=0)		{			genError  ("\p flush vol failed");		}	return;}void burnSData(FSSpec theSelFile,short myUpdated){	OSErr	iErr;	short refNum;	long inOutCount;	long numberOfFiles;	extern short theFNameListLen;	short z;	long filpPOS;		iErr = FSpOpenDF(&theSelFile,fsCurPerm,&refNum);	if(iErr!=0)	{		SysBeep(5);		SysBeep(5);		genError ("\p Can't open that file");		return ;	}		filpPOS = findFILP(refNum);	if (!filpPOS)	{	 genError ("\pFilpPos didn't work");		FSClose(refNum);		return;	}	iErr = SetFPos(refNum,1,(filpPOS+16)+(myUpdated * 68L));	if(iErr!=0)	{		genError  ("\p Can't set pos in that file");		FSClose(refNum);		return ;	}	inOutCount = 28;	iErr = FSWrite(refNum,&inOutCount,&((mySERPtr)[myUpdated].theVName));	if(iErr!=0)	{		genError  ("\p Can't write a volume name in that file");		FSClose(refNum);		return ;	}	inOutCount = 4;	iErr = FSWrite(refNum,&inOutCount,&(((mySERPtr)[myUpdated]).theDirID));	if(iErr!=0)	{		genError  ("\p Can't write a DirID in that file");		FSClose(refNum);		return;	}	/* here is the rename */	inOutCount = 32;	iErr = FSWrite(refNum,&inOutCount,&(((mySERPtr)[myUpdated]).theFName));	if(iErr!=0)	{		genError ("\p Can't write a Filename in that file");		FSClose(refNum);		return;	}	/* here is the rename */	FSClose(refNum);		if(iErr!=0)		{			genError  ("\p Can't close that file");		}	iErr = FlushVol(0,theSelFile.vRefNum);	if(iErr!=0)		{			genError  ("\p flush vol failed");		}	return;}long findFILP(short localRefNum){	OSErr	iErr;	Handle	myTempStore;	long inOutCount;	long lOffset;	OSType	filpType = 'FILP';	myTempStore = NewHandle(500);	if (!myTempStore)		return 0;	//MoveHHi(myTempStore);	iErr = SetFPos(localRefNum,1,0L);	if (iErr!=0)		return 0;	inOutCount = 490;	iErr = FSRead(localRefNum,&inOutCount,*myTempStore);	if (iErr!=0 && iErr !=eofErr)		return 0;	lOffset = Munger(myTempStore,0,&filpType,4,nil,0);	if (lOffset >= 0)	{		DisposHandle(myTempStore);		return lOffset;	}	else	{		DisposHandle(myTempStore);		return 0;	}}Boolean renameSCII(Str255 theoldname, Ptr thePtr){		short itemHit;				/** for dialog enquiry **/	DialogPtr	mypDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 thenewname = "\p";	mypDlg = GetNewDialog(1923,0L,(WindowPtr)-1);		SetPort (mypDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(mypDlg,3,&iType,&iHndl,&iRect);	SetIText(iHndl,theoldname);		ShowWindow(mypDlg);	SetPort (mypDlg);	ModalDialog(xAlertFilter,&itemHit);	GetDItem(mypDlg,3,&iType,&iHndl,&iRect);	GetIText(iHndl,thenewname);		DisposDialog(mypDlg);	if (itemHit == 2)	{		return false;	}	BlockMove (thenewname,thePtr,32L);	return true;}