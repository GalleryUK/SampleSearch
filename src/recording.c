#include <stdio.h>#include "SampleSearch.h"#include "Globals.h"#include <SoundInput.h>#include <Sound.h>#define ftForwards true#define ftBackwards false#define regionReturned		0#define SDIIFormat 1#define AIFFFormat 2#define wavFormat 3FSSpec theLastSpec,presLastSpec;#define allocDisk falseextern FSSpec theConvertDestLoc;extern long dblBufferSize;extern FSSpec theSSPrefSpec;typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;Boolean writeSDIIResources(FSSpec theSpec,long theRate,Boolean stereo,short theWordSize);Boolean removeGlitch;long pausedPos;long reviewTime;short theSampleSize;typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;Boolean exportRegion (FSSpec source, FSSpec destination, RegionRec	myRgn);short getARegion(FSSpec mySpec, short theIndex,RegionRecPtr	theReturnRegion);extern FSSpec theApplSpec;typedef struct RecPrefsRec {Boolean	interactiveEdit;Boolean	autoTruncate;Boolean threshRecord;Boolean monitorOn;short	threshLevel;short noisefloor;short noisefloorOut;short recordFormat;FSSpec 	soundName;} RecPrefsRec, *RecPrefsRecPtr;short reviewSound(short refNum);SndChannelPtr CreateSndChannel(Boolean Stereo);OSErr InstallCallBack (SndChannelPtr mySndChan);extern Boolean gCallBackPerformed;Boolean autoTopTailSDII(FSSpec mySpec, short noiseFloor);Boolean addFileToList(FSSpec mySpec);Boolean scrapRecording (WindowPtr theDialog);Boolean makeSD2intoRegionParam(FSSpec mySpec, long startFr, long endFr);Fixed theARate;Boolean buttonstate;Boolean autoCrop;short theAChans;Boolean waitForRecord(short thresholdLevel);short theASampleSize;Boolean addFileToList(FSSpec mySpec);short fileCopy (short sourceRef, short destRef, long sourceStart, long destStart, long numBytes);long findChunk(short localRefNum, OSType theChunk);long findAPPL(short localRefNum);Boolean isItTheLastChunk(short localRefNum, long theFPos);long findThresh (short refNum,long startPt, long dataSize, short threshold, Boolean direction, short wordLength, Boolean stereo);Boolean postProcess(FSSpec mySpec);void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);Boolean addFileToList(FSSpec mySpec);Boolean getNextName (FSSpecPtr	mySpecPtr);Boolean startRecording (WindowPtr theDialog);Boolean stopRecording (WindowPtr theDialog);Boolean pauseRecording (WindowPtr theDialog);Boolean setupRecording (WindowPtr theDialog);Boolean resumeRecording (WindowPtr theDialog);unsigned long theFlashTime, theRecordedTime, theLastTime;void	drawColourIcon(short left,short top,short cicnResID);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);Rect PRESoRect;Boolean recordPage(void);Boolean recordPage(void){	StandardFileReply reply;	short fRefNum;	Point corner = {50,50};	OSErr	iErr;	FInfo fndrInfo;	Boolean dontDoIt = false;		StandardPutFile("\pSave the new recording as","\pNew Audio",&reply);	if (reply.sfReplacing)	{		iErr = FSpDelete(&(reply.sfFile));		if (iErr != 0 )		{			genError ("\pCan't delete old file");			return false;		}	}	if (reply.sfGood)	{		iErr = FSpCreate(&(reply.sfFile),'Sd2a','AIFF',0);		if (iErr != 0 )		{			genError ("\pCan't create new file");			return false;		}		iErr = FSpOpenDF(&(reply.sfFile),fsWrPerm,&fRefNum);		if (iErr != 0 )		{			genError ("\pCan't open file for writing");			return false;		}		iErr = SndRecordToFile(0,corner,'best',fRefNum);		if (iErr != 0 )		{			dontDoIt = true;		}		iErr = FSClose(fRefNum);		if (iErr != 0 )		{			genError ("\pCan't close file");			return false;		}				if (!dontDoIt)		{			/*BlockMove (&reply.sfFile,&((*therealResults)[totfindcounter]),70L);			FSpGetFInfo(&reply.sfFile,&fndrInfo);			BlockMove (&fndrInfo,&((*theFInfo)[totfindcounter]),16L);			totfindcounter ++;			reFound = true;*/			addFileToList(reply.sfFile);		}				//postProcess(reply.sfFile);				return true;	}		return false;		}/*Boolean postProcess(FSSpec mySpec){	short itemHit;					DialogPtr	myDlg;				Handle	iHndl;					Rect	iRect;					short	iType;					short threshValue;	Boolean truncateStart, truncateEnd;	short iRefNum, fRefNum;	StringHandle h1,h2,h3;	long wordsize, chans;	Handle	dataH;	long truncStart, truncEnd, truncCurrent, soundLength;	FSSpec	copySpec;	Str255 theTempString;	FInfo fndrInfo;	long inOutCount;	OSErr	iErr;	Boolean lastOne;			myDlg = GetNewDialog(1556,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)(ControlHandle)iHndl,true);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,false);	ShowWindow(myDlg);	itemHit = -1;	while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 5:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)(ControlHandle)iHndl));			break;			case 6:				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;			case 1:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					truncateStart = true;				}				else				{					truncateStart = false;				}				GetDItem(myDlg,6,&iType,&iHndl,&iRect);					if (GetCtlValue((ControlHandle)iHndl))				{					truncateEnd = true;				}				else				{					truncateEnd = false;				}				GetDItem(myDlg,7,&iType,&iHndl,&iRect);					threshValue = GetCtlValue((ControlHandle)iHndl);			break;		}	}		DisposDialog(myDlg);	if (itemHit == 2)		return;			// get wordsize and chans 			if (wordsize == 2)		threshValue *= 256;			BlockMove (&mySpec, &copySpec, 70L);	makeStr255("\pcopy",theTempString);	concatStrings(copySpec.name,theTempString,"\p ");		iErr = FSpOpenDF(&mySpec,fsCurPerm,&fRefNum);	if (iErr != 0)	{		genError ("\pCan't open file to truncate");		return false;	}		iErr = FSpCreate(&copySpec,'Sd2a','AIFF',0);	if (iErr != 0)	{		genError ("\pCan't create new file for truncate");		FSClose (fRefNum);		return false;	}		iErr = FSpOpenDF(&copySpec,fsCurPerm,&iRefNum);	if (iErr != 0)	{		genError ("\pCan't open new file for truncate");		FSClose (fRefNum);		return false;	}	truncCurrent = findChunk(fRefNum,'SSND');	lastOne = isItTheLastChunk(fRefNum,truncCurrent);		if (truncCurrent)	{		iErr = fileCopy (fRefNum, iRefNum, 0L, 0L, truncCurrent);		if (iErr != 0)		{			SysBeep (5);			FSClose (fRefNum);			FSClose (iRefNum);			return false;		}	}		truncCurrent += 16L;	inOutCount = 4L;		iErr = FSRead(fRefNum,&inOutCount,&soundLength);	truncStart = findThresh (fRefNum, truncCurrent,soundLength, threshValue, ftForwards, wordsize, chans);	if (truncStart <= 0)	{		// thresh not found or error occured 	}	// write SSND chunk header		iErr = fileCopy (fRefNum, iRefNum, truncStart + truncCurrent, truncCurrent, soundLength - truncStart);	if (!lastOne)	{	 // copy the rest of the file 	}		// close up etc }*/extern long theAPPLReply;long findChunk(short localRefNum, OSType theChunk){	OSErr	iErr;	Handle	myTempStore;	long inOutCount,filePos;	long lOffset;	OSType	filpType = theChunk;	short passes = 0;	EventRecord	theEvent;		theAPPLReply = 0L;	myTempStore = NewHandle(500);	if (!myTempStore)		return 0;	//MoveHHi(myTempStore);	iErr = SetFPos(localRefNum,1,0L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}	inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}				lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			inOutCount = 4;			iErr = SetFPos(localRefNum,1,lOffset + 8L);			iErr = FSRead(localRefNum,&inOutCount,*myTempStore);			if ((*(OSType *)*myTempStore == 'Sd2a') || (*(OSType *)*myTempStore == 'Sd2x')) 			{				DisposHandle(myTempStore);				theAPPLReply = lOffset;				return lOffset;			}			else			{				iErr = SetFPos(localRefNum,3,-12L);			}		}		iErr = SetFPos(localRefNum,2,-490L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}	iErr = GetFPos(localRefNum,&filePos);			inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			lOffset += filePos;						inOutCount = 4;			iErr = SetFPos(localRefNum,1,lOffset + 8L);			iErr = FSRead(localRefNum,&inOutCount,*myTempStore);			if ((*(OSType *)*myTempStore == 'Sd2a') || (*(OSType *)*myTempStore == 'Sd2x')) 			{				DisposHandle(myTempStore);				theAPPLReply = lOffset;				return lOffset;			}						else			{				iErr = SetFPos(localRefNum,3,-12L);			}		}			iErr = SetFPos(localRefNum,1,490L);	if (iErr!=0)	{		DisposHandle(myTempStore);		return 0;	}				passes = 1;		while (iErr != eofErr)	{		inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			inOutCount = 4;			iErr = SetFPos(localRefNum,1,lOffset + (passes*490) + 8L);			iErr = FSRead(localRefNum,&inOutCount,*myTempStore);			if ((*(OSType *)*myTempStore == 'Sd2a') || (*(OSType *)*myTempStore == 'Sd2x')) 			{				DisposHandle(myTempStore);				theAPPLReply = lOffset + (passes*490);				return lOffset + (passes*490);			}			else			{				iErr = SetFPos(localRefNum,3,-12L);			}		}		if(EventAvail(everyEvent,&theEvent))  		{			DisposHandle(myTempStore);			return 0;		}		passes ++;	}	DisposHandle(myTempStore);	return 0;}/*short fileCopy (short sourceRef, short destRef, long sourceStart, long destStart, long numBytes){	Boolean doitagain;	long inOutCount;	Handle dataH;	OSErr	iErr;	short iRefNum;	long startPos = 0;	doitagain = true;		dataH = NewHandle(32768);	if (!dataH)	{		genError ("\pNot enough memory to do that");		return -999;	}		iErr = SetFPos(sourceRef,1,sourceStart);	if (iErr!=0)	{		genError ("\pCan't position file in source");		DisposHandle(dataH);		return -998;	}	iErr = SetFPos(destRef,1,destStart);	if (iErr!=0)	{		genError ("\pCan't position file in dest");				DisposHandle(dataH);		return -998;	}		while (doitagain)	{		inOutCount = numBytes;		if (inOutCount > 32000)		{			inOutCount = 32000L;			doitagain = true;		}		else		{			doitagain = false;		}				iErr = FSRead(iRefNum,&inOutCount,*dataH);		if (iErr != 0)		{			genError ("\pCan't read DF of source file");			DisposHandle(dataH);			return -997;		}				iErr = FSWrite(fRefNum,&inOutCount,*dataH);		if (iErr != 0)		{			genError ("\pCan't write DF of dest file");			DisposHandle(dataH);			return -997;		}		startPos += 32000L;	}	DisposHandle(dataH);	return 0;}*/long findThresh (short refNum,long startPt, long dataSize, short threshold, Boolean direction, short wordLength, Boolean stereo){	OSErr	iErr;	Handle dataH;	long thePosition;	Boolean doitagain;	long inOutCount;	short z;	Byte byteTest;	short wordTest;	short passes = 0;		if (direction)	{		dataH = NewHandle(32768);		if (!dataH)		{			genError ("\pNot enough memory to do that");			return -999;		}				iErr = SetFPos(refNum,1,startPt);		if (iErr!=0)		{			genError ("\pCan't position file in source");			DisposHandle(dataH);			return -998;		}				doitagain = true;				thePosition = startPt;				while (doitagain)		{			if (thePosition + 32000L <= startPt+dataSize)			{				inOutCount = 32000L;				doitagain = true;			}			else			{				inOutCount = startPt+dataSize - thePosition;				doitagain = false;			}						iErr = FSRead(refNum,&inOutCount,dataH);			if (iErr != 0)			{				genError ("\pCan't read from source");				DisposHandle(dataH);				return -997;			}			for (z=0;z<inOutCount;z += (wordLength * (stereo+1)))			{				if (wordLength == 2)				{					if (stereo)					{						BlockMove ((*dataH)+z, &wordTest, 2L);						wordTest += 16384;						if (wordTest-threshold > 16384 || wordTest-threshold < 16384)						{							DisposHandle(dataH);							return ((passes * 32000L) + (long)((*dataH)+z));						}												BlockMove ((*dataH)+z+2, &wordTest, 2L);						wordTest += 16384;						if (wordTest-threshold > 16384 || wordTest-threshold < 16384)						{							DisposHandle(dataH);							return ((passes * 32000L) + (long)((*dataH)+z));						}					}					else					{						BlockMove ((*dataH)+z, &wordTest, 2L);								wordTest += 16384;						if (wordTest-threshold > 16384 || wordTest-threshold < 16384)						{							DisposHandle(dataH);							return ((passes * 32000L) + (long)((*dataH)+z));						}					}							}				else				{					if (stereo)					{						BlockMove ((*dataH)+z,&byteTest, 1L);						byteTest += 128;						if (byteTest-threshold > 128 || byteTest-threshold < 128)						{							DisposHandle(dataH);							return ((passes * 32000L) + (long)((*dataH)+z));						}												BlockMove ((*dataH)+z+2, &byteTest, 1L);						byteTest += 128;						if (byteTest-threshold > 128 || byteTest-threshold < 128)						{							DisposHandle(dataH);							return ((passes * 32000L) + (long)((*dataH)+z));						}					}					else					{						BlockMove ((*dataH)+z, &byteTest, 2L);						byteTest += 128;						if (byteTest-threshold > 128 || byteTest-threshold < 128)						{							DisposHandle(dataH);							return ((passes * 32000L) + (long)((*dataH)+z));						}					}				}			}			passes ++;		}		DisposHandle(dataH);		return eofErr;		}	else	{		/* do it all backwards */	}}typedef struct meterRec {	short meterOn;	short meterValue;} meterRec, *meterRecPtr;pascal void SetupLevelUserProc(WindowPtr theDialog, short theItem);short flashCount,peakCount;Boolean isRecording;Boolean manualPause;Boolean isWaiting;SPB	mySPB;#define AIFF 0#define SDII 1long myInRefNum;short theRecordRefNum;short theRecFormat;Boolean viewAudio(FSSpec mySpec);Boolean editAfterRecord;pascal Boolean myLevelFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);	FSSpec	theRecordingFile;short theVUMeter,thePeakHold;extern Str31  newName;	short zisPressed(unsigned short k );/* CODE EXAMPLE #1 */short zisPressed(unsigned short k )// k =  any keyboard scan code, 0-127{	unsigned char km[16];	GetKeys( ( long *) km);	return ( ( km[k>>3] >> (k & 7) ) & 1);}Boolean CustomRecording (void);Boolean CustomRecording (void){	short fRefNum;	OSErr	iErr;	UserItemUPP xSetupLevelUserProc;	Boolean playThru;	short playthruvol;	long myBuffSize;	short myHeaderLen;	short myNumChans;	FSSpec tempspec;	short mySampSize;		short theTwos;	Fixed	mySampRate;	OSType	myCompType,infoType;	Ptr infoData;	short meterSetting;	meterRec	meterSetup;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255	textStr;	short iCtlValue, iCtlPart, iCtlVal;	GrafPtr	savePort;	StandardFileReply	reply;	Boolean agcState = false;	short devinfo;	FInfo fndrInfo;	GrafPtr 	saverPort;	Point localPt;	short noiseFloor;	RecPrefsRec theRecPrefs;	Handle recPrefsH;	short theAmount;	long finalTick;	Str255 theTextStr;	short prefNum, piRefNum;	long theAve;	unsigned long secs;		unsigned long pressecs;	short z, theMax;	long trashDirID;	short trashVRefNum;	FSSpec lastName;	ModalFilterUPP xmyLevelFilter = NewModalFilterProc(myLevelFilter );	theFlashTime = 0L;	thePeakHold = 0;	theVUMeter = 0;	theLastSpec.vRefNum = -999;	flashCount = 0;	isRecording = false;	isWaiting = false;	meterSetup.meterOn = true;	manualPause = false;	iErr = SPBOpenDevice("\p",siWritePermission,&myInRefNum);	if (iErr != 0)	{		genError ("\pCan't open device");		return false;	}	 	if (zisPressed(0x3A)) 	{		short thesChannels = 1;		short thesBits = 16;		Fixed thesRate = 0xAC440000;					iErr = SPBSetDeviceInfo(myInRefNum,'srat', &thesRate);		iErr = SPBSetDeviceInfo(myInRefNum,'ssiz', &thesBits);		iErr = SPBSetDeviceInfo(myInRefNum,'chan', &thesChannels); 	}		 	myDlg = GetNewDialog(4410,0L,(WindowPtr)-1);	SetPort(myDlg);		color.red = 56797;		color.green = 56797;		color.blue =56797;		RGBBackColor(&color);		piRefNum = CurResFile();			prefNum = FSpOpenResFile (&theSSPrefSpec,fsCurPerm);	if (!prefNum)	{		genError ("\pError finding prefs");	}	UseResFile(prefNum);	recPrefsH = Get1Resource('Rprf',1000);	if (recPrefsH)	{		BlockMove (*recPrefsH, &theRecPrefs, sizeof(RecPrefsRec));		ReleaseResource(recPrefsH);	}	else	{		theRecPrefs.interactiveEdit = false;		theRecPrefs.autoTruncate = false;		theRecPrefs.threshRecord = false;		theRecPrefs.threshLevel = 15;		theRecPrefs.noisefloor = 15;		theRecPrefs.monitorOn = false;		theRecPrefs.recordFormat = SDIIFormat;		theRecPrefs.soundName.vRefNum = -1;		theRecPrefs.soundName.parID = 2L;		makeStr255("\pUntitled",theRecPrefs.soundName.name);				recPrefsH = NewHandle(sizeof(RecPrefsRec));		if (!recPrefsH)		{				genError ("\pNot enough memory");			CloseResFile(prefNum);			UseResFile(piRefNum);			return false;		}		BlockMove (&theRecPrefs, *recPrefsH, sizeof(RecPrefsRec));		AddResource(recPrefsH,'Rprf',1000,"\precord page prefs");		WriteResource(recPrefsH);		ReleaseResource(recPrefsH);	}	CloseResFile(prefNum);	UseResFile(piRefNum);		iErr = FSpGetFInfo(&theRecPrefs.soundName,&fndrInfo);	if (iErr != 0 && iErr != -43)	{		theRecPrefs.soundName.vRefNum = theApplSpec.vRefNum;		theRecPrefs.soundName.parID = theApplSpec.parID;		makeStr255("\pUntitled",theRecPrefs.soundName.name);	}		if (theRecPrefs.threshLevel > 255)		theRecPrefs.threshLevel = 15;	if (theRecPrefs.noisefloor > 255)		theRecPrefs.noisefloor = 15;			editAfterRecord = theRecPrefs.interactiveEdit;	BlockMove (&theRecPrefs.soundName,&theRecordingFile,70L);	noiseFloor = theRecPrefs.noisefloor;	autoCrop = theRecPrefs.autoTruncate;		theRecFormat = SDII;  	/* to be changed when other options are valid */		peakCount = 0;		playthruvol = theRecPrefs.monitorOn;		iErr = SPBSetDeviceInfo(myInRefNum,'plth',&playthruvol);	if (iErr != 0)	{		genError ("\pSetDevice returned error");	}	GetDItem(myDlg,19,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,playthruvol);			iErr = SPBSetDeviceInfo(myInRefNum,'lmet',&meterSetup);		NumToString((long)theRecPrefs.noisefloor,textStr);	GetDItem(myDlg,26,&iType,&iHndl,&iRect);	SetIText(iHndl,textStr);		GetDItem(myDlg,15,&iType,&iHndl,&iRect);	SetIText(iHndl,theRecordingFile.name);							NumToString((long)(255-theRecPrefs.threshLevel),textStr);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetIText(iHndl,textStr);					GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		xSetupLevelUserProc = NewUserItemProc(SetupLevelUserProc);	GetDItem(myDlg,2,&iType,&iHndl,&iRect);	SetDItem(myDlg,2,iType,(Handle)xSetupLevelUserProc,&iRect);		getNextName (&theRecordingFile);		GetDItem(myDlg,15,&iType,&iHndl,&iRect);	SetIText(iHndl,theRecordingFile.name);		/* set the rec format when others are implimented */	GetDItem(myDlg,12,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);		GetDItem(myDlg,13,&iType,&iHndl,&iRect);	HiliteControl((ControlHandle)iHndl,255);	GetDItem(myDlg,27,&iType,&iHndl,&iRect);	HiliteControl((ControlHandle)iHndl,255);		if (theRecPrefs.interactiveEdit)	{		GetDItem(myDlg,20,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,true);	}		if (theRecPrefs.autoTruncate)	{		GetDItem(myDlg,22,&iType,&iHndl,&iRect);		SetCtlValue((ControlHandle)iHndl,true);	}		GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,theRecPrefs.threshLevel);		GetDItem(myDlg,9,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,theRecPrefs.threshRecord);			GetDItem(myDlg,24,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,theRecPrefs.noisefloor);			devinfo = 0;	iErr = SPBGetDeviceInfo(myInRefNum,siOptionsDialog,&devinfo);	if (iErr != 0)	{		genError ("\pSetDevice returned error");	}	if (!devinfo)	{		GetDItem(myDlg,21,&iType,&iHndl,&iRect);		HiliteControl((ControlHandle)iHndl,255);	}			ShowWindow(myDlg);	GetPort (&saverPort);	SetPort (myDlg);	do 	{		ModalDialog(xmyLevelFilter,&itemHit);		switch (itemHit)		{			case 5:	/* threshold slider */				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				iCtlValue =	255 - GetCtlValue((ControlHandle)iHndl);				NumToString((long)iCtlValue,textStr);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				SetIText(iHndl,textStr);			break;						case 8:	/* peak clear */				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				GetPort(&savePort);				SetPort(myDlg);				EraseRect(&iRect);				SetPort(savePort);			break;						case 9:	/* use threshold chack box */				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;						case 20:								GetDItem(myDlg,20,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));				editAfterRecord = GetCtlValue((ControlHandle)iHndl);				if (editAfterRecord)				{					GetDItem(myDlg,22,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,autoCrop = !editAfterRecord);				}			break;						case 22:					GetDItem(myDlg,22,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));				autoCrop = GetCtlValue((ControlHandle)iHndl);				if (autoCrop)				{					GetDItem(myDlg,20,&iType,&iHndl,&iRect);					SetCtlValue((ControlHandle)iHndl,editAfterRecord = !autoCrop);				}			break;						case 24:	/* noisefloor slider */				GetMouse(&localPt);				GetDItem(myDlg,24,&iType,&iHndl,&iRect);				iCtlPart = TestControl((ControlHandle)iHndl,localPt);				switch (iCtlPart)				{					case inUpButton:						GetDItem(myDlg,24,&iType,&iHndl,&iRect);						iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<0) ? 0 : iCtlVal;					break;										case inDownButton:						GetDItem(myDlg,24,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 1;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>100) ? 100 : iCtlVal;					break;										case inPageUp:						GetDItem(myDlg,24,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal -= 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal<0) ? 0 : iCtlVal;											break;										case inPageDown:						GetDItem(myDlg,24,&iType,&iHndl,&iRect);							iCtlVal = GetCtlValue((ControlHandle)iHndl);						iCtlVal += 10;						SetCtlValue((ControlHandle)iHndl,iCtlVal);						iCtlVal = (iCtlVal>100) ? 100 : iCtlVal;					break;										default:					break;				}				GetDItem(myDlg,24,&iType,&iHndl,&iRect);				noiseFloor = iCtlValue =	GetCtlValue((ControlHandle)iHndl);				NumToString((long)iCtlValue,textStr);				GetDItem(myDlg,26,&iType,&iHndl,&iRect);				SetIText(iHndl,textStr);			break;						case 21:							iErr = SPBSetDeviceInfo(myInRefNum,siOptionsDialog,0);				if (iErr != 0)				{					genError ("\pSetDevice returned error");				}			break;						case 19:	/* play thru */				GetDItem(myDlg,19,&iType,&iHndl,&iRect);				playThru = GetCtlValue((ControlHandle)iHndl);				SetCtlValue((ControlHandle)iHndl,!playThru);				playThru = !playThru;				playthruvol = 7 * playThru;				iErr = SPBSetDeviceInfo(myInRefNum,'plth',&playthruvol);				if (iErr != 0)				{					genError ("\pSetDevice returned error");				}			break;						case 10:	/*press record */				if (isWaiting || isRecording)					break;				manualPause = false;				GetPort(&savePort);				SetPort(myDlg);				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,240);				GetDItem(myDlg,11,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,241);				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				if (GetCtlValue((ControlHandle)iHndl))	/* threshold on */				{					GetDItem(myDlg,17,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,242);					setupRecording (myDlg);					isWaiting = true;					isRecording = false;					GetDItem(myDlg,5,&iType,&iHndl,&iRect);					iCtlValue =	255 - GetCtlValue((ControlHandle)iHndl);					iErr = SPBGetDeviceInfo(myInRefNum,'lmet',&meterSetup);					watchcursor(true);					while (!Button() && (meterSetup.meterValue <= iCtlValue))					{						iErr = SPBGetDeviceInfo(myInRefNum,'lmet',&meterSetup);					}					if (meterSetup.meterValue > iCtlValue)					{						startRecording (myDlg);						GetDateTime(&theRecordedTime);						GetDItem(myDlg,10,&iType,&iHndl,&iRect);						drawColourIcon(iRect.left,iRect.top,240);						GetDItem(myDlg,17,&iType,&iHndl,&iRect);						drawColourIcon(iRect.left,iRect.top,243);						isRecording = true;						isWaiting = false;					}					watchcursor(false);				}				else				{					GetDItem(myDlg,17,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,243);					isRecording = true;					isWaiting = false;					setupRecording (myDlg);					startRecording (myDlg);					GetDateTime(&theRecordedTime);				}				SetPort(savePort);			break;						case 11:	/* press stop */				if (!isWaiting && !isRecording)					break;				GetPort(&savePort);				SetPort(myDlg);				GetDItem(myDlg,11,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,242);				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,239);				GetDItem(myDlg,17,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,243);				if (isRecording)				{					BlockMove(&theRecordingFile,&lastName,70L);					stopRecording (myDlg);					isRecording = false;					isWaiting = false;					if (editAfterRecord)					{						iErr = SPBCloseDevice(myInRefNum);						if (iErr !=  0)						{							genError ("\pCan't close device");							return false;						}						//autoTopTailSDII(lastName, noiseFloor);						if (viewAudio(lastName))						{							if (*newName)							{								iErr = FSpRename(&lastName,newName);								BlockMove (newName,lastName.name,(*newName)+1);							}						}						iErr = SPBOpenDevice("\p",siWritePermission,&myInRefNum);						if (iErr != 0)						{							genError ("\pCan't open device");							return false;						}						playthruvol = theRecPrefs.monitorOn;						iErr = SPBSetDeviceInfo(myInRefNum,'plth',&playthruvol);						if (iErr != 0)						{							genError ("\pSetDevice returned error");						}						GetDItem(myDlg,19,&iType,&iHndl,&iRect);						SetCtlValue((ControlHandle)iHndl,playthruvol);							meterSetup.meterOn = true;						iErr = SPBSetDeviceInfo(myInRefNum,'lmet',&meterSetup);						addFileToList(lastName);					}					if (autoCrop)					{						autoTopTailSDII(lastName, noiseFloor);					}					BlockMove (&lastName,&theLastSpec,70L);				}				else				{					iErr = FSClose(theRecordRefNum);					iErr = FSpDelete (&theRecordingFile);					isRecording = false;					isWaiting = false;				}				SetPort(savePort);			break;						case 17:	/* press pause */				GetPort(&savePort);				SetPort(myDlg);								if (isRecording == false && isWaiting == false)				{					isWaiting = true;					manualPause = false;					isRecording = false;					setupRecording(myDlg);					GetDItem(myDlg,17,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,244);					GetDItem(myDlg,11,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,241);					GetDItem(myDlg,10,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,240);					SetPort(savePort);					break;				}				if (isRecording == false && isWaiting == true)				{					isWaiting = false;					isRecording = true;					if (manualPause)					{						resumeRecording (myDlg);						manualPause = false;					}					else					{						startRecording (myDlg);						GetDateTime(&theRecordedTime);						manualPause = false;					}					GetDItem(myDlg,17,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,243);					GetDItem(myDlg,11,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,241);					GetDItem(myDlg,10,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,240);										SetPort(savePort);					break;				}				if (isRecording == true && isWaiting == false)				{					GetDItem(myDlg,17,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,244);					GetDItem(myDlg,11,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,241);					pauseRecording(myDlg);					manualPause = true;					isWaiting = true;					isRecording = false;					SetPort(savePort);					break;				}			break;						case 18:	/* press trash */				GetPort(&savePort);				SetPort(myDlg);				if (isRecording)				{					GetDItem(myDlg,18,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,246);					GetDItem(myDlg,11,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,242);					GetDItem(myDlg,10,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,239);					GetDItem(myDlg,17,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,243);					isRecording = false;					isWaiting = false;					scrapRecording(myDlg);					SysBeep(5);					GetDItem(myDlg,18,&iType,&iHndl,&iRect);					drawColourIcon(iRect.left,iRect.top,245);				}				else				{					if (theLastSpec.vRefNum != -999)					{						BlockMove(&theLastSpec,&presLastSpec,70L);						//iErr = FindFolder(theLastSpec.vRefNum,'temp',true,&trashVRefNum,&trashDirID);						do						{							iErr = FSMakeFSSpec(theLastSpec.vRefNum,theLastSpec.parID,theLastSpec.name,&tempspec);							if (iErr != -43)							{								*((theLastSpec.name + *(theLastSpec.name)) + 1L) = '~';								(*theLastSpec.name)++;								iErr = FSpRename(&presLastSpec,theLastSpec.name);							}						}while (iErr != -43 && (*theLastSpec.name)<62);						//iErr = CatMove(theLastSpec.vRefNum,theLastSpec.parID,theLastSpec.name,trashDirID,theLastSpec.name);												BlockMove(&presLastSpec,&theRecordingFile,70L);						GetDItem(myDlg,15,&iType,&iHndl,&iRect);						SetIText(iHndl,theRecordingFile.name);						theLastSpec.vRefNum = -999;					}					/* redo last recording */				}				SetPort(savePort);			break;							case 12:	/* SDII format */				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,13,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				theRecFormat = SDII;			break;						case 13:	/* AIFF format */								/*GetDItem(myDlg,13,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,true);				GetDItem(myDlg,12,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,false);				theRecFormat = AIFF;*/			break;						case 34:	/* update format */				theAve = 0L;				theMax = 0;				watchcursor(true);				for (z=0;z<4096;z++)				{					iErr = SPBGetDeviceInfo(myInRefNum,'lmet',&meterSetup);					theAve += (long)meterSetup.meterValue;					theMax = (meterSetup.meterValue > theMax) ? meterSetup.meterValue : theMax;				}				watchcursor(false);				//theAmount = LoWord(theAve / 4096L);				theAmount = theMax;				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				theAmount = (theAmount * 110) / 100;				if (theAmount <0 )					theAmount = 0;				SetCtlValue((ControlHandle)iHndl,255-theAmount);				GetDItem(myDlg,6,&iType,&iHndl,&iRect);				NumToString ((long)theAmount,theTextStr);				SetIText(iHndl,theTextStr);				GetDItem(myDlg,24,&iType,&iHndl,&iRect);				theAmount = (theAmount * 100) / 255;				SetCtlValue((ControlHandle)iHndl,theAmount);				GetDItem(myDlg,26,&iType,&iHndl,&iRect);				NumToString ((long)theAmount,theTextStr);				SetIText(iHndl,theTextStr);			break;									case 14:	/* save in */				StandardPutFile("\pSelect Record Location","\pUntitled",&reply);				if (reply.sfGood)				{					if (reply.sfReplacing)					{						iErr = FSpDelete(&reply.sfFile);					}					BlockMove (&reply.sfFile,&theRecordingFile,70L);					GetDItem(myDlg,15,&iType,&iHndl,&iRect);					SetIText(iHndl,reply.sfFile.name);				}			break;						case 36:	/* review  */								if (!isRecording)					break;									GetPort(&savePort);				SetPort(myDlg);				mySPB.inRefNum = myInRefNum;				mySPB.count = 0xFFFFFFFF;				mySPB.milliseconds = 0xFFFFFFFF;				mySPB.completionRoutine = 0L;				mySPB.interruptRoutine = 0L;				GetDItem(myDlg,36,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,251);/* 253 ??? */				/* do stop */				iErr = SPBPauseRecording(myInRefNum);				if (iErr != 0)				{					genError("\pProblem pausing");					return false;				}				iErr = SPBStopRecording(myInRefNum);				if (iErr != 0)				{					genError("\pProblem stopping");					return false;				}				isRecording = false;				iErr = GetFPos(theRecordRefNum,&pausedPos);				/*watchcursor(true);				GetDateTime(&secs);				pressecs = secs;				while (secs < (pressecs + 1L))				{					GetDateTime(&secs);				}				watchcursor(false);*/				/*************/				/*iErr = SPBCloseDevice(myInRefNum);				if (iErr !=  0)				{					genError ("\pCan't close device");					return false;				}*/				/******/				/*lastName				theRecordRefNum*/				if (pausedPos > reviewTime)				{					iErr = SetFPos(theRecordRefNum,fsFromMark,0L-(reviewTime));					iErr = GetFPos(theRecordRefNum,&pausedPos);					removeGlitch = true;				}				else				{					iErr = SetFPos(theRecordRefNum,1,0L);				}									reviewSound(theRecordRefNum);				/*iErr = GetFPos(theRecordRefNum,&pausedPos);				iErr = SPBOpenDevice("\p",siWritePermission,&myInRefNum);				if (iErr != 0)				{					genError ("\pCan't open device");					return false;				}							theTwos = (theSampleSize == 1) ? 0 : 1;				iErr = SPBSetDeviceInfo(myInRefNum,'twos',&theTwos);				if (iErr != 0)				{					genError("\pProblem setting the twos");					return false;				}*/								iErr = SPBRecordToFile(theRecordRefNum,&mySPB,true);				if (iErr != 0)				{					if (iErr == -227)					{						iErr = SPBStopRecording(myInRefNum);						FlashMenuBar(0);						iErr = SPBRecordToFile(theRecordRefNum,&mySPB,true);					}					else					{						genError("\pProblem starting recording");						return false;					}				}				FlashMenuBar(0);				iErr = SPBResumeRecording(myInRefNum);				if (iErr != 0)				{					genError("\pProblem resuming");					return false;				}				isRecording = true;				GetDItem(myDlg,36,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,252);/* 253 ??? */				SetPort(savePort);			break;						case 35:	/* play ?  */							break;								}	} while (itemHit != 1 || isRecording || isWaiting);		iErr = SPBCloseDevice(myInRefNum);	if (iErr !=  0)	{		genError ("\pCan't close device");		return false;	}		BlockMove (&theRecordingFile,&theRecPrefs.soundName,70L);		GetDItem(myDlg,19,&iType,&iHndl,&iRect);	theRecPrefs.monitorOn = GetCtlValue((ControlHandle)iHndl);		/* get the rec format when others are implimented */		GetDItem(myDlg,20,&iType,&iHndl,&iRect);	theRecPrefs.interactiveEdit = GetCtlValue((ControlHandle)iHndl);		GetDItem(myDlg,22,&iType,&iHndl,&iRect);	theRecPrefs.autoTruncate = GetCtlValue((ControlHandle)iHndl);		GetDItem(myDlg,5,&iType,&iHndl,&iRect);	theRecPrefs.threshLevel = GetCtlValue((ControlHandle)iHndl);		GetDItem(myDlg,24,&iType,&iHndl,&iRect);	theRecPrefs.noisefloor = GetCtlValue((ControlHandle)iHndl);		GetDItem(myDlg,9,&iType,&iHndl,&iRect);	theRecPrefs.threshRecord = GetCtlValue((ControlHandle)iHndl);			piRefNum = CurResFile();	prefNum = FSpOpenResFile (&theSSPrefSpec,fsCurPerm);	if (!prefNum)	{		genError ("\pError finding prefs");	}	UseResFile(prefNum);		recPrefsH = Get1Resource('Rprf',1000);	if (recPrefsH)	{		BlockMove (&theRecPrefs, *recPrefsH, sizeof(RecPrefsRec));		ChangedResource(recPrefsH);		WriteResource(recPrefsH);		ReleaseResource(recPrefsH);	}	CloseResFile(prefNum);	UseResFile(piRefNum);			DisposDialog(myDlg);		SetPort (saverPort);	return true;}pascal Boolean myLevelFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	OSErr	iErr;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect, eRect,oRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	meterRec	meterSetup;	Point pointA;	GrafPtr	savePort;	RGBColor	color;	short iCtlValue;	Point thePoint;	Rect	arrowRect;	short Rthreshold;	short themeter,offerSet;	char theChar;	short theQuay;	Str255 tempString;	unsigned long theCurrentTime;	Rect resultRect;	RgnHandle newClipRgn;	Boolean loseIt;		GetPort(&savePort);	SetPort(currentDialog);	meterSetup.meterOn = true;		GetDItem(currentDialog,5,&iType,&iHndl,&iRect);	iCtlValue = 255 - GetCtlValue((ControlHandle)iHndl);		iErr = SPBGetDeviceInfo(myInRefNum,'lmet',&meterSetup);	loseIt = false;	peakCount++;		if (meterSetup.meterValue > theVUMeter)	{		theVUMeter = meterSetup.meterValue;		if (theVUMeter > 135)		{			if (theVUMeter > thePeakHold)			{				loseIt = true;			}			thePeakHold = theVUMeter;			peakCount = 0;		}	}	else	{		theVUMeter -= 10; //(meterSetup.meterValue + theVUMeter) / 2;		if (theVUMeter < 0)			theVUMeter = 0;	}		if ((peakCount & 16) == 16 && ((peakCount+1) & 16) != 16)	{		thePeakHold = 1;  /* crude timing for peak hold. Replace with tick count */		loseIt = true;	}		if (theEventIn->what==mouseDown)		{			thePoint = theEventIn->where;			GlobalToLocal(&thePoint);			GetDItem(currentDialog,5,&iType,&iHndl,&iRect);				if(PtInRect(thePoint,&iRect)) 			{						GetDItem(currentDialog,5,&iType,&iHndl,&iRect);					BlockMove (&iRect,&arrowRect,8L);	 			arrowRect.top = arrowRect.bottom - 16;				if(PtInRect(thePoint,&arrowRect)) 				{						GetDItem(currentDialog,5,&iType,&iHndl,&iRect);						Rthreshold = GetCtlValue((ControlHandle)iHndl);					Rthreshold ++;					Rthreshold = (Rthreshold>255) ? 255 : Rthreshold;					SetCtlValue((ControlHandle)iHndl,Rthreshold);				}				GetDItem(currentDialog,5,&iType,&iHndl,&iRect);					BlockMove (&iRect,&arrowRect,8L);				arrowRect.bottom = arrowRect.top + 16;	 							if(PtInRect(thePoint,&arrowRect)) 				{						GetDItem(currentDialog,5,&iType,&iHndl,&iRect);						Rthreshold = GetCtlValue((ControlHandle)iHndl);					Rthreshold --;					Rthreshold = (Rthreshold<0) ? 0 : Rthreshold;					SetCtlValue((ControlHandle)iHndl,Rthreshold);				}				}		}				if (isWaiting)	{		GetDItem(currentDialog,9,&iType,&iHndl,&iRect);		if (GetCtlValue((ControlHandle)iHndl))		{				if (theVUMeter >= iCtlValue)			{				startRecording (currentDialog);				GetDateTime(&theRecordedTime);				GetDItem(currentDialog,10,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,240);				GetDItem(currentDialog,17,&iType,&iHndl,&iRect);				drawColourIcon(iRect.left,iRect.top,243);				isRecording = true;				isWaiting = false;			}		}	}						/************old code */			/*	GetDItem(currentDialog,4,&iType,&iHndl,&iRect);				BlockMove (&iRect, &oRect, 8L);				themeter = iRect.bottom-iRect.top;				BlockMove (&iRect, &eRect, 8L);				eRect.bottom -= 128-(((255 - theVUMeter)/2));								EraseRect(&eRect);								iRect.top += ((255 - theVUMeter)/2);				oRect.top = iRect.top;				if ((iRect.top - eRect.top) < (themeter/4))  // top bit 				{					iRect.top = iRect.bottom - (3*(themeter/4));					BlockMove (&iRect, &eRect, 8L);					eRect.bottom = iRect.top;					eRect.top = oRect.top;					color.red = 0x0000;					color.green = 0x0000;					color.blue = 0xFFFF;					RGBForeColor(&color);					FillRect(&eRect,black);					color.red = 0x0000;					color.green = 0x0000;					color.blue = 0x0000;					RGBForeColor(&color);				}								color.red = 0;				color.green = 65535;				color.blue = 0x0000;				RGBForeColor(&color); // bottom bit				FillRect(&iRect,black);				color.red = 0x0000;				color.green = 0x0000;				color.blue = 0x0000;				RGBForeColor(&color);*//************old code */		/* new stuff */					GetDItem(currentDialog,30,&iType,&iHndl,&iRect);	iRect.top -= 64;	iRect.top += 128 - (theVUMeter >> 1);		if(SectRect(&PRESoRect,&iRect,&resultRect))	{		newClipRgn = NewRgn();		RectRgn(newClipRgn,&resultRect);		SetClip(newClipRgn);		UpdtControl(currentDialog,currentDialog->clipRgn);		SetClip(currentDialog->visRgn);		DisposeRgn(newClipRgn);	}		GetDItem(currentDialog,29,&iType,&iHndl,&oRect);	oRect.bottom += 64;	oRect.bottom -= theVUMeter >> 1;	EraseRect(&oRect);	PRESoRect = oRect;	/* end new */		GetDItem(currentDialog,9,&iType,&iHndl,&iRect);		if (GetCtlValue((ControlHandle)iHndl))  /* draw threshold bar */	{			GetDItem(currentDialog,4,&iType,&iHndl,&iRect);		InsetRect(&iRect,0,1);		offerSet = iRect.bottom -(iRect.top + 1);		iRect.top = iRect.bottom - (((iCtlValue * (offerSet))/255))-1;		iRect.bottom = iRect.top+1;		color.red = 0x0000;		color.green = 0x0000;		color.blue = 0xa000;		RGBForeColor(&color);		InsetRect(&iRect,1,0);		FillRect(&iRect,&qd.black);		color.red = 0x0000;		color.green = 0x0000;		color.blue = 0x0000;		RGBForeColor(&color);	}		if (thePeakHold > theVUMeter)	{		GetDItem(currentDialog,4,&iType,&iHndl,&iRect);		InsetRect(&iRect,0,1);		offerSet = iRect.bottom - iRect.top;				/*iRect.bottom = iRect.top + (((255 -thePeakHold) * offerSet) / 255);		EraseRect (&iRect);*/				iRect.top +=  (((255 -thePeakHold) * offerSet) / 255);		iRect.bottom = iRect.top + 5;		if (iRect.bottom > 173)		iRect.bottom = 173;		color.red = 65535;		color.green = 000;		color.blue = 0;		RGBForeColor(&color);		InsetRect(&iRect,1,0);		FillRect(&iRect,&qd.black);  /* draw peak hold */		color.red = 0x0000;		color.green = 0x0000;		color.blue = 0x0000;		RGBForeColor(&color);	}		if (theVUMeter >250)	{		GetDItem(currentDialog,8,&iType,&iHndl,&iRect);		color.red = 65535;		color.green = 0x0000;		color.blue = 0x0000;		RGBForeColor(&color);		FillRect(&iRect,&qd.black);   /* draw peak overload */		color.red = 0x0000;		color.green = 0x0000;		color.blue = 0x0000;		RGBForeColor(&color);	}		GetDateTime(&theCurrentTime);	if (isRecording && (theCurrentTime != theLastTime))	{		NumToString(theCurrentTime - theRecordedTime,tempString);		GetDItem(currentDialog,33,&iType,&iHndl,&iRect);		SetIText(iHndl,tempString);		theLastTime = theCurrentTime;	}		flashCount ++;	if (isWaiting)	{		if (theCurrentTime > theFlashTime)		{			GetDItem(currentDialog,10,&iType,&iHndl,&iRect);			drawColourIcon(iRect.left,iRect.top,(buttonstate) ? 240 : 247);			buttonstate = !buttonstate;						/*InsetRect(&iRect,11,11);			iRect.top ++;			InvertRect(&iRect);*/			GetDateTime(&theFlashTime);		}	}				if(theEventIn->what == keyDown) 	{		theQuay = (theEventIn->message) & keyCodeMask;		theChar = (theEventIn->message) & charCodeMask;		if (theQuay == 0x4300   && !(theEventIn->modifiers & shiftKey))  /* record */		{				*theDialogItem = 10;				return TRUE;		}				if (theQuay == 0x5200   && !(theEventIn->modifiers & shiftKey))  /* stop */		{				*theDialogItem = 11;				return true;		}				if (theQuay == 0x4700 )  /* trash */		{				*theDialogItem = 18;				return true;		}				if (theQuay == 0x2A00 )		{				*theDialogItem = 1;				return true;		}				if (theQuay == 0x4C00 )		{				*theDialogItem = 1;				return true;		}				if (theQuay == 0x4100   && !(theEventIn->modifiers & shiftKey))  /* stop */		{				*theDialogItem = 17;				return true;		}			}		SetPort(savePort);		return false;}pascal void SetupLevelUserProc(WindowPtr theDialog, short theItem){	GrafPtr	savePort;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect, eRect;				/** for dialog enquiry **/	short	iType,iCtlValue;				/** for dialog enquiry **/	Str255 textStr;		GetPort(&savePort);	SetPort(theDialog);		GetDItem(theDialog,10,&iType,&iHndl,&iRect);	drawColourIcon(iRect.left,iRect.top,239);	GetDItem(theDialog,11,&iType,&iHndl,&iRect);	drawColourIcon(iRect.left,iRect.top,242);	GetDItem(theDialog,17,&iType,&iHndl,&iRect);	drawColourIcon(iRect.left,iRect.top,243);	GetDItem(theDialog,18,&iType,&iHndl,&iRect);	drawColourIcon(iRect.left,iRect.top,245);	/*GetDItem(theDialog,35,&iType,&iHndl,&iRect);	drawColourIcon(iRect.left,iRect.top,250);	GetDItem(theDialog,36,&iType,&iHndl,&iRect);	drawColourIcon(iRect.left,iRect.top,252);*/		GetDItem(theDialog,4,&iType,&iHndl,&iRect);	PenSize(1,1);	InsetRect(&iRect,-2,-2);	FrameRect(&iRect);		GetDItem(theDialog,8,&iType,&iHndl,&iRect);	PenSize(1,1);	InsetRect(&iRect,-2,-2);	FrameRect(&iRect);		GetDItem(theDialog,5,&iType,&iHndl,&iRect);	iCtlValue = GetCtlValue((ControlHandle)iHndl);	iCtlValue = 255-iCtlValue;	NumToString((long)iCtlValue,textStr);	GetDItem(theDialog,6,&iType,&iHndl,&iRect);	SetIText(iHndl,textStr);		GetDItem(theDialog,12,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,true);	GetDItem(theDialog,13,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,false);		SetPort(savePort);	}Boolean getNextName (FSSpecPtr	mySpecPtr){	OSErr	iErr;	FSSpec	theOtherSpec;	short index = 0;	Str255	theNumber;	long theNumLong;		BlockMove (mySpecPtr, &theOtherSpec,70L);	iErr = FSMakeFSSpec(theOtherSpec.vRefNum,theOtherSpec.parID,theOtherSpec.name,mySpecPtr);	if (iErr == -43)		return true;			if (*(theOtherSpec.name + (long)(*theOtherSpec.name) - 4L) != '-')	{		concatStrings(theOtherSpec.name,"\p0000","\p-");		iErr = FSMakeFSSpec(theOtherSpec.vRefNum,theOtherSpec.parID,theOtherSpec.name,mySpecPtr);		if (iErr == -43)			return true;	}		iErr = 0;	while (iErr == 0)	{			watchcursor(true);		BlockMove ((theOtherSpec.name + (long)(*theOtherSpec.name) - 3L), theNumber+1L,4L);		*theNumber = 4;		StringToNum(theNumber,&theNumLong);		theNumLong++;		NumToString(theNumLong,theNumber);		BlockMove (theNumber+1L,(theOtherSpec.name + (long)(*theOtherSpec.name) - (long)*theNumber + 1L),*theNumber);		iErr = FSMakeFSSpec(theOtherSpec.vRefNum,theOtherSpec.parID,theOtherSpec.name,mySpecPtr);		watchcursor(false);	}			/*iErr = 0;	while (iErr == 0)	{		if (*(theOtherSpec.name + *theOtherSpec.name) >= '0' && *(theOtherSpec.name + *theOtherSpec.name) <= '8')		{			*(theOtherSpec.name + *theOtherSpec.name) += 1;		}		else		{			concatStrings(theOtherSpec.name,"\p0","\p-");		}		iErr = FSMakeFSSpec(theOtherSpec.vRefNum,theOtherSpec.parID,theOtherSpec.name,mySpecPtr);	}*/	return true;}typedef struct voxStart {short	mode;short	trigger;} voxStart;typedef struct voxStop {short	mode;short	trigger;short Ttime;} voxStop; Fixed theRate;short theChans;Boolean setupRecording (WindowPtr theDialog){	short iRefNum, refNum, rfRefNum;	long count;	short  theCont;	OSErr	iErr;	long theLo, theHi,theDBIN;	Handle	theSize, theSRate, theChannels;	Str255	theSizeStr, theSRateLoStr, theSRateHiStr, theChannelsStr,BackupName;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect, eRect;				/** for dialog enquiry **/	short	iType,iCtlValue;				/** for dialog enquiry **/	short theTwos;	Boolean overWrite = false;	voxStart theVStart;	voxStop theVStop;	FSSpec thetempspec;		removeGlitch = false;	iErr = SPBGetDeviceInfo(myInRefNum,'srat',&theRate);	if (iErr != 0)	{		genError("\pProblem getting rate");		return false;	}	theARate = theRate;		iErr = SPBGetDeviceInfo(myInRefNum,'ssiz',&theSampleSize);	if (iErr != 0)	{		genError("\pProblem getting sample size");		return false;	}	theASampleSize = theSampleSize;		iErr = SPBGetDeviceInfo(myInRefNum,'chan',&theChans);	if (iErr != 0)	{		genError("\pProblem getting num chans");		return false;	}		/*iErr = SPBGetDeviceInfo(myInRefNum,'dbin',&theDBIN);	if (iErr != 0)	{		genError("\pProblem getting theDBIN");		return false;	}	theCont = 1;*/		/*theVStart.mode= 1;	theVStart.trigger= 200;		theVStop.mode = 1;	theVStop.trigger = 100;	theVStop.Ttime = 1000;	iErr = SPBSetDeviceInfo(myInRefNum,'voxr',&theVStart);	if (iErr != 0)	{		genError("\pProblem setting theCont");		return false;	}	iErr = SPBSetDeviceInfo(myInRefNum,'voxs',&theVStop);	if (iErr != 0)	{		genError("\pProblem setting theCont");		return false;	}*/			theAChans = theChans;		GetDItem(theDialog,15,&iType,&iHndl,&iRect);	GetIText(iHndl,theRecordingFile.name);		GetDItem(theDialog,13,&iType,&iHndl,&iRect);	if (GetCtlValue((ControlHandle)iHndl)) /* AIFF */	{		theTwos = 1;		iErr = SPBSetDeviceInfo(myInRefNum,'twos',&theTwos);		if (iErr != 0)		{			genError("\pProblem setting twos");			return false;		}		iErr = FSpCreate(&theRecordingFile,'Sd2a','AIFF',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theRecordingFile);					iErr = FSpCreate(&theRecordingFile,'Sd2a','AIFF',0);				}				else				{					BlockMove(theRecordingFile.name,BackupName,*theRecordingFile.name + 1);					do					{						iErr = FSMakeFSSpec(theRecordingFile.vRefNum,theRecordingFile.parID,BackupName,&thetempspec);						if (iErr != -43)						{							*((BackupName + *(BackupName)) + 1L) = '~';							(*BackupName)++;						}					}while (iErr != -43);					iErr = FSpRename(&theRecordingFile,BackupName);					/*getNextName (&theRecordingFile);					GetDItem(theDialog,15,&iType,&iHndl,&iRect);					SetIText(iHndl,theRecordingFile.name);*/					iErr = FSpCreate(&theRecordingFile,'Sd2a','AIFF',0);				}			}		}		iErr = FSpOpenDF(&theRecordingFile,fsWrPerm,&theRecordRefNum);		if (iErr != 0)		{			genError("\pProblem opening file to record into");			return false;		}		mySPB.inRefNum = myInRefNum;		mySPB.count = 0xFFFFFFFF;		mySPB.milliseconds = 0xFFFFFFFF;		mySPB.completionRoutine = 0L;		mySPB.interruptRoutine = 0L;			iErr = SetupAIFFHeader(theRecordRefNum,LoWord(theChans),theRate,theSampleSize,'NONE',0L,0L);		if (iErr != 0)		{			genError("\pProblem setting up file to record into");			return false;		}		return true;	}	else /* sd2 */	{		theTwos = (theSampleSize == 1) ? 0 : 1;		iErr = SPBSetDeviceInfo(myInRefNum,'twos',&theTwos);		if (iErr != 0)		{			genError("\pProblem setting the twos");			return false;		}		overWrite = false;		iErr = FSpCreate(&theRecordingFile,'Sd2a','Sd2f',0);		if (iErr != 0)		{			if (iErr == dupFNErr)			{				if (YesNo ("\pFile Exists, overwrite ?"))				{					FSpDelete (&theRecordingFile);					iErr = FSpCreate(&theRecordingFile,'Sd2a','AIFF',0);				}				else				{					BlockMove(theRecordingFile.name,BackupName,*theRecordingFile.name + 1);					do					{						iErr = FSMakeFSSpec(theRecordingFile.vRefNum,theRecordingFile.parID,BackupName,&thetempspec);						if (iErr != -43)						{							*((BackupName + *(BackupName)) + 1L) = '~';							(*BackupName)++;						}					}while (iErr != -43);					iErr = FSpRename(&theRecordingFile,BackupName);					/*getNextName (&theRecordingFile);					GetDItem(theDialog,15,&iType,&iHndl,&iRect);					SetIText(iHndl,theRecordingFile.name);*/					iErr = FSpCreate(&theRecordingFile,'Sd2a','Sd2f',0);				}			}			else			{				genError ("\pCan't create that file");				return false;			}		}		writeSDIIResources(theRecordingFile,(unsigned long)theRate>>16,(theChans == 2),theSampleSize >> 3);/*		FSpCreateResFile(&theRecordingFile,'Sd2a','Sd2f',0);			iErr = ResError();		if (iErr != 0)		{				genError("\pProblem creating RF");				return false;		}				NumToString((long)(theSampleSize / 8),theSizeStr);		theSize = NewString(theSizeStr);		if (!theSize)		{			genError("\pOut of memory");			return false;		}				NumToString((long)theChans,theChannelsStr);		theChannels = NewString(theChannelsStr);		if (!theChannels)		{			genError("\pOut of memory");			DisposHandle(theSize);			return false;		}				theHi = (unsigned long)((unsigned long)theRate >> 16);		theLo = ((unsigned long)(LoWord((unsigned long)theRate)))&0x0000FFFF;		NumToString(theLo,theSRateLoStr);		NumToString(theHi,theSRateHiStr);		*theSRateHiStr = 5;		*theSRateLoStr = 5;		concatStrings(theSRateHiStr,theSRateLoStr,"\p.");		theSRate = NewString(theSRateHiStr);		if (!theSRate)		{			genError("\pOut of memory");			DisposHandle(theSize);			DisposHandle(theChannels);			return false;		}			iRefNum = CurResFile();		rfRefNum = FSpOpenResFile(&theRecordingFile,fsWrPerm);		if (rfRefNum == -1)		{			genError ("\pCan't open res file");			DisposHandle(theSize);			DisposHandle(theChannels);			DisposHandle(theSRate);			return false;		}		UseResFile(rfRefNum);				AddResource(theSRate,'STR ',1001,"\psample-rate");		iErr = ResError();		if (iErr != 0)		{			genError("\pProblem adding resource");			UseResFile(iRefNum);			return false;		}		AddResource(theSize,'STR ',1000,"\psample-size");		iErr = ResError();		if (iErr != 0)		{			genError("\pProblem adding resource");			UseResFile(iRefNum);			return false;		}		AddResource(theChannels,'STR ',1002,"\pchannels");		iErr = ResError();		if (iErr != 0)		{			genError("\pProblem adding resource");			UseResFile(iRefNum);			return false;		}		CloseResFile(rfRefNum);		UseResFile(iRefNum); */	}	iErr = FSpOpenDF(&theRecordingFile,fsWrPerm,&theRecordRefNum);	if (iErr != 0)	{		if (overWrite = false)		{			genError("\pProblem opening file to record into");			return false;		}	}		count = 2000000L;	if (allocDisk)	{		iErr = AllocContig(theRecordRefNum,&count);		if (iErr)		{			genError("\pNot enough disk space to allocate 2MB contig");		}	}	mySPB.inRefNum = myInRefNum;	mySPB.count = 0xFFFFFFFF;	mySPB.milliseconds = 0xFFFFFFFF;	mySPB.completionRoutine = 0L;	mySPB.interruptRoutine = 0L;	/* experiment */		iErr = SPBRecordToFile(theRecordRefNum,&mySPB,true);	if (iErr != 0)	{		if (iErr == -227)		{			iErr = SPBStopRecording(myInRefNum);			iErr = SPBRecordToFile(theRecordRefNum,&mySPB,true);		}		else		{			genError("\pProblem starting recording");			return false;		}	}	iErr = SPBPauseRecording(myInRefNum);	if (iErr != 0)	{		genError("\pProblem pausing");		return false;	}	/* end */	reviewTime = 5L * ((long)theRate >> 16) * (long)(theChans) * ((long)theSampleSize / 8);	return true;}Boolean startRecording (WindowPtr theDialog){	OSErr	iErr;	iErr = SPBResumeRecording(myInRefNum);	//iErr = SPBRecordToFile(theRecordRefNum,&mySPB,true);	if (iErr != 0)	{		genError("\pProblem resuming recording");		return false;	}}Boolean stopRecording (WindowPtr theDialog){	OSErr	iErr;	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect, eRect;				/** for dialog enquiry **/	short	iType,iCtlValue;				/** for dialog enquiry **/	long theBytes, theFrames;	unsigned long secs;		unsigned long pressecs;	long inOutCount;	Ptr pNew;		iErr = SPBPauseRecording(myInRefNum);	if (iErr != 0)	{		genError("\pProblem pausing");		return false;	}	iErr = SPBStopRecording(myInRefNum);	if (iErr != 0)	{		genError("\pProblem stopping");		return false;	}		GetDItem(theDialog,13,&iType,&iHndl,&iRect);	if (GetCtlValue((ControlHandle)iHndl)) /* AIFF */	{		theBytes = mySPB.count;		if (!theAChans)			theAChans ++;		theFrames = theBytes / theAChans;		if (!theASampleSize)			theASampleSize ++;		theFrames /= theASampleSize;			iErr = SetFPos(theRecordRefNum,1,0L);		iErr = SetupAIFFHeader(theRecordRefNum,LoWord(theAChans),theARate,theASampleSize,'NONE',theBytes,theFrames);		if (iErr != 0)		{			genError("\pProblem stopping");			return false;		}	}	watchcursor(true);	GetDateTime(&secs);	pressecs = secs;	while (secs < (pressecs + 1L))	{		GetDateTime(&secs);	}	watchcursor(false);	inOutCount = (long)(theAChans * (theASampleSize / 8)) * 3L;	pNew = NewPtrClear(20L);	if (removeGlitch)	{		iErr = SetFPos(theRecordRefNum,1,pausedPos);		iErr = FSWrite (theRecordRefNum,&inOutCount,pNew);		removeGlitch = false;	}	DisposPtr(pNew);	iErr = FSClose(theRecordRefNum);		{		if (!editAfterRecord)			addFileToList(theRecordingFile);	}	getNextName (&theRecordingFile);	GetDItem(theDialog,15,&iType,&iHndl,&iRect);	SetIText(iHndl,theRecordingFile.name);	}Boolean pauseRecording (WindowPtr theDialog){	OSErr	iErr;	iErr = SPBPauseRecording(myInRefNum);	if (iErr != 0)	{		genError("\pProblem pausing");		return false;	}}Boolean resumeRecording (WindowPtr theDialog){	OSErr	iErr;	iErr = SPBResumeRecording(myInRefNum);	if (iErr != 0)	{		genError("\pProblem resuming");		return false;	}}Boolean scrapRecording (WindowPtr theDialog){	OSErr	iErr;	iErr = SPBStopRecording(myInRefNum);	if (iErr != 0)	{		genError("\pProblem stopping");		return false;	}	iErr = FSClose(theRecordRefNum);	iErr = FSpDelete(&theRecordingFile);}Boolean waitForRecord(short thresholdLevel){	}Boolean autoTopTailSDII(FSSpec mySpec, short noiseFloor){	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	short sourceRefNum;	short rfRefNum;	long sourcePtr;	long destPtr;	Handle theAudioData;	long theStart,theEnd;	OSErr	iErr;	long fPos, filePos;	long inOutCount;	SignedByte theByte;	short theWord;	long savePos, theCountLeft;	OSErr	eErr;	long tempFloor;	RegionRec	myRegion;	FSSpec newSpec;		getConvertDest();	if (getSDIIData (mySpec,&theRate, &theWordSize,&stereo, &theBytes))		return false;	if (theWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	tempFloor = (long)noiseFloor;	tempFloor = (tempFloor * (long)((theWordSize == 2) ? 32767 : 127)) / 100L;	noiseFloor = LoWord(tempFloor);		/* here is the low level bodge */	if (noiseFloor < 3500)		noiseFloor = 10;			theAudioData = NewHandle(32768L);	if (!theAudioData)	{		return false;	}				iErr = FSpOpenDF(&mySpec,fsWrPerm,&sourceRefNum);	if (iErr != 0)	{		return false;	}	theStart = 0L;	theEnd = theBytes >> (stereo + (theWordSize - 1)) ;	eErr = 0;		while (!eErr)	{		iErr = GetFPos(sourceRefNum,&savePos);		inOutCount = 32000L;		eErr = FSRead(sourceRefNum,&inOutCount,*theAudioData);		if (eErr != 0 && eErr != eofErr)		{			FSClose (sourceRefNum);			DisposHandle(theAudioData);			return false;		}		for (fPos = 0L;fPos<inOutCount;fPos += (long)((stereo + 1)*theWordSize))		{				switch (theWordSize)			{				case 1:					BlockMove ((*theAudioData) + fPos,&theByte,1L);					if (abs((short)theByte) > noiseFloor)					{						theStart = (fPos + savePos);						goto FireExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos+1L,&theByte,1L);						if (abs((short)theByte) > noiseFloor)						{							theStart = (fPos + savePos) >> 1;							goto FireExit;						}					}				break;								case 2:					BlockMove ((*theAudioData) + fPos,&theWord,2L);					if (abs(theWord) > noiseFloor)					{						theStart = (fPos + savePos) >> 1;						goto FireExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos + 2L,&theWord,2L);						if (abs(theWord) > noiseFloor)						{							theStart = (fPos + savePos) >> 2;							goto FireExit;						}					}				break;				}		}	}FireExit:	iErr = SetFPos(sourceRefNum,2,0L);	eErr = SetFPos(sourceRefNum,3,-32000L);	if (eErr == posErr)	{		eErr = SetFPos(sourceRefNum,1,0L);		theCountLeft = theBytes;	}		else		theCountLeft = 32000L;	eErr = 0;		while (!eErr)	{		inOutCount = theCountLeft;		if (inOutCount < 32000L)			eErr = eofErr;		iErr = GetFPos(sourceRefNum,&savePos);		iErr = FSRead(sourceRefNum,&inOutCount,*theAudioData);		if (iErr != 0 && iErr != eofErr)		{			FSClose (sourceRefNum);			DisposHandle(theAudioData);			return false;		}		for (fPos = inOutCount-(long)((stereo + 1)*theWordSize);fPos>=0L;fPos -= (long)((stereo + 1)*theWordSize))		{				switch (theWordSize)			{				case 1:					BlockMove ((*theAudioData) + fPos,&theByte,1L);					if (abs((short)theByte) > noiseFloor)					{						theEnd = (fPos + savePos) >> (stereo + (theWordSize - 1));						goto SecondExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos+1L,&theByte,1L);						if (abs((short)theByte) > noiseFloor)						{							theEnd = (fPos + savePos) >> (stereo + (theWordSize - 1));							goto SecondExit;						}					}				break;								case 2:					BlockMove ((*theAudioData) + fPos,&theWord,2L);					if (abs(theWord) > noiseFloor)					{						theEnd = (fPos + savePos) >> (stereo + (theWordSize - 1));						goto SecondExit;					}					if (stereo)					{						BlockMove ((*theAudioData) + fPos + 2L,&theWord,2L);						if (abs(theWord) > noiseFloor)						{							theEnd = (fPos + savePos) >> (stereo + (theWordSize - 1));							goto SecondExit;						}					}				break;			}		}		theCountLeft = 32000L;		iErr = GetFPos(sourceRefNum,&filePos);		if (filePos == 0)		{			theEnd = 0;			goto SecondExit;		}		else		{			if (filePos >= 32000L)			{				iErr = SetFPos(sourceRefNum,3,-(32000L+inOutCount));			}			else			{				iErr = SetFPos(sourceRefNum,1,0L);				theCountLeft = filePos;							}		}	}SecondExit:	FSClose (sourceRefNum);	DisposHandle(theAudioData);	if (theEnd < theStart)	{		return false;	}		if (!makeSD2intoRegionParam(mySpec, theStart, theEnd))	{		return false;	}		if (autoCrop)	{		BlockMove(&mySpec,&newSpec,70L);		newSpec.parID = theConvertDestLoc.parID;		newSpec.vRefNum = theConvertDestLoc.vRefNum;		iErr = getARegion(mySpec, 0,&myRegion);		if (iErr == regionReturned)		{			exportRegion (mySpec, newSpec, myRegion);			addFileToList(newSpec);		}	}}Boolean makeSD2intoRegionParam(FSSpec mySpec, long startFr, long endFr){	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	short fRefNum;	Handle hRsrc;	ddRLHeader theHeader;	RegionRec theRegRec;	unsigned long secs;	short iRefNum;	long templong;	OSErr	iErr;		getSDIIData (mySpec, &theRate,&theWordSize,&stereo, &theBytes);		theHeader.VersionNumber = 1;	theHeader.HeaderSize = 12L;	theHeader.RegionSize = (long)sizeof(RegionRec);	theHeader.ResourceDate = 0x00000000;	theHeader.NextID = 2L;			theRegRec.RegionID = 1L;	theRegRec.StartFrame = startFr;	templong = (theBytes / (long)(stereo+1));	if (!templong)		templong = 2L;	theRegRec.StopFrame = endFr;	theRegRec.SynchFrame = startFr;	GetDateTime(&secs);	theRegRec.TimeStampMS = secs;	theRegRec.TimeStampLS = secs;	BlockMove (mySpec.name,theRegRec.RegionName,32L);		iRefNum = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);	if (fRefNum == -1)	{		FSpCreateResFile(&mySpec,'Sd2a','Sd2f',0);		iErr = ResError();		fRefNum = FSpOpenResFile(&mySpec,fsWrPerm);		iErr = ResError();	}		UseResFile(fRefNum);	hRsrc = Get1Resource('ddRL',1000);	if (hRsrc)	{		RmveResource(hRsrc);		DisposHandle(hRsrc);	}		hRsrc = NewHandle(sizeof(ddRLHeader) + sizeof (RegionRec));	iErr = ResError();	if (!hRsrc)	{		genError ("\pCan't allocate memory for new region");		CloseResFile(fRefNum);		UseResFile(iRefNum);		return false;	}	BlockMove (&theHeader,*hRsrc,sizeof (ddRLHeader));	BlockMove (&theRegRec,(*hRsrc)+sizeof (ddRLHeader),sizeof (RegionRec));		iErr = ResError();		AddResource(hRsrc,'ddRL',1000,"\pRegion List");	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	iErr = ResError();	return true;}short reviewSound(short refNum){	Handle	mySndH[2];	short	thecurfile;	Str255	sampsize;	OSErr	iErr;	SndChannelPtr mySndChan;	// pointer to a sound channel	OSErr myErr;	Str255	samprate;	Boolean	whichBuff;	Str255	chans;	char	mysampsize;	long	mysamprate,xx,inOutCount;	char	mychans;	Handle 	hRsrc;	long z;	Fixed	sampleRate;	short 	numChans;	short		numBits;	short	tempchans;	Boolean fileEnded,Endedfile;	SCStatus theStatus;	EventRecord theEvent;	short headerLen;	Ptr mySndPtr;	unsigned char km[16];	short keycounter;	long filePos;	Boolean autoStop;	long theTicks = 0L;	long theTickDiff;	long bytesPerTick;		ParamBlockRec mypb;	IOParam *Audiopb = (IOParam *)&mypb;			SndCommand cmd;	cmd.cmd = flushCmd;		numBits = theSampleSize / 8;		sampleRate = theRate;		numChans = theChans;		bytesPerTick = ((long)(HiWord((long)sampleRate)) * (long)numChans * (long)numBits) / 60L;		mySndH[0] = NewHandle(dblBufferSize);		if (!mySndH[0])			genErrorN("\pError making new handle",0);				mySndH[1] = NewHandle(dblBufferSize);	if (!mySndH[1])		genErrorN("\pError making new handle",0);				iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,sampleRate,numBits*8,'NONE',0x3C,0,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 1",iErr);	mySndPtr = (*mySndH[0])+headerLen;	inOutCount = dblBufferSize-800L;	autoStop = false;	watchcursor(TRUE);	iErr = FSRead(refNum,&inOutCount,mySndPtr);	Endedfile = (iErr == eofErr || autoStop);	if (iErr!=0 && iErr!=-39)		genErrorN("\pError reading data fork",iErr);	iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,sampleRate,numBits*8,'NONE',0x3C,inOutCount,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 2",iErr);		/** process twos's complement **/	if (numBits ==1)	{		for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)		{			*((Ptr)z) += 128;		}	}	mySndChan = CreateSndChannel(numChans == 2);		/** SDI is mono **/	whichBuff = 0;	fileEnded = autoStop;	gCallBackPerformed = false;	if ( mySndH[0] != nil ) 	{		do		{			Endedfile = fileEnded;			theTicks = TickCount();			myErr = SndPlay (mySndChan, (SndListResource **)mySndH[whichBuff], true);			if ( myErr )				genErrorN("\pError playing sound",myErr);			iErr = InstallCallBack (mySndChan);			whichBuff = !whichBuff;			/** swap double buffers **/			mySndPtr = (*mySndH[whichBuff])+headerLen;									inOutCount = dblBufferSize-800L;				autoStop = false;			/*if (Button())			{				theTickDiff = TickCount() - theTicks;				iErr = SndDoImmediate(mySndChan,&cmd);				cmd.cmd = quietCmd;				iErr = SndDoImmediate(mySndChan,&cmd);				iErr = SetFPos(refNum,1,filePos+(bytesPerTick * theTickDiff));				FlashMenuBar(0);				goto quickexit;			}*/			iErr = GetFPos(refNum,&filePos);			Audiopb->ioCompletion = 0;			Audiopb->ioRefNum = refNum;			Audiopb->ioBuffer = mySndPtr;			Audiopb->ioReqCount = inOutCount;			Audiopb->ioPosMode = fsFromMark;			Audiopb->ioPosOffset = 0L;						iErr = PBRead((union ParamBlockRec *)Audiopb,true);			Endedfile = fileEnded = (iErr == eofErr);			if (iErr!=0 && iErr!=-39)				genErrorN("\pError reading data fork",iErr);						if (iErr == 0)			{				while (Audiopb->ioResult == 1)				{										}			}						Endedfile = fileEnded = (Audiopb->ioActCount < inOutCount);			/*iErr = FSRead(refNum,&inOutCount,mySndPtr);			fileEnded = (iErr == eofErr || autoStop);			if (iErr!=0 && iErr!=-39)				genErrorN("\pError reading data fork",iErr);*/			iErr = SetupSndHeader((SndListResource **)mySndH[whichBuff],numChans,sampleRate,numBits*8,'NONE',0x3C,inOutCount,&headerLen);			if (iErr!=0)				genErrorN("\pError setting up snd header 2",iErr);			//HUnlock(mySndH[whichBuff]);			if (numBits ==1)			{				for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)				{					*((Ptr)z) += 128;				}			}			while (!gCallBackPerformed)			{				if (EventAvail(everyEvent & mDownMask,&theEvent))				{					theTickDiff = TickCount() - theTicks;					iErr = SndDoImmediate(mySndChan,&cmd);					cmd.cmd = quietCmd;					iErr = SndDoImmediate(mySndChan,&cmd);					iErr = SetFPos(refNum,1,filePos-(bytesPerTick * theTickDiff));					FlashMenuBar(0);					goto quickexit;				}			}			gCallBackPerformed = false;		}while (!Endedfile);	quickexit:		iErr = SndDisposeChannel(mySndChan,false);		DisposPtr((Ptr)mySndChan);	}	DisposPtr((Ptr)mySndChan);		DisposHandle(mySndH[0]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle 1",myErr);	DisposHandle(mySndH[1]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle",myErr);		watchcursor(false);}