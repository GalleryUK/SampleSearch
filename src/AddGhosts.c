#include "SampleSearch.h"#include "Globals.h"#include <stdio.h>extern OSType creatorSearchType;extern Boolean creatorSearch;short theSequentialvolumearrayptr;extern Boolean ExcludeDrives;short goGetNumberOfOVOLs(FSSpec myFSSpec);Boolean scanList(Str255	theDrive);short findMaxVRefNum(void);void RemoveVBL(void);OSErr translateVRefNum(short * theVRef);extern short fvolumesSource[1000];extern short fVolmaxVRef;short resolveVRefNum(short theVRef);void cleanUpFVolumeGaps(void);short AddGhosts(void);short AddGhosts(void) /*search in ghosts */{	Str255	sAgainName;	char	*tempName;	char	*CsAgainName;	OSErr	iErr;	short	listcounter;	char	*strResult;	short	newListCounter;	short		findStrLen;	char	tempstor[255];	char	tempstor2[255];	char	tempstor3[255];	OSType	searchType;	StringHandle	hString;	FInfo	fndrInfo;	Boolean stillOK;	short		ghostFileindex;	short 	chunkInMem;	short	myRefNum;	long	myInOutCounter;	long	tempInOutCounter;	long	FInfoInOutCounter;	long	totfindlen;	long	filePos;	short		seqReadNumber;	short 	numberOfOVOLs;	OSType presCreator;	FInfo ** tempFInfo;		tempName = tempstor;				/** ???????? **/	CsAgainName = tempstor2;			/** ??????????? **/	strResult = tempstor3; 				/*** ??????????? **/		newListCounter=totfindcounter;		BlockMove(gFileName,sAgainName,64L); 					UprString(sAgainName,false);	findStrLen = *sAgainName;	PtoCstr(sAgainName);										/** ????????? **/	BlockMove(sAgainName,CsAgainName,64L);	typeRelevant = false;	hString = GetString(999+iCtlValue);							/** grab file type from popup from resource **/		BlockMove(*hString +1,&searchType,4L);		numTypesToSearch = 0;										/** one less than we need **/	BlockMove(*hString +1,&Fiyltype[0],4L);	if (searchType == 'IIII')	{		numTypesToSearch = 3;		typeCounter = 0;		Fiyltype[0] = 'SCin';		Fiyltype[1] = 'SCsi';		Fiyltype[2] = 'SCsd';		Fiyltype[3] = 'SCss';	}	if (searchType == 'XXXX')	{		numTypesToSearch = 1;		typeCounter = 0;		Fiyltype[0] = 'AIFF';		Fiyltype[1] = 'Sd2f';	}			if (searchType == 'UUUU')	{		numTypesToSearch = 2;		typeCounter = 0;		Fiyltype[0] = 'AIFF';		Fiyltype[1] = 'SFIL';		Fiyltype[2] = 'Sd2f';	}	if (searchType == 'AAAA')	{		typeRelevant = false;									/** ignore file type **/	}	else	{		typeRelevant = true;	}	numberOfOVOLs = 0;	fvolumearrayptr = volumearrayptr;  /** why ???????*/	theSequentialvolumearrayptr = volumearrayptr;	progressCreate("\pSearching on Ghosts");	for (ghostFileindex=0;ghostFileindex<ghostCounter;ghostFileindex++)	{		if (progressDisp(ghostFileindex * 100 / ghostCounter)) 		{			reFound = true;				totfindcounter = newListCounter;			FInfoArrayPtr = newListCounter;			reFound = true;				return 	totfindcounter;			}		/*if (!scanList(ghosts[ghostFileindex].name) && ExcludeDrives)		{*/			iErr = FSpOpenDF(&ghosts[ghostFileindex],fsCurPerm,&myRefNum);			if (!iErr)			{				totfindcounter = newListCounter; /* this was previously commented !!!! */				gogetoldrefs(ghosts[ghostFileindex],ghostFileindex > 0);				numberOfOVOLs = goGetNumberOfOVOLs(ghosts[ghostFileindex]);				totfindlen = 4;				iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);		/** length of FSSpec data **/				if (iErr!=0)					genError("\pCould not read some data in addghosts 1"); 				iErr = GetFPos(myRefNum,&filePos);							/*preserve pos (0 plus 4 bytes) **/				iErr = SetFPos(myRefNum,1,myInOutCounter+4L);					/** set to end of that (include 4 byte length headrer ) **/ 				if (iErr!=0)					genError("\pCould not set file position in addghosts 1"); 								iErr = FSRead(myRefNum,&totfindlen,&FInfoInOutCounter);		/** read in array len**/				if (iErr!=0)					genError("\pCould not read some data in addghosts 2"); 				FInfoInOutCounter = FInfoInOutCounter*16L;						/*DisposHandle(theFInfo);				theFInfo = (FInfo **)NewHandleClear((totfindcounter * 16L) + FInfoInOutCounter);				if (!theFInfo)				{					genError("\pCannot allocate memory for FInfo array");					ExitToShell;				}*/					/* is there any point to this ??? */			tempFInfo = (FInfo **)NewHandleClear(kMaxMatches * 16L);			if (!theFInfo)			{				genError("\pCannot allocate memory for FInfo array");				ExitToShell();			}						BlockMove (*theFInfo,*tempFInfo, kMaxMatches * 16L);			DisposHandle((Handle)theFInfo);			theFInfo = (FInfo **)NewHandleClear((kMaxMatches  * 16L) + FInfoInOutCounter);			if (!theFInfo)			{				genError("\pCannot allocate memory for FInfo array");				ExitToShell();			}			BlockMove (*tempFInfo,*theFInfo, kMaxMatches * 16L);			DisposHandle((Handle)tempFInfo);	/**************************************/					//	FInfolistInMem = false;				/*SetHandleSize(theFInfo,(totfindcounter * 16L) + FInfoInOutCounter);				iErr = MemError();				if (iErr != 0)				{					genError("\pCould not alter handle size of theFInfo");					RemoveVBL();					ExitToShell();				}*/				iErr = FSRead(myRefNum,&FInfoInOutCounter,&(*theFInfo) [totfindcounter]);		/** read FInfo array **/				//iErr = FSRead(myRefNum,&FInfoInOutCounter,*theFInfo);		/** read FInfo array **/								if (iErr!=0)					genError("\pCould not read some data in addghosts 3"); 								iErr = SetFPos(myRefNum,1,filePos);				if (iErr!=0)					genError("\pCould not set file position in addghosts 2"); 				seqReadNumber = 0;								for (;myInOutCounter>0;)				{					if (myInOutCounter > 500L*70L)					{						tempInOutCounter = 500L*70L;						myInOutCounter -= 500L*70L;					}						else					{						tempInOutCounter = myInOutCounter;						myInOutCounter = 0;					}					iErr = FSRead(myRefNum,&tempInOutCounter,(*gTheResults));					if (iErr!=0)						genError("\pCould not read some data in addghosts 4"); 										chunkInMem = tempInOutCounter / 70L;										for(listcounter=0;listcounter< chunkInMem;listcounter++)					{						stillOK = true;						BlockMove(((*gTheResults)[listcounter].name),tempName,64L);							UprString((unsigned char *)tempName,false);						PtoCstr((unsigned char *)tempName);										if(typeRelevant)			/** file type selected **/						{								BlockMove((*theFInfo) + (listcounter +totfindcounter+(seqReadNumber * 500)) ,&fndrInfo,16L);							//BlockMove((*theFInfo) + (listcounter+(seqReadNumber * 500)) ,&fndrInfo,16L);														//iErr = FSpGetFInfo(&(*gTheResults)[listcounter],&fndrInfo);							stillOK = false;							for (typeCounter = 0;typeCounter<= numTypesToSearch;typeCounter++)							{								if (fndrInfo.fdType == Fiyltype[typeCounter])		/** allow for all samples exception **/								{									stillOK = true;								}							}						}											if (*CsAgainName)			/** string is not null **/						{							if (!strstr((const char *)tempName,(const char *)CsAgainName))							{								stillOK = false;									}						}											if (fdFldrMask)				/** fdfldr selected **/						{							if ((fndrInfo.fdFldr & fdFldrMask) != (fdFldrVal & fdFldrMask))							{								stillOK = false;							}						}												if (creatorSearch)						{							BlockMove((*theFInfo) + (listcounter +totfindcounter+(seqReadNumber * 500)) ,&fndrInfo,16L);							if (fndrInfo.fdCreator != creatorSearchType)							{								stillOK = false;							}						}											if (stillOK)						{							if (newListCounter < kMaxMatches )							{								BlockMove(&(*gTheResults)[listcounter],&(*therealResults)[newListCounter],70L);																//(*therealResults)[newListCounter].vRefNum -= (volumearrayptr+1); /** problem here **///#ifndef powerc								//(*therealResults)[newListCounter].vRefNum -= fvolumearrayptr; /** problem here **/								translateVRefNum(&(*therealResults)[newListCounter].vRefNum);							//	(*therealResults)[newListCounter].vRefNum -= fVolmaxVRef; /** problem here **///#endif												//(*therealResults)[newListCounter].vRefNum -= volumearrayptr; /** problem here **/												BlockMove((*theFInfo) + (listcounter +totfindcounter+(seqReadNumber * 500)),(*theFInfo)+newListCounter,16L);								newListCounter++;															}						}								}		/** end of for listcounter **/						seqReadNumber++;				}			/** end of for myinoutcounter **/			}				/** end of if no err **/			iErr = FSClose(myRefNum);			totfindcounter = newListCounter;#ifndef powerc			gogetoldrefs(ghosts[ghostFileindex],ghostFileindex);				resolveOVols(); 			cleanUpFVolumeGaps(); /* fix it first */#endif			/*}	*/	}						/** end of for ghost file index **/	reFound = true;		progressDispos();			totfindcounter = newListCounter;	FInfoArrayPtr = newListCounter;	reFound = true;			tempFInfo = (FInfo **)NewHandleClear(kMaxMatches * 16L);	if (!theFInfo)	{		genError("\pCannot allocate memory for FInfo array");		ExitToShell();	}		BlockMove (*theFInfo,*tempFInfo, kMaxMatches * 16L);	DisposHandle((Handle)theFInfo);	theFInfo = (FInfo **)NewHandleClear(kMaxMatches * 16L);	if (!theFInfo)	{		genError("\pCannot allocate memory for FInfo array");		ExitToShell();	}	BlockMove (*tempFInfo,*theFInfo, kMaxMatches * 16L);	DisposHandle((Handle)tempFInfo);	resolveOVols();	return 	totfindcounter;	}short goGetNumberOfOVOLs(FSSpec myFSSpec){	OSErr	iErr;/** this function will create or append to the fvolumes list, OVols found in ghosts **/		short snapRefNum;	short iCnt,z;	Handle hRsrc, vRsrc;	short iRefNum;	short currentRef;	short oldmaxVRef = maxVRef;		iRefNum = CurResFile();			/** preserve current resource file **/		snapRefNum = HOpenResFile(myFSSpec.vRefNum,myFSSpec.parID,myFSSpec.name,fsCurPerm);	/** open resource fork of specified ghost **/	iErr = ResError();	if (iErr!=0)	{		genError("\pCouldn't open the current file in gogetoldrefs");		return 0;	}	UseResFile(snapRefNum);	iErr = ResError();	if (iErr!=0)	{		genError("\pCould not UseResFile at start of gogetvolrefs");		UseResFile(iRefNum);		return 0;	}	gogetvolref();	iCnt = CountResources('oVOL');	if (!iCnt)	{		genError("\pCouldn't find any oVol resources in gogetoldrefs");		UseResFile(iRefNum);		return 0;	}	CloseResFile(snapRefNum);	UseResFile(iRefNum);	iErr = ResError();	if (iErr!=0)	{		genError("\pCould not UseResFile at end of gogetvolrefs");	}	return iCnt;}OSErr translateVRefNum(short * theVRef){	short z;	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	if (fvolumesSource[z] == *theVRef)	{		*theVRef = fvolumes[z];		return noErr;	}	return -1;	}short resolveVRefNum(short theVRef){	short z;	for (z=1;z<=fvolumearrayptr;z++)	if (fvolumes[z] == theVRef)	{		return -z;	}	return 0;	}