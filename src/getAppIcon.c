Boolean _GetIconSuiteForTypeCreator(OSType	inCreator, OSType inType, short vRefNum, Handle *outIconSuite);Boolean _GetIconSuiteForTypeCreator(OSType	inCreator, OSType inType, short vRefNum, Handle *outIconSuite){	DTPBRec	dtpb;	short	dtdbRefNum = 0, i;	OSErr	err;	short	resRef, saveResRefNum = CurResFile();	short 	count = 0, numMenuItems;	Str63	appName;	Handle	iconData;	short	volumeType;		if(vRefNum)	{		dtpb.ioNamePtr = NULL;		dtpb.ioVRefNum = vRefNum;		err = PBDTGetPath(&dtpb);	}	else	{		dtpb.ioResult = noErr;	}			if(dtpb.ioResult == noErr)	{		dtdbRefNum = dtpb.ioDTRefNum;			//	volumeType = GetFilesVolumeType(vRefNum);				if(true/*volumeType != GenericServer && volumeType != GenericFloppy*/ )		{					dtpb.ioCompletion = nil;			dtpb.ioDTRefNum = dtdbRefNum;			dtpb.ioNamePtr = appName;			dtpb.ioIndex = 0;			dtpb.ioFileCreator = inCreator;			//			err = PBDTGetAPPL( &dtpb, FALSE);						if(err == noErr)			{				dtpb.ioFileType = inType;				dtpb.ioTagInfo = 0;							err = NewIconSuite( outIconSuite );								if(!err)				{					iconData = NewHandle(1024);		//space for icl8					if(iconData)					{						HLock(iconData);						dtpb.ioDTBuffer = *iconData;						dtpb.ioDTReqCount = 1024;						dtpb.ioIconType = kLarge8BitIcon;						err = PBDTGetIconSync(&dtpb);												if(err == noErr)						{							err = AddIconToSuite(iconData,*outIconSuite,'icl8');							HUnlock(iconData);						}						else						{							DisposeHandle(iconData);						}									}														iconData = NewHandle(512);		//space for icl4					if(iconData)					{						HLock(iconData);						dtpb.ioDTBuffer = *iconData;						dtpb.ioDTReqCount = 512;						dtpb.ioIconType = kLarge4BitIcon;						err = PBDTGetIconSync(&dtpb);												if(err == noErr)						{							err = AddIconToSuite(iconData,*outIconSuite,'icl4');							HUnlock(iconData);						}						else						{							DisposeHandle(iconData);						}									}										iconData = NewHandle(256);					HLock(iconData);					if(iconData)					{						dtpb.ioDTBuffer = *iconData;						dtpb.ioDTReqCount = 256;						dtpb.ioIconType = kLargeIcon;						err = PBDTGetIconSync(&dtpb);												if(err == noErr)						{							err = AddIconToSuite(iconData,*outIconSuite,'ICN#');							HUnlock(iconData);							return true;						}						else						{							//if we can't get the 'ICN#', we don't have a mask and can't draw!							DisposeHandle(iconData);							DisposeIconSuite(*outIconSuite, true);								*outIconSuite = nil;						}									}				}								}		}	}	return false;}