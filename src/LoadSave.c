#include "SampleSearch.h"#include "Globals.h"#include "prefs.h"void LoadFaves(void);void Audition(FSSpec mySpec, short playFreq);void openFSList(FSSpec mySpec);extern FSSpec theApplSpec;void checkHandleSize (Handle theHandle,long arraySize,long cellSize);extern newPrefsRec theNewPrefs;extern short maxVRef;OSErr renameTabAuto(short tabNum, Str31 theName);void resolveListEntries(FSSpec faveFile);short findMaxVRefNum(void);void cleanUpFVolumeGaps(void);OSErr translateVRefNum(short * theVRef);OSErr copyVolsListToFVolsList(void);void openList(void){		  		OSErr	iErr;	StandardFileReply	mySFReply;			short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;		myTypes[0] = 'SFlf';  	StandardGetFile(0,1,myTypes,&mySFReply);  	if (mySFReply.sfGood)  	{		copyVolsListToFVolsList();			gogetoldrefs(mySFReply.sfFile,0);		  	iErr = HOpen(mySFReply.sfFile.vRefNum,mySFReply.sfFile.parID,mySFReply.sfFile.name,2,&myRefNum);		if (!iErr)		{			totfindlen = 4L;			iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);						if(iErr !=0)				genError("\pCould not read info from file");			if (myInOutCounter > ((kMaxMatches-1) *70L))			{				genError ("\pThis file is too large to load, and will be cropped");				myInOutCounter = ((kMaxMatches-1) * 70L);			}				iErr = FSRead(myRefNum,&myInOutCounter,*therealResults);			if(iErr !=0)				genError("\pCould not read info from file");			totfindcounter = myInOutCounter/ 70L;						iErr = FSRead(myRefNum,&totfindlen,&FInfoArrayPtr);			if(iErr !=0)				genError("\pCould not read info from file");							FInfoArrayPtr = FInfoArrayPtr * 16L;			if (FInfoArrayPtr > (kMaxMatches * 16L))				FInfoArrayPtr = (kMaxMatches *16L);			//SetHandleSize(theFInfo,FInfoArrayPtr);			iErr = MemError();			if (iErr != 0 )			{				genError("\p could not resize FInfo in open menu");				FInfolistInMem = false;			}			else			{				iErr = FSRead(myRefNum,&FInfoArrayPtr,*theFInfo);				if(iErr !=0)				genError("\pCould not read info from file");				FInfolistInMem = true;			}			iErr = FSClose(myRefNum);			reFound = true;							for (z=0;z<totfindcounter;z++)			{				 translateVRefNum(&(*therealResults)[z].vRefNum);			}					resolveOVols(); 			cleanUpFVolumeGaps(); 		/*	gogetoldrefs(mySFReply.sfFile,0);			resolveOVols(); */			renameTabAuto(theNewPrefs.whichTab, mySFReply.sfFile.name);		}							}}void saveList(void){	OSErr	iErr;	StandardFileReply	mySFReply;			short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	long theFInfoCount;	short iRefNum;	Handle hString[299],vRefRes[299];	StandardPutFile("\pEnter the filename to save as","\pSampleFinder File",&mySFReply);	if (mySFReply.sfGood)	{		if (mySFReply.sfReplacing)			iErr = FSpDelete(&mySFReply.sfFile);			iErr = FSpCreate(&mySFReply.sfFile,'MgAl','SFlf',mySFReply.sfScript);		if (iErr!=0)			genError("\pCould not create file");		iErr = HOpen(mySFReply.sfFile.vRefNum,mySFReply.sfFile.parID,mySFReply.sfFile.name,2,&myRefNum);		if (iErr!=0)			genError("\pCould not open new file");		myInOutCounter = totfindcounter * 70L; 		totfindlen = 4;		iErr = FSWrite(myRefNum,&totfindlen,&myInOutCounter);		if (iErr!=0)			genError("\pCould not write to new file");		iErr = FSWrite(myRefNum,&myInOutCounter,(*therealResults));		if (iErr!=0)			genError("\pCould not write to new file");		if 	(!FInfolistInMem)		{						FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr != 0)				genError("\pCan't resize theFInfo in save list");												checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));							for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;		}				iErr = FSWrite(myRefNum,&totfindlen,&FInfoArrayPtr);		if (iErr!=0)			genError("\pCould not write to new file");			theFInfoCount = FInfoArrayPtr*sizeof(FInfo);			 		HLock((Handle)theFInfo);										// needs to be implemented 		iErr = FSWrite(myRefNum,&theFInfoCount,*theFInfo);			if (iErr!=0)			genError("\pCould not write to new file");		HUnlock ((Handle)theFInfo);			iErr = FSClose(myRefNum);				//myRefNum = HOpenResFile(mySFReply.sfFile.vRefNum,mySFReply.sfFile.parID,mySFReply.sfFile.name,fsCurPerm);				gogetvolref();		iRefNum = CurResFile();			HCreateResFile(mySFReply.sfFile.vRefNum,mySFReply.sfFile.parID,mySFReply.sfFile.name);		iErr = ResError();		if (iErr!=0)			genError("\pCould not create resource file");		myRefNum = HOpenResFile(mySFReply.sfFile.vRefNum,mySFReply.sfFile.parID,mySFReply.sfFile.name,fsCurPerm);				if (myRefNum == -1)			genError("\pCould not open new resource fork");			UseResFile(myRefNum);			iErr = ResError();			if (iErr!=0)			genError("\pCould not use new resource fork");			for (z=1;z<=volumearrayptr;z++)		{				hString[z] = NewHandle(256);			//MoveHHi(hString[z]);			BlockMove(volName[z],*hString[z],28L);			AddResource(hString[z],'oVOL',z,"\pVolume Name for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");			vRefRes[z] = NewHandle(2);			//MoveHHi(vRefRes[z]);			**vRefRes[z] = volumes[z];			AddResource(vRefRes[z],'oREF',z,"\pvRefNum for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");			}		for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)		{				hString[z] = NewHandle(256);			//MoveHHi(hString[z]);			BlockMove(fvolName[z],*hString[z],28L);			AddResource(hString[z],'oVOL',z,"\pVolume Name for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");			vRefRes[z] = NewHandle(2);			//MoveHHi(vRefRes[z]);			**vRefRes[z] = volumes[z];			AddResource(vRefRes[z],'oREF',z,"\pvRefNum for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");		}				CloseResFile(myRefNum);		for (z=1;z=fvolumearrayptr;z++)		{			ReleaseResource(vRefRes[z]);			//DisposHandle (vRefRes[z]);			ReleaseResource(hString[z]);			//DisposHandle (hString[z]);		}				UseResFile(iRefNum);		iErr = ResError();		if (iErr!=0)			genError("\pCould not use old resource file");		iErr = FlushVol(0,mySFReply.sfFile.vRefNum);		/*if (iErr!=0)			genError("\pCould not flush volume");*/	}}void LoadFaves(void){		  		OSErr	iErr;	StandardFileReply	mySFReply;			short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	extern FSSpec	faveFSpec, faveISpec;		copyVolsListToFVolsList();		gogetoldrefs(faveFSpec,0);		  	//iErr = HOpen(faveFSpec.vRefNum,faveFSpec.parID,faveFSpec.name,fsCurPerm,&myRefNum);		iErr = FSpOpenDF(&faveFSpec,fsCurPerm,&myRefNum);		if (!iErr)		{			totfindlen = 4L;			iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);			if (myInOutCounter > (2474L * 70L))			{				genError ("\pThis file is too large and will be cropped");				myInOutCounter = 2474L * 70L;			}			if(iErr !=0)				genError("\pCould not read info from file");							iErr = FSRead(myRefNum,&myInOutCounter,*therealResults);			if(iErr !=0)				genError("\pCould not read info from file");			totfindcounter = myInOutCounter/ 70L;			iErr = FSClose(myRefNum);			if (iErr!=0)				genError("\pCan't close FSpec fave file");			for (z=0;z<totfindcounter;z++)			{				 translateVRefNum(&(*therealResults)[z].vRefNum);			}		/*for (z=0;z<totfindcounter;z++)			{				(*therealResults)[z].vRefNum -= maxVRef;			}*/			/* this above was commented */			//gogetoldrefs(faveFSpec,0);		}				iErr = FSpOpenDF(&faveISpec,fsCurPerm,&myRefNum);				if (!iErr)		{			totfindlen = 4;			iErr = FSRead(myRefNum,&totfindlen,&FInfoArrayPtr);			if(iErr !=0)				genError("\pCould not read info from file");			if (FInfoArrayPtr > 2474L)				FInfoArrayPtr = 2474L;			FInfoArrayPtr = FInfoArrayPtr * 16L;			//SetHandleSize(theFInfo,FInfoArrayPtr);			iErr = MemError();			if (iErr != 0 )			{				genError("\p could not resize FInfo in load faves");				FInfolistInMem = false;			}			else			{				iErr = FSRead(myRefNum,&FInfoArrayPtr,*theFInfo);				if(iErr !=0)				genError("\pCould not read info from file");				FInfolistInMem = true;			}			iErr = FSClose(myRefNum);		}		reFound = true;			resolveOVols(); 		cleanUpFVolumeGaps(); 			}Boolean makefaveFile(short listIndex,FSSpec *theFaveFile, FSSpec *theFaveInfo);void LoadTabFaves(short whichList);void LoadTabFaves(short whichList){		  		OSErr	iErr;	StandardFileReply	mySFReply;			short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	FSSpec faveFile,myFaveInfo;		makefaveFile(whichList,&faveFile,&myFaveInfo);	copyVolsListToFVolsList();	gogetoldrefs(faveFile,0);		  	//iErr = HOpen(faveFile.vRefNum,faveFile.parID,faveFile.name,fsCurPerm,&myRefNum);		iErr = FSpOpenDF(&faveFile,fsCurPerm,&myRefNum);		if (!iErr)		{			totfindlen = 4L;			iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);			if (myInOutCounter > ((kMaxMatches-1) * 70L))			{				genError ("\pThis file is too large and will be cropped");				myInOutCounter = (kMaxMatches-1) * 70L;			}			if(iErr !=0)				genError("\pCould not read info from file");							iErr = FSRead(myRefNum,&myInOutCounter,*therealResults);			if(iErr !=0)				genError("\pCould not read info from file");			totfindcounter = myInOutCounter/ 70L;			iErr = FSClose(myRefNum);			if (iErr!=0)				genError("\pCan't close FSpec fave file");									/*for (z=0;z<totfindcounter;z++)			{							//(*therealResults)[z].vRefNum -= volumearrayptr;				 (*therealResults)[z].vRefNum -= maxVRef;			}*/									/* this above was commented */			for (z=0;z<totfindcounter;z++)			{				 translateVRefNum(&(*therealResults)[z].vRefNum);			}		//	translateVRefNum(short * theVRef)	//		resolveListEntries(faveFile);						//		}				iErr = FSpOpenDF(&myFaveInfo,fsCurPerm,&myRefNum);				if (!iErr)		{			totfindlen = 4;			iErr = FSRead(myRefNum,&totfindlen,&FInfoArrayPtr);			if(iErr !=0)				genError("\pCould not read info from file");			if (FInfoArrayPtr > (kMaxMatches-1))				FInfoArrayPtr = (kMaxMatches-1);			FInfoArrayPtr = FInfoArrayPtr * 16L;			//SetHandleSize(theFInfo,FInfoArrayPtr);			iErr = MemError();			if (iErr != 0 )			{				genError("\p could not resize FInfo in load faves");				FInfolistInMem = false;			}			else			{				iErr = FSRead(myRefNum,&FInfoArrayPtr,*theFInfo);				if(iErr !=0)					genError("\pCould not read info from file");				FInfolistInMem = true;			}			iErr = FSClose(myRefNum);		}		reFound = true;			resolveOVols(); 		cleanUpFVolumeGaps(); 			}void openFSList(FSSpec mySpec){		  		OSErr	iErr;			short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	FInfo fndrInfo;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);		if (iErr != 0)		{			SysBeep(5);			return;		}		switch (fndrInfo.fdType)		{		  	case 'AIFF':case 'Sd2f':case 'SFIL':		  		Audition(mySpec, 0x3C);		  	break;		  	default:				copyVolsListToFVolsList();					gogetoldrefs(mySpec,0);				 	 	iErr = HOpen(mySpec.vRefNum,mySpec.parID,mySpec.name,2,&myRefNum);				if (!iErr)				{					totfindlen = 4;					iErr = FSRead(myRefNum,&totfindlen,&myInOutCounter);										if(iErr !=0)						genError("\pCould not read info from file");					if (myInOutCounter > ((kMaxMatches-1) *70L))					{						genError ("\pThis file is too large to load, and will be cropped");						myInOutCounter = ((kMaxMatches-1) * 70L);					}						iErr = FSRead(myRefNum,&myInOutCounter,*therealResults);					if(iErr !=0)						genError("\pCould not read info from file");					totfindcounter = myInOutCounter/ 70L;										iErr = FSRead(myRefNum,&totfindlen,&FInfoArrayPtr);					if(iErr !=0)						genError("\pCould not read info from file");						if (FInfoArrayPtr > (kMaxMatches-1))							FInfoArrayPtr = (kMaxMatches-1);					FInfoArrayPtr = FInfoArrayPtr * 16L;										//SetHandleSize(theFInfo,FInfoArrayPtr);					iErr = MemError();					if (iErr != 0 )					{						genErrorN("\p could not resize FInfo in open menu",iErr);						FInfolistInMem = false;							}					else					{						iErr = FSRead(myRefNum,&FInfoArrayPtr,*theFInfo);						if(iErr !=0)						genError("\pCould not read info from file");						FInfolistInMem = true;							}					iErr = FSClose(myRefNum);					if (iErr !=0)						genErrorN ("\pCan't close file",iErr);					reFound = true;												gogetvolref();						maxVRef = (-(findMaxVRefNum()));					for (z=0;z<totfindcounter;z++)					{						 translateVRefNum(&(*therealResults)[z].vRefNum);					}					resolveOVols(); 					cleanUpFVolumeGaps(); 				//	gogetoldrefs(mySpec,0);				//	resolveOVols(); 															renameTabAuto(theNewPrefs.whichTab, mySpec.name);				}			break;		}	}void saveasFaveList(FSSpec mySpec, FSSpec myInfoSpec);void saveasFaveList(FSSpec mySpec, FSSpec myInfoSpec){	OSErr	iErr;		short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	long theFInfoCount;	short iRefNum;	Handle hString[299],vRefRes[299];	iErr = FSpCreate(&mySpec,'MgAl','SFlf',0);	if (iErr!=0)		genError("\pCould not create file");	iErr = HOpen(mySpec.vRefNum,mySpec.parID,mySpec.name,2,&myRefNum);	if (iErr!=0)		genError("\pCould not open new file");	myInOutCounter = totfindcounter * 70L; 	totfindlen = 4;	iErr = FSWrite(myRefNum,&totfindlen,&myInOutCounter);	if (iErr!=0)		genError("\pCould not write to new file");	iErr = FSWrite(myRefNum,&myInOutCounter,(*therealResults));	if (iErr!=0)		genError("\pCould not write to new file");	FSClose(myRefNum);		/* this info is OUT OF DATE !!! */	if 	(!FInfolistInMem)	{		FInfoArrayPtr = totfindcounter;				checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));		//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));		iErr = MemError();		if (iErr != 0)			genError("\pCan't resize theFInfo in save list");		checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));		for (z=0;z<totfindcounter;z++)			{			iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);		}			FInfolistInMem = true;	}	iErr = FSpCreate(&myInfoSpec,'MgAl','SFlf',0);	if (iErr!=0)		genError("\pCould not create file");	iErr = HOpen(myInfoSpec.vRefNum,myInfoSpec.parID,myInfoSpec.name,2,&myRefNum);	if (iErr!=0)		genError("\pCould not open new file");	iErr = FSWrite(myRefNum,&totfindlen,&FInfoArrayPtr);	if (iErr!=0)		genError("\pCould not write to new file");		theFInfoCount = FInfoArrayPtr*sizeof(FInfo);			 	HLock((Handle)theFInfo);										// needs to be implemented 	iErr = FSWrite(myRefNum,&theFInfoCount,*theFInfo);		if (iErr!=0)		genError("\pCould not write to new file");	HUnlock ((Handle)theFInfo);	iErr = FSClose(myRefNum);			//myRefNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);		gogetvolref();	iRefNum = CurResFile();		HCreateResFile(mySpec.vRefNum,mySpec.parID,mySpec.name);	iErr = ResError();	if (iErr!=0)		genError("\pCould not create resource file");	myRefNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);	if (myRefNum == -1)		genError("\pCould not open new resource fork");	UseResFile(myRefNum);		iErr = ResError();		if (iErr!=0)		genError("\pCould not use new resource fork");	for (z=1;z<=volumearrayptr;z++)	{			hString[z] = NewHandle(256);		//MoveHHi(hString[z]);		BlockMove(volName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");		vRefRes[z] = NewHandle(2);		//MoveHHi(vRefRes[z]);		**vRefRes[z] = volumes[z];		AddResource(vRefRes[z],'oREF',z,"\pvRefNum for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{			hString[z] = NewHandle(256);		//MoveHHi(hString[z]);		BlockMove(fvolName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");				 vRefRes[z] = NewHandle(2);			//MoveHHi(vRefRes[z]);			**vRefRes[z] = fvolumes[z];			AddResource(vRefRes[z],'oREF',z,"\pvRefNum for list");			iErr = ResError();			if (iErr!=0)				genError("\pCould not add resource");		}		CloseResFile(myRefNum);	for (z=1;z<=fvolumearrayptr;z++)	{		//DisposHandle (vRefRes[z]);		//ReleaseResource(hString[z]); /* this was previously enabled - is it needed ? */		//DisposHandle (hString[z]);	}	UseResFile(iRefNum);		iErr = ResError();	if (iErr!=0)		genError("\pCould not use old resource file");	iErr = FlushVol(0,mySpec.vRefNum);	/*if (iErr!=0)		genError("\pCould not flush volume");*/}void saveFSList(FSSpec mySpec){	OSErr	iErr;		short 	myRefNum;	long	myInOutCounter;	SFTypeList	myTypes;	long	totfindlen;	short z;	long theFInfoCount;	short iRefNum;	Handle hString[299];		iErr = FSpCreate(&mySpec,'MgAl','SFlf',0);	if (iErr!=0)		genError("\pCould not create file");	iErr = HOpen(mySpec.vRefNum,mySpec.parID,mySpec.name,2,&myRefNum);	if (iErr!=0)		genError("\pCould not open new file");	myInOutCounter = totfindcounter * 70L; 	totfindlen = 4;	iErr = FSWrite(myRefNum,&totfindlen,&myInOutCounter);	if (iErr!=0)		genError("\pCould not write to new file");	iErr = FSWrite(myRefNum,&myInOutCounter,(*therealResults));	if (iErr!=0)		genError("\pCould not write to new file");	if 	(!FInfolistInMem)	{				FInfoArrayPtr = totfindcounter;		//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));		iErr = MemError();		if (iErr != 0)			genError("\pCan't resize theFInfo in save list");						checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));								for (z=0;z<totfindcounter;z++)			{			iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);		}			FInfolistInMem = true;	}	iErr = FSWrite(myRefNum,&totfindlen,&FInfoArrayPtr);	if (iErr!=0)		genError("\pCould not write to new file");		theFInfoCount = FInfoArrayPtr*sizeof(FInfo);			 	HLock((Handle)theFInfo);										// needs to be implemented 	iErr = FSWrite(myRefNum,&theFInfoCount,*theFInfo);		if (iErr!=0)		genError("\pCould not write to new file");	HUnlock ((Handle)theFInfo);	iErr = FSClose(myRefNum);		//myRefNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);		gogetvolref();	iRefNum = CurResFile();		HCreateResFile(mySpec.vRefNum,mySpec.parID,mySpec.name);	iErr = ResError();	if (iErr!=0)		genError("\pCould not create resource file");	myRefNum = HOpenResFile(mySpec.vRefNum,mySpec.parID,mySpec.name,fsCurPerm);		if (myRefNum == -1)		genError("\pCould not open new resource fork");	UseResFile(myRefNum);		iErr = ResError();		if (iErr!=0)		genError("\pCould not use new resource fork");	for (z=1;z<=volumearrayptr;z++)	{			hString[z] = NewHandle(256);		//MoveHHi(hString[z]);		BlockMove(volName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{			hString[z] = NewHandle(256);		//MoveHHi(hString[z]);		BlockMove(fvolName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");	}		CloseResFile(myRefNum);	for (z=1;z=fvolumearrayptr;z++)		{			//DisposHandle (vRefRes[z]);			ReleaseResource(hString[z]);			//DisposHandle (hString[z]);		}	UseResFile(iRefNum);		iErr = ResError();	if (iErr!=0)		genError("\pCould not use old resource file");	iErr = FlushVol(0,mySpec.vRefNum);	/*if (iErr!=0)		genError("\pCould not flush volume");*/}/***************************/Boolean MemToFSSpec(FSSpec mySpec, Boolean justSelected, Boolean askForSpec, Boolean toFaves, Boolean toClipboard);void RefreshMemA(void);void RefreshMemA(void){	OSErr iErr;	FSSpec theBackUpSpec;		iErr = FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);	if (iErr != -43)		iErr = FSpDelete(&theBackUpSpec);	MemToFSSpec(theBackUpSpec, false, false, false,false);	}void RefreshMemB(void);void RefreshMemB(void){	OSErr iErr;	FSSpec theBackUpSpec;		iErr = FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);	if (iErr == -43)	{		return;	}	gogetvolref();	openFSList(theBackUpSpec);	resolveOVols();	iErr = FSpDelete(&theBackUpSpec);	return;}void checkHandleSize (Handle theHandle,long arraySize,long cellSize){	long totSize = arraySize * cellSize;	long curSize = GetHandleSize(theHandle);		if (totSize > curSize)	{		genError("\pHandle Size mismatch - beware");				}}	