#include "SampleSearch.h"#include "Globals.h"#include <AIFF.h>#include <SoundInput.h>#include <FixMath.h>#include <stdio.h>//#include "fp.h"#include <Sound.h>#include <Resources.h>#include <Types.h>#define kSoundComplete 1 #define kWaitIfFull TRUE	// wait for room in queue#define kSoundComplete  1	// last command in channel;  Application definedextern Boolean autoSustain;extern long dblBufferSize;extern Boolean gCallBackPerformed;  long findCOMM(short localRefNum, OSType);SndChannelPtr CreateSndChannel(Boolean Stereo);short isPressed(unsigned short k );void genErrorN(Str255 myText,long Errno);OSErr InstallCallBack(SndChannelPtr);extern short  arrowPressed;pascal void SampleCallBack(SndChannelPtr,SndCommand);Boolean pleaseStop(void);short arrowKey(void);#define kLeftArrowPressed 1#define kRightArrowPressed 2	#define kDownArrowPressed 3#define kUpArrowPressed 4/*void AIFFtoSnd(FSSpec mySpec,short playFreq);void AIFFtoSnd(FSSpec mySpec,short playFreq){	OSErr	iErr;	ExtSoundHeader      sound;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	short refNum;	SndChannelPtr mySndChan;	long z;	long filePos;	CommonChunk	myCommCnk;	long audiosize,AOffset,thePlaySize;	Fixed	sampleRate;	OSErr sndErr;	EventRecord theEvent;		gCallBackPerformed = true;	useTwo = 0;				iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)	{		genError("\pproblem opening file to play in AIFF to Snd Res");		//SysBeep(5);		return;	}	filePos = findCOMM(refNum,'COMM');	if (!filePos)	{		genError ("\pCan't find common chunk");		iErr = FSClose(refNum);		if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	inOutCount = sizeof (CommonChunk);	iErr = SetFPos(refNum,1,filePos);	iErr = FSRead(refNum,&inOutCount,&myCommCnk);	if (iErr!=0)	{		genError ("\pCan't read comm chunk from file");		iErr = FSClose(refNum);		return;	}		iErr = SetFPos(refNum,1,0L);		filePos = findCOMM(refNum,'SSND');	if (!filePos)	{		genError ("\pCan't find SSND chunk");		iErr = FSClose(refNum);		return;	}		filePos += 4L;	inOutCount = 4L;	iErr = SetFPos(refNum,1,filePos);	iErr = FSRead(refNum,&inOutCount,&audiosize);	if (iErr!=0)	{		genError ("\pCan't read audio size from file");		iErr = FSClose(refNum);		return;	}		iErr = FSRead(refNum,&inOutCount,&AOffset);	if (iErr!=0)	{		genError ("\pCan't read AOffset from file");		iErr = FSClose(refNum);		return;	}		filePos += 4L;	iErr = SetFPos(refNum,1,filePos);		watchcursor(true);		stereo = (myCommCnk.numChannels == 2);	theWordSize = myCommCnk.sampleSize >> 3;	sampleRate = myCommCnk.sampleRate;			thePlaySize = audiosize;		mySndH[0] = NewPtr(dblBufferSize);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		FSClose (refNum);		return;	}		mySndH[1] = NewPtr(dblBufferSize);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		FSClose (refNum);		return;	}				inOutCount = (thePlaySize > dblBufferSize) ? dblBufferSize : thePlaySize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}		thePlaySize -= inOutCount;		if (theWordSize ==1)	{		for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)		{			*((Byte *)z) += 128;		}	}			mySndChan = CreateSndChannel(stereo);			    sound.samplePtr =  mySndH[useTwo];          	    sound.numChannels = stereo+1;             	    sound.sampleRate = sampleRate << 16;       	    sound.loopStart = 0;              	    sound.loopEnd = 0;	    sound.encode = extSH;               	    sound.baseFrequency = playFreq; 	    sound.numFrames = (inOutCount >> stereo) / theWordSize;     		sound.AIFFSampleRate = 0;	    sound.markerChunk = nil;           /	    sound.instrumentChunks = nil;      	    sound.AESRecording = nil;          	    sound.sampleSize = theWordSize * 8;            	    sound.futureUse1 = 0;              	    sound.futureUse2 = 0;              	    sound.futureUse3 = 0;              	    sound.futureUse4 = 0;              		    cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    sndErr = SndDoImmediate(mySndChan,&cmd);	    		gCallBackPerformed = false;		sndErr = InstallCallBack (mySndChan);			if (iErr == eofErr || (inOutCount < dblBufferSize))	{		while (gCallBackPerformed == false)		{			if(pleaseStop()  ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = (thePlaySize > dblBufferSize) ? dblBufferSize : thePlaySize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{						iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}		thePlaySize -= inOutCount;		if (theWordSize ==1)		{			for (z = (long)mySndH[!useTwo]; z<(long)mySndH[!useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}	}	while (!stoppit)	{		    sound.samplePtr =  mySndH[!useTwo];          	    sound.numChannels = stereo+1;             	    sound.sampleRate = sampleRate << 16;      	    sound.loopStart = 0;                	    sound.loopEnd = 0;	    sound.encode = extSH;               	    sound.baseFrequency = playFreq; 	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /	    sound.markerChunk = nil;           	   sound.AIFFSampleRate = 0;	    sound.instrumentChunks = nil;      	    sound.AESRecording = nil;          	    sound.sampleSize = theWordSize * 8;              	    sound.futureUse1 = 0;              	    sound.futureUse2 = 0;              	    sound.futureUse3 = 0;              	    sound.futureUse4 = 0;              		    cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    sndErr = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			if(pleaseStop()  ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		gCallBackPerformed = false;		if (!stoppit)			sndErr = InstallCallBack (mySndChan);					if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = (thePlaySize > dblBufferSize) ? dblBufferSize : thePlaySize;				iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{								iErr = SndDisposeChannel(mySndChan,true);				DisposPtr((Ptr)mySndChan);				DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}			thePlaySize -= inOutCount;			if (theWordSize ==1)			{				for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}			if ((iErr == eofErr) || (inOutCount < dblBufferSize))			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  	   if ((iErr != eofErr) && (inOutCount == dblBufferSize))	   {		   cmd.cmd = flushCmd;		    cmd.param2 = 0;		    sndErr = SndDoImmediate(mySndChan,&cmd);		    cmd.cmd = quietCmd;		    cmd.param2 = 0;		    sndErr = SndDoImmediate(mySndChan,&cmd);	   }	   iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);		while (theStat.scChannelBusy && !(pleaseStop()  ||  (arrowPressed = arrowKey ())))		{			iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);		}		iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);		FSClose(refNum);	DisposPtr(mySndH[0]);	DisposPtr(mySndH[1]);		if (arrowPressed)	{		switch (arrowPressed)		{			case kUpArrowPressed:			//	PostEvent(keyDown,0x00027E1E);			//	PostEvent(keyDown,0x00023120);			break;			case kDownArrowPressed:			//	PostEvent(keyDown,0x00027D1F);				//PostEvent(keyDown,0x00023120);			break;			case kLeftArrowPressed:			//	PostEvent(keyDown,0x00027B1C);				//PostEvent(keyDown,0x00023120);			break;			case kRightArrowPressed:			//	PostEvent(keyDown,0x00027C1D);			//	PostEvent(keyDown,0x00023120);			break;		}	}	//GetNextEvent(everyEvent,&theEvent);	return;}*/extern long normBuffer;Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);Boolean AIFFNormalPlay (FSSpec mySpec, short playFreq);Boolean AIFFNormalPlay (FSSpec mySpec, short playFreq){	OSErr	iErr;	short refNum;	long filePos;	CommonChunk	myCommCnk;	long inOutCount;	long audiosize,AOffset;	/******/	Handle	mySndH[2];	short	fRefNum;	short	thecurfile;	Str255	sampsize;	SndChannelPtr mySndChan;	// pointer to a sound channel	OSErr myErr;	Str255	samprate;	Boolean	whichBuff;	short keycounter;	Str255	chans;	char	mysampsize;	long	mysamprate,xx;	char	mychans;	Handle 	hRsrc;	long z;	Fixed	sampleRate;	short 	numChans;	short		numBits;	unsigned char km[16];	short	tempchans;	Boolean fileEnded,Endedfile;	SCStatus theStatus;	EventRecord theEvent;	short headerLen;	Ptr mySndPtr;	long bytesTilEnd;	/********/	long theRate;	short theWordSize;	short channels; 	long theBytes;	getAIFFDataII (mySpec,&theRate, &theWordSize,&channels, &theBytes);	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr!=0)	{		genError ("\pCan't open file");		return;	}		filePos = findCOMM(refNum,'COMM');	if (!filePos)	{		genError ("\pCan't find common chunk");		iErr = FSClose(refNum);		if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	inOutCount = sizeof (CommonChunk);	iErr = SetFPos(refNum,1,filePos);	iErr = FSRead(refNum,&inOutCount,&myCommCnk);	if (iErr!=0)	{		genError ("\pCan't read comm chunk from file");		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	iErr = SetFPos(refNum,1,0L);		filePos = findCOMM(refNum,'SSND');	if (!filePos)	{		genError ("\pCan't find SSND chunk");		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	filePos += 4L;	inOutCount = 4L;	iErr = SetFPos(refNum,1,filePos);	iErr = FSRead(refNum,&inOutCount,&audiosize);	if (iErr!=0)	{		genError ("\pCan't read audio size from file");		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	iErr = FSRead(refNum,&inOutCount,&AOffset);	if (iErr!=0)	{		genError ("\pCan't read AOffset from file");		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	if (false /*AOffset*/)	{		genError ("\pThis type of AIFF is not yet supported");		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		return;	}	filePos += 4L;	iErr = SetFPos(refNum,1,filePos);		mySndH[0] = NewHandle(normBuffer);					/** buffer a **/		if (!mySndH[0])	{		//SysBeep(5);		genError("\pNot enough memory, increase partition size, or reduce buffer in prefs");		FSClose(refNum);		return false;	}			//MoveHHi(mySndH[0]);			numChans = myCommCnk.numChannels;	numBits = myCommCnk.sampleSize;		sampleRate = (Fixed)theRate << 16;	//sampleRate = (unsigned long)myCommCnk.sampleRate;	bytesTilEnd = audiosize;	/*****************/	mySndChan = CreateSndChannel(numChans == 2);	whichBuff = 0;	Endedfile = false;	/********/	//sampleRate = 48000L * 65536L;	gCallBackPerformed = true;	if ( mySndH[0] != nil ) 	{		do		{			//HLock(mySndH[0]);			iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,(Fixed)sampleRate << 16,numBits,'NONE',0x3C,0,&headerLen);			mySndPtr = (*mySndH[0])+headerLen;			if (bytesTilEnd >= normBuffer - 800L)			{				inOutCount = normBuffer - 800L;				bytesTilEnd -= normBuffer - 800L;				Endedfile = false;			}			else			{				inOutCount = bytesTilEnd;				bytesTilEnd = 0;				Endedfile = true;			}			iErr = FSRead(refNum,&inOutCount,mySndPtr);			if (iErr!=0 && iErr!=-39)				genErrorN("\pError reading data fork",iErr);			iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,(Fixed)sampleRate << 16,numBits,'NONE',0x3C,inOutCount,&headerLen);			if (iErr!=0)				genErrorN("\pError setting up snd header 2",iErr);			if (numBits ==8)			{				for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)				{					*((Ptr)z) += 128;				}			}			while (!gCallBackPerformed)			{				keycounter = 0;				GetKeys(( long*)km);				for (z=0;z<=15;z++)					keycounter += (km[z] *((z+1)*16));									if (pleaseStop()  ||  (arrowPressed = arrowKey ()))				{					Endedfile = true;					gCallBackPerformed = true;					break;				}				}			gCallBackPerformed = false;			myErr = SndPlay (mySndChan, (SndListResource **)mySndH[0], true);			if ( myErr )				genErrorN("\pError playing sound",myErr);			iErr = InstallCallBack (mySndChan);							}while (false);		iErr = SndDisposeChannel(mySndChan,false);		DisposPtr((Ptr)mySndChan);	}	DisposHandle(mySndH[0]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle",myErr);	DisposPtr((Ptr)mySndChan);	iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);	watchcursor (false);		return;/***********/}long findCOMM(short localRefNum, OSType	theType){	OSErr	iErr;	Handle	myTempStore;	long inOutCount;	long lOffset;	OSType	filpType = theType;	long	soFar = 0;	extern long theTXFERLong;	myTempStore = NewHandle(2000);	if (!myTempStore)	{		theTXFERLong = 0;		return 0;	}	iErr = SetFPos(localRefNum,1,0L);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}		inOutCount = 1900L;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			theTXFERLong = 0;			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,0,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			theTXFERLong = (soFar + lOffset);			return (soFar + lOffset);		}		iErr = SetFPos(localRefNum,2,-1900L);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}	iErr = GetFPos(localRefNum,&soFar);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}			inOutCount = 1900L;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			theTXFERLong = 0;			DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			theTXFERLong = (soFar + lOffset);			return (soFar + lOffset);		}		iErr = SetFPos(localRefNum,1,1900L);	if (iErr!=0)	{		theTXFERLong = 0;		DisposHandle(myTempStore);		return 0;	}			soFar =1900L;		while (iErr != eofErr)	{		inOutCount = 1900L;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)		{			theTXFERLong = 0;				DisposHandle(myTempStore);			return 0;		}		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle(myTempStore);			theTXFERLong = (soFar + lOffset);			return (soFar + lOffset);		}		soFar +=1900L;	}	DisposHandle(myTempStore);	theTXFERLong = 0;	return 0;}