/*#include "Align.h"#include "UserIF.h"#include "FileDlg.h"*/#include <Aliases.h>#include "ProTools.h"#define PT24FPS 0000#define PT25FPS 0001#define PT2997NDFPS 0004#define PT2997DFFPS 0005#define PT30FPS 0003#define PT30DFFPS 0002void samplesToDropTimeCode(unsigned long theTimeStamp,long *hour,long *min,long *sec,long *frame,long SRate);Boolean isDropSecond(Byte Hours,Byte Mins,Byte Secs);short roundUpDown(float theFloat);/*#include "Probe.h"#include <Limits.h>#include "StrUtils.h"#include "AudioFil.h"#include "DemoKeys.h"*//*	Open a region within Pro Tools using the spot Apple Event		The SRgn apple event will place it on the track provided in the track parameter.	The timecode values are given in absolute frames, not in EvTime, like	SampleCell uses.	A new track isn't created unless the session does not contain the number of	tracks that the user wants to place the region at.	Return	Error code*/void ProToolsSpotRegionII (FSSpec theFile,Str255 regionName, short trkNum, long startFrame, long endFrame, long spotTimeInSamples, short theSessFrameRate);long convertSamplesFramesToTCFrames (long SRate, long theTimeStamp, short frameRate);OSErr extractSMPTEFromFile (FSSpec theFile,long *theFrameCount, short frameRate, long SRate);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);short getSessionFrameRate(FSSpec theSession);OSErr ProToolsOpenRegion(AliasHandle theFileAlias,						 short sTrackNumber, 						unsigned long lSMPTEstartTime, short sFrameFormat,						 ConstStr255Param strRegionName,						 unsigned long lStartSample, unsigned long lStopSample);						 						 void makeStr255 (Str255 theString, StringPtr theStr);void ProToolsSpotRegionWithRate (FSSpec theFile,Str255 regionName, short trkNum, unsigned long startFrame, unsigned long endFrame, unsigned long theFrameCount,short theSessFrameRate);void ProToolsSpotRegionWithRate (FSSpec theFile,Str255 regionName, short trkNum, unsigned long startFrame, unsigned long endFrame, unsigned long theFrameCount,short theSessFrameRate){	Boolean fSpot;	AliasHandle alFile;		long theRate;	short theWordSize;	Boolean stereo;	long theBytes;		getSDIIData (theFile, &theRate,&theWordSize,&stereo, &theBytes);		//theFrameCount = convertSamplesFramesToTCFrames (theRate, spotTimeInSamples, theSessFrameRate);							NewAliasMinimal(&theFile, &alFile);	//ProToolsOpenRegion(alFile, 2,/* TrkNum*/ 2,/* SMPTEstartTime */ 0, /* sFrameFormat */"\pVocALign",/* RegName*/ 0,/*StartSample*/44100*5); /*lStopSample*/	if (startFrame ==-1)	{		startFrame = 0;	}	if (endFrame ==-1)	{		endFrame = theBytes >> 1;	}	ProToolsOpenRegion(alFile, trkNum, theFrameCount, theSessFrameRate, regionName, startFrame,endFrame); }OSErr ProToolsOpenRegion(AliasHandle theFileAlias,						 short sTrackNumber, 						unsigned long lSMPTEstartTime, short sFrameFormat,						 ConstStr255Param strRegionName,						 unsigned long lStartSample, unsigned long lStopSample){	// allocate and null out all the AEDesc's we are going to create	// so our failure handler does the right thing and we don't have to	// create a million nested handlers.	static Str31 strRegion;	// Must be static 	AEAddressDesc processAEAddressDesc;	/*volatile */AppleEvent appleEventToSend,appleEventReply;	/*volatile */AERecord regionAERecord;	OSErr osError = noErr;	OSType ProToolsSignature = 'PTul';		processAEAddressDesc.dataHandle = NULL;	regionAERecord.dataHandle = NULL;	appleEventToSend.dataHandle = NULL;	appleEventReply.dataHandle = NULL;	makeStr255 ((StringPtr)strRegionName,strRegion);	//pstrcpy(strRegion, strRegionName);				// Create an address descriptor for the target process/application	if(osError == noErr)		osError = AECreateDesc(typeApplSignature, &ProToolsSignature,								sizeof(ProToolsSignature), &processAEAddressDesc);		// Create an apple event to send	if(osError == noErr)				osError = AECreateAppleEvent('Sd2a','ORgn', &processAEAddressDesc,									 kAutoGenerateReturnID,kAnyTransactionID, &appleEventToSend);	// add an alias to the apple event	if(osError == noErr)	{					HLock((Handle)theFileAlias);		osError = AEPutParamPtr(&appleEventToSend, 'FILE', typeAlias,									(Ptr)(*theFileAlias), GetHandleSize((Handle)(theFileAlias)));		HUnlock((Handle)(theFileAlias));	}					// Make a region descriptor	if(osError == noErr)	{				osError = AECreateList(NULL, 0, true /*isRecord*/, &regionAERecord);	}		if(osError == noErr)		{		osError = AEPutParamPtr(&appleEventToSend,'Trak',typeShortInteger, 								(Ptr)&sTrackNumber, sizeof(sTrackNumber));	}		if(osError == noErr)					{		osError = AEPutParamPtr(&appleEventToSend,'FFrm',typeShortInteger, 								(Ptr)&sFrameFormat, sizeof(sFrameFormat));	}		if(osError == noErr)	{		osError = AEPutParamPtr(&appleEventToSend,'SMSt',typeLongInteger, 								(Ptr)&lSMPTEstartTime, sizeof(lSMPTEstartTime));	}	if(osError == noErr)	{				osError = AEPutKeyPtr(&regionAERecord,'Name',typeChar, (Ptr)&strRegion[0],								sizeof(strRegion));	}		if(osError == noErr)	{		osError =  AEPutKeyPtr(&regionAERecord,'Star',typeLongInteger, 								(Ptr) &lStartSample, sizeof(lStartSample));	}		if(osError == noErr)	{			osError =  AEPutKeyPtr(&regionAERecord,'Stop',typeLongInteger, 				 				(Ptr) &lStopSample, sizeof(lStopSample));	}		// Add the region descriptor to the apple event	if(osError == noErr)	{		osError = AEPutParamDesc(&appleEventToSend,'Rgn ', &regionAERecord);	}		// Create a NULL reply event because we don't expect any reply	if(osError == noErr)	{		osError = AECreateDesc(typeNull, NULL, 0, &appleEventReply);	}			// And finally send the apple event	// NOTE: Could just pass NULL for the idle and filter proc's	// MacApp3 sets gMacAppAppleEventFilterProc to NULL and 	// sets gMacAppAppleEventIdleProc to a proc that vectors back into	// TApplication::AppleEventIdleProc that basically receives and acts	// on activate and update events so that screen and window stuff	// happen while the event is being sent...	if(osError == noErr)	{		osError = AESend(&appleEventToSend, &appleEventReply,					 	 kAEWaitReply |kAECanInteract,kAEHighPriority, kAEDefaultTimeout,					 	 NULL, NULL);	}		AEDisposeDesc(&processAEAddressDesc);	AEDisposeDesc(&appleEventToSend);	AEDisposeDesc(&appleEventReply);	AEDisposeDesc(&regionAERecord);/*	if(osError != noErr)		genError("\pAn Error occurred");*/			return osError;}OSErr ProToolsSpotRegionSampleAccurate(AliasHandle theFileAlias,						 short sTrackNumber, 						unsigned long lSamplestartTime,						 ConstStr255Param strRegionName,						 unsigned long lStartSample, unsigned long lStopSample){	// allocate and null out all the AEDesc's we are going to create	// so our failure handler does the right thing and we don't have to	// create a million nested handlers.	static Str31 strRegion;	// Must be static 	AEAddressDesc processAEAddressDesc;	/*volatile */AppleEvent appleEventToSend,appleEventReply;	/*volatile */AERecord regionAERecord;	OSErr osError = noErr;	OSType ProToolsSignature = 'PTul';	short sFrameFormat;	processAEAddressDesc.dataHandle = NULL;	regionAERecord.dataHandle = NULL;	appleEventToSend.dataHandle = NULL;	appleEventReply.dataHandle = NULL;		makeStr255 ((StringPtr)strRegionName,strRegion);	//pstrcpy(strRegion, strRegionName);				// Create an address descriptor for the target process/application	if(osError == noErr)		osError = AECreateDesc(typeApplSignature, &ProToolsSignature,								sizeof(ProToolsSignature), &processAEAddressDesc);		// Create an apple event to send	if(osError == noErr)				osError = AECreateAppleEvent('Sd2a','SRgn', &processAEAddressDesc,									 kAutoGenerateReturnID,kAnyTransactionID, &appleEventToSend);	// add an alias to the apple event	if(osError == noErr)	{					HLock((Handle)theFileAlias);		osError = AEPutParamPtr(&appleEventToSend, 'FILE', typeAlias,									(Ptr)(*theFileAlias), GetHandleSize((Handle)(theFileAlias)));		HUnlock((Handle)(theFileAlias));	}					// Make a region descriptor	if(osError == noErr)	{				osError = AECreateList(NULL, 0, true /*isRecord*/, &regionAERecord);	}		if(osError == noErr)		{		osError = AEPutParamPtr(&appleEventToSend,'Trak',typeShortInteger, 								(Ptr)&sTrackNumber, sizeof(sTrackNumber));	}/* heres the line we changed */		//sFrameFormat = ;	if(osError == noErr)					{		osError = AEPutParamPtr(&appleEventToSend,'FFrm',typeShortInteger, 								(Ptr)&sFrameFormat, sizeof(sFrameFormat));	}		if(osError == noErr)	{		osError = AEPutParamPtr(&appleEventToSend,'SMSt',typeLongInteger, 								(Ptr)&lSamplestartTime, sizeof(lSamplestartTime));	}	if(osError == noErr)	{				osError = AEPutKeyPtr(&regionAERecord,'Name',typeChar, (Ptr)&strRegion[0],								sizeof(strRegion));	}		if(osError == noErr)	{		osError =  AEPutKeyPtr(&regionAERecord,'Star',typeLongInteger, 								(Ptr) &lStartSample, sizeof(lStartSample));	}		if(osError == noErr)	{			osError =  AEPutKeyPtr(&regionAERecord,'Stop',typeLongInteger, 				 				(Ptr) &lStopSample, sizeof(lStopSample));	}		// Add the region descriptor to the apple event	if(osError == noErr)	{		osError = AEPutParamDesc(&appleEventToSend,'Rgn ', &regionAERecord);	}		// Create a NULL reply event because we don't expect any reply	if(osError == noErr)	{		osError = AECreateDesc(typeNull, NULL, 0, &appleEventReply);	}			// And finally send the apple event	// NOTE: Could just pass NULL for the idle and filter proc's	// MacApp3 sets gMacAppAppleEventFilterProc to NULL and 	// sets gMacAppAppleEventIdleProc to a proc that vectors back into	// TApplication::AppleEventIdleProc that basically receives and acts	// on activate and update events so that screen and window stuff	// happen while the event is being sent...	if(osError == noErr)	{		osError = AESend(&appleEventToSend, &appleEventReply,					 	 kAEWaitReply |kAECanInteract,kAEHighPriority, kAEDefaultTimeout,					 	 NULL, NULL);	}		AEDisposeDesc(&processAEAddressDesc);	AEDisposeDesc(&appleEventToSend);	AEDisposeDesc(&appleEventReply);	AEDisposeDesc(&regionAERecord);/*	if(osError != noErr)		genError("\pAn Error occurred");*/			return osError;}////	Switch to ProTools////	Return//	TRUE			- If switched to protools//Boolean SwitchToProTools(void){	return SwitchToApp('PTul');}	////	Locate and switch to an application////	Parameters//	lSignature		- Application signature////	Return//	TRUE			- If switched to protools//Boolean SwitchToApp(long lSignature){	Boolean fMatch = FALSE;	Boolean fSwitched = FALSE;	ProcessSerialNumber PSN;	ProcessInfoRec pirCurrent;	EventRecord theEvent;	short z;	PSN.highLongOfPSN = 0;	PSN.lowLongOfPSN = kNoProcess;	do{		pirCurrent.processInfoLength = sizeof(ProcessInfoRec);		pirCurrent.processName = NULL;		pirCurrent.processAppSpec = NULL;				if(GetNextProcess(&PSN)	!= noErr)			break;					if(GetProcessInformation( &PSN, &pirCurrent) == noErr)			if(pirCurrent.processSignature == lSignature)			{				fMatch = TRUE;				break;			}						}while(!(PSN.highLongOfPSN == 0 && PSN.lowLongOfPSN == kNoProcess)); 			if(fMatch)					if(SetFrontProcess(&PSN) == noErr)			fSwitched = TRUE;	for (z=0;z<5;z++)	{		WaitNextEvent(everyEvent,&theEvent,0,0);	}		return fSwitched;	}	////	Check if ProTools is running////	Return//	TRUE			- If application is running//Boolean IsProToolsRunning(void){	return IsAppRunning('PTul');}		////	Check if an application is running////	Parameters//	lSignature		- Application signature////	Return//	TRUE			- If application is running//Boolean IsAppRunning(long lSignature){	Boolean fMatch = FALSE;	ProcessSerialNumber PSN;	ProcessInfoRec pirCurrent;	PSN.highLongOfPSN = 0;	PSN.lowLongOfPSN = kNoProcess;	do{		pirCurrent.processInfoLength = sizeof(ProcessInfoRec);		pirCurrent.processName = NULL;		pirCurrent.processAppSpec = NULL;				if(GetNextProcess(&PSN)	!= noErr)			break;					if(GetProcessInformation( &PSN, &pirCurrent) == noErr)			if(pirCurrent.processSignature == lSignature)			{				fMatch = TRUE;				break;			}						}while(!(PSN.highLongOfPSN == 0 && PSN.lowLongOfPSN == kNoProcess));				return fMatch;	}	