#include "SampleSearch.h"#include "Globals.h"#include "Fonts.h"#include "drawOverView.h"#include <math.h>#include "tabs.h"Cell nullCell;void deSelectAll();short presSize,presFont;void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);long getSampleCellInstSize (FSSpec mySpec);void DrawIconButton(short left,short top,short iconResID);void drawColourIcon(short left,short top,short cicnResID);Boolean DrawInfoBox (FSSpec mySpec, short index);void OpenMany(void);void clearOverViewInWindow (void);Rect zRect;short playAudioInWaveForm (FSSpec theFile,Rect DisplayRect,short startHoriz);short identifySCII(FSSpec mySpec);long findANNO(short localRefNum);Boolean SetFSSpecComment(FSSpec mySpec, Str255 theComment);Boolean GetFSSpecComment(FSSpec mySpec, StringPtr theComment);long findAPPL(short localRefNum);Boolean VgetvolName(short theVRefNum, StringPtr myString);void AddToFaveTab(FSSpec	mySpec, short index,short whichList);void initialiseUPPs (void);extern Boolean dragAvailable;Cell rememberCell;Boolean	rememberSelection = false;extern Boolean listOpen;Boolean SSinBG = false;Boolean _GetIconSuiteForTypeCreator(OSType	inCreator, OSType inType, short vRefNum, Handle *outIconSuite);short handleRegionPopUpClick (FSSpec mySpec, short currentSDIIRegion, Boolean noMenu);Boolean loseTheWindow = false;Boolean goingToFind = false;void checkList(void);void saveForUndo (void);void zDrawGrowIcon (WindowPtr theWindow);void divertLoadChoose(void);void OpenManyinFinder(void);#define kReEditNone 0#define kReEditLeft 0#define kReEditRight 0extern Cell theLastCell;extern short nextRegionToHilite;Boolean autoCalcOverviews = false;void cutWaveformSelection(void);void fadeSelection(Boolean fadeIn);void drawSDIIToolBar(FSSpec mySpec);Boolean waveFormSelected = false;Rect selectRect;long handleSelectionPopUpClick (FSSpec mySpec);Boolean playFromList = false;RGBColor zColor;void SDIIPlayScrub(FSSpec mySpec, Rect displayRect, short startHoriz);Boolean addSD2RegionFromOverView(FSSpec mySpec, Rect DisplayRect, long frameStart, long frameStop);void myGrayDragProc (void);void clearRegionTools(void);extern short theCurrentSDIIRegion;#include "prefs.h"void normaliseSelection (void);void silenceSelection(void);extern Boolean regionSelected;void createSDIIOverviewMany(void);void zGetFontInfo(FontInfo * fInfoPtr);extern newPrefsRec theNewPrefs;long theAPPLReply;Boolean editSD2RegionFromOverView(FSSpec mySpec, Rect DisplayRect, long frameStart, long frameStop,short whichRegion);void captureSelectionToFileTAB(short theTab);Rect zcommentRect;Boolean windowHiliteDrawn = false;void captureSelectionToFile(Boolean writeTemp);short zlastHilite =-1;extern FSSpec theDisplayedFile;extern Boolean autoSustain;Boolean optionKeyHeld = false;extern Boolean mousePlay;Rect myOverViewButtonRect;extern  short ListFontHite;void	drawColourIconII(short left,short top,short cicnResID);void showCommentinWin(short mode, Cell theCell);extern Boolean dontQuery;void AuditionMany(short playFreq);OSErr renameTab(short tabNum);void windowUpdate(void);extern short keyAcrossTheTop[14];extern Fixed keyRatio[14];void updateOptions(void);void makelCellCoords(void);ControlHandle	myCustomButton[10];void zeditComment(FSSpec	theSelFile, short  index);short isPressed(unsigned short k );extern Boolean folderSearch;extern short presTop;	extern long theGreyColor;long  obtainSize(short theIndex);Boolean isItOnLine(short myVRefNum);void openFolderList(FSSpec mySpec, short theKey);void zeditComment(FSSpec	theSelFile, short  index);Boolean translateFileType (OSType	theType, StringPtr theTypeText);Boolean divertIt;Boolean volumeMounted;//#include "Drag.h"void doRichardsThing(void);extern short presLeft;pascal Boolean myNormClikLoop(void);extern short presvertsize;extern short prestempor;typedef struct listFontRec {Str255 fontName;short fontSize;} listFontRec, *listFontRecPtr;extern Boolean dontAdd;EventRecord theGlobalEvent;extern listFontRec  theFontRec;		pascal OSErr  MyHandleQuit (AppleEvent *theAppleEvent, AppleEvent *reply, long											handlerRefCon);OSErr nameFromVRefNum (short whichVol, StringPtr volName);											pascal void myDragLoop(void);											pascal Boolean myLClikLoop(void);pascal Boolean myDragLClikLoop(void);																																	extern Boolean	oneOpened;extern FSSpec	theODOCSpec;Cell zlCellCoords;void LoadTabFaves(short whichList);short globPlay;void SaveAsTabFave(short whichList);long startTick;extern ProcessSerialNumber PSNus;Point startClickPoint;extern  DragTrackingHandlerUPP xMyTrackingHandler;extern  DragReceiveHandlerUPP xMyReceiveDropHandler;DragGrayRgnUPP xmyDragLoop;DragGrayRgnUPP xmyGrayDragProc;ListClickLoopUPP xmyDragLClikLoop;ListClickLoopUPP xmyLClikLoop;extern SndCallBackUPP zSampleCallBack;pascal void SampleCallBack (SndChannelPtr theChan, SndCommand theCmd);void initialiseUPPs (void);void initialiseUPPs (void){	xmyDragLoop = NewDragGrayRgnProc(myDragLoop);	xmyGrayDragProc = NewDragGrayRgnProc(myGrayDragProc);	xmyDragLClikLoop = NewListClickLoopProc(myDragLClikLoop);	xmyLClikLoop = NewListClickLoopProc(myLClikLoop);	xAlertFilter = NewModalFilterProc(AlertFilter);	zSampleCallBack = NewSndCallBackProc (SampleCallBack);}void handleEvents(void){		EventRecord	theEvent;						/** for event handling **/	short	thePart;							/** for event handling **/	WindowPtr	whichWindow;					/** for event handling **/	Boolean	beep;	long	windSize;							/** for resize window **/	Rect	dragRect;	short iCtlPart;	Boolean tempSus;	ControlHandle	whichCtl;	Rect	sizeRect,myButtonsRect,myTabsRect;	GrafPtr	oldPort;	short i,theButton;	OSErr	ery,iErr;	extern Boolean squashColumns;	StandardFileReply	mySFR;	short numberOfColumns;	short	windowCode;	char theChar;		/* a keyboard character */	StandardFileReply reply;	SFTypeList	mytypeList;	FInfo fndrInfo;	Handle	hString;	short theQuay,fontNum;	Boolean	arrowKeyPressed;	Boolean	genPurp;	long myLong;	double tempCalc;	char thedata[255];	Ptr dataPtr = &thedata[0];	short iPartCode;	short	dataLen;	short backupCell;	Point localPt;	Cell	autoScrollCell;	Rect	commentRect;	FMetricRec theInfo;	FontInfo fontInfo;	short z;	Boolean presSustain;	RGBColor myColor;	Rect myWaveToolsRect, regionsPopUpRect,selectActionPopUpRect;	GrafPtr savePort;			GetPort (&savePort);	SetPort ((GrafPtr)myWindow);		globPlay = 0x3C;			  						mytypeList[0] = 'APPL';	done = FALSE;	dragRect = qd.screenBits.bounds;	reFound = false;		while (!done && !reFound)	{		watchcursor(false);				SetRect(&myButtonsRect,(*myWindow).portRect.right-325,5,(*myWindow).portRect.right-5,33);		SetRect(&myTabsRect,(*myWindow).portRect.left,59,(*myWindow).portRect.right,80);		SetRect(&commentRect,(*myWindow).portRect.left + 1,0,(*myWindow).portRect.right-325,50);		/* resize bounds */		SetRect (&sizeRect, 415, 145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0),qd.screenBits.bounds.right - qd.screenBits.bounds.left,qd.screenBits.bounds.bottom - qd.screenBits.bounds.top);				SetRect(&myWaveToolsRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,(*myWindow).portRect.right,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);		SetRect(&regionsPopUpRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);		SetRect(&selectActionPopUpRect,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,256,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);									if (WaitNextEvent (everyEvent, &theEvent, (SSinBG) ? 60 : 1, nil ) ) 		{			switch (theEvent.what) 			{				case activateEvt:					watchcursor(false);				break;								case app4Evt:					if (theEvent.message & 0x01000000) {	/* suspend/resume */						if (theEvent.message & 0x00000001) 						{							//Resume							SSinBG = false;						} 						else 						{							//Suspend							SSinBG = true;						}					}				break;				case kHighLevelEvent:					if (theEvent.message == 'find')					{						if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])							SaveAsTabFave(theNewPrefs.whichTab);						done = true;						goingToFind = true;						iErr = SetFrontProcess(&PSNus);						SSinBG = false;					}					else					{						oneOpened = false;						iErr = AEProcessAppleEvent (&theEvent);						if (oneOpened)						{							openFSList(theODOCSpec);							checkList();							gogetvolref();							resolveOVols();							reFound = true;						}					}					break;					case keyDown: case autoKey:					SSinBG = false;					divertIt = false;					if ((theEvent.modifiers & cmdKey) == 0)							{						theQuay = (theEvent.message) & keyCodeMask;						theChar = theEvent.message & charCodeMask;						if (theQuay == 0x7300)						{							deSelectAll();							autoScrollCell.v = 0;							autoScrollCell.h = 0;														LSetSelect( true, autoScrollCell, myList );							GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll(myList);						/*	TextFont(0);													TextSize(12); */							arrowKeyPressed = true;							break;						}						if (theQuay == 0x7700)						{							deSelectAll();							autoScrollCell.v = (DisplayedColumns == 4) ? (totfindcounter / 4) : totfindcounter;							autoScrollCell.h = 0;														LSetSelect( true, autoScrollCell, myList );							GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll(myList);						/*	TextFont(0);												TextSize(12); */							arrowKeyPressed = false;							break;						}						if (theQuay == 0x7D00)						{							LSetSelect( FALSE, lCellCoords, myList );							backupCell = lCellCoords.v;																		switch (DisplayedColumns)							{								case 1:									lCellCoords.v +=1;								break;																case 4:									lCellCoords.v +=1;								break;												}													/*tempCalc = (short)ceil((double)totfindcounter / (double)DisplayedColumns);							if (lCellCoords.v >=  tempCalc )								lCellCoords.v =tempCalc-1;*/							dataLen = 255;							LGetCell(dataPtr,&dataLen,lCellCoords,myList);							if (!dataLen)								lCellCoords.v = backupCell;															LSetSelect( TRUE, lCellCoords, myList );							theLastCell = lCellCoords;							GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll( myList );							/* TextFont(0);													TextSize(12); */							arrowKeyPressed = true;								regionSelected = waveFormSelected = false;							showCommentinWin(kFirstSelected,nullCell);							theCurrentSDIIRegion = -99;							/** down arrow pressed **/						}						if (theQuay == 0x7E00)						{							LSetSelect( FALSE, lCellCoords, myList );														lCellCoords.v -=1;							if (lCellCoords.v < 0)								lCellCoords.v =0;															theLastCell = lCellCoords;							LSetSelect( TRUE, lCellCoords, myList );														GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll( myList );						/*	TextFont(0);													TextSize(12);  */							arrowKeyPressed = true;							regionSelected = waveFormSelected = false;							showCommentinWin(kFirstSelected,nullCell);							theCurrentSDIIRegion = -99;							/** up arrow pressed **/						}						if (theQuay == 0x7B00)						{							LSetSelect( FALSE, lCellCoords, myList );							lCellCoords.h -=1;							if (lCellCoords.h < 0)							{								lCellCoords.h = DisplayedColumns - 1;								lCellCoords.v --;								if (lCellCoords.v < 0)								{									lCellCoords.v =0;								} 							}							LSetSelect( TRUE, lCellCoords, myList );							theLastCell = lCellCoords;							GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll( myList );						/*	TextFont(0);													TextSize(12);  */							arrowKeyPressed = true;							regionSelected = waveFormSelected = false;							showCommentinWin(kFirstSelected,nullCell);							theCurrentSDIIRegion = -99;							/** left arrow pressed **/						}						if (theQuay == 0x7C00)						{							LSetSelect( FALSE, lCellCoords, myList );							backupCell = lCellCoords.h;							lCellCoords.h +=1;							if (lCellCoords.h >= DisplayedColumns)							{								lCellCoords.h = 0;								lCellCoords.v ++;							}							dataLen = 255;							LGetCell(dataPtr,&dataLen,lCellCoords,myList);							if (!dataLen)								lCellCoords.h = backupCell;							LSetSelect( TRUE, lCellCoords, myList );							theLastCell = lCellCoords;							GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll( myList );						/*	TextFont(0);													TextSize(12);  */							arrowKeyPressed = true;							regionSelected = waveFormSelected = false;							showCommentinWin(kFirstSelected,nullCell);							theCurrentSDIIRegion = -99;							/** right arrow pressed **/						}																							if (theQuay == 0x3100)						{							playFromList = true;							HandleMenu(MenuKey((char) (89)));							playFromList = false;							arrowKeyPressed = true;							break;						}												/* page up **/						if (theQuay == 0x7400)						{							if ((*myList)->cellSize.v > 0)							{								short windowCellsV = ((*myList)->rView.bottom - (*myList)->rView.top) / (*myList)->cellSize.v;								windowCellsV --;								GetFNum(theFontRec.fontName,&fontNum);								TextFont(fontNum);						/** font for list - chicago **/								TextSize(theFontRec.fontSize);								TextFace(0);									LScroll(0,-windowCellsV,myList);							}							break;						}												/* page down **/						if (theQuay == 0x7900)						{							if ((*myList)->cellSize.v > 0)							{								short windowCellsV = ((*myList)->rView.bottom - (*myList)->rView.top) / (*myList)->cellSize.v;								windowCellsV --;								GetFNum(theFontRec.fontName,&fontNum);								TextFont(fontNum);						/** font for list - chicago **/								TextSize(theFontRec.fontSize);								TextFace(0);								LScroll(0,windowCellsV,myList);							}							break;						}																								for (z=0;z<14;z++)						{							if (theQuay == (keyAcrossTheTop[z] << 8))							{								playFromList = true;								HandleMenu(MenuKey((char) (89)));								playFromList = false;								arrowKeyPressed = true;								break;							}						}																								if ((FrontWindow() == (**myList).port) && !arrowKeyPressed && ((theChar >= 0x41 && theChar >= 0x5A ) || ((theChar >= 0x61 && theChar >= 0x7A ) )) )						{							ListSearchUPP xcmp1stChar;							SetPort ((GrafPtr)myWindow);							LSetSelect( FALSE, lCellCoords, myList );		/* deselect current selection */							SetPt( &lCellCoords, 0,0 );						/* start at top of list */							xcmp1stChar = NewListSearchProc(cmp1stChar);							genPurp = LSearch( &theChar, 1, xcmp1stChar, &lCellCoords, myList );							LSetSelect( TRUE, lCellCoords, myList );		/* select cell which matched */							theLastCell = lCellCoords;							GetFNum(theFontRec.fontName,&fontNum);							TextFont(fontNum);						/** font for list - chicago **/							TextSize(theFontRec.fontSize);							LAutoScroll( myList );	/* scroll in case it's off screen */						/*	TextFont(0);													TextSize(12);  */							makelCellCoords();							regionSelected = waveFormSelected = false;							showCommentinWin(kFirstSelected,nullCell);								theCurrentSDIIRegion = -99;										}						arrowKeyPressed = false;					}									theChar = theEvent.message & charCodeMask;					if ((theChar == ' ' || theChar == 'æ') && (theEvent.modifiers & cmdKey))					{						if (waveFormSelected)						{							captureSelectionToFile(true);						}					}										if ((theEvent.modifiers & cmdKey) != 0)			   		{			   			 theQuay = (theEvent.message) & keyCodeMask;												if (theQuay == 0x7D00)						{							OpenMany();								/********/							break;						}			     		 AdjustMenus();			     		 playFromList = true;				 		 HandleMenu(MenuKey((char) (theEvent.message & charCodeMask)));				 		 playFromList = false;					}					if (theQuay == 0x4300 && (theEvent.modifiers & cmdKey))					{						theNewPrefs.dontAddToList = !theNewPrefs.dontAddToList;						if (theNewPrefs.dontAddToList)							genError ("\pAdd to list disabled");						else							genError ("\pAdd to list enabled");					}					if (theQuay == 0x7C00 && (theEvent.modifiers & cmdKey))					{						if (waveFormSelected)						{							theCurrentSDIIRegion = nextRegionToHilite + 1;								handleRegionPopUpClick (theDisplayedFile,theCurrentSDIIRegion, true);							drawSDIIToolBar(theDisplayedFile);							nextRegionToHilite = theCurrentSDIIRegion;						}					}					if (theQuay == 0x7B00 && (theEvent.modifiers & cmdKey))					{						if (waveFormSelected)						{							theCurrentSDIIRegion = nextRegionToHilite - 1;							if (theCurrentSDIIRegion >= 0)							{								nextRegionToHilite = theCurrentSDIIRegion;								handleRegionPopUpClick (theDisplayedFile, theCurrentSDIIRegion,true);								drawSDIIToolBar(theDisplayedFile);							}						}					}					theChar = theEvent.message & charCodeMask;					if ((theChar == 't' || theChar == 'T') && (theEvent.modifiers & cmdKey & optionKey))					{						if (waveFormSelected)						{							captureSelectionToFile(false);						}					}				break;								case mouseDown:					thePart = FindWindow (theEvent.where,&whichWindow);					SetPort (whichWindow);															if ((theEvent.modifiers & optionKey) != 0)						optionKeyHeld = true;					else						optionKeyHeld = false;					switch (thePart)					{						case inSysWindow: 			    			SystemClick (&theEvent, whichWindow);			    		break;			    			 			case inMenuBar: /** make sure menus are disabled with no selection*/							SSinBG = false;			  				AdjustMenus();			  				myLong = MenuSelect(theEvent.where);			  				playFromList = true;			  				HandleMenu(myLong);			  				playFromList = false;			    		break;						case inContent:							SSinBG = false;							SetPort ((GrafPtr)myWindow);							GlobalToLocal(&theEvent.where);															/********* in tabs ************/							if(PtInRect(theEvent.where,&myTabsRect)) 							{								short tt;								tt = mouseInside(theEvent.where,55,0);																if (tt >= 0)								{									if (theEvent.modifiers & optionKey)									{										renameTab(tt);											SetPort(whichWindow);										setUpTabs();										drawTabs(55,0);														}									else									{										short qq;										Handle sndHdl;																				for (qq=0;qq<=lastItem;qq++)										{											tabSelected[qq] = false;											}										tabSelected[tt] = true;											calcDrawingArray();											MoveTo((*myWindow).portRect.left,79);											LineTo((*myWindow).portRect.right,79);										drawTabs(55,0);																				watchcursor(true);										if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])										{											SaveAsTabFave(theNewPrefs.whichTab);										}										LoadTabFaves(tt);										watchcursor(false);																				theNewPrefs.whichTab = tt;											}								}							}																					if(PtInRect(theEvent.where,&myWaveToolsRect))   /* in my wave tools */							{								if(PtInRect(theEvent.where,&regionsPopUpRect)) 								{									short myMenuChoice = handleRegionPopUpClick (theDisplayedFile, theCurrentSDIIRegion,false);									if (myMenuChoice == 1)									{										theCurrentSDIIRegion = -99;										regionSelected = false;										waveFormSelected = true;										drawSDIIToolBar(theDisplayedFile);										selectRect = zRect;										selectRect.top++;										showCommentinWin(kFirstSelected,nullCell);									}									if (myMenuChoice == 2)									{										theCurrentSDIIRegion = -99;										regionSelected = false;										waveFormSelected = false;																				//showCommentinWin(kFirstSelected,nullCell);									}									if (myMenuChoice > 3)									{										theCurrentSDIIRegion = myMenuChoice - 4;										nextRegionToHilite = theCurrentSDIIRegion;										drawSDIIToolBar(theDisplayedFile);									}								}							}														if(PtInRect(theEvent.where,&myWaveToolsRect))   /* in my wave tools */							{								if(PtInRect(theEvent.where,&selectActionPopUpRect) &&  waveFormSelected)								{									long myMenuChoice = handleSelectionPopUpClick (theDisplayedFile);										if (HiWord(myMenuChoice) == 15)									{										short theRegionItem;																				switch (LoWord(myMenuChoice))										{											case 1:												captureSelectionToFile(false);											break;																						case 2:												addSD2RegionFromOverView(theDisplayedFile, zRect, (long)selectRect.left, (long)selectRect.right);												drawSDIIToolBar(theDisplayedFile);											break;																						case 3: /* disabled */																						break;																						default:												theRegionItem = LoWord(myMenuChoice) - 4;												editSD2RegionFromOverView(theDisplayedFile, zRect, (long)selectRect.left, (long)selectRect.right,theRegionItem);											break;										}									}									else									{										switch (LoWord(myMenuChoice))										{											case 1:												/* deal with Pop up */											break;																						case 2:												playFromList = true;												HandleMenu(MenuKey((char) (89)));												playFromList = false;												arrowKeyPressed = true;											break;																						case 4:												normaliseSelection ();											break;																						case 5:												silenceSelection();												 /* silence */											break;																						case 6:											 	fadeSelection(true);											break;																						case 7:											 	fadeSelection(false);											break;																						case 8:												/* set the destination */												captureSelectionToFile(true);												/* delete the original */												/* rename */												/* refresh */											break;																							case 10:												cutWaveformSelection();											break;																				}																			}																}							}																																			/********* in the grey area ************/							if(PtInRect(theEvent.where,&commentRect)) 							{								SetPt( &lCellCoords, 0,0 );		/* start at top of list  */								if (LGetSelect( TRUE, &lCellCoords, myList))								{									DrawInfoBox (((*therealResults)[(lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments]), (lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments);									break;								}							}																																				/****** in OV button ********/							if(theNewPrefs.waveFormWindow) 							{									Point localPoint = theEvent.where;								localPoint.v -= 15;								localPoint.h -= 15;								if (PtInRect(localPoint,&myOverViewButtonRect))								{									if (isPressed(0x3A))									{										autoCalcOverviews = !autoCalcOverviews;											zDrawGrowIcon ((GrafPtr)myWindow);																}									createSDIIOverviewMany();								}							}																																							/*********** in the buttons ************/							if(PtInRect(theEvent.where,&myButtonsRect)) 								{								theButton = (theEvent.where.h - myButtonsRect.left) / 64;								GetMouse(&localPt);								while(StillDown() && (theEvent.modifiers & optionKey) == 0)								{									drawColourIconII((*myWindow).portRect.right-69-((4-theButton)*64),5,5005+theButton);									while(PtInRect(localPt,&myButtonsRect) && StillDown())									{										GetMouse(&localPt);									}									drawColourIconII((*myWindow).portRect.right-69-((4-theButton)*64),5,5000+theButton);									while(!PtInRect(localPt,&myButtonsRect) && StillDown())									{										GetMouse(&localPt);									}										}								drawColourIconII((*myWindow).portRect.right-69-((4-theButton)*64),5,5000+theButton);								if (!PtInRect(localPt,&myButtonsRect))									break;								switch (theButton)								{									case 0:										if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])											SaveAsTabFave(theNewPrefs.whichTab);										done = true;										goingToFind = true;									break;									case 1:										totfindcounter = NewSearchAgain();									break;									case 2:										playFromList = true;										mousePlay = true;										presSustain = autoSustain;										autoSustain = true;										AuditionMany(0x3C);										autoSustain = presSustain;										mousePlay = false;										playFromList = false;										break;									case 3:									if ((theEvent.modifiers & optionKey) == 0)											OpenMany();											else										{											if ((theEvent.modifiers & cmdKey) == 0)												divertLoadChoose();											else												doRichardsThing();												}									break;									case 4:										OpenManyinFinder();									break;																		default:									break;								}							}																						/*********** In the waveform ***********/							if (theNewPrefs.waveFormWindow)							{								short reEditSelection = kReEditNone;								SetRect(&zRect,0,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight + 1,myWindow->portRect.right,myWindow->portRect.bottom);																		selectRect.top = zRect.top + 1;									selectRect.bottom = zRect.bottom;															if(PtInRect(theEvent.where,&zRect))  /* fiddling with the audio */								{									long zoptionDown = ((long)theEvent.modifiers & optionKey);									long zshiftDown = ((long)theEvent.modifiers & shiftKey);									long zctrlDown = ((long)theEvent.modifiers & controlKey);									long zcmdDown = ((long)theEvent.modifiers & cmdKey); 																		if (zshiftDown)									{										Point thePosition, oldPosition;										Boolean forward = true;										short startPoint = 0,endPoint = 0,revStart = -99;										Rect invertRect;										Boolean doneDrag = false;										SetPort ((GrafPtr)myWindow);																				regionSelected = false;										theCurrentSDIIRegion = -99;										GetMouse(&thePosition);										reEditSelection = kReEditNone;																				if (waveFormSelected)										{											if (abs(thePosition.h - selectRect.left) < 4)											{												reEditSelection = kReEditLeft;												regionSelected = waveFormSelected = false;												showCommentinWin(kFirstSelected,nullCell);												waveFormSelected = true;												drawSDIIToolBar(theDisplayedFile);												startPoint = selectRect.right /*selectRect.left*/;												endPoint = selectRect.right;												oldPosition = thePosition;												oldPosition.h ++;												revStart = selectRect.left;												forward = false;												invertRect = selectRect;												selectRect.left = invertRect.left = thePosition.h;												InvertRect(&invertRect);											}											else											{												if (abs(thePosition.h - selectRect.right) < 4)												{													reEditSelection = kReEditRight;													regionSelected = waveFormSelected = false;													showCommentinWin(kFirstSelected,nullCell);													waveFormSelected = true;													drawSDIIToolBar(theDisplayedFile);													startPoint = selectRect.left;													endPoint = selectRect.right;													oldPosition = thePosition;																										forward = true;													revStart = -99;													invertRect = selectRect;													selectRect.right = invertRect.right = thePosition.h;													InvertRect(&invertRect);												}												else												{													regionSelected = waveFormSelected = false;													showCommentinWin(kFirstSelected,nullCell);																										oldPosition = thePosition;													invertRect.left = thePosition.h-1;													invertRect.top = zRect.top + 1;													invertRect.bottom = zRect.bottom;													invertRect.right = thePosition.h;													InvertRect(&invertRect);													startPoint = thePosition.h - 1;													endPoint = thePosition.h;												}											}										}										else										{											regionSelected = waveFormSelected = false;											showCommentinWin(kFirstSelected,nullCell);																						oldPosition = thePosition;											invertRect.left = thePosition.h-1;											invertRect.top = zRect.top + 1;											invertRect.bottom = zRect.bottom;											invertRect.right = thePosition.h;											InvertRect(&invertRect);											startPoint = thePosition.h - 1;											endPoint = thePosition.h;										}																				while(Button())										{											while(Button() && (thePosition.h == oldPosition.h))											{												GetMouse(&thePosition);											}																					if (thePosition.h > oldPosition.h) /* forward */											{													doneDrag = true;													if (forward)													{																												invertRect.left = invertRect.right;														invertRect.right = thePosition.h;														InvertRect(&invertRect);														forward = true;														if (thePosition.h < startPoint)														{															revStart = thePosition.h;														}														else														{															endPoint = thePosition.h;														}																											}													else													{																												invertRect.right = thePosition.h;														InvertRect(&invertRect);														forward = true;																											}											}											else   /* backward */											{												doneDrag = true;												if (!forward)												{													invertRect.right = invertRect.left;													invertRect.left = thePosition.h;													//startPoint = thePosition.h;													InvertRect(&invertRect);													forward = false;																									if (thePosition.h < startPoint)													{																												revStart = thePosition.h;														endPoint = startPoint;														forward = false;													}													else													{														endPoint = thePosition.h;													}																									}												else /* reversing */												{																											invertRect.left = thePosition.h;														InvertRect(&invertRect);														//endPoint = thePosition.h;														forward = false;												}											}											oldPosition.h = thePosition.h;										}																					selectRect.top = invertRect.top;										selectRect.bottom = invertRect.bottom;																				if (doneDrag)										{											if (revStart == -99) /* you never reversed */											{												selectRect.left = startPoint;												selectRect.right = endPoint;												//Debugger();												/*	endPoint												startPoint */											}											else											{												if (endPoint != startPoint)												{													selectRect.left = startPoint;													selectRect.right = endPoint;													//Debugger();													/*startPoint */													/*	endPoint */												}												else												{													selectRect.left = revStart;													selectRect.right = endPoint;												//Debugger();													//Debugger();													/*revStart */													/*	endPoint */																									}													}																						//PenMode(patOr);											myColor.red = (regionSelected) ? 0x0000 : 0xFFFF;											myColor.green = (regionSelected) ? 0xFFFF : 0x0000;											myColor.blue = 0;											RGBForeColor(&myColor);											FrameRect(&selectRect);											//PaintRect(&selectRect);											/*FillRect(&selectRect,black);*/											//PenMode(patCopy);											myColor.red = 0;											myColor.green = 0;											myColor.blue = 0;											RGBForeColor(&myColor);													waveFormSelected = true;											drawSDIIToolBar(theDisplayedFile);												zDrawGrowIcon ((GrafPtr)myWindow);										}										else										{											regionSelected = waveFormSelected = false;											}									}									if (zoptionDown)									{										if (waveFormSelected)										{											Point theMouse;											Point oldPoint;											GetMouse(&theMouse);											oldPoint = theMouse;											while (Button())											{												while (Button() && ((theMouse.h == oldPoint.h) && (theMouse.v == oldPoint.v)) )												{													GetMouse(&theMouse);												}												if ((theMouse.h != oldPoint.h) || (theMouse.v != oldPoint.v))												{													/* do the drag */													RgnHandle theRegion;													long lDistVH;																										theRegion = NewRgn();																										RectRgn(theRegion,&selectRect);													windowHiliteDrawn = false;													zlastHilite =-1;													lDistVH = DragGrayRgn(theRegion,theMouse,&myWindow->portRect,&myWindow->portRect,0,xmyGrayDragProc);																										if (windowHiliteDrawn)													{														RGBColor theColor;																												theColor.red = 0xFFFF;														theColor.green = 0xFFFF;														theColor.blue = 0xFFFF;														RGBForeColor(&theColor);																											FrameRect(&zcommentRect);																												theColor.red = 0;														theColor.green = 0;														theColor.blue = 0;														RGBForeColor(&theColor);														windowHiliteDrawn = false;																												captureSelectionToFile(false);														/* the user dropped it in the list */													}																										if (zlastHilite > -1)													{														/* the user dropped it in the tab */														hiliteCell(zlastHilite, false,55,0);																												captureSelectionToFileTAB(zlastHilite);														zlastHilite = -1;													}																										DisposeRgn(theRegion);													//genError("\pThat is going to drag the selection into a new file !!!");												}																						}																					}																		}																		if (zctrlDown)									{										SDIIPlayScrub (theDisplayedFile,zRect,theEvent.where.h);									}																		if (!zoptionDown && !zshiftDown && !zctrlDown)									{										mousePlay = true;										playAudioInWaveForm (theDisplayedFile,zRect,theEvent.where.h);										mousePlay = false;									}								}									else								{									theGlobalEvent = theEvent;									(*myList)->lClickLoop = xmyDragLClikLoop;								}							}																															/***** In the List *******/																		beep = false;							SetRect (&zcommentRect,0, 80,myWindow->portRect.right,myWindow->portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight  :  0) - ((theNewPrefs.SDIIToolBar) ?  theNewPrefs.toolsHeight :  0));							if (PtInRect(theEvent.where,&zcommentRect)) 							{								theGlobalEvent = theEvent;								(*myList)->lClickLoop = xmyDragLClikLoop;							//	if (theEvent.modifiers & optionKey)							//	{							//		(*myList)->lClickLoop = xmyLClikLoop; /* local copy to tabs - not used now ? */							//	}								if (theEvent.modifiers & shiftKey)								{									(*myList)->lClickLoop = xmyDragLClikLoop;								}																	startTick = TickCount();								startClickPoint = theEvent.where;																zColor.red = 0;								zColor.blue = 0;								zColor.green = 0;								RGBForeColor(&zColor);								GetFNum(theFontRec.fontName,&fontNum);								TextFont(fontNum);						/** font for list - chicago **/								TextSize(theFontRec.fontSize);								SetPort((GrafPtr)myWindow);								beep = LClick(theEvent.where,theEvent.modifiers, myList);	/** this tells if you dbl clicked **/										theLastCell = LLastClick(myList);								theCurrentSDIIRegion = -99;														regionSelected = waveFormSelected = false;								showCommentinWin(kFirstSelected,nullCell);																if (theEvent.modifiers & cmdKey)								{									SetPt( &lCellCoords, 0,0 );		/* start at top of list  */									if (LGetSelect( TRUE, &lCellCoords, myList))									{										DrawInfoBox (((*therealResults)[(lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments]), (lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments);										break;									}								}																								lCellCoords = LLastClick(myList);																if (beep) /****** double clicked ********/								{									if (!(lCellCoords.h == 1 && DisplayComments))									{										if (folderSearch)										{											openFolderList((*therealResults)[(lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments],(short)isPressed(0x3A));											break;										}										divertIt = false;										if (theEvent.modifiers & optionKey)											divertIt = true;										if (checkReference ((lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments))										{											ery = OpenSelection((*therealResults)[(lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments]);											if (volumeMounted)											{												//RefreshMem();											}										}															}									if (lCellCoords.h == 1 && DisplayComments)									{										switch (DispMode)										{											case 0:												zeditComment((*therealResults)[(lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments], (lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments);											break;											case 5:												editCategory();											break;											default:												if (checkReference ((lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments))												{													ery = OpenSelection((*therealResults)[(lCellCoords.v*DisplayedColumns)+lCellCoords.h*!DisplayComments]);												}											break;										}									}								}							}						break;																							case inDrag:							SSinBG = false;							if (whichWindow == (GrafPtr)myWindow)							DragWindow((GrafPtr)myWindow, theEvent.where, &dragRect);							//InvalRect(&(myWindow->portRect));							presTop = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.top + 19;							presLeft = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.left + 1;							prestempor = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.right;							presvertsize = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.bottom-57;							theNewPrefs.windowLocation = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox;						break;																case inGoAway:							SSinBG = false;							if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])												SaveAsTabFave(theNewPrefs.whichTab);							done = TRUE;							break;												case inZoomIn:						case inZoomOut:							SSinBG = false;							if (whichWindow == (GrafPtr)myWindow)							{								if(TrackBox((GrafPtr)myWindow,theEvent.where,thePart)) 								{									Rect teRects;																		GetPort (&oldPort);									SetPort (whichWindow);																		EraseRect(&whichWindow->portRect);									ZoomWindow((GrafPtr)myWindow,thePart,false);										EraseRect(&whichWindow->portRect);									//EraseRect(&whichWindow->portRect);																/***/																	SetRect (&teRects, 0, 80,myWindow->portRect.right - 15,myWindow->portRect.bottom - 15 - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) - ((theNewPrefs.SDIIToolBar) ?  theNewPrefs.toolsHeight : 0));									LSize(teRects.right-teRects.left,teRects.bottom-teRects.top,myList);																	regionSelected = waveFormSelected = false;									theCurrentSDIIRegion = -99;																		SetRect(&myOverViewButtonRect,(*myList)->rView.right - 15,(*myList)->rView.bottom - 15 ,(*myList)->rView.right,(*myList)->rView.bottom );									SetRect(&myButtonsRect,(*myWindow).portRect.right-325,5,(*myWindow).portRect.right-5,33);									SetRect(&myTabsRect,(*myWindow).portRect.left,59,(*myWindow).portRect.right,80);									SetRect(&commentRect,(*myWindow).portRect.left + 1,0,(*myWindow).portRect.right-325,50);									/* resize bounds */									SetRect (&sizeRect, 415, 145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0),qd.screenBits.bounds.right - qd.screenBits.bounds.left,qd.screenBits.bounds.bottom - qd.screenBits.bounds.top);									SetRect(&myWaveToolsRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,(*myWindow).portRect.right,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);									SetRect(&regionsPopUpRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);									SetRect(&zRect,myWindow->portRect.left,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight + 1,myWindow->portRect.right,myWindow->portRect.bottom);									waveFormSelected = false;									selectRect.top = zRect.top + 1;									selectRect.bottom = zRect.bottom;												numberOfColumns = (teRects.right-teRects.left)/150;									if (numberOfColumns == 0)									{										numberOfColumns = 1;									}									if (squashColumns == 1)									{										numberOfColumns = DisplayedColumns + DisplayComments;									}									if (numberOfColumns == 0)										numberOfColumns = 4;									cSize.h = ((teRects.right-teRects.left)-15)/numberOfColumns;																																			GetFNum(theFontRec.fontName,&fontNum);									TextFont (fontNum);									TextSize (theFontRec.fontSize);									zGetFontInfo(&fontInfo);															ListFontHite = fontInfo.leading + fontInfo.ascent + fontInfo.descent;									if (!ListFontHite)									{										genError("\pList font hite problem");										ListFontHite = 12;									}									cSize.v = ListFontHite; 					/** for chicago 12 pt **/									LCellSize (cSize,myList);																		InvalRect(&myWindow->portRect);									DrawGrowIcon((GrafPtr)myWindow);																presTop = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.top + 19;									presLeft = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.left + 1;									prestempor = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.right;									presvertsize = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.bottom -57;																		/***/									SetPort(oldPort);									//TextFont (0);									//TextSize (12);									theNewPrefs.windowLocation = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox;								}							}							break;													case inGrow:							SSinBG = false;							windSize = GrowWindow (whichWindow,theEvent.where,&sizeRect);							if (windSize)							{								GetPort (&oldPort);																presFont =  oldPort->txFont;								presSize = oldPort->txSize;								SetPort (whichWindow);																color.red = 0xFFFF;								color.blue = 0xFFFF;								color.green = 0xFFFF;								RGBBackColor(&color);																EraseRect(&whichWindow->portRect);								SizeWindow(whichWindow,LoWord(windSize),HiWord(windSize),true);								LSize(LoWord(windSize)-15,HiWord(windSize)-65-30 - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) - ((theNewPrefs.SDIIToolBar) ?  theNewPrefs.toolsHeight :  0),myList);								regionSelected = waveFormSelected = false;								theCurrentSDIIRegion = -99;															//	presvertsize = LoWord(windSize);							//	prestempor = HiWord(windSize);												SetRect(&myOverViewButtonRect,(*myList)->rView.right - 15,(*myList)->rView.bottom - 15 ,(*myList)->rView.right,(*myList)->rView.bottom );								SetRect(&myButtonsRect,(*myWindow).portRect.right-325,5,(*myWindow).portRect.right-5,33);								SetRect(&myTabsRect,(*myWindow).portRect.left,59,(*myWindow).portRect.right,80);								SetRect(&commentRect,(*myWindow).portRect.left + 1,0,(*myWindow).portRect.right-325,50);								/* resize bounds */								SetRect (&sizeRect, 415, 145 + ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0),qd.screenBits.bounds.right - qd.screenBits.bounds.left,qd.screenBits.bounds.bottom - qd.screenBits.bounds.top);								SetRect(&myWaveToolsRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,(*myWindow).portRect.right,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);								SetRect(&regionsPopUpRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 2,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 2);								SetRect(&zRect,myWindow->portRect.left,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight + 1,myWindow->portRect.right,myWindow->portRect.bottom);								waveFormSelected = false;								selectRect.top = zRect.top + 1;								selectRect.bottom = zRect.bottom;										numberOfColumns = LoWord(windSize)/150;								if (numberOfColumns == 0)								{									numberOfColumns = 1;								}								if (squashColumns == 1)									{									numberOfColumns = DisplayedColumns + DisplayComments;									}									if (numberOfColumns == 0)										numberOfColumns = 4;								cSize.h = (LoWord(windSize)-15)/numberOfColumns;																															GetFNum(theFontRec.fontName,&fontNum);								TextFont (fontNum);								TextSize (theFontRec.fontSize);								//FontMetrics(&theInfo);								zGetFontInfo(&fontInfo);														ListFontHite = fontInfo.leading + fontInfo.ascent + fontInfo.descent;								if (!ListFontHite)								{									genError("\pList font hite problem");									ListFontHite = 12;								}								cSize.v = ListFontHite; 					/** for chicago 12 pt **/								LCellSize (cSize,myList);																InvalRect(&myWindow->portRect);								DrawGrowIcon((GrafPtr)myWindow);														presTop = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.top + 19;								presLeft = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.left + 1;								prestempor = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.right;								presvertsize = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox.bottom -57;																SetPort(oldPort);																theNewPrefs.windowLocation = (**((*(WindowPeek)myWindow).strucRgn)).rgnBBox;							}						default:						break;				}				break;											case updateEvt:					if ((WindowPtr) theEvent.message == (GrafPtr)myWindow) 					{						GrafPtr savePort;												GetPort (&savePort);												presFont =  savePort->txFont;						presSize = savePort->txSize;						SetPort(myWindow);						BeginUpdate ((WindowPtr) theEvent.message);						color.red = 0xFFFF;						color.blue = 0xFFFF;						color.green = 0xFFFF;						RGBBackColor(&color);						DrawGrowIcon ((WindowPtr) myWindow);												GetFNum(theFontRec.fontName,&fontNum);						TextFont(fontNum);						/** font for list - chicago **/						TextSize(theFontRec.fontSize);												color.red = 0;						color.blue = 0;						color.green = 0;						RGBForeColor(&color);						LUpdate((*myList)->port->visRgn,myList);												DrawGrowIcon((GrafPtr)myWindow);							windowUpdate();							showCommentinWin(kFirstSelected,nullCell);							DrawControls(myWindow);									EndUpdate ((WindowPtr) theEvent.message);						SetPort (savePort);					}				break;			}		}	}	//HUnlock((Handle) myList);	regionSelected = waveFormSelected = false;		//TextFont (0);	//TextSize (12);		if (goingToFind)	{		loseTheWindow = true;		goingToFind = false;	}	else	{		/* remember the selection */		Cell theCell = {0,0};		if(LGetSelect(true,&theCell,myList)) 		{			rememberSelection = true;			rememberCell = theCell;		}		else		{			rememberSelection = false;			rememberCell = theCell;		}		LDispose(myList);		listOpen = false;		myList = 0;		if (dragAvailable)		{			RemoveTrackingHandler(xMyTrackingHandler, myWindow);			RemoveReceiveHandler(xMyReceiveDropHandler, myWindow);		}		DisposeWindow((WindowPtr)myWindow);		loseTheWindow = false;	}	SetPort (savePort);}void windowUpdate(void){	RGBColor	myColor;	Rect	buttonblackRect;	short fontNum;	GrafPtr savePort;		GetPort(&savePort);	presSize = savePort->txSize;	presFont =  savePort->txFont;			SetPort (myWindow);		myColor.red = theGreyColor;	myColor.green = theGreyColor;	myColor.blue = theGreyColor;	RGBForeColor(&myColor);		buttonblackRect.left = (*myWindow).portRect.left;	buttonblackRect.right = (*myWindow).portRect.right;	buttonblackRect.top = 0;	buttonblackRect.bottom = 80;	if (theGreyColor != 65535)		FillRect(&buttonblackRect,&qd.black);	else		EraseRect(&buttonblackRect);			myColor.red = 0x0000;	myColor.green = 0x0000;	myColor.blue = 0x0000;	RGBForeColor(&myColor);			MoveTo((*myWindow).portRect.left,79);	LineTo((*myWindow).portRect.right,79);			TextFont(21);	TextSize(9);		myColor.red = 0xFFFF;	myColor.green = 0xFFFF;	myColor.blue = 0xFFFF;	RGBForeColor(&myColor);		MoveTo((*myWindow).portRect.left+6, 13);	DrawString("\pFiletype:");	MoveTo((*myWindow).portRect.left+6, 25);	DrawString("\pWhere:");	MoveTo((*myWindow).portRect.left+6, 37);	DrawString("\pFileSize:");	MoveTo((*myWindow).portRect.left+6, 49);	DrawString("\pComment:");			myColor.red = 0;	myColor.green = 0;	myColor.blue = 0;	RGBForeColor(&myColor);		MoveTo((*myWindow).portRect.left+5, 12);	DrawString("\pFiletype:");	MoveTo((*myWindow).portRect.left+5, 24);	DrawString("\pWhere:");	MoveTo((*myWindow).portRect.left+5, 36);	DrawString("\pFileSize:");	MoveTo((*myWindow).portRect.left+5, 48);	DrawString("\pComment:");						//DrawControls(myWindow);	//SysBeep(5);	drawColourIconII((*myWindow).portRect.right-325,5,5000);	drawColourIconII((*myWindow).portRect.right-261,5,5001);	drawColourIconII((*myWindow).portRect.right-197,5,5002);	drawColourIconII((*myWindow).portRect.right-133,5,5003);	drawColourIconII((*myWindow).portRect.right-69,5,5004);	/** update list **/		drawTabs(55,0);		/*if divert app, draw app icon below LNCH  button */	if (divertSamples)	{			FInfo fndrInfo;		Handle iconSuite;				if (divertSpec.vRefNum < 0)		{			OSErr iErr = FSpGetFInfo(&divertSpec,&fndrInfo);			if (!iErr)			{				if (_GetIconSuiteForTypeCreator(fndrInfo.fdCreator,fndrInfo.fdType, divertSpec.vRefNum, &iconSuite))				{					Rect iconRect;					SetRect (&iconRect,(*myWindow).portRect.right-108,34 ,(*myWindow).portRect.right-92,50);					PlotIconSuite(&iconRect,atNone,ttNone,iconSuite);				}			}		}	}	SetPort(savePort);		return;}void controlsCreate(void);void controlsCreate(void){		short xadvance = 60;	short xgap = 5;	short xstart = (*myWindow).portRect.left+5;	short ytop =  (*myWindow).portRect.top+32;	short ybot = (*myWindow).portRect.top + 47;	Rect	customButtonRect;	short fontNum;			return;	GetFNum(theFontRec.fontName,&fontNum);	TextFont(fontNum);						/** font for list - chicago **/	TextSize(theFontRec.fontSize);	customButtonRect.left = xstart;	customButtonRect.right = xstart + xadvance;	customButtonRect.top = ytop;	customButtonRect.bottom = ybot;	myCustomButton[0] = NewControl(myWindow,&customButtonRect,"\pFIND",true,0,0,255,0,0);		customButtonRect.left = xstart + xadvance + xgap;	customButtonRect.right = xstart + (2*xadvance) + xgap;	customButtonRect.top = ytop;	customButtonRect.bottom = ybot;	myCustomButton[1] = NewControl(myWindow,&customButtonRect,"\pFILTER",true,0,0,255,0,1);	customButtonRect.left = xstart + (2*xadvance) + (2*xgap);	customButtonRect.right = xstart + (3*xadvance) + (2*xgap);	customButtonRect.top = ytop;	customButtonRect.bottom = ybot;	myCustomButton[2] = NewControl(myWindow,&customButtonRect,"\pPLAY",true,0,0,255,0,2);	customButtonRect.left = xstart + (3*xadvance) + (3*xgap);	customButtonRect.right = xstart + (4*xadvance) + (3*xgap);	customButtonRect.top = ytop;	customButtonRect.bottom = ybot;	myCustomButton[3] = NewControl(myWindow,&customButtonRect,"\pLAUNCH",true,0,0,255,0,3);	customButtonRect.left = xstart + (4*xadvance) + (4*xgap);	customButtonRect.right = xstart + (5*xadvance) + (4*xgap);	customButtonRect.top = ytop;	customButtonRect.bottom = ybot;	myCustomButton[4] = NewControl(myWindow,&customButtonRect,"\pSHOW",true,0,0,255,0,4);}void showCommentinWin(short mode, Cell myCell){	FInfo fndrInfo;	OSErr	iErr;	short refNum;	long inOutCount,iLErr;	Str255	theComment,theTempComment;	Handle hRsrc;	RGBColor myColor;	short SCFormat;	long SCinpos, AIFFpos, theFileSize;	Cell theCell;	short index, iCnt;	Rect wipeRect;	Str255 theFileType, theFileSizeStr,theWhichDrive;	RgnHandle	oldClipRgnH, newClipRgnH;	short oldRefNum,fontNum;	GrafPtr savePort;			nextRegionToHilite = 0;	GetPort(&savePort);		presSize = myWindow->txSize;	presFont =  myWindow->txFont;		SetPort(myWindow);	TextSize(9);		oldClipRgnH = NewRgn();	newClipRgnH = NewRgn();		*theComment = 0;		SetPt( &theCell, 0,0 );		/* start at top of list  */	if (( LGetSelect( TRUE, &theCell, myList) || mode == kUseCellParam) && !dontQuery) 	{		if (mode == kUseCellParam)		{			theCell = myCell;		}		index = (theCell.v*DisplayedColumns)+theCell.h*!DisplayComments;				if (!FInfolistInMem && !folderSearch)		{						if (-((*therealResults)[index].vRefNum) <= maxVRef && isItOnLine((*therealResults)[index].vRefNum))			{				iErr = FSpGetFInfo(&((*therealResults)[index]),&fndrInfo);				if (iErr !=0)				{					//SysBeep(5);					//genError ("\pCan't get FInfo");					DisposeRgn(oldClipRgnH);					DisposeRgn(newClipRgnH);					SetPort(savePort);					return;				} 			}			else			{				BlockMove (&((*theFInfo)[index]),&fndrInfo,16L);			}		}		else		{			if (!folderSearch)			{				BlockMove (&((*theFInfo)[index]),&fndrInfo,16L);			}			else			{				fndrInfo.fdType = 'FOLD';				fndrInfo.fdCreator = '    ';			}		}				if (!folderSearch && -(((*therealResults)[index]).vRefNum) <= maxVRef && isItOnLine((*therealResults)[index].vRefNum))		{			switch(fndrInfo.fdType)			{ /* 13 */			case 'SFIL':				iErr = FSpOpenDF(&((*therealResults)[index]),fsCurPerm,&refNum);				if (iErr!=0)				{					makeStr255("\pFile is Open",theComment);					//genError("\pCouldn't open data fork");				}				if( !iErr)				{ /* 9 */					iErr = SetFPos(refNum,1,764L);					if (iErr!=0)					{						makeStr255("\pCan't read file",theComment);						//genError("\pCouldn't move file pointer");					}					inOutCount = 255L;					iErr = FSRead(refNum,&inOutCount,theComment);					if (iErr!=0)					{						makeStr255("\pCan't read file",theComment);						//genError("\pCouldn't read from file pointer");					}					FSClose(refNum);				} /* 9 */				else				{						*theComment = 0;				}			break;						case 'Sd2f':				oldRefNum= CurResFile();				refNum = FSpOpenResFile(&((*therealResults)[index]),fsCurPerm);				if (refNum > 0)				{ 					hRsrc = Get1Resource('sdDD',1000);					iErr = ResError();					if(hRsrc)					{												BlockMove((*hRsrc)+10,theComment,256L);						//HUnlock(hRsrc);						ReleaseResource(hRsrc);					}					CloseResFile(refNum);									}				else				{						*theComment = 0;  						}				UseResFile(oldRefNum);			break;						case 'SCin': case 'MixD': case 'SCsi' : case 'SCsd' : case 'SCss':				SCFormat = identifySCII(((*therealResults)[index]));			 	if (SCFormat !=2)			 	{			 		*theComment = 0;			 		break;			 	}				iErr = FSpOpenDF(&((*therealResults)[index]),fsCurPerm,&refNum);				if (iErr!=0)				{					//SysBeep(5);					makeStr255("\pFile is Open",theComment);					//genError("\pCouldn't open data fork");				}				if( !iErr)				{ /* 9 */					SCinpos =  findANNO(refNum);					if (SCinpos)					{						iErr = SetFPos(refNum,1,SCinpos+4L);						if (iErr!=0)						{							makeStr255("\pCan't read file",theComment);							//genError("\pCouldn't move file pointer");						}													inOutCount = 4L;						iErr = FSRead(refNum,&inOutCount,&SCinpos);						if (iErr!=0)						{							makeStr255("\pCan't read file",theComment);							//genError("\pCouldn't read from file pointer");							//SysBeep(5);						}						inOutCount = SCinpos;						if (SCinpos)						{							iErr = FSRead(refNum,&inOutCount,theComment);							if (iErr!=0)							{								makeStr255("\pCan't read file",theComment);								//SysBeep(5);								//genError("\pCouldn't read from file pointer");							}						}					}					FSClose(refNum);				} /* 9 */			break;						case 'AIFF':				if (fndrInfo.fdCreator == 'CARI')				{					if (!GetFSSpecComment(((*therealResults)[index]), (StringPtr)theComment))					*theComment = 0;				}				else				{					iErr = FSpOpenDF(&((*therealResults)[index]),fsCurPerm,&refNum);					if (iErr!=0)					{							makeStr255("\pFile is Open",theComment);						//genError("\pCouldn't open data fork");					}					if( !iErr)					{ /* 9 */						iLErr =  findAPPL(refNum);						if (iLErr)						{							AIFFpos = theAPPLReply;							iErr = SetFPos(refNum,1,AIFFpos+22L);							if (iErr!=0)							{								makeStr255("\pCan't read file",theComment);								//genError("\pCouldn't move file pointer");							}															inOutCount = 255L;							iErr = FSRead(refNum,&inOutCount,theComment);							if (iErr!=0 && iErr !=-39)							{								makeStr255("\pCan't read file",theComment);								//genErrorN("\pCouldn't read from file pointer", iErr);							}						}						FSClose(refNum);					} /* 9 */				}			break;						default:								if (!GetFSSpecComment(((*therealResults)[index]), (StringPtr)theComment))					*theComment = 0;			break;			}		}		else		{			if (-(((*therealResults)[index]).vRefNum) <= maxVRef)			{				if (!GetFSSpecComment(((*therealResults)[index]), (StringPtr)theComment))					*theComment = 0;			}			else			{				if (!VgetvolName((*therealResults)[index].vRefNum, theTempComment))				{					*theTempComment = 0;				}			/*	BlockMove(fvolName[-((*therealResults)[index].vRefNum)],theTempComment,28L);*/				makeStr255("\pGhost Item",theComment);				concatStrings(theComment,theTempComment,"\p on ");			}		}						if (!folderSearch && -(((*therealResults)[index]).vRefNum)<=maxVRef)		{			theFileSize = obtainSize(index);		}		else		{			theFileSize = 0;		}		SetPort (myWindow);		wipeRect.left = (*myWindow).portRect.left + 55;		wipeRect.right = (*myWindow).portRect.right-330;		wipeRect.top = 0;		wipeRect.bottom = 41;		/*EraseRect(&wipeRect);*/				myColor.red = theGreyColor;		myColor.green = theGreyColor;		myColor.blue = theGreyColor;		RGBForeColor(&myColor);				if (theGreyColor != 65535)			FillRect(&wipeRect,&qd.black);		else			EraseRect(&wipeRect);					myColor.red = 0x0000;		myColor.green = 0x0000;		myColor.blue = 0x0000;		RGBForeColor(&myColor);								MoveTo((*myWindow).portRect.left + 55,24);		TextFont(geneva);		GetClip(oldClipRgnH);			nameFromVRefNum((*therealResults)[index].vRefNum,theWhichDrive);				RectRgn(newClipRgnH,&wipeRect);		SetClip(newClipRgnH);		DrawString(theWhichDrive);		SetClip(oldClipRgnH);								*theFileType = 4;		if (!translateFileType (fndrInfo.fdType, (StringPtr)theFileType))		{			BlockMove (&(fndrInfo.fdType),theFileType + 1,4L);		}		MoveTo((*myWindow).portRect.left + 55,12);		wipeRect.left = (*myWindow).portRect.left + 55;		wipeRect.right = (*myWindow).portRect.right-330;		wipeRect.top = 0;		wipeRect.bottom = 41;		GetClip(oldClipRgnH);		RectRgn(newClipRgnH,&wipeRect);		SetClip(newClipRgnH);		DrawString(theFileType);		SetClip(oldClipRgnH);						MoveTo((*myWindow).portRect.left + 55,36);		theFileSize /= 1000;		NumToString(theFileSize,theFileSizeStr);		*theFileSizeStr += 1;		*(theFileSizeStr + *theFileSizeStr) = 'k';		DrawString(theFileSizeStr);						myColor.red = theGreyColor;		myColor.green = theGreyColor;		myColor.blue = theGreyColor;		RGBBackColor(&myColor);										wipeRect.left = (*myWindow).portRect.left + 55;		wipeRect.right = (*myWindow).portRect.right-110;		wipeRect.top = 37;		wipeRect.bottom = 53;		/*MoveTo((*myWindow).portRect.left + 55,48);*/		/*RectRgn(newClipRgnH,&wipeRect);		SetClip(newClipRgnH);*/		/*DrawString(theComment);*/		/*SetClip(oldClipRgnH);*/		TextBox(theComment+1,*theComment,&wipeRect,0);		myColor.red = 0xFFFF;		myColor.green = 0xFFFF;		myColor.blue = 0xFFFF;		RGBBackColor(&myColor);					//	TextFont (0);		//TextSize (12);		switch (fndrInfo.fdType)		{			case 'Sd2f': case 'AIFF':case 'MPEG':case '.MPG':case 'MPG ':case 'PLAY':case 'MP3 ':case '.MP3':case '.mp3':case 'Mp3 ':			{				RGBColor myColor;								drawOverViewInWindow((*therealResults)[index]);								if (waveFormSelected)				{					InvertRect(&selectRect);														myColor.red = (regionSelected) ? 0x0000 : 0xFFFF;					myColor.green = (regionSelected) ? 0xFFFF : 0x0000;					myColor.blue = 0;					RGBForeColor(&myColor);					FrameRect(&selectRect);										myColor.red = 0;					myColor.green = 0;					myColor.blue = 0;					RGBForeColor(&myColor);							zDrawGrowIcon (myWindow);				}								drawSDIIToolBar((*therealResults)[index]);			}			}	}	else  /* nothing selected */	{		makeStr255 ("\p ",theComment);		wipeRect.left = (*myWindow).portRect.left + 55;		wipeRect.right = (*myWindow).portRect.right-330;		wipeRect.top = 0;		wipeRect.bottom = 41;		/*EraseRect(&wipeRect);*/		myColor.red = theGreyColor;		myColor.green = theGreyColor;		myColor.blue = theGreyColor;		SetPort (myWindow);		RGBForeColor(&myColor);		if (theGreyColor != 65535)			FillRect(&wipeRect,&qd.black);		else			EraseRect(&wipeRect);		myColor.red = 0x0000;		myColor.green = 0x0000;		myColor.blue = 0x0000;		RGBForeColor(&myColor);		MoveTo((*myWindow).portRect.left + 55,24);		TextFont(21);		GetClip(oldClipRgnH);		RectRgn(newClipRgnH,&wipeRect);		SetClip(newClipRgnH);		DrawString(theComment);		SetClip(oldClipRgnH);		makeStr255("\p    ",theFileType);		*theFileType = 4;		MoveTo((*myWindow).portRect.left + 55,12);		DrawString(theFileType);		MoveTo((*myWindow).portRect.left + 55,36);		theFileSize = 0;		theFileSize /= 1000;				/*NumToString(theFileSize,theFileSizeStr);		*theFileSizeStr += 1;		*(theFileSizeStr + *theFileSizeStr) = 'k';		DrawString(theFileSizeStr);*/			//	TextFont (0);		//TextSize (12);			clearOverViewInWindow();		clearRegionTools();	}	DisposeRgn(oldClipRgnH);	DisposeRgn(newClipRgnH);			SetPort(savePort);	return; }long  obtainSize(short theIndex){	long theResSize = 0L;	long theDataSize = 0L;	long theModDate = 0;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	OSErr	iErr;	Str255 zfilename;	long	dirID,myDrDir;	short Fcounter = 0;	FInfo  fndrInfo;		iErr = FSpGetFInfo(&((*therealResults)[theIndex]),&fndrInfo);	if (iErr !=0)	{		return 0;	} 	switch (fndrInfo.fdType)	{		case 'SCin': case 'SCsi': case 'SCss': case 'SCsd':			return getSampleCellInstSize ((*therealResults)[theIndex]);		break;				default:			BlockMove((*therealResults)[theIndex].name,zfilename,64L);			fpb->ioVRefNum = (*therealResults)[theIndex].vRefNum;		/* default volume */			fpb->ioNamePtr = zfilename;	/* buffer to receive name */			fpb->ioFDirIndex = 0; 			fpb->ioDirID = (*therealResults)[theIndex].parID;						rc = PBGetCatInfo( &cipbr, FALSE );				if (rc) 					return;					if (!(fpb->ioFlAttrib & 16)) 			{				theDataSize = fpb->ioFlLgLen;				theResSize = fpb->ioFlRLgLen;				theModDate = fpb->ioFlMdDat;			}			return (theResSize + theDataSize);		break;	}}void makelCellCoords(void){	SetPt( &lCellCoords, 0,0 );		/* start at top of list  */	LGetSelect( TRUE, &lCellCoords, myList);}void deSelectAll(void){ short z,xpos,ypos; Cell theCell;  for (z=0;z<totfindcounter;z++) { 	ypos = z / (((DisplayedColumns==4)*4)+(DisplayedColumns == 1)); 	if (DisplayedColumns== 4) 		xpos = z - (ypos * 4); 	else 		xpos = 0; 	SetPt(&theCell,xpos,ypos); 	LSetSelect(false,theCell,myList); } return;}short lastHilite = -1;short DragFile(EventRecord *theEvent,Cell theCell,FSSpec theSpecWeWant);pascal Boolean myNormClikLoop(void){	return true;}pascal Boolean myDragLClikLoop(void){	//. . . do whatever you like;  the list's window is active and frontmost  . .	//. . . the mouse is at (*theList)->mouseLoc  (in local coordinates). . .	//. . . use LRect and PtInRect to help find which cell is at that location		short z,xpos,ypos;	 Cell theCell; 	Rect cellRect; 	Point myGlobLoc; 	RgnHandle theRgn; 	long lDistVH; 	Point theMouse; 	Point mlocalPt;	Rect wineRect;	Boolean shifter;	wineRect = (*myWindow).portRect;		wineRect.top+=80;			shifter = (isPressed(0x0038) || isPressed(0x003C) );		GetMouse(&theMouse);		lDistVH = DeltaPoint(startClickPoint,theMouse);	//if ((TickCount() - startTick > 10 )  && !shifter)	if(StillDown() && lDistVH && !shifter) /* dont do this if this cell isnt already selected - it should be deselecting */	{ 		GetMouse(&theMouse);	 			 for (z=0;z<totfindcounter;z++)		 {		 	ypos = z >> ((DisplayedColumns==4) ? 2 : 1);		 			 	if (DisplayedColumns== 4)		 		xpos = z - (ypos * 4);		 	else		 		xpos = 0;		 						theCell.h = xpos;								theCell.v = ypos;							 	LRect(&cellRect,theCell,myList);			 	if(PtInRect(theMouse,&cellRect)) 			 	{					if(!LGetSelect(false,&theCell,myList)) 					{			 			deSelectAll();					}			 		LSetSelect(true,theCell,myList);			 		break;			 	}		 }				/*theRgn = NewRgn();	*/			myGlobLoc = theGlobalEvent.where;		LocalToGlobal(&myGlobLoc);							GetMouse(&mlocalPt);		LocalToGlobal(&mlocalPt);								if ((abs(mlocalPt.h -theGlobalEvent.where.h) > 0 )|| (abs(mlocalPt.v - theGlobalEvent.where.v) > 0))		{			FSSpec testSpec;			OSErr iErr;			LocalToGlobal(&theGlobalEvent.where);				//		if (-((*therealResults)[(theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1))].vRefNum) <= volumearrayptr)	//		{			iErr = FSMakeFSSpec((*therealResults)[(theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1))].vRefNum,(*therealResults)[(theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1))].parID,(*therealResults)[(theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1))].name,&testSpec);			if (!iErr)			{					DragFile(&theGlobalEvent,theCell,(*therealResults)[(theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1))]);			}		}	}	/*	DisposeRgn(theRgn);*/	return (TRUE);			/* return FALSE to abort LClick */}pascal Boolean myLClikLoop(void){	//. . . do whatever you like;  the list's window is active and frontmost  . .	//. . . the mouse is at (*theList)->mouseLoc  (in local coordinates). . .	//. . . use LRect and PtInRect to help find which cell is at that location		short z,xpos,ypos;	 Cell theCell; 	Rect cellRect; 	RgnHandle theRgn; 	long lDistVH; 	Point theMouse;	Rect wineRect;	wineRect = (*myWindow).portRect;		wineRect.top+=80;	 	GetMouse(&theMouse);	 		 for (z=0;z<totfindcounter;z++)	 {	 	ypos = z >> ((DisplayedColumns==4) ? 2 : 1);	 		 	if (DisplayedColumns== 4)	 		xpos = z - (ypos * 4);	 	else	 		xpos = 0;	 					theCell.h = xpos;						theCell.v = ypos;					 	LRect(&cellRect,theCell,myList);		 	if(PtInRect(theMouse,&cellRect)) 		 	{		 		deSelectAll();		 		LSetSelect(true,theCell,myList);		 		break;		 	}	 }		theRgn = NewRgn();	if(StillDown()) 	{		RectRgn(theRgn,&cellRect);		while (Button())		{			lDistVH = DragGrayRgn(theRgn,theMouse,&wineRect,&wineRect,0,xmyDragLoop);		}		if (lastHilite >= 0)		{			AddToFaveTab((*therealResults)[(theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1))], (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1)),lastHilite);			hiliteCell(lastHilite, false,55,0);			lastHilite = -1;		}	}	DisposeRgn(theRgn);	return (TRUE);			/* return FALSE to abort LClick */}pascal void myDragLoop(void){	Point localPt;	short cellSel;					GetMouse(&localPt);	cellSel = mouseInside (localPt, 55, 0);	if (cellSel == -1)	{		if (lastHilite >= 0)		{			hiliteCell(lastHilite, false,55,0);			lastHilite = -1;		}	}	else	{		if (lastHilite != cellSel)		{			if (lastHilite >= 0)			{				hiliteCell(lastHilite, false,55,0);				lastHilite = -1;			}			hiliteCell(cellSel, true,55,0);			lastHilite = cellSel;		}	}	return;}pascal void MyZItemProc(WindowPtr theDlg,short theItem);	/** draws the line round the default dialog item **/void saveNewPrefs (void);OSErr renameTab(short tabNum){	OSErr		iErr = 0;					FSSpec	mySpec;	FInfo	fndrInfo;	short z;	short temprefNum;	Str255 newName;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	myDlg = GetNewDialog(9000,0L,(WindowPtr)-1);		SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetDItem(myDlg,6,iType,(Handle)NewUserItemProc(MyZItemProc),&iRect);	GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetIText(iHndl,theNewPrefs.tabName[tabNum]);	SelIText(myDlg,7,0,32767);			GetDItem(myDlg,8,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,theNewPrefs.tabLocked[tabNum]);		ShowWindow(myDlg);	itemHit = 0;		while (itemHit != 1 && itemHit != 2)	{		ModalDialog(xAlertFilter,&itemHit);		switch (itemHit)		{			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));			break;		}	}		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	GetIText(iHndl,newName);		if (itemHit == 1 && *newName > 0 && *newName < 32)	{		BlockMove(newName,theNewPrefs.tabName[tabNum],*newName +1);		GetDItem(myDlg,8,&iType,&iHndl,&iRect);		theNewPrefs.tabLocked[tabNum] = GetCtlValue((ControlHandle)iHndl);	}		DisposDialog(myDlg);	saveNewPrefs();	return iErr;}OSErr nameFromVRefNum (short whichVol, StringPtr volName){	/* Return the name and vRefNum of volume specified by whichVol */	HVolumeParam	volPB;	OSErr	error;	volPB.ioNamePtr = volName;	/* make sure it returns the name */	volPB.ioVRefNum = whichVol;	/* 0 means use ioVolIndex */	volPB.ioVolIndex = 0;	error = PBHGetVInfo((union HParamBlockRec *)&volPB,false);	/* do it */	if(error != noErr)		*volName = 0;		return (error);}OSErr renameTabAuto(short tabNum, Str31 theName);OSErr renameTabAuto(short tabNum, Str31 theName){	if(EqualString("\pSFTempUndoFile",theName,true,true)) 	{	}	else	{		BlockMove(theName,theNewPrefs.tabName[tabNum],*theName +1);		saveNewPrefs();		setUpTabs();		drawTabs(55,0);		}	}void selectTab(short tt);void selectTab(short tt){	short qq;	Handle sndHdl;		/*sndHdl = GetResource('snd ',128);	iErr = SndPlay(0,sndHdl,false);*/		for (qq=0;qq<=lastItem;qq++)	{		tabSelected[qq] = false;		}	tabSelected[tt] = true;		calcDrawingArray();		/*MoveTo((*myWindow).portRect.left,79);		LineTo((*myWindow).portRect.right,79);*/	drawTabs(55,0);		watchcursor(true);	if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])		SaveAsTabFave(theNewPrefs.whichTab);	LoadTabFaves(tt);	watchcursor(false);		theNewPrefs.whichTab = tt;		}Boolean hiliteCell(short cellNumber, Boolean hilite,short top,short left);short mouseInside (Point thePoint, short top, short left);void myGrayDragProc (void){	Point theMouse;	short cellSel;	RGBColor theColor;		GetMouse(&theMouse);		cellSel = mouseInside (theMouse, 55, 0); 	if (cellSel == -1)	{		if (zlastHilite >= 0)		{			hiliteCell(zlastHilite, false,55,0);			zlastHilite = -1;		}	}	else	{		if (zlastHilite != cellSel)		{			if (zlastHilite >= 0)			{				hiliteCell(zlastHilite, false,55,0);				zlastHilite = -1;			}			hiliteCell(cellSel, true,55,0);			zlastHilite = cellSel;		}	}		if(PtInRect(theMouse,&zcommentRect)) 	{		if (!windowHiliteDrawn)		{			theColor.red = 52224;			theColor.green = 52224;			theColor.blue = 65280;			RGBForeColor(&theColor);					FrameRect(&zcommentRect);						theColor.red = 0;			theColor.green = 0;			theColor.blue = 0;			RGBForeColor(&theColor);			windowHiliteDrawn = true;		}	}	else	{		if (windowHiliteDrawn)		{			theColor.red = 0xFFFF;			theColor.green = 0xFFFF;			theColor.blue = 0xFFFF;			RGBForeColor(&theColor);					FrameRect(&zcommentRect);						theColor.red = 0;			theColor.green = 0;			theColor.blue = 0;			RGBForeColor(&theColor);			windowHiliteDrawn = false;		}		}}