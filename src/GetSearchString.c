#include "SampleSearch.h"#include "Globals.h"#include "MovableModal.h"#include<stdio.h>#include <Files.h>#include <Palettes.h>extern FSSpec theApplSpec;void cleanUpRes(void);#include <OSUtils.h>#include "undoStuff.h"#include <Packages.h>Boolean commentSearch;Str255 commentSearchStr;Str255 theLastNameSearched = "\p";Boolean optionDownWhenMouseDown;void doCommentSearch(void);Boolean getFiltstring(Boolean reFind);Boolean ExactMatch;void showCommentinWin(short mode, Cell theCell);extern Cell rememberCell;extern Boolean	rememberSelection;void getGhostsDirSpecInsideGhosts(Str255 folderName);extern WindowPtr	myWindow;void windowUpdate(void);OSErr refillGhostsArrayFromMasterNoFolders(void);extern Boolean dragAvailable;OSErr fillGhostsArrayFromDir(void);typedef struct listFontRec {Str255 fontName;short fontSize;} listFontRec, *listFontRecPtr;extern Boolean listOpen;OSErr removeCharFromStartOfName (StringPtr string);extern listFontRec  theFontRec;extern short presSize,presFont;extern Boolean loseTheWindow;pascal Boolean FindFilter (DialogPtr theDialog, EventRecord *theEvent, short *itemHit);extern long GhostsDirID;void getGhostsDirSpec(void);extern Boolean ExcludeDrives;OSErr GetIndVolume (short whichVol, char *volName, short *volRefNum);Boolean ExcludeFilter;void RemoveVBL(void);OSType creatorFindDialog(void);Boolean scanList(Str255	theDrive);Boolean mySearchBodge;void getMenuDefaults(short * myMenus);void setMenuDefaults(short * myMenus);void RetrievePrefs(void);extern OSType creatorSearchType;extern Boolean creatorSearch;Boolean DoublesFilter;extern Boolean SkipList;pascal void MyNewItemProc(WindowPtr theDlg,short theItem);OSType	searchType;extern Boolean PreservePopups;Boolean searchBefore, searchAfter;unsigned long beforeDate, afterDate;unsigned long dateStringToDate(Str255 theDateStr,Boolean BEmode);Boolean parseNumber (char theChar);short charToNum (char theChar);short convertToShort(short theStart, short theNumChars, Str255 theString);pascal void MyZItemProc(WindowPtr theDlg,short theItem);	/** draws the line round the default dialog item **/pascal void MyYItemProc(WindowPtr theDlg,short theItem);	/** draws the line round the default dialog item **/void saveNewPrefs (void);#include "prefs.h"extern newPrefsRec theNewPrefs;#define findPanelColor 50000pascal void MyQItemProc(WindowPtr theDlg,short theItem);pascal void MyQItemProc(WindowPtr theDlg,short theItem)		/** draws the line round the default dialog item **/{	Rect	iRect;	Handle	iHndl;	short	iType;		GetDItem(theDlg,theItem,&iType,&iHndl,&iRect);	EraseRect(&iRect);}extern  DragTrackingHandlerUPP xMyTrackingHandler;extern  DragReceiveHandlerUPP xMyReceiveDropHandler;Boolean getsearchstring(Boolean reFind){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	short	fRefNum,iRefNum;	Point	where;							Str255 itemString;	Boolean realGhostFound;	Point tempPt;	OSErr	ery,iErr;	FInfo	fndrInfo;	GrafPtr	savePort;	OSType	filtyp;	short myCtlValue;	Str255 temptext, myFileNameCopy,theTempVol;	short 	tempstor;	RgnHandle theRgn;	long 	templong;	short Searchdata;	StringHandle	hString;	AliasHandle alias;	Boolean wasChanged,windowMode;	PaletteHandle hPalette;	RGBColor caretBlack;	MenuHandle	hRsrc,h2Rsrc,h3Rsrc;	short countchecks=0, chA,chB,chC,chD;		short z;	short	errCode;	short theMenus[5];	SysEnvRec	ser;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	Str255	dirFullName, todayStr, beforeStr, afterStr;	long myDrDir;	unsigned long secs;	long dirID;	MenuHandle hMenu;	char * occur;	short iCtlMax;	RGBColor	color;	FSSpec theBackUpSpec;	Str255 theTempName = "\pSFTempUndoFile";	Str255 Cstring,substring;	MenuHandle theGroupMenu, theMemberMenu,tMen;	short groupRefNum,memberRefNum;	FSSpec theGroupSpec;	FSSpec theMemberSpec;	IOParam GMpb;	Str255 theReadText;	short theVrefKey;	short menuVRefs[99];	short menuitem;	ModalFilterUPP xFindFilter = NewModalFilterProc (FindFilter);	getGhostsDirSpec();	commentSearch = false;	*commentSearchStr = 0;	if (reFind)	{		getFiltstring(true);		return;	}		ExactMatch = false;	mySearchBodge = true;	creatorSearch = false;	ghostCounter = 0;    GetStrOpen = false;   // myHand = NewHandle(4);   // MoveHHi(myHand);    //iHndl = &myHand;    //iRect = &myRect;    textSearch = true;	menuitem = 3;    itemHit = 99;    SkipList = false;    if (!reFind)	/** if first search ****/	{				hRsrc = GetMenu(3000);				/*hRsrc = GetResource('MENU',3000);		iErr = ResError();		if (!hRsrc)			genError ("\pCould not load popup menu resource 3000");*/					InsertMenu(hRsrc,-1);		for (z=1;z<=volumearrayptr;z++)		{				Str255 theTempVol;								makeStr255 (volName[z],theTempVol);				doTheSlashAnalysis(theTempVol);								if (*theTempVol)				{					menuVRefs[menuitem] = volumes[z];					menuitem++;					AppendMenu(hRsrc,theTempVol);					iErr = ResError();					/*if (iErr != 0)						genError ("\pCould not append item to resource 3000");*/					if (scanList(volName[z]) && ExcludeDrives)					{						DisableItem(hRsrc,z+2);					}					 BlockMove (volName[z],Cstring,28L);					  PtoCstr (Cstring);					  makeStr255("\pAudio CD",substring);					  PtoCstr (substring);					  occur = strstr((const char *)Cstring,(const char *)substring);					  if (occur)					{						DisableItem(hRsrc,z+2);					}										 makeStr255("\pAudio-CD",substring);					  PtoCstr (substring);					  occur = strstr((const char *)Cstring,(const char *)substring);					  if (occur)					{						DisableItem(hRsrc,z+2);					}				}		}					fpb->ioVRefNum = theApplSpec.vRefNum;		/* default volume */		dirID = GhostsDirID;		fpb->ioNamePtr = zfilename;	/* buffer to receive name */						h2Rsrc = GetMenu(1030);				/*if (!h2Rsrc)			genError("\pCould not load menu 1030");		h2Rsrc = GetResource('MENU',1030);*/				if (!h2Rsrc)			genError ("\pCould not load popup menu resource 1030");					realGhostFound = false;		InsertMenu(h2Rsrc,-1);		for( idx=1; TRUE; idx++) 		{	/* indexing loop */			fpb->ioDirID = dirID;		/* must set on each loop */			myDrDir = dirID;			fpb->ioFDirIndex = idx;					rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) 				break;	/* exit when no more entries */				if (!(fpb->ioFlAttrib & 16)) 			{			/** i.e it is a file **/				if (fpb->ioFlFndrInfo.fdType == 'SFlf' && ghostCounter <=198 && !EqualString(fpb->ioNamePtr,theTempName,false,false)) 				{					iErr = FSMakeFSSpec(fpb->ioVRefNum,myDrDir,fpb->ioNamePtr,&ghosts[ghostCounter]);					if (fpb->ioFlFndrInfo.fdFlags & 0x8000) 					{						iRefNum = CurResFile();						fRefNum = FSpOpenResFile(&ghosts[ghostCounter],fsCurPerm);						if (fRefNum == -1)						{													genError ("\pCan't open alias");							break;						}						alias = (AliasHandle)GetResource('alis',0);						iErr = ResolveAlias(nil,alias,&ghosts[ghostCounter],&wasChanged);						CloseResFile(fRefNum);						UseResFile(iRefNum);						if (iErr != 0)						{							genError ("\pCan't resolve alias");														break;						}					}										makeStr255 (ghosts[ghostCounter].name, theTempVol);					doTheSlashAnalysis(theTempVol);					AppendMenu(h2Rsrc,ghosts[ghostCounter].name);					/* error -43 here */					/*iErr = ResError();					if (iErr != 0)						genError ("\pCould not append item to resource 1020");*/					/*if (scanList(ghosts[ghostCounter].name) && ExcludeDrives)					{						DisableItem(h2Rsrc,ghostCounter+3);					}*/					ghostCounter++;					realGhostFound = true;				}			}			else			{				Str255 tempFName = "\p";				/* its a folder */					iErr = FSMakeFSSpec(fpb->ioVRefNum,myDrDir,fpb->ioNamePtr,&ghosts[ghostCounter]);					makeStr255 (ghosts[ghostCounter].name, theTempVol);					doTheSlashAnalysis(theTempVol);					concatStrings (tempFName,ghosts[ghostCounter].name,"\p ");					AppendMenu(h2Rsrc,tempFName);					//SetItemMark(h2Rsrc,ghostCounter+3,0xD7);					/* error -43 here */					/*iErr = ResError();					if (iErr != 0)						genError ("\pCould not append item to resource 1020");*/					/*if (scanList(ghosts[ghostCounter].name) && ExcludeDrives)					{						DisableItem(h2Rsrc,ghostCounter+3);					}*/					ghostCounter++;			}		} // end of for idx				if (!realGhostFound){	DisableItem(h2Rsrc,2); /* dont let you choose all ghosts if there are none */}		/*******************/		BlockMove (&theApplSpec,&theGroupSpec,70L);	BlockMove (&theApplSpec,&theMemberSpec,70L);		makeStr255("\pSampleSearchª Category Groups",theGroupSpec.name);	iErr = FSpOpenDF(&theGroupSpec,fsCurPerm,&groupRefNum);	if (iErr == -43)	{		iErr = FSpCreate(&theGroupSpec,'ttxt','TEXT',0);		if (iErr)		{			genError("\pCan't make categories file");			return;		}		iErr = FSpOpenDF(&theGroupSpec,fsCurPerm,&groupRefNum);		if (iErr)		{			genError("\pCan't open categories file");			return;		}		}		makeStr255("\pSampleSearchª Category Members",theMemberSpec.name);	iErr = FSpOpenDF(&theMemberSpec,fsCurPerm,&memberRefNum);	if (iErr == -43)	{		iErr = FSpCreate(&theMemberSpec,'ttxt','TEXT',0);		if (iErr)		{			genError("\pCan't make categories file");			return;		}		iErr = FSpOpenDF(&theMemberSpec,fsCurPerm,&memberRefNum);		if (iErr)		{			genError("\pCan't open categories file");			return;		}		}			theGroupMenu = GetMenu(20000);	theMemberMenu = GetMenu(20001);	SetItemStyle(theGroupMenu,1,2);	SetItemStyle(theMemberMenu,1,2);		GMpb.ioRefNum = groupRefNum;	GMpb.ioReqCount = 253;	GMpb.ioPosMode = 0x0D80 | fsAtMark;	GMpb.ioBuffer = (Ptr)theReadText;	iErr = 0;		while (!iErr)	{		iErr = PBRead((union ParamBlockRec *)&GMpb,false);		*(theReadText + GMpb.ioActCount) = 0;		CtoPstr ((Ptr)theReadText);		if (!iErr && GMpb.ioActCount > 0)			AppendMenu(theGroupMenu,theReadText);	}	iErr = FSClose(groupRefNum);			GMpb.ioRefNum = memberRefNum;	GMpb.ioReqCount = 253;	GMpb.ioPosMode = 0x0D80 | fsAtMark;	GMpb.ioBuffer = (Ptr)theReadText;	iErr = 0;	while (!iErr)	{		iErr = PBRead((union ParamBlockRec *)&GMpb,false);		*(theReadText + GMpb.ioActCount) = 0;		CtoPstr ((Ptr)theReadText);		if (!iErr && GMpb.ioActCount > 0)			AppendMenu(theMemberMenu,theReadText);	}	iErr = FSClose(memberRefNum);/****************/		GetPort(&savePort);		myDlg = GetNewDialog ( 128, 0L,(WindowPtr)-1);		/** 'Find what ?' dialog **/			if (!myDlg)		{			ExitToShell();		}		SetPort(myDlg);						if 	(!ghostCounter)			DisableItem(h2Rsrc,0);		}  //end of if !refind	else	{		myDlg = GetNewDialog ( 128+reFind, 0L,(WindowPtr)-1);		/** 'Find what ?' dialog **/			if (!myDlg)		{			ExitToShell();		}		SetPort (myDlg);							if (!myDlg)		{			genError ("\pCan't load dialog");			SetDAFont(0);			return;		}	} 	 	if (!reFind)	{		/*********************/			if (!PreservePopups)		{			GetDItem ( myDlg, 4, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl,iCtlValue);		    getMenuDefaults(theMenus);			GetDItem(myDlg,15,&iType,&iHndl,&iRect);			iCtlMax = GetCtlMax((ControlHandle)(ControlHandle)iHndl);			if (theMenus[0]<=iCtlMax)				SetCtlValue((ControlHandle)iHndl,theMenus[0]);			GetDItem(myDlg,16,&iType,&iHndl,&iRect);			iCtlMax = GetCtlMax((ControlHandle)iHndl);			if (theMenus[1]<=iCtlMax)				SetCtlValue((ControlHandle)iHndl,theMenus[1]);			GetDItem(myDlg,4,&iType,&iHndl,&iRect);			iCtlMax = GetCtlMax((ControlHandle)iHndl);			if (theMenus[2]<=iCtlMax)				SetCtlValue((ControlHandle)iHndl,theMenus[2]);		}/*********************/	}		if (reFind)	{		HideDItem(myDlg,15);		HideDItem(myDlg,16);	}	theRgn = NewRgn();		HideDItem(myDlg,28);		if (!theNewPrefs.findDropDownOpen)	{		SizeWindow(myDlg,400,182,true);		windowMode = true;	}	else	{		windowMode = false;	}			SetPt (&tempPt,theNewPrefs.findWindowLocation.top,theNewPrefs.findWindowLocation.left);		if(PtInRect(tempPt,&qd.screenBits.bounds)) 	{		MoveWindow(myDlg,theNewPrefs.findWindowLocation.left,theNewPrefs.findWindowLocation.top,true);	}		ShowWindow(myDlg);		/********/	fdFldrMask = 0;					/** initialise Searchmask **/	fdFldrVal = 0;		typeRelevant = true;				/** initialise Searchdata **/	GetDItem(myDlg,4,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	iCtlValue = GetCtlValue((ControlHandle)iHndl);  						/** now get menu selected **/	   	    /* bus error here */ 												/** if popup has been used - it is item 10 in the dialog **/    	hString = GetString(999+iCtlValue);		if (hString)			BlockMove(*hString +1,&searchType,4L);		if (searchType == 'AAAA')		{			HideDItem(myDlg,9);		    HideDItem(myDlg,11);		    HideDItem(myDlg,38);		    //HideDItem(myDlg,10);		     HideDItem(myDlg,12);		    HideDItem(myDlg,13);		   // UpdtDialog(myDlg,myDlg->visRgn);		    typeRelevant = false;	    }	SetPort (myDlg);		/* restore the last name searched */	GetDItem(myDlg,5,&iType,&iHndl,&iRect);  		SetIText(iHndl,theLastNameSearched);	SelIText(myDlg,5,0,32767);		do	{dialogLoop:		optionDownWhenMouseDown = false;			movableModalDialog(xFindFilter, &itemHit );		//ModalDialog ( FindFilter, &itemHit );			theNewPrefs.findWindowLocation = (**((*(WindowPeek)myDlg).strucRgn)).rgnBBox;		OffsetRect(&theNewPrefs.findWindowLocation,6,27);		/* look here for window relocation code - i think this value depends on the font size and the border thickness !!! */				GetDItem ( myDlg, 9, &iType, &iHndl, &iRect );		//GetIText ( iHndl, temptext );					/** get dialog entry for Searchdata **/		//StringToNum (temptext, &templong);		/** put data into Searchdata **/		Searchdata = GetCtlValue((ControlHandle)iHndl) - 1;		//Searchdata = LoWord(templong);						GetDItem ( myDlg, 11, &iType, &iHndl, &iRect );		//GetIText ( iHndl, temptext );					/** get dialog entry for Searchdata **/		//StringToNum (temptext, &templong);				/** put data into Searchdata **/		//tempstor = LoWord(templong);		tempstor = GetCtlValue((ControlHandle)iHndl) - 1;				fdFldrVal = (Searchdata * 256) + tempstor;		/** make composite value **/				GetDItem ( myDlg, 13, &iType, &iHndl, &iRect );  /** get handle for fdFldr # item **/		NumToString (fdFldrVal,temptext);		SetIText(iHndl,temptext);		RectRgn(theRgn,&iRect);	//	UpdtDialog(myDlg,theRgn);						/** draw data **/		switch (itemHit)		{		/*case 9:															GetDItem ( myDlg, 8, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl,true);			break;					case 11:			GetDItem ( myDlg, 10, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl,true);			break;			*/					case 29:			SizeWindow(myDlg,400,296,true);					windowMode = false;			theNewPrefs.findDropDownOpen = true;		break;				case 30:			SizeWindow(myDlg,400,182,true);			windowMode = true;			theNewPrefs.findDropDownOpen = false;		break;				/*	case 15:			if (isPressed(0x3A))			{				GetDItem ( myDlg, 15, &iType, &iHndl, &iRect );				theVrefKey = GetCtlValue((ControlHandle)iHndl);						tMen = GetResource('MENU',3000);				if ( (*tMen)->enableFlags &  (1<<(theVrefKey + 1)) )				{					DisableItem(tMen,theVrefKey + 2);				}				else				{					EnableItem(tMen,theVrefKey + 2);				}			}*/								case 14:		if (reFind)		{			GetDItem ( myDlg, 14, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		}		else		{			GetStrOpen = true;			DisposDialog (myDlg);			TextFont (0);			TextSize(12);			/*DeleteMenu(3000);			DeleteMenu(1030);*/			ReleaseResource((Handle)hRsrc);			ReleaseResource((Handle)h2Rsrc);			color.red = 65535;			color.green = 65535;			color.blue = 65535;			RGBBackColor(&color);		}		break;				case 17:			SkipList = true;			GetStrOpen = true;			DisposDialog (myDlg);			TextFont (0);			TextSize(12);			/*DeleteMenu(3000);			DeleteMenu(1030);*/			ReleaseResource((Handle)hRsrc);			ReleaseResource((Handle)h2Rsrc);			color.red = 65535;			color.green = 65535;			color.blue = 65535;			RGBBackColor(&color);								break;			case 18:		if (reFind)		{			GetDItem ( myDlg, 18, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		}		else		{			GetDItem ( myDlg, 18, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		}		break;						case 19:			GetDItem ( myDlg, 19, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		break;				case 22:			GetDateTime((unsigned long *)&secs);			IUDateString(secs,0,todayStr);			GetDItem ( myDlg, 21, &iType, &iHndl, &iRect );			SetIText(iHndl,todayStr);			GetDItem ( myDlg, 19, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, true);					break;						case 23:			creatorSearchType = creatorFindDialog();			InvalRect(&myDlg->portRect);			creatorSearch = (creatorSearchType != 0);						if (creatorSearch)			{				GetDItem(myDlg,27,&iType,&iHndl,&iRect); 				BlockMove (&creatorSearchType,todayStr+1,4L);				*todayStr = 4;				SetIText(iHndl,todayStr);				ShowDItem(myDlg,28);			}			else			{				GetDItem(myDlg,27,&iType,&iHndl,&iRect); 				makeStr255("\p",todayStr);				SetIText(iHndl,todayStr);				HideDItem(myDlg,28);			}			SetPort (myDlg);			DrawDialog (myDlg);							break;				case 24:			GetDItem ( myDlg, 24, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		break;				case 4:												/** file type pop up **/		GetDItem(myDlg,4,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	    iCtlValue = GetCtlValue((ControlHandle)iHndl);  						/** now get menu selected **/	     												/** if popup has been used - it is item 10 in the dialog **/    	hString = GetString(999+iCtlValue);				BlockMove(*hString +1,&searchType,4L);		//HUnlock(hString);		if (searchType == 'AAAA')		{			HideDItem(myDlg,9);		    HideDItem(myDlg,11);		    HideDItem(myDlg,38);		   // HideDItem(myDlg,10);		    HideDItem(myDlg,12);		    HideDItem(myDlg,13);		  //  UpdtDialog(myDlg,myDlg->visRgn);		    mySearchBodge = false;		    typeRelevant = false;	    }	    else	    {		    ShowDItem(myDlg,9);		    ShowDItem(myDlg,11);		    ShowDItem(myDlg,38);		    //ShowDItem(myDlg,10);		    ShowDItem(myDlg,12);		    ShowDItem(myDlg,13);		   // UpdtDialog(myDlg,myDlg->visRgn);		    typeRelevant = true;	    } 	    break;		case 3: case 6:					 /** if OK not cancel **/			if (itemHit == 6)			{				/* folder sub search */				//genError("\pThis function limits search to items inside the folder you are about to choose, and its subfolders");				optionDownWhenMouseDown = true;				itemHit = 3;			}			GetDItem(myDlg,5,&iType,&iHndl,&iRect);			GetIText(iHndl,theLastNameSearched);			if (reFind)			{				GetDItem(myDlg,14,&iType,&iHndl,&iRect);				myCtlValue = GetCtlValue((ControlHandle)iHndl); 				DoublesFilter = false;				if (myCtlValue)					DoublesFilter = true;								GetDItem(myDlg,18,&iType,&iHndl,&iRect);				myCtlValue = GetCtlValue((ControlHandle)iHndl);				ExcludeFilter = false;				if (myCtlValue)					ExcludeFilter = true; 			}						GetDItem(myDlg,24,&iType,&iHndl,&iRect);			ExactMatch = GetCtlValue((ControlHandle)iHndl);							GetDItem ( myDlg, 5, &iType, &iHndl, &iRect ); /** read data from textedit **/			GetIText ( iHndl, gFileName );					/** put it into global variable gFileName **/						if (itemHit == 99)				break;						GetDItem ( myDlg, 9, &iType, &iHndl, &iRect );		/** find group check box **/			if (GetCtlValue((ControlHandle)iHndl) > 1)			{				countchecks++;				GetDItem ( myDlg, 9, &iType, &iHndl, &iRect );				/*GetIText ( iHndl, temptext );									StringToNum (temptext, &templong);	*/											fdFldrVal = GetCtlValue((ControlHandle)iHndl)-1;				//fdFldrVal = LoWord(templong);				fdFldrVal = (fdFldrVal * 256);				/** shift left by 8 into hi byte **/				fdFldrMask = 65280;						/** set hi byte to 1's **/			}						GetDItem ( myDlg, 11, &iType, &iHndl, &iRect );		/** find member check box **/			if (GetCtlValue((ControlHandle)iHndl) > 1)			{				countchecks++;				GetDItem ( myDlg, 11, &iType, &iHndl, &iRect );				tempstor = GetCtlValue((ControlHandle)iHndl)-1;								/*GetIText ( iHndl, temptext );									StringToNum (temptext, &templong);								tempstor = LoWord(templong);*/								fdFldrVal = (fdFldrVal | tempstor);			/** fill in Lo byte **/				fdFldrMask = fdFldrMask | 255;					/** set Lo byte to 1's **/			}						if (!reFind)										/** process drive select and ghost opo ups **/			{				short markChar;				if (optionDownWhenMouseDown)				{					dSearcharrayptr = 1;					ghostCounter = 0;				}				else				{					GetDItem(myDlg,4,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    		myCtlValue = GetCtlValue((ControlHandle)iHndl);    				    		theMenus[2] = myCtlValue;					GetDItem(myDlg,15,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    		myCtlValue = GetCtlValue((ControlHandle)iHndl);    				    		theMenus[0] = myCtlValue;    				    		if (myCtlValue == 2)		    			dSearcharrayptr = 0;		    		if (myCtlValue > 2)		    		{			    		dSearcharrayptr = 1;				//	menuVRefs[menuitem] = volumes[z];				//	menuitem++;			    		volumes[1] = menuVRefs[myCtlValue];						volumearrayptr = 1;						GetItem(hRsrc,myCtlValue,volName[1]);			    	//	BlockMove(volName[myCtlValue-2],volName[1],28L);		    		}			    	GetDItem(myDlg,16,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    		myCtlValue = GetCtlValue((ControlHandle)iHndl);		    		theMenus[1] = myCtlValue;		    		setMenuDefaults(theMenus); 		    		switch (myCtlValue)		    		{			    		case 1:			    			ghostCounter = 0;			    		break;			    					    		case 2:							fillGhostsArrayFromDir();			    		break;			    					    		default:							h2Rsrc = GetMenu(1030);							GetItem(h2Rsrc,myCtlValue,itemString);							if (*(itemString + 1) == '')							//GetItemMark(h2Rsrc,myCtlValue,&markChar);							//if (markChar == 0x00D7 || markChar == 0xD700)							{								/* get the DirID for that name */								removeCharFromStartOfName (itemString);								removeCharFromStartOfName (itemString);								//GetItem(h2Rsrc,myCtlValue,itemString);								getGhostsDirSpecInsideGhosts(itemString);								fillGhostsArrayFromDir();							}							else							{					    		ghostCounter = 1;					    		if (myCtlValue>3)					    		{					    			BlockMove(&ghosts[myCtlValue-3],&ghosts[0],70L);								}							}							break;					}				}	    					}			if (searchType == 'FFFF' && ghostCounter > 0)			{				genError ("\pCan't find folders on Ghosts");				itemHit = 99;				goto dialogLoop;			}						/* date processing */			afterDate = 0L;			beforeDate = 0xFFFFFFFF; 			if (!reFind)			{				GetDItem(myDlg,18,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    	searchBefore = (GetCtlValue((ControlHandle)iHndl) > 0);		    			    	GetDItem(myDlg,19,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    	searchAfter = (GetCtlValue((ControlHandle)iHndl) > 0);								if (searchAfter)				{										DateCacheRecord theCache;					long lengthUsed;					short myString2DateStatus;					LongDateRec dateTime;					OSErr anErr;					DateTimeRec theDTRP;					GetDItem(myDlg,21,&iType,&iHndl,&iRect); 					GetIText(iHndl,afterStr);			/*		anErr = InitDateCache (&theCache);					myString2DateStatus = StringToDate((char *)(afterStr + 1),*afterStr,&theCache,&lengthUsed,&dateTime);					theDTRP.year = dateTime.ld.year;					theDTRP.month = dateTime.ld.month;					theDTRP.day = dateTime.ld.day;					theDTRP.hour = dateTime.ld.hour;					theDTRP.minute = dateTime.ld.minute;					theDTRP.second = dateTime.ld.second;					Date2Secs(&theDTRP,&afterDate);*/					afterDate = dateStringToDate(afterStr, false);					if (afterDate == 0xFFFFFFFF)					{						genError ("\pIncorrect date format");						itemHit = 99;						break;					}				}								if (searchBefore)				{										DateCacheRecord theCache;					long lengthUsed;					short myString2DateStatus;					LongDateRec dateTime;					OSErr anErr;					DateTimeRec theDTRP;					GetDItem(myDlg,20,&iType,&iHndl,&iRect); 					GetIText(iHndl,beforeStr);				/*	anErr = InitDateCache (&theCache);					myString2DateStatus = StringToDate((char *)(beforeStr + 1),*beforeStr,&theCache,&lengthUsed,&dateTime);					theDTRP.year = dateTime.ld.year;					theDTRP.month = dateTime.ld.month;					theDTRP.day = dateTime.ld.day;					theDTRP.hour = dateTime.ld.hour;					theDTRP.minute = dateTime.ld.minute;					theDTRP.second = dateTime.ld.second;					Date2Secs(&theDTRP,&beforeDate);*/					beforeDate = dateStringToDate(beforeStr, true);					if (beforeDate == 0xFFFFFFFF)					{						genError ("\pIncorrect date format");						itemHit = 99;						break;					}				}											}			/*** new comment code */			*commentSearchStr = 0;			commentSearch = true;			GetDItem(myDlg,37,&iType,&iHndl,&iRect);			GetIText(iHndl, commentSearchStr);			if (*commentSearchStr == 0)			{			   commentSearch = false;			}			UprString(commentSearchStr,false);			/***********/			DisposDialog (myDlg);			TextFont (0);			TextSize(12);			if (itemHit == 99)				break;			if (!reFind)			{				/*DeleteMenu(3000);				DeleteMenu(1030);*/				ReleaseResource((Handle)hRsrc);				ReleaseResource((Handle)h2Rsrc);							}			color.red = 65535;			color.green = 65535;			color.blue = 65535;			RGBBackColor(&color);									if (*gFileName<1)			/** ie name field is null **/			{				textSearch = false;							}									break;						case 2: 		/** ie exit pressed **/				/*if (!reFind)				{					DeleteMenu(3000);					DeleteMenu(1030);					ReleaseResource((Handle)hRsrc);					ReleaseResource((Handle)h2Rsrc);				}*/				color.red = 65535;				color.green = 65535;				color.blue = 65535;				RGBBackColor(&color);				DisposDialog (myDlg);				TextFont (0);				TextSize(12);				if (!reFind)				{					FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempUndoFile",&theBackUpSpec);					FSpDelete(&theBackUpSpec);					FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);					FSpDelete(&theBackUpSpec);					cleanUpRes();					//RemoveVBL();					saveNewPrefs ();					ExitToShell();				}			break;					case 8:case 10:				GetDItem ( myDlg, itemHit, &iType, &iHndl, &iRect );		/** make check boxes on when writing into box **/				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));					break;				}	} while (itemHit !=3 && itemHit !=6 && itemHit!=2 && (itemHit!=14 || reFind) && itemHit != 17);		//DisposHandle(myHand);	PtoCstr (commentSearchStr);	//ReleaseResource((Handle)hMCTbl);	SetDAFont(0);		if (loseTheWindow && SkipList)	{		SetPort (myWindow);		LDispose(myList);		listOpen = false;		rememberSelection = false;		myList = 0;		if (dragAvailable)		{			RemoveTrackingHandler(xMyTrackingHandler, myWindow);			RemoveReceiveHandler(xMyReceiveDropHandler, myWindow);		}			DisposeWindow((WindowPtr)myWindow);		loseTheWindow = false;	}			return (itemHit==3 || itemHit == 14 || itemHit == 17);}unsigned long dateStringToDate(Str255 theDateStr , Boolean BEmode){	DateTimeRec	theDTRecord;	short theCharCount = 0;	short theWordCount = 1;	short theArrayCount = 0;	short theNumChars [6];	short z;	OSErr	iErr;	unsigned long  secs = 0xFFFFFFFF;		for (z = 1;z<= (short)(*theDateStr);z++)	{		if ( !parseNumber(*(theDateStr + z)) && *(theDateStr + z) != '/')			return secs;	}		*(theDateStr + *theDateStr +1) = '/';	*theDateStr = *theDateStr + 1;	while (theArrayCount <= 2 && theCharCount < 10)	{		if (*(theDateStr + theCharCount + theWordCount) != '/')		{			theCharCount += 1;		}		else		{			theNumChars[theArrayCount] = theCharCount;			theWordCount += theCharCount + 1;			theCharCount = 0;			theArrayCount ++;		}	}	*theDateStr = *theDateStr -1;	if (theNumChars[0] <1 || theNumChars[1] < 1 || theNumChars[2] < 2)		return secs;	if  (theNumChars[0] > 2 || theNumChars[1] > 2 || theNumChars[2] > 2)		return secs;		theCharCount = 1;			theDTRecord.day = convertToShort (theCharCount,theNumChars[0],theDateStr);	theCharCount += theNumChars[0] + 1;	theDTRecord.month = convertToShort (theCharCount,theNumChars[1],theDateStr);	theCharCount += theNumChars[1] + 1;	theDTRecord.year = convertToShort (theCharCount,theNumChars[2],theDateStr) + 1900;	theDTRecord.hour = (BEmode * 23);	theDTRecord.minute = (BEmode * 59);	theDTRecord.second = (BEmode * 59);	Date2Secs(&theDTRecord,&secs);	return secs;	}Boolean parseNumber (char theChar){	if (theChar >= '0' && theChar <= '9')		return true;	else		return false;}short convertToShort(short theStart, short theNumChars, Str255 theString){	short theRetShort = 0;	short z;	short theMultiplier=1;		for (z=theNumChars;z>=1;z--)	{		theRetShort += charToNum(*(theString+theStart+z-1)) * theMultiplier;		theMultiplier *= 10;	}	return theRetShort;}short charToNum (char theChar){	return (short)(theChar - '0');}OSErr GetIndVolume (short whichVol, char *volName, short *volRefNum){	/* Return the name and vRefNum of volume specified by whichVol */	HVolumeParam	volPB;	OSErr	error;	volPB.ioNamePtr = (unsigned char *)volName;	/* make sure it returns the name */	volPB.ioVRefNum = 0;	/* 0 means use ioVolIndex */	volPB.ioVolIndex = whichVol;	/* use this to determine volume */	error = PBHGetVInfo((union HParamBlockRec *)&volPB,false);	/* do it */	if(error == noErr)		*volRefNum = volPB.ioVRefNum;	/* return the volume reference */	/* other information is available from this record; see the File Manager*/	/* description of PBHGetVInfo for more details... */	return (error);}extern long theGreyColor;pascal void MyNewItemProc(WindowPtr theDlg,short theItem)		{	Rect	iRect;	Handle	iHndl;	short	iType;		GDHandle	gdh;		GetDItem (theDlg,26,&iType,&iHndl,&iRect);	gdh = GetMainDevice();	color.red = findPanelColor;	color.blue = findPanelColor;	color.green = findPanelColor;	RGBForeColor(&color);	if (theGreyColor == 65535)	{		FillRect(&iRect,&qd.gray);	}	else	{		FillRect(&iRect,&qd.black);	}	GetDItem (theDlg,31,&iType,&iHndl,&iRect);	FillRect(&iRect,&qd.black);	color.red = 0x0000;	color.green = 0x0000;	color.blue = 0x0000;	RGBForeColor(&color);}pascal Boolean FindFilter (DialogPtr theDialog, EventRecord *theEvent,							 short *itemHit){	Rect	iRect;	short	type,iType;	Handle	iHndle;	Handle	iHandle;	Point	theCell;	OSErr	iErr;	char theChar;	short theItem;	short 	itype;	Handle theHandle;	short theQuay;	Rect dragRect;	short theVrefKey;	WindowPtr	whichWindow;	short thePart;	RGBColor	color;	MenuHandle tMen;			GrafPtr	savePort;	GetPort (&savePort);	switch (theEvent->what) 	{		case keyDown:			SetPort(theDialog);			// if key was pressed, handle return key			theQuay = (theEvent->message) & keyCodeMask;			theChar = (theEvent->message) & charCodeMask;			if ( (theChar == 0x0d) || (theChar == 0x03)) 			{					*itemHit = 3;					SetPort (savePort);					return TRUE;			}						if (theEvent->modifiers & cmdKey)			{				if (theQuay == 0x0C00)				{						*itemHit = 2;						SetPort (savePort);						return TRUE;				}				if (theQuay == 0x0100)				{						*itemHit = 17;						SetPort (savePort);							return TRUE;				}								if (theQuay == 0x0000)				{					GetDItem (theDialog,15,&iType,&iHndle,&iRect);					SetCtlValue((ControlHandle)iHndle,1);				}								if (theChar >= 0x31 && theChar <= 0x39)				{					theVrefKey = theChar - 0x30;										GetDItem (theDialog,15,&iType,&iHndle,&iRect);					SetCtlValue((ControlHandle)iHndle,theVrefKey + 2);				}			}												SetPort (savePort);			return FALSE;	break;		case mouseDown:			SetPort(theDialog);			if (theEvent->modifiers & optionKey)				optionDownWhenMouseDown = true;			else				optionDownWhenMouseDown = false;			SetPort (savePort);			return false;	break;				case updateEvt:				if(theEvent->message == (long)theDialog)				{					SetPort (theDialog);					//InvalRect(&theDialog->portRect);					BeginUpdate(theDialog);						GetDItem (theDialog,26,&iType,&iHndle,&iRect);						color.red = findPanelColor;						color.blue = findPanelColor;						color.green = findPanelColor;						RGBForeColor(&color);						if (theGreyColor == 65535)						{							FillRect(&iRect,&qd.gray);						}						else						{							FillRect(&iRect,&qd.black);						}						color.red = 0x0000;						color.green = 0x0000;						color.blue = 0x0000;						RGBForeColor(&color);						PenSize(2,1);						MoveTo(iRect.left,iRect.top);						LineTo(iRect.left,iRect.bottom);						PenSize(1,2);						MoveTo(iRect.left,iRect.top);						LineTo(iRect.right,iRect.top);						PenSize(1,1);						color.red = 0xFFFF;						color.green = 0xFFFF;						color.blue = 0xFFFF;						RGBForeColor(&color);						MoveTo(iRect.right,iRect.top);						LineTo(iRect.right,iRect.bottom);						MoveTo(iRect.left,iRect.bottom);						LineTo(iRect.right,iRect.bottom);						MoveTo(iRect.right-1,iRect.top+1);						LineTo(iRect.right-1,iRect.bottom);						MoveTo(iRect.left+1,iRect.bottom-1);						LineTo(iRect.right,iRect.bottom-1);						color.red = findPanelColor;						color.blue = findPanelColor;						color.green = findPanelColor;						RGBForeColor(&color);						GetDItem (theDialog,31,&iType,&iHndle,&iRect);						if (theGreyColor == 65535)						{							FillRect(&iRect,&qd.gray);						}						else						{							FillRect(&iRect,&qd.black);						}						color.red = 0x0000;						color.green = 0x0000;						color.blue = 0x0000;						RGBForeColor(&color);						PenSize(2,1);						MoveTo(iRect.left,iRect.top);						LineTo(iRect.left,iRect.bottom);						PenSize(1,2);						MoveTo(iRect.left,iRect.top);						LineTo(iRect.right,iRect.top);						PenSize(1,1);						color.red = 0xFFFF;						color.green = 0xFFFF;						color.blue = 0xFFFF;						RGBForeColor(&color);						MoveTo(iRect.right,iRect.top);						LineTo(iRect.right,iRect.bottom);						MoveTo(iRect.left,iRect.bottom);						LineTo(iRect.right,iRect.bottom);						MoveTo(iRect.right-1,iRect.top+1);						LineTo(iRect.right-1,iRect.bottom);						MoveTo(iRect.left+1,iRect.bottom-1);						LineTo(iRect.right,iRect.bottom-1);						color.red = 0x0000;						color.green = 0x0000;						color.blue = 0x0000;						RGBForeColor(&color);						GetDItem (theDialog,3,&iType,&iHndle,&iRect);						PenSize(1,1);						InsetRect(&iRect,-1,-1);						//FrameRect(&iRect);						DrawDialog (theDialog);					EndUpdate(theDialog);					SetPort (savePort);					return false;				}								if (theEvent->message == (long)myWindow)				{						short theQuay,fontNum;						//FlashMenuBar(0);						presFont =  savePort->txFont;						presSize = savePort->txSize;						SetPort(myWindow);						BeginUpdate ((WindowPtr) theEvent->message);						color.red = 0xFFFF;						color.blue = 0xFFFF;						color.green = 0xFFFF;						RGBBackColor(&color);						DrawGrowIcon ((WindowPtr) myWindow);												GetFNum(theFontRec.fontName,&fontNum);						TextFont(fontNum);						/** font for list - chicago **/						TextSize(theFontRec.fontSize);												color.red = 0;						color.blue = 0;						color.green = 0;						RGBForeColor(&color);						LUpdate((*myList)->port->visRgn,myList);												DrawGrowIcon((GrafPtr)myWindow);							windowUpdate();						showCommentinWin(kFirstSelected,nullCell);						DrawControls(myWindow);									EndUpdate ((WindowPtr) theEvent->message);						SetPort (savePort);				}			return true;		break;				case activateEvt:			 SetPort(theDialog);			 return FALSE;		break;				default :			SetPort (savePort);			return FALSE;		break;	}	SetPort (savePort);}Boolean getFiltstring(Boolean reFind){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	short	fRefNum,iRefNum;	Point	where;	OSErr	ery,iErr;	FInfo	fndrInfo;	GrafPtr	savePort;	OSType	filtyp;	short myCtlValue;	Str255 temptext, myFileNameCopy;	short 	tempstor;	RgnHandle theRgn;	long 	templong;	short Searchdata;	StringHandle	hString;	AliasHandle alias;	Boolean wasChanged;	short menuVRefs[99];	short menuitem;	MenuHandle	hRsrc,h2Rsrc,h3Rsrc;	short countchecks=0, chA,chB,chC,chD;		short z;	short	errCode;	short theMenus[5];	SysEnvRec	ser;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	Str255	dirFullName, todayStr, beforeStr, afterStr;	long myDrDir, secs;	long dirID;	MenuHandle hMenu;	char * occur;	short iCtlMax;	FSSpec theBackUpSpec;	    Str255 theTempName = "\pSFTempUndoFile";		commentSearch = false;	*commentSearchStr = 0;			ExactMatch = false;	mySearchBodge = true;	creatorSearch = false;	ghostCounter = 0;    GetStrOpen = false;   // myHand = NewHandle(4);   // MoveHHi(myHand);    //iHndl = &myHand;    //iRect = &myRect;    textSearch = true;    itemHit = 99;    SkipList = false;    if (!reFind)	/** if first search ****/	{				hRsrc = GetMenu(3000);		/*if (!hRsrc)			genError("\pCould not load menu 3000");*/		/*hRsrc = GetResource('MENU',3000);		iErr = ResError();		if (!hRsrc)			genError ("\pCould not load popup menu resource 3000");*/		InsertMenu(hRsrc,-1);menuitem = 3;		for (z=1;z<=volumearrayptr;z++)		{			Str255 theTempVol;			makeStr255 (volName[z], theTempVol);			doTheSlashAnalysis(theTempVol);			if (*theTempVol)			{				menuVRefs[menuitem] = volumes[z];				menuitem++;				AppendMenu(hRsrc,theTempVol);				/*iErr = ResError()*/;				/*if (iErr != 0)					genError ("\pCould not append item to resource 3000");*/				if (scanList(volName[z]) && ExcludeDrives)				{					DisableItem(hRsrc,z+2);				}				if (EqualString(volName[z],"\pAudio CD 1",true,true))				{					DisableItem(hRsrc,z+2);				}			}		}			fpb->ioVRefNum = theApplSpec.vRefNum;		/* default volume */		dirID = GhostsDirID;		fpb->ioNamePtr = zfilename;	/* buffer to receive name */			h2Rsrc = GetMenu(1030);		/*if (!h2Rsrc)			genError("\pCould not load menu 1030");		h2Rsrc = GetResource('MENU',1030);		if (!h2Rsrc)			genError ("\pCould not load popup menu resource 1030");*/		InsertMenu(h2Rsrc,-1);		for( idx=1; TRUE; idx++) 		{	/* indexing loop */			fpb->ioDirID = dirID;		/* must set on each loop */			myDrDir = dirID;			fpb->ioFDirIndex = idx;					rc = PBGetCatInfo( &cipbr, FALSE );			if (rc) 				break;	/* exit when no more entries */				if (!(fpb->ioFlAttrib & 16)) 			{			/** i.e it is a file **/				if (fpb->ioFlFndrInfo.fdType == 'SFlf' && ghostCounter <=98 && !EqualString(fpb->ioNamePtr,theTempName,false,false)) 				{					iErr = FSMakeFSSpec(fpb->ioVRefNum,myDrDir,fpb->ioNamePtr,&ghosts[ghostCounter]);					if (fpb->ioFlFndrInfo.fdFlags & 0x8000) 					{						iRefNum = CurResFile();						fRefNum = FSpOpenResFile(&ghosts[ghostCounter],fsCurPerm);						if (fRefNum == -1)						{													genError ("\pCan't open alias");							break;						}						alias = (AliasHandle)GetResource('alis',0);						iErr = ResolveAlias(nil,alias,&ghosts[ghostCounter],&wasChanged);						CloseResFile(fRefNum);						UseResFile(iRefNum);						if (iErr != 0)						{							genError ("\pCan't resolve alias");														break;						}					}					AppendMenu(h2Rsrc,ghosts[ghostCounter].name);					/* error -43 here */					/*iErr = ResError();					if (iErr != 0)						genError ("\pCould not append item to resource 1020");*/					/*if (scanList(ghosts[ghostCounter].name) && ExcludeDrives)					{						DisableItem(h2Rsrc,ghostCounter+3);					}*/					ghostCounter++;				}			}		} // end of for idx		myDlg = GetNewDialog ( 128, 0L,(WindowPtr)-1);		/** 'Find what ?' dialog **/				SetPort (myDlg);	/*color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);*/		if (!myDlg)		{			genError ("\pCan't load dialog");			return;		}				if 	(!ghostCounter)			DisableItem(h2Rsrc,0);		}  //end of if !refind	else	{		 myDlg = GetNewDialog ( 128+reFind, 0L,(WindowPtr)-1);		/** 'Find what ?' dialog **/				SetPort (myDlg);	/*color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);*/		 if (!myDlg)		{			genError ("\pCan't load dialog");			return;		}	}		SetPort(myDlg);	/*color.red = 56797;	color.green = 56797;	color.blue =56797;	RGBBackColor(&color);*/				    GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);	if (!reFind)	{		/*********************/			if (!PreservePopups)		{			GetDItem ( myDlg, 4, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl,iCtlValue);		    getMenuDefaults(theMenus);			GetDItem(myDlg,15,&iType,&iHndl,&iRect);			iCtlMax = GetCtlMax((ControlHandle)iHndl);			if (theMenus[0]<=iCtlMax)				SetCtlValue((ControlHandle)iHndl,theMenus[0]);			GetDItem(myDlg,16,&iType,&iHndl,&iRect);			iCtlMax = GetCtlMax((ControlHandle)iHndl);			if (theMenus[1]<=iCtlMax)				SetCtlValue((ControlHandle)iHndl,theMenus[1]);			GetDItem(myDlg,4,&iType,&iHndl,&iRect);			iCtlMax = GetCtlMax((ControlHandle)iHndl);			if (theMenus[2]<=iCtlMax)				SetCtlValue((ControlHandle)iHndl,theMenus[2]);		}/*********************/	}		 if (reFind)	{		HideDItem(myDlg,15);		HideDItem(myDlg,16);	}	theRgn = NewRgn();	ShowWindow(myDlg);	/********/	fdFldrMask = 0;					/** initialise Searchmask **/	fdFldrVal = 0;		typeRelevant = true;				/** initialise Searchdata **/	GetDItem(myDlg,4,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	iCtlValue = GetCtlValue((ControlHandle)iHndl);  						/** now get menu selected **/	   	    /* bus error here */ 												/** if popup has been used - it is item 10 in the dialog **/    	hString = GetString(999+iCtlValue);		if (hString)			BlockMove(*hString +1,&searchType,4L);		if (searchType == 'AAAA')		{			HideDItem(myDlg,9);		    HideDItem(myDlg,11);		    HideDItem(myDlg,38);		    //HideDItem(myDlg,10);		     HideDItem(myDlg,12);		    HideDItem(myDlg,13);		  //  UpdtDialog(myDlg,myDlg->visRgn);		    typeRelevant = false;	    }	do	{		ModalDialog(xAlertFilter, &itemHit );		GetDItem ( myDlg, 9, &iType, &iHndl, &iRect );		GetIText ( iHndl, temptext );					/** get dialog entry for Searchdata **/		StringToNum (temptext, &templong);				/** put data into Searchdata **/		Searchdata = LoWord(templong);		GetDItem ( myDlg, 11, &iType, &iHndl, &iRect );		GetIText ( iHndl, temptext );					/** get dialog entry for Searchdata **/		StringToNum (temptext, &templong);				/** put data into Searchdata **/		tempstor = LoWord(templong);		fdFldrVal = (Searchdata * 256) + tempstor;		/** make composite value **/		GetDItem ( myDlg, 13, &iType, &iHndl, &iRect );  /** get handle for fdFldr # item **/		NumToString (fdFldrVal,temptext);		SetIText(iHndl,temptext);		RectRgn(theRgn,&iRect);		//UpdtDialog(myDlg,theRgn);						/** draw data **/		switch (itemHit)		{		case 9:												/** fdfldr check boxes from textedit click **/			GetDItem ( myDlg, 8, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl,true);			break;					case 11:			GetDItem ( myDlg, 10, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl,true);			break;				case 6:			doCommentSearch();			SetPort (myDlg);			DrawDialog (myDlg);		break;					case 14:		if (reFind)		{			GetDItem ( myDlg, 14, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		}		else		{			GetStrOpen = true;			DisposDialog (myDlg);			TextFont (0);			TextSize(12);			/*DeleteMenu(3000);			DeleteMenu(1030);*/			ReleaseResource((Handle)hRsrc);			ReleaseResource((Handle)h2Rsrc);					}		break;				case 17:			SkipList = true;			GetStrOpen = true;			DisposDialog (myDlg);			TextFont (0);			TextSize(12);			/*DeleteMenu(3000);			DeleteMenu(1030);*/			ReleaseResource((Handle)hRsrc);			ReleaseResource((Handle)h2Rsrc);					break;			case 18:		if (reFind)		{			GetDItem ( myDlg, 18, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		}		else		{			GetDItem ( myDlg, 18, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		}		break;						case 19:			GetDItem ( myDlg, 19, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		break;				case 22:			GetDateTime((unsigned long *)&secs);			IUDateString(secs,0,todayStr);			GetDItem ( myDlg, 21, &iType, &iHndl, &iRect );			SetIText(iHndl,todayStr);			GetDItem ( myDlg, 19, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, true);		break;				case 23:			creatorSearchType = creatorFindDialog();						InvalRect(&myDlg->portRect);			creatorSearch = (creatorSearchType != 0);			if (creatorSearch)			{				GetDItem(myDlg,23,&iType,&iHndl,&iRect); 				BlockMove (&creatorSearchType,todayStr+1,4L);				*todayStr = 4;				SetCTitle((ControlHandle)iHndl,todayStr);			}			else			{				GetDItem(myDlg,23,&iType,&iHndl,&iRect); 				makeStr255("\pCreator..",todayStr);				SetCTitle((ControlHandle)iHndl,todayStr);			}		break;				case 24:			GetDItem ( myDlg, 24, &iType, &iHndl, &iRect );			SetCtlValue((ControlHandle)iHndl, !GetCtlValue((ControlHandle)iHndl));		break;				case 4:												/** file type pop up **/		GetDItem(myDlg,4,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	    iCtlValue = GetCtlValue((ControlHandle)iHndl);  						/** now get menu selected **/	     												/** if popup has been used - it is item 10 in the dialog **/    	hString = GetString(999+iCtlValue);				BlockMove(*hString +1,&searchType,4L);		//HUnlock(hString);		if (searchType == 'AAAA')		{			HideDItem(myDlg,9);		    HideDItem(myDlg,11);		    HideDItem(myDlg,38);		   // HideDItem(myDlg,10);		    HideDItem(myDlg,12);		    HideDItem(myDlg,13);		  //  UpdtDialog(myDlg,myDlg->visRgn);		    mySearchBodge = false;		    typeRelevant = false;	    }	    else	    {		    ShowDItem(myDlg,9);		    ShowDItem(myDlg,11);		    ShowDItem(myDlg,38);		  //  ShowDItem(myDlg,10);		    ShowDItem(myDlg,12);		    ShowDItem(myDlg,13);		 //   UpdtDialog(myDlg,myDlg->visRgn);		    typeRelevant = true;	    } 	    break;		case 1: 					 /** if OK not cancel **/					if (reFind)			{				GetDItem(myDlg,14,&iType,&iHndl,&iRect);				myCtlValue = GetCtlValue((ControlHandle)iHndl); 				DoublesFilter = false;				if (myCtlValue)					DoublesFilter = true;								GetDItem(myDlg,18,&iType,&iHndl,&iRect);				myCtlValue = GetCtlValue((ControlHandle)iHndl);				ExcludeFilter = false;				if (myCtlValue)					ExcludeFilter = true; 								*commentSearchStr = 0;				commentSearch = true;				GetDItem(myDlg,37,&iType,&iHndl,&iRect);				GetIText(iHndl, commentSearchStr);				if (*commentSearchStr == 0)				{				   commentSearch = false;				}				UprString(commentSearchStr,false);									}						GetDItem(myDlg,24,&iType,&iHndl,&iRect);			ExactMatch = GetCtlValue((ControlHandle)iHndl);							GetDItem ( myDlg, 5, &iType, &iHndl, &iRect ); /** read data from textedit **/			GetIText ( iHndl, gFileName );					/** put it into global variable gFileName **/									if (itemHit == 99)				break;						GetDItem ( myDlg, 8, &iType, &iHndl, &iRect );		/** find group check box **/			if (GetCtlValue((ControlHandle)iHndl))			{				countchecks++;				GetDItem ( myDlg, 9, &iType, &iHndl, &iRect );				GetIText ( iHndl, temptext );					/** get dialog entry for Searchdata **/				StringToNum (temptext, &templong);				/** put data into Searchdata **/				fdFldrVal = LoWord(templong);				fdFldrVal = (fdFldrVal * 256);				/** shift left by 8 into hi byte **/				fdFldrMask = 65280;						/** set hi byte to 1's **/			}			GetDItem ( myDlg, 10, &iType, &iHndl, &iRect );		/** find member check box **/			if (GetCtlValue((ControlHandle)iHndl))			{				countchecks++;				GetDItem ( myDlg, 11, &iType, &iHndl, &iRect );				GetIText ( iHndl, temptext );					/** get dialog entry for Searchdata **/				StringToNum (temptext, &templong);				/** get data for member **/				tempstor = LoWord(templong);				fdFldrVal = (fdFldrVal | tempstor);			/** fill in Lo byte **/				fdFldrMask = fdFldrMask | 255;					/** set Lo byte to 1's **/			}			if (!reFind)										/** process drive select and ghost opo ups **/			{				GetDItem(myDlg,4,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	    		myCtlValue = GetCtlValue((ControlHandle)iHndl);    			    		theMenus[2] = myCtlValue;				GetDItem(myDlg,15,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	    		myCtlValue = GetCtlValue((ControlHandle)iHndl);    			    		theMenus[0] = myCtlValue;    			    		if (myCtlValue == 2)	    			dSearcharrayptr = 0;	    		if (myCtlValue > 2)	    		{		    		dSearcharrayptr = 1;				//	menuVRefs[menuitem] = volumes[z];				//	menuitem++;			    		volumes[1] = menuVRefs[myCtlValue];						GetItem(hRsrc,myCtlValue,volName[1]);			    	//	BlockMove(volName[myCtlValue-2],volName[1],28L);		    	/*	dSearcharrayptr = 1;		    		volumes[1] = volumes[myCtlValue-2];		    		BlockMove(volName[myCtlValue-2],volName[1],28L);*/	    		}		    	GetDItem(myDlg,16,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/	    		myCtlValue = GetCtlValue((ControlHandle)iHndl);	    		theMenus[1] = myCtlValue;	    		setMenuDefaults(theMenus); 	    		switch (myCtlValue)	    		{		    		case 1:		    			ghostCounter = 0;		    		break;		    				    		case 2:		    		break;		    				    		default:			    		ghostCounter = 1;			    		if (myCtlValue>3)				    		{				    			BlockMove(&ghosts[myCtlValue-3],&ghosts[0],70L);							}						break;				}	    					}			if (searchType == 'FFFF' && dSearcharrayptr == 0)			{				genError ("\pCan't find folders on Ghosts");				itemHit = 99;			}						/* date processing */			afterDate = 0L;			beforeDate = 0xFFFFFFFF; 			if (!reFind)			{				GetDItem(myDlg,18,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    	searchBefore = (GetCtlValue((ControlHandle)iHndl) > 0);		    			    	GetDItem(myDlg,19,&iType,&iHndl,&iRect);  			/** get handle etc of popup **/		    	searchAfter = (GetCtlValue((ControlHandle)iHndl) > 0);								if (searchAfter)				{										DateCacheRecord theCache;					long lengthUsed;					short myString2DateStatus;					LongDateRec dateTime;					OSErr anErr;					DateTimeRec theDTRP;					GetDItem(myDlg,21,&iType,&iHndl,&iRect); 					GetIText(iHndl,afterStr);				/*	anErr = InitDateCache (&theCache);					myString2DateStatus = StringToDate((char *)(afterStr + 1),*afterStr,&theCache,&lengthUsed,&dateTime);					theDTRP.year = dateTime.ld.year;					theDTRP.month = dateTime.ld.month;					theDTRP.day = dateTime.ld.day;					theDTRP.hour = dateTime.ld.hour;					theDTRP.minute = dateTime.ld.minute;					theDTRP.second = dateTime.ld.second;					Date2Secs(&theDTRP,&afterDate);*/					afterDate = dateStringToDate(afterStr, false);					if (afterDate == 0xFFFFFFFF)					{						genError ("\pIncorrect date format");						itemHit = 99;						break;					}				}								if (searchBefore)				{										DateCacheRecord theCache;					long lengthUsed;					short myString2DateStatus;					LongDateRec dateTime;					OSErr anErr;					DateTimeRec theDTRP;					GetDItem(myDlg,20,&iType,&iHndl,&iRect); 					GetIText(iHndl,beforeStr);				/*	anErr = InitDateCache (&theCache);					myString2DateStatus = StringToDate((char *)(beforeStr + 1),*beforeStr,&theCache,&lengthUsed,&dateTime);					theDTRP.year = dateTime.ld.year;					theDTRP.month = dateTime.ld.month;					theDTRP.day = dateTime.ld.day;					theDTRP.hour = dateTime.ld.hour;					theDTRP.minute = dateTime.ld.minute;					theDTRP.second = dateTime.ld.second;					Date2Secs(&theDTRP,&beforeDate);*/					beforeDate = dateStringToDate(afterStr, true);					if (beforeDate == 0xFFFFFFFF)					{						genError ("\pIncorrect date format");						itemHit = 99;						break;					}				}			}						if (itemHit == 99)				break;						DisposDialog (myDlg);			TextFont (0);			TextSize(12);			if (!reFind)			{				/*DeleteMenu(3000);				DeleteMenu(1030);*/				ReleaseResource((Handle)hRsrc);				ReleaseResource((Handle)h2Rsrc);							}						if (*gFileName<1)			/** ie name field is null **/			{				textSearch = false;							}									break;						case 2: 		/** ie exit pressed **/				DisposDialog (myDlg);				TextFont (0);			TextSize(12);				/*if (!reFind)				{					DeleteMenu(3000);					DeleteMenu(1030);					ReleaseResource((Handle)hRsrc);					ReleaseResource((Handle)h2Rsrc);				}*/								if (!reFind)				{					/*DisposHandle(therealResults);					DisposHandle(gTheResults);					DisposPtr(gBuffer);						DisposHandle(theUndoResults);*/					FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempUndoFile",&theBackUpSpec);					FSpDelete(&theBackUpSpec);					FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);					FSpDelete(&theBackUpSpec);					cleanUpRes();					//RemoveVBL();					saveNewPrefs ();					ExitToShell();				}				break;					case 8:case 10:				GetDItem ( myDlg, itemHit, &iType, &iHndl, &iRect );		/** make check boxes on when writing into box **/				SetCtlValue((ControlHandle)iHndl,!GetCtlValue((ControlHandle)iHndl));					break;				}	} while (itemHit !=1 && itemHit!=2 && (itemHit!=14 || reFind) && itemHit != 17);		//DisposHandle(myHand);	return (itemHit==1 || itemHit == 14 || itemHit == 17);}void doCommentSearch(void){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255 textStr;	OSType theRetType;	StandardFileReply	reply;	FInfo fndrInfo;	OSErr	iErr;	myDlg = GetNewDialog(11250,0L,(WindowPtr)-1); 	SetPort (myDlg);/*	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);*/	GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetCtlValue((ControlHandle)iHndl,commentSearch);	GetDItem(myDlg,2,&iType,&iHndl,&iRect);	SetIText(iHndl,commentSearchStr);		ShowWindow(myDlg);		do	{		ModalDialog(0,&itemHit);		if (itemHit == 3)		{			GetDItem(myDlg,3,&iType,&iHndl,&iRect);			SetCtlValue((ControlHandle)iHndl,(commentSearch = !GetCtlValue((ControlHandle)iHndl)));		}		if (itemHit == 2)		{			GetDItem(myDlg,3,&iType,&iHndl,&iRect);			SetCtlValue((ControlHandle)iHndl,true);			commentSearch = true;		}	}while (itemHit != 1);	GetDItem(myDlg,37,&iType,&iHndl,&iRect);	GetIText(iHndl, commentSearchStr);		if (*commentSearchStr == 0)	{	   commentSearch = false;	}			DisposDialog(myDlg);	UprString(commentSearchStr,false);				return;}OSErr removeCharFromStartOfName (StringPtr string){	BlockMove (string + 2, string+1,(*string) - 1);	*string = *string - 1;}OSErr fillGhostsArrayFromDir(void){	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	DirInfo	*dpb = (DirInfo *) &cipbr;	short	rc, idx;	long dirID,myDrDir;	Str255 theTempName = "\pSFTempUndoFile";	OSErr iErr;	short iRefNum;	AliasHandle alias;	Boolean wasChanged;	ghostCounter = 0;	fpb->ioVRefNum = theApplSpec.vRefNum;		/* default volume */	dirID = GhostsDirID;	fpb->ioNamePtr = zfilename;	/* buffer to receive name */	for( idx=1; TRUE; idx++) 	{	/* indexing loop */		fpb->ioDirID = dirID;		/* must set on each loop */		myDrDir = dirID;		fpb->ioFDirIndex = idx;			rc = PBGetCatInfo( &cipbr, FALSE );		if (rc) 			break;	/* exit when no more entries */		if (!(fpb->ioFlAttrib & 16)) 		{			/** i.e it is a file **/			if (fpb->ioFlFndrInfo.fdType == 'SFlf' && ghostCounter <=198 && !EqualString(fpb->ioNamePtr,theTempName,false,false)) 			{				iErr = FSMakeFSSpec(fpb->ioVRefNum,myDrDir,fpb->ioNamePtr,&ghosts[ghostCounter]);				if (fpb->ioFlFndrInfo.fdFlags & 0x8000) 				{					iRefNum = CurResFile();					fRefNum = FSpOpenResFile(&ghosts[ghostCounter],fsCurPerm);					if (fRefNum == -1)					{											genError ("\pCan't open alias");						break;					}					alias = (AliasHandle)GetResource('alis',0);					iErr = ResolveAlias(nil,alias,&ghosts[ghostCounter],&wasChanged);					CloseResFile(fRefNum);					UseResFile(iRefNum);					if (iErr != 0)					{						genError ("\pCan't resolve alias");												break;					}				}				ghostCounter++;			}		}	}}