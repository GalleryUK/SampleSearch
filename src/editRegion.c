#include <Dialogs.h>#include <Quickdraw.h>#define MAP_WIDE 486#define MAP_HIGH 296#define MAP_WBYTES  ( ( ( MAP_WIDE / 16 ) +1 ) * 2 )#define MAP_SIZE ( MAP_WBYTES * MAP_HIGH )#include "SampleSearch.h"#include "Globals.h"#define editStart true#define editStop false#define viewBoth 0#define viewOne 1//pascal OSErr	GetStdFilterProc(ProcPtr *theProc) = {0x303C, 0x0203,0xAA68};extern Boolean editRegionCancelled;		typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;extern Boolean mousePlay;/*********** function prototypes *****************/extern short normaliseMaximum;Boolean normaliseFile(FSSpec mySpec,Boolean justRegion, long startPoint, long endPoint);void SDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos);Boolean isOdd(long theLong);pascal Boolean myPopFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);pascal void MyHiliteItemProc(WindowPtr theDialog, short theItem);pascal void MyPopProc(WindowPtr theDialog, short theItem);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);Boolean makeMeanAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel);Boolean makeMaxAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel);Boolean tempSwap;void calcZoomLevel(void);pascal Boolean myEditFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem);Boolean drawAudio(WindowPtr theDialog);pascal void EditUserProc(WindowPtr theDialog, short theItem);/*********** globals *************/long theChunk, theBytes;Boolean dontUpdate;RegionRec** theRgnHdl;Boolean drawMode;Boolean editPoint;Point ppp;long winstart,pixelAdvance;extern Boolean autoSustain;Handle theAudio;Boolean optionDown,shiftDown;short theWordSize;Boolean stereo;short leftMark,rightMark;long zoomLevel;  /* zoom level is in x *  frames / pixel if viewboth is on, it is calc'ed differently */	FSSpec theSpec;Boolean drawMarkers;/**********************************/extern Boolean rewriteOrig;Boolean editRegion(FSSpec mySpec,RegionRec** myRgnHdl);Boolean editRegion(FSSpec mySpec,RegionRec** myRgnHdl){	short itemHit,PopitemHit;					DialogPtr	myDlg, popDlg;				Handle	iHndl;					Rect	iRect;				short	iType;					Str255 tempStr;	long templong;	GrafPtr	savePort;	Point localPt;	Rect slideRect;	Handle iHndlL,iHndlR;	short keeph,linePoint;	GrafPtr	save2Port,save3Port, save4Port;	Boolean doneowt;	long thenewlong;	short winOffset;	Rect PopInvertRect,uRect;	Point popPoint;	RegionRec thetempRgn;	long thePopLong;	short PleftMark,PrightMark;	BitMap	saveMap, tempMap;	Rect	sRect, dRect;	long Pwinstart,PpixelAdvance;	Boolean PdrawMode;	OSErr	iErr;	long theXRate;	short theXWordSize;	Boolean Xstereo; 	long theXBytes;	GrafPtr saveMPort;	ModalFilterUPP xmyEditFilter = NewModalFilterProc(myEditFilter);	getSDIIData (mySpec, &theXRate, &theXWordSize, &Xstereo, &theXBytes);	if (theXWordSize == 3)	{		genError ("\pThis function does not support 24-bit files");		return;	}	/*drawMode = viewBoth;*/	drawMode = viewOne;	editPoint = editStart;	drawMarkers = true;	theRgnHdl = myRgnHdl;	theSpec = mySpec;	dontUpdate = false;	GetPort (&saveMPort);	myDlg = GetNewDialog(7495,0L,(WindowPtr)-1);	if (!myDlg)	{		ExitToShell();	}	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);		GetDItem(myDlg,3,&iType,&iHndl,&iRect);	SetDItem(myDlg,3,iType,(Handle)NewUserItemProc(MyItemProc),&iRect);		GetDItem(myDlg,4,&iType,&iHndl,&iRect);	winOffset = iRect.left;	SetDItem(myDlg,4,iType,(Handle)NewUserItemProc(EditUserProc),&iRect);		NumToString((*myRgnHdl)->StartFrame,tempStr);	GetDItem(myDlg,5,&iType,&iHndl,&iRect);	SetIText(iHndl,tempStr);		NumToString((*myRgnHdl)->StopFrame,tempStr);	GetDItem(myDlg,6,&iType,&iHndl,&iRect);	SetIText(iHndl,tempStr);		GetDItem(myDlg,12,&iType,&iHndl,&iRect);	SetIText(iHndl,(*myRgnHdl)->RegionName);		GetDItem(myDlg,20,&iType,&iHndl,&iRect);	SetDItem(myDlg,20,iType,(Handle)NewUserItemProc(MyHiliteItemProc),&iRect);	editPoint = editStart;	calcZoomLevel();	ShowWindow(myDlg);	GetPort(&save2Port);	SetPort(myDlg);	do	{		itemHit = -1;		ModalDialog(xmyEditFilter,&itemHit);				switch (itemHit)		{					case 21:				dontUpdate = false;				GetDItem(myDlg,21,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1); 				GetPort(&save4Port);				normaliseMaximum = 128;				rewriteOrig = true;				normaliseFile(mySpec,true, (**myRgnHdl).StartFrame, (**myRgnHdl).StopFrame);				InvalRect(&(myDlg->portRect));				SetPort(save4Port);								GetDItem(myDlg,21,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);  			break;						case 1:				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StartFrame);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StopFrame);								if ((*myRgnHdl)->StartFrame > (*myRgnHdl)->StopFrame)				{					long templong = (*myRgnHdl)->StartFrame;					(*myRgnHdl)->StartFrame = (*myRgnHdl)->StopFrame;					(*myRgnHdl)->StopFrame = templong;				}								GetDItem(myDlg,12,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								BlockMove (tempStr, (*myRgnHdl)->RegionName, 32L);			break;						case 7:				/* expand left */				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StartFrame);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StopFrame);				if ((*myRgnHdl)->StartFrame > (*myRgnHdl)->StopFrame)				{					long templong = (*myRgnHdl)->StartFrame;					(*myRgnHdl)->StartFrame = (*myRgnHdl)->StopFrame;					(*myRgnHdl)->StopFrame = templong;				}								if (editPoint == editStart)				{					(*myRgnHdl)->StartFrame -=  200L * theChunk;					if ((*myRgnHdl)->StartFrame < 0L )					(*myRgnHdl)->StartFrame = 0L;				}				else				{					(*myRgnHdl)->StopFrame -=  200L * theChunk;					if ((*myRgnHdl)->StopFrame <0L )					(*myRgnHdl)->StopFrame = 0L;				}								GetDItem(myDlg,5,&iType,&iHndl,&iRect);				NumToString((*myRgnHdl)->StartFrame,tempStr);				SetIText(iHndl,tempStr);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				NumToString((*myRgnHdl)->StopFrame,tempStr);				SetIText(iHndl,tempStr);				drawAudio(myDlg);			break;						case 9:				GetDItem(myDlg,9,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1);  				dontUpdate = false;				drawMode = viewOne;				zoomLevel *= 2L;				while (Button())				{				}				drawAudio(myDlg);				HiliteControl((ControlHandle)iHndl,0);  				/* zoom in */			break;			case 8:				GetDItem(myDlg,8,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1);  				dontUpdate = false;				drawMode = viewOne;				zoomLevel /= 2L;				if (zoomLevel < 1L)				{					zoomLevel = 1L;				}				while (Button())				{				}				drawAudio(myDlg);				HiliteControl((ControlHandle)iHndl,0);  				/* zoom out */			break;			case 10:				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1);  				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StartFrame);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StopFrame);								GetDItem(myDlg,12,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								BlockMove (tempStr, (*myRgnHdl)->RegionName, 32L);				autoSustain = true;								if ((*myRgnHdl)->StartFrame > (*myRgnHdl)->StopFrame)				{					long templong = (*myRgnHdl)->StartFrame;					(*myRgnHdl)->StartFrame = (*myRgnHdl)->StopFrame;					(*myRgnHdl)->StopFrame = templong;				}				//mousePlay = true;				SDIIRegionPlay(mySpec,0x3C,(((*myRgnHdl)->StartFrame) * (long)(Xstereo + 1) * (long)theXWordSize),(((*myRgnHdl)->StopFrame) * (long)(Xstereo +1) * (long)theXWordSize));			//mousePlay = false;				GetDItem(myDlg,10,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);   				/* audition */			break;						case 11:				/* expand right */				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StartFrame);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StopFrame);				if ((*myRgnHdl)->StartFrame > (*myRgnHdl)->StopFrame)				{					long templong = (*myRgnHdl)->StartFrame;					(*myRgnHdl)->StartFrame = (*myRgnHdl)->StopFrame;					(*myRgnHdl)->StopFrame = templong;				}								if (editPoint == editStart)				{   /* the bytes is zero */					(*myRgnHdl)->StartFrame +=  200L * theChunk;					if ((((*myRgnHdl)->StartFrame)*(long)(Xstereo + 1)*theXWordSize) > theXBytes )					(*myRgnHdl)->StartFrame = theXBytes / ((long)(stereo + 1)*theXWordSize) ;				}				else				{					(*myRgnHdl)->StopFrame +=  200L * theChunk;					if ((((*myRgnHdl)->StopFrame)*(long)(Xstereo + 1)*theXWordSize) > theXBytes )					(*myRgnHdl)->StopFrame = theXBytes / ((long)(stereo + 1)*theXWordSize) ;				}				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				NumToString((*myRgnHdl)->StartFrame,tempStr);				SetIText(iHndl,tempStr);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				NumToString((*myRgnHdl)->StopFrame,tempStr);				SetIText(iHndl,tempStr);				drawAudio(myDlg);			break;						case 19:				dontUpdate = false;				/* view both */				drawMode = viewBoth;				GetDItem(myDlg,5,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StartFrame);								GetDItem(myDlg,6,&iType,&iHndl,&iRect);				GetIText(iHndl,tempStr);								StringToNum(tempStr,&(*myRgnHdl)->StopFrame);				if ((*myRgnHdl)->StartFrame > (*myRgnHdl)->StopFrame)				{					long templong = (*myRgnHdl)->StartFrame;					(*myRgnHdl)->StartFrame = (*myRgnHdl)->StopFrame;					(*myRgnHdl)->StopFrame = templong;				}				GetDItem(myDlg,19,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1);  				while (Button())				{				}				drawAudio(myDlg);				HiliteControl((ControlHandle)iHndl,0);  			break;						case 17:				dontUpdate = false;				GetDItem(myDlg,17,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1);				GetDItem(myDlg,18,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);  				editPoint = editStart;				if (drawMode != viewBoth)				{					while (Button())					{					}					drawAudio(myDlg);				}			break;						case 18:				dontUpdate = false;				GetDItem(myDlg,17,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,0);   //InvertRect(&iRect);				GetDItem(myDlg,18,&iType,&iHndl,&iRect);				HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);				editPoint = editStop;				if (drawMode != viewBoth)				{					while (Button())					{					}					drawAudio(myDlg);				}											break;						case 4:				dontUpdate = false;				if (!optionDown)				{					GetDItem(myDlg,4,&iType,&iHndl,&iRect);					slideRect.top = iRect.top+1;					slideRect.bottom =  iRect.bottom-1;					GetPort(&savePort);					SetPort(myDlg);					if (shiftDown)					{						tempSwap = true;						if (editPoint == editStart)						{							editPoint = editStop;							GetDItem(myDlg,17,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,0);   //InvertRect(&iRect);							GetDItem(myDlg,18,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);						}						else						{							editPoint = editStart;							GetDItem(myDlg,17,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);							GetDItem(myDlg,18,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,0);   //InvertRect(&iRect);						}					}					else					{						tempSwap = false;					}					if (editPoint == editStart)					{						slideRect.left = leftMark;						slideRect.right = leftMark+1;					}					else					{						slideRect.left = rightMark;						slideRect.right = rightMark+1;					}					GetMouse(&localPt);					keeph = localPt.h;										GetDItem(myDlg,5,&iType,&iHndlL,&iRect);					GetDItem(myDlg,6,&iType,&iHndlR,&iRect);					doneowt = false;					while (Button())					{						GetMouse(&localPt);						if (localPt.h != keeph)						{							doneowt = true;							InvertRect(&slideRect);							slideRect.left = localPt.h;							slideRect.right = localPt.h+1;							InvertRect(&slideRect);							/* calc new pos and fill in to edit text fields */							keeph = localPt.h;							thenewlong = winstart + (pixelAdvance * (keeph - winOffset));							NumToString(thenewlong,tempStr);														if (editPoint == editStart)							{									SetIText(iHndlL,tempStr);								(*myRgnHdl)->StartFrame = thenewlong;								}							else							{								SetIText(iHndlR,tempStr);								(*myRgnHdl)->StopFrame = thenewlong;							}									}							}					if (doneowt)					{						if (editPoint == editStart)						{							GetDItem(myDlg,4,&iType,&iHndl,&iRect);							leftMark = keeph;							//InvertRect(&slideRect);						}						else						{							GetDItem(myDlg,4,&iType,&iHndl,&iRect);							rightMark = keeph;							//InvertRect(&slideRect);						}					}					/* do all the altering shit */					SetPort(savePort);					if (tempSwap)					{						if (editPoint == editStart)						{							editPoint = editStop;							GetDItem(myDlg,17,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,0);   //InvertRect(&iRect);							GetDItem(myDlg,18,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);						}						else						{							editPoint = editStart;							GetDItem(myDlg,17,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);							GetDItem(myDlg,18,&iType,&iHndl,&iRect);							HiliteControl((ControlHandle)iHndl,0);   //InvertRect(&iRect);						}					}				}				else	/* optionkey down */				{										dontUpdate = true;					PdrawMode = drawMode;					Pwinstart = winstart;					PpixelAdvance = pixelAdvance;										tempMap.baseAddr = (char *)( QDPtr )NewPtr( MAP_SIZE  );					tempMap.rowBytes = MAP_WBYTES;	// initialize needed fields					SetRect( &tempMap.bounds, 0,0, MAP_WIDE,MAP_HIGH );										saveMap =  myDlg->portBits;	//ClrQuickDraw uses &theGrafPtr(CPort)					SetPortBits( &tempMap );	// Color QuickDraw uses SetPortPix					EraseRect( &myDlg->portBits.bounds ); // or &theGrafPtr( CPort )					SetPortBits( &saveMap );	// SetPortPix reactivate on-screen canvas					sRect = dRect = myDlg->portRect;	// set source and destination rects					CopyBits(&myDlg->portBits,&tempMap, &sRect, &dRect, srcCopy, nil);															drawMarkers = false;					GetDItem (myDlg,(editPoint == editStart) ? 5 : 6,&iType,&iHndl,&iRect);					GetIText(iHndl,tempStr);					StringToNum(tempStr,&thePopLong);										BlockMove (*theRgnHdl,&thetempRgn, sizeof(RegionRec));					PleftMark = leftMark;					PrightMark = rightMark;					(**theRgnHdl).StartFrame = thePopLong - pixelAdvance;					if ((**theRgnHdl).StartFrame < 0L)						(**theRgnHdl).StartFrame = 0L;											(**theRgnHdl).StopFrame = thePopLong + pixelAdvance;										popDlg = GetNewDialog(7496,0L,(WindowPtr)-1);					SetPort (popDlg);					color.red = 0xFFFF;					color.green = 0xFFFF;					color.blue = 0xFFFF;					RGBBackColor(&color);					iErr = ResError();					if (!popDlg)					{						genErrorN("\pAn error occurred",iErr);					}					if (popDlg)					{						GetDItem(popDlg,4,&iType,&iHndl,&iRect);						PopInvertRect.top = iRect.top+1;						PopInvertRect.bottom = iRect.bottom-1;						linePoint = ((iRect.right - iRect.left) / 2) + iRect.left;						PopInvertRect.left = linePoint;						PopInvertRect.right = linePoint+1;						SetDItem(popDlg,4,iType,(Handle)NewUserItemProc(MyPopProc),&iRect);						GetDItem (popDlg,2,&iType,&iHndl,&iRect);						SetIText(iHndl,tempStr);						ShowWindow(popDlg);						GetPort(&save3Port);						SetPort(popDlg);						while (Button())						{						}						ModalDialog(xAlertFilter,&PopitemHit);						InvertRect(&PopInvertRect);						if (PopitemHit == 4)						{							while (Button())							{								GetMouse(&popPoint);								if (popPoint.h != linePoint)								{										InvertRect(&PopInvertRect);									linePoint = popPoint.h;									PopInvertRect.left = linePoint;									PopInvertRect.right = linePoint+1;									thePopLong = winstart + (pixelAdvance * (linePoint - iRect.left));									NumToString(thePopLong,tempStr);									GetDItem (popDlg,2,&iType,&iHndl,&uRect);									SetIText(iHndl,tempStr);									InvertRect(&PopInvertRect);								}							}						}												GetDItem (popDlg,2,&iType,&iHndl,&uRect);						GetIText(iHndl,tempStr);						SetPort(save3Port);					}					DisposDialog(popDlg);					SetPort (myDlg);					color.red = 56797;					color.green = 56797;					color.blue = 56797;					RGBBackColor(&color);					CopyBits(&tempMap,&myDlg->portBits, &sRect, &dRect, srcCopy, nil);					DisposePtr((Ptr)tempMap.baseAddr);	// free up canvas RAM					GetDItem (myDlg,(editPoint == editStart) ? 5 : 6,&iType,&iHndl,&iRect);					SetIText(iHndl,tempStr);					BlockMove (&thetempRgn,*theRgnHdl, sizeof(RegionRec));					leftMark = PleftMark;					rightMark = PrightMark;					drawMarkers = true;					winstart = Pwinstart;					pixelAdvance = PpixelAdvance;					drawMode = PdrawMode;					UpdtControl(myDlg,myDlg->visRgn);				}			break;						default:			break;		}			} while (itemHit !=1 && itemHit !=2);			SetPort(save2Port);	DisposDialog(myDlg);	SetPort (saveMPort);	editRegionCancelled = false;	if (itemHit == 2)	{		editRegionCancelled = true;		return false;	}	return true;}pascal Boolean myEditFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	OSErr	myErr;	Boolean	returnVal = false;	WindowPtr	temp;	ModalFilterUPP standardProc;	Point thePoint;	Cell XlCellCoords;	short iType;	Handle iHndl;	Rect iRect;	Point p;	char theChar;	short theQuay;		if(theEventIn->modifiers & optionKey)		optionDown = true;	else		optionDown = false;			if(theEventIn->modifiers & shiftKey)		shiftDown = true;	else		shiftDown = false;			if(theEventIn->what==updateEvt || theEventIn->what==activateEvt)	{		if (dontUpdate)		{			BeginUpdate(currentDialog);			EndUpdate(currentDialog);			return true;		}	}			if(theEventIn->what==updateEvt &&				(WindowPtr) theEventIn->message!=currentDialog)	{		/* if the update is for the dialog box, ignore it since the regular			ModalDialog function will redraw it as necessary.		*/		if (dontUpdate)			return true;		else			returnVal = false; //MyDrawProc((WindowPtr) theEventIn->message);	}	else	{		/* it wasn't an update, pass it on to the system filter */		//GetPort(&temp);/* save the current port, set to the dialog */		//SetPort(currentDialog);		/* necessary to track the edit cursor changes */		if(theEventIn->what==0)			return true;		#ifdef powerc				myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = CallUniversalProc(standardProc,uppModalFilterProcInfo,currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#else	myErr = GetStdFilterProc(&standardProc);		if(!myErr)		{			returnVal = ((ModalFilterProcPtr)standardProc)				(currentDialog,theEventIn,theDialogItem);			//SetPort(temp);		}#endif		ppp = theEventIn->where;		GlobalToLocal(&ppp);		if(theEventIn->what == keyDown) 		{			theQuay = (theEventIn->message) & keyCodeMask;			theChar = (theEventIn->message) & charCodeMask;						if ( (theChar == 0x0d) || (theChar == 0x03)) 			{					*theDialogItem = 1;					return TRUE;			}						if (theQuay == 0x3100  && (theEventIn->modifiers & shiftKey))			{					*theDialogItem = 10;					return true;			}						if (theQuay == 0x7B00)			{					*theDialogItem = 17;					return true;			}						if (theQuay == 0x7C00)			{					*theDialogItem = 18;					return true;			}		}		return returnVal;	}}pascal void EditUserProc(WindowPtr theDialog, short theItem){		drawAudio(theDialog);	}pascal void MyPopProc(WindowPtr theDialog, short theItem){	drawMode = viewBoth;	drawAudio(theDialog);	return;}pascal Boolean myPopFilter(DialogPtr currentDialog, EventRecord *theEventIn,short *theDialogItem){	return false;}pascal void MyHiliteItemProc(WindowPtr theDialog, short theItem){	Rect iRect;	Handle iHndl;	short	iType;				if (editPoint == editStart)	{		GetDItem(theDialog,17,&iType,&iHndl,&iRect);		HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);	}	else	{		GetDItem(theDialog,18,&iType,&iHndl,&iRect);		HiliteControl((ControlHandle)iHndl,1);   //InvertRect(&iRect);	}		GetDItem(theDialog,4,&iType,&iHndl,&iRect);	FrameRect(&iRect);}Boolean drawAudio(WindowPtr theDialog){	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	RgnHandle	curClip,newClipRgn;	short screenWidth,screenHite, spareHite;	long dataSize;	long viewStartPt, viewEndPt,editpoint;	long theRate,theDataWidth;	long theBytes;	long theFrames;	long leftLevel, rightLevel,prightLevel,pleftLevel;	short refNum;	short z;	OSErr	iErr;	short leftZeroLine, rightZeroLine;	short maxVolume;	short theLeftMark, theRightMark;	Rect	invRect;	long lFreeBytes;	if (dontUpdate && drawMarkers)	{		BeginUpdate(theDialog);		EndUpdate(theDialog);		return false;	}			getSDIIData (theSpec, &theRate, &theWordSize, &stereo, &theBytes);	if (theWordSize == 0)	{		return false;	}	PenSize(1,1);	theFrames = theBytes / (stereo + 1) / theWordSize;	curClip = NewRgn();	newClipRgn = NewRgn();		GetDItem(theDialog,4,&iType,&iHndl,&iRect);	RectRgn(newClipRgn,&iRect);	InsetRect(&iRect,1,1);	color.red = 0xFFFF;	color.blue = 0xFFFF;	color.green = 0xFFFF;	RGBForeColor (&color);	FillRect (&iRect,&qd.black);	color.red = 0;	color.blue = 0;	color.green = 0;	RGBForeColor (&color);	//EraseRect(&iRect);	GetClip(curClip);	SetClip(newClipRgn);		lFreeBytes = FreeMem();		screenWidth = iRect.right - iRect.left;	screenHite = iRect.bottom - iRect.top;		spareHite = screenHite;		leftZeroLine = ((spareHite / 4) + iRect.top);		spareHite = screenHite;		rightZeroLine = ((3 * (spareHite / 4)) + iRect.top);		maxVolume = (screenHite / 2);	editpoint = (editPoint == editStop) ? (**theRgnHdl).StopFrame : (**theRgnHdl).StartFrame;	dataSize = (**theRgnHdl).StopFrame - (**theRgnHdl).StartFrame;	viewStartPt = (drawMode == viewBoth) ? ((**theRgnHdl).StartFrame - (dataSize/10L))						 : editpoint - (((long)screenWidth / 2L) * (long)zoomLevel);						 						 	viewEndPt = (drawMode == viewBoth) ? ((**theRgnHdl).StopFrame + (dataSize/10L)) 						 : editpoint + (((long)screenWidth / 2L) * (long)zoomLevel);		if (viewStartPt < 0L)  /* the start display frame count */	{		viewStartPt = 0L;	}	if (viewEndPt > theFrames) /* the end of display frame count */	{ 		viewEndPt = theFrames;	}		theChunk = viewEndPt - viewStartPt; /* the number of frames displayed */		iErr = FSpOpenDF(&theSpec,fsCurPerm,&refNum);	if (iErr != 0)	{		SetClip(curClip);		return false;	}	iErr = SetFPos(refNum,1,(viewStartPt * (long)(stereo +1) * theWordSize));	if (iErr != 0)	{		SysBeep(5);		iErr = FSClose(refNum);		SetClip(curClip);		return false;	}		theChunk /= screenWidth;  /* now it becomes the number of frames per pixel */	if (!theChunk)		theChunk ++;			viewEndPt = (theChunk * screenWidth) + viewStartPt;		theDataWidth = theChunk * (long)screenWidth;		theLeftMark = (((**theRgnHdl).StartFrame - (long)viewStartPt) / (long)theChunk);	theRightMark = (long)screenWidth - (((long)viewEndPt - (**theRgnHdl).StopFrame) / (long)theChunk);		theAudio = NewHandle(65536);	if (!theAudio)	{		SysBeep(5);		return false;	}	for (z=0;z<screenWidth;z++)	{		makeMaxAudioFromFile (refNum, theChunk, stereo, theWordSize, &leftLevel, &rightLevel);		pleftLevel = leftLevel;		prightLevel = rightLevel;		if (theWordSize == 1)		{			leftLevel =  (leftLevel * (long)maxVolume) >> 8;			rightLevel =  (rightLevel * (long)maxVolume) >> 8;		}		else		{			leftLevel =  (leftLevel * (long)maxVolume) >> 8;			rightLevel =  (rightLevel * (long)maxVolume) >> 8;		}				if (leftLevel == 0L && pleftLevel>0L)		{			leftLevel = 1L;			}			if (rightLevel == 0L && prightLevel>0L)		{			rightLevel = 1L;			}					if (!stereo)			rightLevel = 0;					if (true)		{			MoveTo(iRect.left + z,leftZeroLine - LoWord(leftLevel));			LineTo(iRect.left + z,leftZeroLine + LoWord(leftLevel));			MoveTo(iRect.left + z,rightZeroLine - LoWord(rightLevel));			LineTo(iRect.left + z,rightZeroLine +LoWord( rightLevel));		}		if(Button()) 			z = screenWidth;	}	if (drawMode == viewBoth)			zoomLevel = theChunk;			DisposHandle (theAudio);	PenSize(1,1);		leftMark = iRect.left + (LoWord(theLeftMark));	rightMark = iRect.left + (LoWord(theRightMark));		invRect.top = iRect.top+1;	invRect.bottom = iRect.bottom-1;	invRect.left = leftMark;	invRect.right = leftMark + 1;	if (drawMarkers)		InvertRect(&invRect);		invRect.left = rightMark;	invRect.right = rightMark + 1;	if (drawMarkers)		InvertRect(&invRect);		if (leftMark >= iRect.left && leftMark <= iRect.right && rightMark>= iRect.left && rightMark <= iRect.right)		drawMode = viewBoth;		SetClip(curClip);	DisposeRgn(newClipRgn);	DisposeRgn(curClip);	iErr = FSClose(refNum);	winstart = viewStartPt;	pixelAdvance = theChunk;	return true;}void calcZoomLevel(void){	zoomLevel = 12L;}Boolean makeMeanAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel){	long theCount[2];	long theMacroCount[2];	long z,y,x, theTHRH;	SignedByte	theByte;	short theWord,theOtherWord;	long filePos;	long startPos;	short macroCount;	long inOutCount;	OSErr	iErr;	long divvy;		if (isOdd (theBytes))		theBytes--;	theBytes = (long)(theBytes * (long)(stereo + 1) * (long)wordSize);		if (!theBytes)	{		theBytes = 1L;	}	x = 0L;	theCount[0] = 0L;	theCount[1] = 0L;	theMacroCount[0] = 0L;	theMacroCount[1] = 0L;		iErr = GetFPos(refNum,&startPos);	if (iErr != 0)	{		return false;	}	filePos = startPos;	theCount[0] = 0L;	theCount[1] = 0L;	while ((filePos - startPos) < theBytes)	{		if ((theBytes - (filePos - startPos)) < 65536L)		{			inOutCount = (theBytes - (filePos - startPos));			if (isOdd (inOutCount))			{				inOutCount--;				if (!inOutCount)					inOutCount = 2L * (long)(stereo+1);			}		}		else		{			inOutCount = 65536L;		}		iErr = FSRead(refNum,&inOutCount,*theAudio);		if (iErr != 0)		{			return false;		}		iErr = GetFPos(refNum,&filePos);		if (iErr != 0)		{			return false;		}				for (z=0L;z< inOutCount;z += (long)(2L * (long)(stereo + 1)))		{			theTHRH = 0L;			y=0L;						while (y <= theTHRH)			{				if (wordSize == 1)				{					BlockMove ((*theAudio) + z + y,&theWord,2L);					theOtherWord = theWord;					theOtherWord = theOtherWord * 256;					theOtherWord = theOtherWord / 256;					theCount[y /2] += (long)(abs (theOtherWord));					theWord = theWord / 256;					theCount[y/2] += (long)(abs (theWord));					y += 2L;				}				if (wordSize == 2)				{					BlockMove ((*theAudio) + z + y,&theWord,2L);					theCount[y / 2] += (long)(abs(theWord));					y += 2L;				}				theTHRH = (long)((long)stereo * 2L);			}		}		theCount[0] /= ((long)(inOutCount)/(long)(stereo + 1));		theCount[1] /= ((long)(inOutCount)/(long)(stereo + 1));			theMacroCount[0] += theCount[0];		theMacroCount[1] += theCount[1];		x ++;	}	divvy = (wordSize==2) ? 255L : 1L;	if (!divvy)		divvy++;	*leftLevel = theMacroCount[0] / x / divvy;	*rightLevel = theMacroCount[1] / x / divvy;	return true;		}Boolean isOdd(long theLong){		if ((theLong - ((theLong / 2L) * 2L)) == 0L)		return false;	else		return true;}Boolean makeMaxAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel){	long theCount[2];	long theMacroCount[2];	long z,y,x, theTHRH;	SignedByte	theByte;	short theWord,theOtherWord;	long filePos;	long startPos;	short macroCount;	long inOutCount;	OSErr	iErr;	long divvy;		theBytes = (long)(theBytes * (long)(stereo + 1) * (long)wordSize);		/*if (isOdd (theBytes))		theBytes--;*/			if (!theBytes)	{		theBytes = 1L;	}	x = 0L;	theCount[0] = 0L;	theCount[1] = 0L;	theMacroCount[0] = 0L;	theMacroCount[1] = 0L;		iErr = GetFPos(refNum,&startPos);	if (iErr != 0)	{		return false;	}	filePos = startPos;		while ((filePos - startPos) < theBytes)	{		if ((theBytes - (filePos - startPos)) < 65536L)		{			inOutCount = (theBytes - (filePos - startPos));			if (isOdd (inOutCount))			{				inOutCount--;				if (!inOutCount)					inOutCount = 2L * (long)(stereo+1);			}		}		else		{			inOutCount = 65536L;		}		iErr = FSRead(refNum,&inOutCount,*theAudio);		if (iErr != 0)		{			return false;		}		iErr = GetFPos(refNum,&filePos);		if (iErr != 0)		{			return false;		}				for (z=0L;z< inOutCount;z += (long)(2L * (long)(stereo + 1)))		{			theTHRH = 0L;			y=0L;						while (y <= theTHRH)			{				if (wordSize == 1)				{					BlockMove ((*theAudio) + z + y,&theWord,2L);					theOtherWord = theWord;					theOtherWord = theOtherWord * 256;					theOtherWord = theOtherWord >> 8;					if ((long)(abs (theOtherWord)) > theCount[y /2])					{						theCount[y >> 1] = (long)(abs (theOtherWord));					}					theWord = theWord>> 8;					if ((long)(abs (theWord)) > theCount[y >> 1])					{						theCount[y >> 1] = (long)(abs (theWord));					}					y += 2L;				}				if (wordSize == 2)				{					//BlockMove ((*theAudio) + z + y,&theWord,2L);					//   *(short *)theWord = *(short *)((*theAudio) + z + y);					theWord = *(short *)((*theAudio) + z + y);					// XXX 										if (theWord < 0)					{						theWord = -theWord;						if ((long)theWord > theCount[y >> 1])						{							 theCount[y >> 1] = (long)theWord;						}					}					else					{						if ((long)theWord > theCount[y >> 1])						{							 theCount[y >> 1] = (long)theWord;						}					}														//  XXX	if ((long)(abs(theWord)) > theCount[y >> 1])				//	XXX {				//	XXX	 theCount[y >> 1] = (long)(abs(theWord));				//	XXX }										y += 2L;				}				theTHRH = (long)((long)stereo * 2L);			}		}		x ++;	}	divvy = (wordSize==2) ? 255L : 1L;	if (!divvy)		divvy++;			if (theCount[0] > 0L && ((theCount[0]/divvy) == 0L))	{		*leftLevel = 1L;	}	else	{		*leftLevel = theCount[0] / divvy;	}		if (theCount[1] > 0L && ((theCount[1]/divvy) == 0L))	{		*rightLevel = 1L;	}	else	{		*rightLevel = theCount[1] / divvy;	}	iErr = SetFPos(refNum,1,startPos + theBytes);	return true;		}Boolean ZmakeMaxAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel);Boolean ZmakeMaxAudioFromFile (short refNum, long theBytes, Boolean stereo, short wordSize, long* leftLevel, long* rightLevel){	long theCount[2];	long theMacroCount[2];	long z,y,x, theTHRH;	SignedByte	theByte;	short theWord,theOtherWord;	long filePos;	long startPos;	short macroCount;	long inOutCount;	OSErr	iErr;	long divvy;		if (isOdd (theBytes))		theBytes--;	theBytes = (long)(theBytes * (long)(stereo + 1) * (long)wordSize);		if (!theBytes)	{		theBytes = 1L;	}	x = 0L;	theCount[0] = 0L;	theCount[1] = 0L;	theMacroCount[0] = 0L;	theMacroCount[1] = 0L;		iErr = GetFPos(refNum,&startPos);	if (iErr != 0)	{		return false;	}	filePos = startPos;		while ((filePos - startPos) < theBytes)	{		if ((theBytes - (filePos - startPos)) < 65536L)		{			inOutCount = (theBytes - (filePos - startPos));			if (isOdd (inOutCount))			{				inOutCount--;				if (!inOutCount)					inOutCount = 2L * (long)(stereo+1);			}		}		else		{			inOutCount = 65536L;		}		iErr = FSRead(refNum,&inOutCount,*theAudio);		if (iErr != 0)		{			return false;		}		iErr = GetFPos(refNum,&filePos);		if (iErr != 0)		{			return false;		}				for (z=0L;z< inOutCount;z += (long)(2L * (long)(stereo + 1)))		{			theTHRH = 0L;			y=0L;						while (y <= theTHRH)			{				if (wordSize == 1)				{					BlockMove ((*theAudio) + z + y,&theWord,2L);					theOtherWord = theWord;					theOtherWord = theOtherWord * 256;					theOtherWord = theOtherWord / 256;					if ((long)(abs (theOtherWord)) > theCount[y /2])					{						theCount[y /2] = (long)(abs (theOtherWord));					}					theWord = theWord / 256;					if ((long)(abs (theWord)) > theCount[y /2])					{						theCount[y /2] = (long)(abs (theWord));					}					y += 2L;				}				if (wordSize == 2)				{					BlockMove ((*theAudio) + z + y,&theWord,2L);					if ((long)(abs(theWord)) > theCount[y / 2])					{						theCount[y / 2] = (long)(abs(theWord));					}					y += 2L;				}				theTHRH = (long)((long)stereo * 2L);			}		}		x ++;	}	divvy = (wordSize==2) ? 255L : 1L;	if (!divvy)		divvy++;	*leftLevel = theCount[0] / divvy;	*rightLevel = theCount[1] / divvy;	return true;		}