/*--------------------------------------------------------------------------*//*																			*//*		MCPlayMovie.														*//*			by John Wang													*//*																			*//*		Description:	This program demonstrates playing movies with		*//*			QuickTime movie controllers.  It also allows the user to save	*//*			the movies in a flattened format using FlattenMovie().			*//*																			*//*		Version:		1.0 Completed 11/17/91								*//*						1.1 Added palette support so that app restores		*//*							color table when changed by another app.		*//*																			*//*--------------------------------------------------------------------------*/#include "SampleSearch.h"#include "Globals.h"#include 	<Gestalt.h>#include	<Palettes.h>#include	"Movies.h"#define Gestalttest		0xA1AD#define NoTrap			0xA89F#define	appleID			128			#define	appleMenu		0#define	aboutMeCommand	1#define	fileID			129#define openCommand		1#define	flattenCommand	2#define closeCommand	3#define	quitCommand 	5#define	aboutMeDLOG		128#define	okButton		1#define	MAXWINDOWS		5Movie getMovieFromFile(FSSpec mySpec);#include "prefs.h"Boolean audioOnly = false;Boolean overViewPlay = false;FSSpec theMovieWeAreplaying;extern newPrefsRec theNewPrefs;Boolean Fileplaying = false;/*------------------------------------------------------*//*	Global Variables.									*//*------------------------------------------------------*/Boolean				DoneFlag = FALSE;MenuHandle			mymenu0, mymenu1;Boolean				playingMovie[MAXWINDOWS];Movie				myMovie[MAXWINDOWS];WindowPtr			myQTWindow[MAXWINDOWS];MovieController		mcPlay[MAXWINDOWS];short					startlocation;CTabHandle			mycolors;PaletteHandle		srcPalette;/*------------------------------------------------------*//*	getMovieFromFile().									*//*------------------------------------------------------*/Movie getMovieFromFile(FSSpec mySpec){	OSErr					err;	StandardFileReply		reply;	Point					where = {200, 50};	SFTypeList				types;	short					movieResRefNum;	short					actualResId;	Movie					theMovie;		types[0] = 'MooV';		/*StandardGetFilePreview(nil, 1, types, &reply);	if (!reply.sfGood) return((Movie) 0);*/	BlockMove (&mySpec,&reply.sfFile,70L);		err = OpenMovieFile(&reply.sfFile, &movieResRefNum, fsRdPerm);	if (GetMoviesError()) return((Movie) 0);	if (err) return ((Movie) 0);	actualResId = DoTheRightThing;	err = NewMovieFromFile((Movie *)&theMovie, movieResRefNum, &actualResId, (StringPtr) 0, newMovieActive, (Boolean *) 0);	if (GetMoviesError()) return((Movie) 0);	if (err) return ((Movie) 0);	err = CloseMovieFile(movieResRefNum);	if (GetMoviesError()) return((Movie) 0);	if (err) return ((Movie) 0);	return (theMovie);}extern Rect displayRect;/*------------------------------------------------------*//*	playMovie().											*//*------------------------------------------------------*/Boolean checkSDIIOverview(FSSpec mySpec);Rect			movieBounds;OSErr playMovie(short	index);OSErr playMovie(short	index){	Rect eraseRect;	short waveformH, waveFormV;	WindowPeek myPeek;	index = 0;	GetMovieBox(myMovie[index], &movieBounds);	OffsetRect(&movieBounds, -movieBounds.left, -movieBounds.top); /* set it to 0,0 */	overViewPlay = false;	if (movieBounds.bottom - movieBounds.top == 0)	{		audioOnly = true;		overViewPlay = true;		//if (checkSDIIOverview(theMovieWeAreplaying))	//	{		//	overViewPlay = true;	//	}	}	else	{		audioOnly = false;	}	if (audioOnly || isPressed(0x3A))	{		if (overViewPlay)		{		}		else		{			movieBounds.right = myWindow->portRect.right - 27;			SetMovieBox(myMovie[index], &movieBounds);			OffsetRect(&movieBounds, startlocation, startlocation);			myPeek = (WindowPeek)myWindow;	//		OffsetRect(&movieBounds, 0/*myWindow->*/, myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight);		}	}	else	{		SetMovieBox(myMovie[index], &movieBounds);		OffsetRect(&movieBounds, startlocation, startlocation);	}if (audioOnly && overViewPlay){	SetMovieGWorld(myMovie[index], (CGrafPtr) myWindow, 0);	SetRect(&movieBounds,0,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight -14,myWindow->portRect.right,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight);	mcPlay[index] = NewMovieController(myMovie[index], &movieBounds, mcTopLeftMovie);	MCGetControllerBoundsRect(mcPlay[index], &movieBounds);}else{	myQTWindow[index] = NewCWindow(0L, &movieBounds, "\ppress ESC to stop playback", 0, 0, (WindowPtr) -1, true, 0L);	SetPalette ((WindowPtr) myQTWindow[index], srcPalette, TRUE);	OffsetRect(&movieBounds, -startlocation, -startlocation);	startlocation += 50;	if (startlocation > 300) startlocation = 50;		SetMovieGWorld(myMovie[index], (CGrafPtr) myQTWindow[index], 0);	mcPlay[index] = NewMovieController(myMovie[index], &movieBounds, mcTopLeftMovie);	MCGetControllerBoundsRect(mcPlay[index], &movieBounds);	SizeWindow(myQTWindow[index], movieBounds.right - movieBounds.left,							movieBounds.bottom - movieBounds.top, TRUE);	if ((audioOnly || isPressed(0x3A)) && !overViewPlay)	{		MoveWindow(myQTWindow[index],(**(*myPeek).strucRgn).rgnBBox.left + 12,(**(*myPeek).strucRgn).rgnBBox.bottom - theNewPrefs.theWaveFormHeight + 1,true);	}	ShowWindow(myQTWindow[index]);}		/*if (GetMoviesError()) 		DebugStr("\pSetMovieGWorld error.");*//*	Uncomment these lines if you want to pre load the movie into ram.	Don't forget to increase the partition size when recompiling.		GotoBeginningOfMovie(myMovie[index]);	if (LoadMovieIntoRam(myMovie[index], GetMovieTime(myMovie[index], 0L),									GetMovieDuration(myMovie[index]),									0) != noErr)		DebugStr("\PNot enough memory to load movie into ram.");*/}/*------------------------------------------------------*//*	flatten().											*//*------------------------------------------------------*/short flatten(short index);short flatten(short index){	StandardFileReply		reply;	OSErr       theErr      = noErr;	StandardPutFile("\pName of flattened movie.", "\pUntitled", &reply);	if (!reply.sfGood) return; 	/*if (theErr = GetMoviesError()) 		DebugStr("\pCall Before FlattenMovies failed.");*/ 	FlattenMovie(myMovie[index],				flattenAddMovieToDataFork,				&reply.sfFile,				'JWJW',				0,				createMovieFileDeleteCurFile,				nil,				nil);					/*if (theErr = GetMoviesError()) 		DebugStr("\pFlattenMovies failed.");*/  	return(theErr);}/*------------------------------------------------------*//*	showAboutMeDialog()									*//*------------------------------------------------------*//*------------------------------------------------------*//*	init().												*//*------------------------------------------------------*/Boolean init(void);Boolean init(void){	OSErr				err;	short					i;	long				QDfeature, OSfeature;		/*	Set up variables.	*/	startlocation = 50;	for (i = 0; i < MAXWINDOWS; i++) {		playingMovie[i] = FALSE;		myQTWindow[i] = nil;	}	mycolors = GetCTable (72);	if (mycolors == nil) Debugger();	srcPalette = NewPalette (((**mycolors).ctSize)+1, mycolors, pmTolerant, 0);	/*	Use Gestalt to find if QuickDraw and QuickTime is available.	*/	/*if ((GetTrapAddress(Gestalttest) != GetTrapAddress(NoTrap))) 	{		err = Gestalt(gestaltQuickdrawVersion, &QDfeature);		if (err)			return false;		err = Gestalt(gestaltSystemVersion, &OSfeature);		if (err)			return false;		if (!DoneFlag && (QDfeature & 0x0f00) != 0x0200 && OSfeature < 0x0607)			return false;		err = Gestalt(gestaltQuickTime, &QDfeature);		if (err)			return false;	}	else		return false;*/		/*	Open QuickTime last.	*/	err = EnterMovies();	if (err)		return false;	Fileplaying = false;	return true;}/*------------------------------------------------------*//*	finish().											*//*------------------------------------------------------*/void finish(void);extern FSSpec theDisplayedFile;void drawSDIIToolBar(FSSpec mySpec);void finish(void){	short i;	for (i = 0; i < MAXWINDOWS; i++)		if (playingMovie[i] == TRUE) 		{			CloseComponent(mcPlay[i]);			DisposeMovie(myMovie[i]);if (audioOnly && overViewPlay){	drawSDIIToolBar(theDisplayedFile);	InvalRect (&movieBounds);}else{			DisposeWindow(myQTWindow[i]);} 			playingMovie[i] = FALSE;		}		ExitMovies();	return;}/*------------------------------------------------------*//*	doOpenCommand().										*//*------------------------------------------------------*/short thisMovie;void doOpenCommand(FSSpec mySpec);void doOpenCommand(FSSpec mySpec){	short			i, useThisIndex;		useThisIndex = -1;		/*	Search for the first window that is nil.	*/	for (i = MAXWINDOWS-1; i >= 0; i--)		if (myQTWindow[i] == nil)			useThisIndex = i;				/*	If index = -1, then it means that there are no windows avaiable.	*/	if (useThisIndex != -1) {		thisMovie = useThisIndex;		myMovie[useThisIndex] = getMovieFromFile(mySpec);		if (myMovie[useThisIndex] != 0) 		{			playMovie(useThisIndex);			playingMovie[useThisIndex] = TRUE;		}		else		{			SysBeep(5);		}	}}/*------------------------------------------------------*//*	doFlattenCommand().										*//*------------------------------------------------------*/void doFlattenCommand(void);void doFlattenCommand(void){	short			i, useThisIndex;	WindowPtr	myTempWindow;		/*	Flatten movie that is currently selected.	*/	myTempWindow = FrontWindow();	if (myTempWindow == nil) return;	for (i = 0; i < MAXWINDOWS; i++)		if (myQTWindow[i] == myTempWindow)			flatten(i);}/*------------------------------------------------------*//*	doCloseCommand().										*//*------------------------------------------------------*/void doCloseCommand(void);void doCloseCommand(void){	short		i, useThisIndex;	WindowPtr	myTempWindow;	/*	Close selected window.	*/	if (audioOnly && overViewPlay)	{		DisposeMovie(myMovie[0]);								playingMovie[0] = FALSE;				myQTWindow[0] = nil;		InvalRect (&movieBounds);	}	else	{		myTempWindow = FrontWindow();		if (myTempWindow == nil) return;		for (i = 0; i < MAXWINDOWS; i++)			if (myQTWindow[i] == myTempWindow) {				CloseComponent(mcPlay[i]);				DisposeMovie(myMovie[i]);				DisposeWindow(myTempWindow);				playingMovie[i] = FALSE;				myQTWindow[i] = nil;			}	}}/*------------------------------------------------------*//*	doCommand().										*//*------------------------------------------------------*/void doCommand(short what, FSSpec mySpec);void doCommand(short what, FSSpec mySpec){	switch (what) 	{		case openCommand:			doOpenCommand(mySpec);			break;		case flattenCommand:			doFlattenCommand();			break;		case closeCommand:			doCloseCommand();			break;		case quitCommand:			DoneFlag = TRUE;			break;		default:			break;	}	return;}/*------------------------------------------------------*//*	playMovies().											*//*------------------------------------------------------*/short playMovies(EventRecord *myEvent);short playMovies(EventRecord *myEvent){	short		i;	for (i = 0; i < MAXWINDOWS; i++)		if (playingMovie[i] == TRUE) 		{			if (MCIsPlayerEvent(mcPlay[i], myEvent))			{				return(TRUE);			}		}	return(FALSE);}/*------------------------------------------------------*//*	main().												*//*------------------------------------------------------*/void playMoviesMain(FSSpec mySpec, float startRatio);	void playMoviesMain(FSSpec mySpec, float startRatio){	short					i;	char			key;	Boolean			track;	long			growResult;	EventRecord 	myEvent;	WindowPtr		whichWindow;	short				yieldTime;	short				ret;	short theQuay;	Fixed playSpeed = 25.0;	long someFlags;	Fixed playRate = 0x00010000;	Boolean keysOn = true;	ComponentResult aCompRes;TimeValue durationTime;TimeValue setTime;short progressSoFar;	TimeValue aTime, lastTime;TimeRecord currentTime;	init();	yieldTime = 0;	theMovieWeAreplaying = mySpec;	doCommand(openCommand, mySpec);			//StartMovie	(myMovie[thisMovie]);			//	ComponentResult aCompRes;			durationTime = GetMovieDuration (myMovie[thisMovie]);if (startRatio != 0){	setTime = (TimeValue)((float)durationTime * startRatio);	SetMovieTimeValue (myMovie[thisMovie], setTime);}			StartMovie (myMovie[thisMovie]);		aCompRes = MCDoAction (mcPlay[0], mcActionSetKeysEnabled, &keysOn);		MCMovieChanged(mcPlay[0],myMovie[thisMovie]);	Fileplaying = true;/*	aCompRes = MCDoAction (mcPlay[0], mcActionPlay, &playSpeed);		Fileplaying = true;*/	for ( ;; ) 	{		/*	We can't just do ExitToShell because we must cann ExitMovies.	*/		if (DoneFlag)			finish();				if (audioOnly && overViewPlay)		{			aTime = GetMovieTime (myMovie[thisMovie], &currentTime);			if (durationTime)			{				progressSoFar = ((float)aTime / (float)durationTime) * 100;				if (aTime >= durationTime) 				{					doCloseCommand();					finish();					return;				}			}			else			{				doCloseCommand();				finish();				return;			}		}			ret = WaitNextEvent(everyEvent & ~updateMask, &myEvent, yieldTime, nil);				if (playMovies(&myEvent))				continue;				if (isPressed (0x35))		{			doCloseCommand();			finish();			return;		}			/*aCompRes = MCGetControllerInfo (mcPlay[0], &someFlags);		if (someFlags & mcInfoIsPlaying)		{			FlashMenuBar(0);		}*/		if (ret) 		{			switch (myEvent.what) 			{				case mouseDown:					switch (FindWindow(myEvent.where, &whichWindow)) 					{						case inSysWindow:								doCommand(closeCommand, mySpec);								doCommand(quitCommand, mySpec);							break;												case inContent:								doCommand(closeCommand, mySpec);								finish();								return;							break;						case inDrag:							DragWindow (whichWindow, myEvent.where, &qd.screenBits.bounds);							break;						case inGrow:							break;						case inGoAway:							track = TrackGoAway (whichWindow, myEvent.where);							if (track)								{								doCloseCommand();								finish();								return;							}							break;						case inZoomIn:							break;						case inZoomOut:							break;						default:							break;					}				break;				case keyDown:					theQuay = (myEvent.message) & keyCodeMask;						//theChar = (myEvent.message) & charCodeMask;					if (theQuay == 0x3100) 					{							/* play / stop */						if (!Fileplaying)						{							StartMovie	(myMovie[thisMovie]);							Fileplaying = true;						}						else						{							StopMovie	(myMovie[thisMovie]);							Fileplaying = false;						}					}					if (theQuay == 0x3500) 					{							doCloseCommand();							finish();							return;					}					if (theQuay == 0x0D00 && (myEvent.modifiers & cmdKey)) 					{							doCloseCommand();							finish();							return;					}				break;				case updateEvt:					for (i = 0; i < MAXWINDOWS; i++)					if (audioOnly && overViewPlay)					{					}					else					{							if ((WindowPtr) myEvent.message == myQTWindow[i]) 						{							BeginUpdate((WindowPtr) myQTWindow[i]);							EndUpdate((WindowPtr) myQTWindow[i]);						}					}					break;					case diskEvt:					break;				case activateEvt:					break;				case app4Evt:					break; 				default:					break;			}		}	}}void playMoviesMainMany(void);void playMoviesMainMany(void){	Cell theCell;	short theindex;	SetPt( &theCell, 0,0 );		/* start at top of list  */	if (LGetSelect( TRUE, &theCell, myList))  	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		playMoviesMain((*therealResults)[theindex],0);		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}}