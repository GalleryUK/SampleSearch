#include "SampleSearch.h"#include "Globals.h"short removeDoubles(short theNumberOfItems, Handle theInfoHan);long findSCLP(short localRefNum);short getDawnSCLPNameComment(short refNum, short index, short clipIndex, StringPtr	theName, StringPtr theComment, StringPtr thePath);short getDawnClipSizePath (short refNum, short index, long *theSize, StringPtr thePath);Boolean	getDawnComment (FSSpec mySpec);short OpenDawnFile (FSSpec theSpec);#include "undoStuff.h"void saveForUndo (void);Boolean	resolveDawn (FSSpec theSpec);Boolean	resolveDawn (FSSpec theSpec){	short myRefNum;	Str255 theName,theComment, thePath;	OSErr	iErr = 0, Err;	short clipLoop, editRecLoop;	Rect theRect;	Str255 theTempStr;	FSSpec	theTempSpec;	FInfo	theTempInfo;	short	localCounter = 0;	FInfo	**theTFInfo;	StandardFileReply	reply;	short theRLref,iRefNum;	long inOutCount, fileLength;	Handle	hString[499];	short itemHit;	short z;	Handle volumeRef[499];	Boolean goforit;			watchcursor(true);		theTFInfo = (FInfo **)NewHandle((1000L) * 16L);	if (!theTFInfo)	{		genError("\pCannot allocate memory for FInfo array");		return false;	}			myRefNum = OpenDawnFile (theSpec);	if (myRefNum <= 0)	{		watchcursor(false);		return false;	}	clipLoop = 1;	editRecLoop = 1;	goforit = false;				Err = FSpGetFInfo(&theSpec,&theTempInfo);	BlockMove(&theTempInfo,&((*theTFInfo)[localCounter]),16L);	BlockMove(&theSpec,&((*gTheResults)[localCounter]), 70L);	localCounter++;		while (iErr != -2 && !goforit)	{		while (iErr >= 0 && !goforit)		{			iErr = getDawnSCLPNameComment(myRefNum,editRecLoop,clipLoop,theName, theComment, thePath);						Err = FSMakeFSSpec(0,0,thePath,&theTempSpec);						Err = FSpGetFInfo(&theTempSpec,&theTempInfo);			/*if (Err != 0)			{				genError("\pAn item could not be located");				DisposHandle(theTFInfo);				watchcursor(false);				return;			}*/						BlockMove(&theTempSpec,&((*gTheResults)[localCounter]), 70L);			BlockMove(&theTempInfo,&((*theTFInfo)[localCounter]),16L);			localCounter++;						editRecLoop ++;			if ((iErr == -2))			{				goforit = true;				break;			}		}		clipLoop ++;		editRecLoop = 1;		iErr = 0;		if (goforit)			break;	}	FSClose(myRefNum);	/****************** here ***********************/		localCounter = removeDoubles(localCounter, (Handle)theTFInfo);	StandardPutFile("\pEnter a filename for the Instrument's list","\pResolved EDL",&reply);	if (reply.sfGood)	{		if (reply.sfReplacing)					iErr = FSpDelete(&reply.sfFile);		iErr = FSpCreate(&(reply.sfFile),'MgAl','SFlf',reply.sfScript);		if (iErr !=0 && iErr!= -48)		{			genError ("\pCan't create new list file");			DisposHandle((Handle)theTFInfo);			watchcursor(false);			return false;		}		if (iErr == -48)		{				ParamText("\pFile Exists, Okay to Delete ?",0,0,0);				color.red = 56797;			color.green = 56797;			color.blue = 56797;			RGBBackColor(&color);			itemHit = dAlert(1066,0);			if (itemHit == 2)			{				iErr = FSpDelete(&(reply.sfFile));				if (iErr != 0)					genError ("\pCan't delete");				iErr = FSpCreate(&(reply.sfFile),'MgAl','SFlf',reply.sfScript);				if (iErr != 0)					genError ("\pStill Can't create file");			}			}		iErr = FSpOpenDF(&(reply.sfFile),fsCurPerm,&theRLref);		if (iErr !=0)		{			genError ("\pCan't open new file");			DisposHandle((Handle)theTFInfo);			watchcursor(false);			return false;		}		inOutCount = 4L;		fileLength = localCounter * 70L;		iErr = FSWrite(theRLref,&inOutCount,&fileLength);		if (iErr !=0)		{			genError ("\pCan't write to list file");			DisposHandle((Handle)theTFInfo);			watchcursor(false);			return false;		}			inOutCount = localCounter *70L;		iErr = FSWrite(theRLref,&inOutCount,(*gTheResults));		if (iErr !=0)		{			genError ("\pCan't write to list file");			DisposHandle((Handle)theTFInfo);			watchcursor(false);			return false;		}			inOutCount = 4L;		fileLength = localCounter;		iErr = FSWrite(theRLref,&inOutCount,&fileLength);		if (iErr !=0)		{			genError ("\pCan't write to list file");			DisposHandle((Handle)theTFInfo);			watchcursor(false);			return false;		}			inOutCount = localCounter *16L;		iErr = FSWrite(theRLref,&inOutCount,(*theTFInfo));		if (iErr !=0)		{			genError ("\pCan't write to list file");			DisposHandle((Handle)theTFInfo);			watchcursor(false);			return false;		}			iErr = FSClose (theRLref);			if (iErr !=0)			genError ("\pProblem closing file ");				/****************************/		DisposHandle((Handle)theTFInfo);		gogetvolref();	iRefNum = CurResFile();		HCreateResFile(reply.sfFile.vRefNum,reply.sfFile.parID,reply.sfFile.name);	iErr = ResError();	if (iErr!=0)		genError("\pCould not create resource file");	myRefNum = HOpenResFile(reply.sfFile.vRefNum,reply.sfFile.parID,reply.sfFile.name,fsCurPerm);		if (myRefNum == -1)		genError("\pCould not open new resource fork");	UseResFile(myRefNum);		iErr = ResError();		if (iErr!=0)		genError("\pCould not use new resource fork");	for (z=1;z<=volumearrayptr;z++)	{			hString[z] = NewHandle(256);		if (!hString[z])		{			genError ("\pMemory Allocation Failed");			watchcursor(false);			UseResFile(iRefNum);			return false;		}		volumeRef[z] = NewHandle(2);		if (!volumeRef[z])		{			genError ("\pMemory Allocation Failed");			watchcursor(false);			UseResFile(iRefNum);			return false;		}		BlockMove(volName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");		**(volumeRef[z]) = volumes[z];		AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			watchcursor(false);			UseResFile(iRefNum);			return false;		}	}	for (z=volumearrayptr+1;z<=fvolumearrayptr;z++)	{			hString[z] = NewHandle(256);		if (!hString[z])		{			genError ("\pMemory Allocation Failed");			watchcursor(false);			return false;		}		volumeRef[z] = NewHandle(2);		if (!volumeRef[z])		{			genError ("\pMemory Allocation Failed");			watchcursor(false);			UseResFile(iRefNum);			return false;		}		BlockMove(fvolName[z],*hString[z],28L);		AddResource(hString[z],'oVOL',z,"\pVolume Name for list");		iErr = ResError();		if (iErr!=0)			genError("\pCould not add resource");		**(volumeRef[z]) = volumes[z];		AddResource(volumeRef[z] ,'oREF',z,"\pVRefNum reference");		iErr = ResError();		if (iErr != 0)		{			genError ("\pCan't create resource");			watchcursor(false);			UseResFile(iRefNum);			return false;		}	}				CloseResFile(myRefNum);	UseResFile(iRefNum);	iErr = ResError();	if (iErr!=0)		genError("\pCould not use old resource file");			for (z=1;z<=fvolumearrayptr;z++)	{		ReleaseResource(volumeRef[z]);		ReleaseResource(hString[z]);	}	/******************************/	ParamText ("\pOpen resolved bank immediately ?",0,0,0);	itemHit = dAlert (1066,0);	if (itemHit == 2)	{		saveForUndo ();		openFSList((reply.sfFile));		checkList();		gogetvolref();		resolveOVols();	}   }   else   {   	 watchcursor(false);  	 return 0;   }}short OpenDawnFile (FSSpec theSpec){	short refNum;	OSErr	iErr;		iErr = FSpOpenDF(&theSpec,fsCurPerm,&refNum);	if (!iErr)		return refNum;	else		return iErr;}short getDawnSCLPNameComment(short refNum, short index,short clipIndex,StringPtr theName,StringPtr theComment, StringPtr thePath){	OSErr	iErr;	long theCount,theTotCount;	long inOutCount;	long tempCount, theRecordSize;	Byte theChar;	short counter;	long numberOfRecs;		iErr = SetFPos(refNum,1,0L);	if (iErr!=0)	{		return iErr;	}		theTotCount = 0;		for (counter = 0;counter < clipIndex;counter ++)	{		theCount = findSCLP(refNum);		if (!theCount)			return -2;		theTotCount = theCount;		iErr = SetFPos(refNum,3,4L);		if (iErr!=0)		{			return iErr;		}	}	iErr = SetFPos(refNum,1,theTotCount + 38L);	if (iErr!=0)	{		return iErr;	}	tempCount = 1;	iErr = FSRead(refNum,&tempCount,&theChar);	if (iErr!=0)	{		return iErr;	}	inOutCount = (long)theChar;	inOutCount ++;	iErr = SetFPos(refNum,3,-1L);	if (iErr!=0)	{		return iErr;	}		iErr = FSRead(refNum,&inOutCount,theName);	/* read the name */	if (iErr!=0)	{		return iErr;	}	tempCount = 1;	iErr = FSRead(refNum,&tempCount,&theChar);	if (iErr!=0)	{		return iErr;	}	inOutCount = (long)theChar;	inOutCount ++;	iErr = SetFPos(refNum,3,-1L);	if (iErr!=0)	{		return iErr;	}	iErr = FSRead(refNum,&inOutCount,theComment);	/* read the comment */	if (iErr!=0)	{		return iErr;	}	iErr = GetFPos(refNum,&inOutCount);	iErr = SetFPos(refNum,3,2L);	if (iErr!=0)	{		return iErr;	}	tempCount = 1;	iErr = FSRead(refNum,&tempCount,&theChar);	/* skip next str */	if (iErr!=0)	{		return iErr;	}	inOutCount = (long)theChar;	iErr = SetFPos(refNum,3,inOutCount);	if (iErr!=0)	{		return iErr;	}	iErr = GetFPos(refNum,&inOutCount);	tempCount = 4;	iErr = FSRead(refNum,&tempCount,&inOutCount);	/* skip handle */	if (iErr!=0)	{		return iErr;	}	iErr = SetFPos(refNum,3,inOutCount);	if (iErr!=0)	{		return iErr;	}	iErr = GetFPos(refNum,&inOutCount);	tempCount = 4;	iErr = FSRead(refNum,&tempCount,&inOutCount);	/* skip handle */	if (iErr!=0)	{		return iErr;	}	iErr = SetFPos(refNum,3,inOutCount);	if (iErr!=0)	{		return iErr;	}	iErr = GetFPos(refNum,&inOutCount);	iErr = SetFPos(refNum,3,23L);	if (iErr!=0)	{		return iErr;	}	tempCount = 4;	iErr = FSRead(refNum,&tempCount,&inOutCount);	/* skip handle */	if (iErr!=0)	{		return iErr;	}	iErr = SetFPos(refNum,3,inOutCount);	if (iErr!=0)	{		return iErr;	}		iErr = GetFPos(refNum,&inOutCount);	if (iErr!=0)	{		return iErr;	}	tempCount = 4;	iErr = FSRead(refNum,&tempCount,&inOutCount);	/* skip handle */	if (iErr!=0)	{		return iErr;	}	iErr = SetFPos(refNum,3,inOutCount * 4L);	if (iErr!=0)	{		return iErr;	}	iErr = GetFPos(refNum,&inOutCount);	tempCount = 4;	iErr = FSRead(refNum,&tempCount,&theRecordSize);	if (iErr!=0)	{		return iErr;	}	numberOfRecs = theRecordSize / 476L;		if ((long)index > numberOfRecs)	{		return -1;	}		for (counter = 0;counter < index;counter ++)	{		iErr = SetFPos(refNum,3,156L);		if (iErr!=0)		{			return iErr;		}		iErr = GetFPos(refNum,&inOutCount);		if (iErr!=0)		{			return iErr;		}				inOutCount = 256;		iErr = FSRead(refNum,&inOutCount,thePath);	/* read the pathName */		if (iErr!=0)		{			return iErr;		}		iErr = SetFPos(refNum,3,64L);		if (iErr!=0)		{			return iErr;		}	}	return 0;}short getDawnClipSizePath (short refNum, short index, long *theSize,StringPtr thePath){}long findSCLP(short localRefNum){	OSErr	iErr;	Handle	myTempStore;	long inOutCount, currentPos;	long lOffset;	OSType	filpType = 'SCLP';	short passes = 0;	iErr = GetFPos(localRefNum, &currentPos);		myTempStore = NewHandle(500);	if (!myTempStore)	{		genError ("\pCannot allocate memory for SCLP handle");		return 0;	}	while (iErr != eofErr)	{		inOutCount = 490;		iErr = FSRead(localRefNum,&inOutCount,*myTempStore);		if (iErr!=0 && iErr !=eofErr)			return 0;		lOffset = Munger(myTempStore,0,&filpType,4,nil,0);		if (lOffset >= 0)		{			DisposHandle((Handle)myTempStore);			return lOffset + (passes*490) + currentPos;		}		passes ++;	}	DisposHandle((Handle)myTempStore);	return 0;}short removeDoubles(short theNumberOfItems, Handle theInfoHan){	OSErr	iErr;	short z,y;	Boolean foundOne;	Boolean keepIt[1000];		for (z=0;z<theNumberOfItems;z++)	{		keepIt[z] = true;	}		for (z=0; z<theNumberOfItems;z++)	{		if (keepIt[z])		{			for (y=z;y<theNumberOfItems;y++)			{				if(EqualString((*gTheResults)[z].name,(*gTheResults)[y].name,true,true)) 				{					keepIt[y] = false;				}			}		}	}	for (z=0;z<(theNumberOfItems-1);z++)	{		if (!keepIt[z])		{			BlockMove(&(*gTheResults)[z+1],&(*gTheResults)[z],(theNumberOfItems * 70L) - ((z+1L)*70L));			BlockMove(&(*theInfoHan)[z+1],&(*theInfoHan)[z],(theNumberOfItems * 16L) - ((z+1L)*16L));			theNumberOfItems --;		}	}	}