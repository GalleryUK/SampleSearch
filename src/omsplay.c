/*	Sample OMS Application	Doug Wyatt, 12/8/92		Font: Monaco 9, 4 spaces per tab stop		This program illustrates the following:		Determining whether OMS is present		Signing into and out of OMS		Structure of the appHook		Using OMS's compatibility mode to determine whether to use MIDI Manager		Responding to suspend/resume events (remember to set the appropriate			bit in your SIZE resource!).		Creating and maintaining OMSDeviceMenus.		Receiving and sending MIDI.			©1992 Opcode Systems Inc.*/#include "OMS.h"#include "OMSDeviceMenu.h"void SDIIPlay(FSSpec,short playFreq);unsigned char	MIDIlen = 0;unsigned char	Mididata[4];#if UseMIDIMgr#include <MIDI.h>#endifextern FSSpec theDisplayedFile;#define MySignature		'Smpl'	/*	Creator ID of this sample application, also used as the OMS client ID.  Change to match your application's creator ID. */#define InputPortID		'in  '#define OutputPortID	'out '/* Globals */Boolean	gMIDIMgrExists;			/* is MIDI Manager present? */Boolean	gSignedInToMIDIMgr;		/* are we signed into MIDI Manager? */Boolean gNodesChanged;short	gInputPortRefNum;		/* refNum of the OMS input port */short	gOutputPortRefNum;		/* refNum of the OMS output port */short	gCompatMode;			/* current OMS compatibility mode */OMSDeviceMenuH	gInputMenu, gOutputMenu;short 	gChosenInputID = 0;		/* uniqueID of selected input; 0 means none */short	gChosenOutputID = 0;	/* uniqueID of selected output; 0 means none */short	gOutNodeRefNum = -1;	/* node refNum of the selected output; -1 means non									existant */void	SignInToMIDIMgr(void);void	SignInToMIDIMgr(void){	/* whatever you want to do */	gSignedInToMIDIMgr = TRUE;}void	SignOutFromMIDIMgr(void);void	SignOutFromMIDIMgr(void){	/* whatever you want to do */	gSignedInToMIDIMgr = FALSE;}void	CheckSignInOrOutOfMIDIManager(void);void	CheckSignInOrOutOfMIDIManager(void){	/* Make sure MIDI Manager is installed; it's possible (but unlikely) that OMS will		say that the compatibility mode is omsModeUseMIDIMgr though MIDI Manager is		not present */	if (!gMIDIMgrExists)		return;	if (gCompatMode == omsModeUseMIDIMgr) {		if (!gSignedInToMIDIMgr)			SignInToMIDIMgr();	} else {		if (gSignedInToMIDIMgr)			SignOutFromMIDIMgr();	}}/*	If opening is true, open a connection to the device specified by gChosenInputID.	If false, close the connection.		This is overly simplistic; applications should support multiple input	devices enabled simultaneously, typically using OMSChooseNodes.*/void	OpenOrCloseConnection(Boolean opening);void	OpenOrCloseConnection(Boolean opening){	OSErr err;	OMSConnectionParams conn;		if (gChosenInputID == 0)		return;	conn.nodeUniqueID = gChosenInputID;	conn.appRefCon = 0;		/* not used in this example */	if (opening)		err = OMSOpenConnections(MySignature, InputPortID, 1, &conn, FALSE);	else OMSCloseConnections(MySignature, InputPortID, 1, &conn);}void	InputMenuSideEffects(void);void	InputMenuSideEffects(void){	OpenOrCloseConnection(FALSE);	gChosenInputID = (*gInputMenu)->select.uniqueID;	OpenOrCloseConnection(TRUE);}void	OutputMenuSideEffects(void);void	OutputMenuSideEffects(void){	gChosenOutputID = (*gOutputMenu)->select.uniqueID;	gOutNodeRefNum = (*gOutputMenu)->selectedRefNum;	// play a chromatic scale to the destination on channel 1	{		short note;		OMSMIDIPacket pkt;		long delTime;				for (note = 60; note < 72; ++note) {			pkt.flags = 0;			pkt.len = 3;			pkt.data[0] = 0x90;	// noteon, channel 1			pkt.data[1] = note;			pkt.data[2] = 64;	// velocity			OMSWritePacket2(&pkt, gOutNodeRefNum, gOutputPortRefNum);						Delay(10L, (unsigned long *)&delTime);	// hold the note down						pkt.data[2] = 0;	// velocity = 0 is note-off			OMSWritePacket2(&pkt, gOutNodeRefNum, gOutputPortRefNum);		}	}}pascal void MyAppHook(OMSAppHookMsg *pkt, long myRefCon);pascal void MyAppHook(OMSAppHookMsg *pkt, long myRefCon){#ifdef THINK_C	/*	Set up A5 for access to globals during this routine. */	asm {		move.l	a5,-(sp)		; save previous A5		move.l	myRefCon,a5		; set up A5 from myRefCon	}#elif __MWERKS__	long olda5 = SetA5(myRefCon);#endif		switch (pkt->msgType) {	case omsMsgModeChanged:		/* Respond to compatibility mode having changed */		gCompatMode = pkt->u.modeChanged.newMode;		/* this will cause side effects in the event loop */		break;	case omsMsgDestDeleted:		if (gChosenOutputID == pkt->u.nodeDeleted.uniqueID) {			gOutNodeRefNum = -1;	/* invalid */		}		break;	case omsMsgNodesChanged:		gNodesChanged = TRUE;		break;	}#ifdef THINK_C	asm {		move.l	(sp)+,a5		; restore previous A5	}#elif __MWERKS__	SetA5(olda5);#endif}pascal void	MyReadHook(OMSPacket *pkt, long myRefCon);pascal void	MyReadHook(OMSPacket *pkt, long myRefCon){	/*	Set up A5 for access to globals during this routine. */#ifdef THINK_C	asm {		move.l	a5,-(sp)		; save previous A5		move.l	myRefCon,a5		; set up A5 from myRefCon	}#elif __MWERKS__	long olda5 = SetA5(myRefCon);#endif		/*	Process the MIDI packet as efficiently as possible.  It is guaranteed to be MIDI		data, not some high-level event.  The applicationÕs refCon (appRefCon) that was 		passed to OMSOpenConnection is in the low order word of pkt->tStamp. 		A convenient way for an application to determine the source of the MIDI data is for 		it to pass a number identifying the source as the appRefCon to OMSOpenConnection.		The high-order word of pkt->tStemp is the sourceÕs ioRefNum (not its uniqueID); 		applications can also look at this to determine the source of the MIDI data. */		/*	This sample program merely echoes input to the selected output */	if (gOutNodeRefNum != -1)	{		OMSWritePacket(pkt, gOutNodeRefNum, gOutputPortRefNum);		MIDIlen = pkt->len;		BlockMove(&pkt->data[0],&Mididata[0],4L);	}	#ifdef THINK_C	asm {		move.l	(sp)+,a5		; restore previous A5	}#elif __MWERKS__	SetA5(olda5);#endif}OSErr	InitOMS(OSType appSignature, OSType inPortID, OSType outPortID);OSErr	InitOMS(OSType appSignature, OSType inPortID, OSType outPortID){	OSErr err;	OMSAppHookUPP appHook;	OMSReadHookUPP readHook;	#if UseMIDIMgr	gMIDIMgrExists = (SndDispVersion(midiToolNum) != 0);#else	gMIDIMgrExists = FALSE;#endif	gSignedInToMIDIMgr = FALSE;		/*	Find out what version of OMS is installed, if any. */	if (OMSVersion() == 0) {		/*	If OMSVersion returns 0, OMS is not installed.			A program which can work without OMS might maintain a global			boolean to indicate whether OMS is present. */		return 1;	/* any old error number */	}	#ifdef powerc	appHook = NewOMSAppHook(MyAppHook);	readHook = NewOMSReadHook(MyReadHook);#else	appHook = MyAppHook;	readHook = MyReadHook;#endif		/*	Sign in to OMS */	err = OMSSignIn(appSignature, /*oldA5 = */SetCurrentA5()/*;(long)LMGetCurrentA5()*/, "\pSampleSearch.¹"/*(StringPtr)LMGetCurApName()*/, appHook, &gCompatMode);	/*	Passing CurrentA5 as the refCon solves the problem of A5 setup in the appHook.		Using other Apple-recommended techniques for setting up A5 in the appHook		are fine as well.  The client name will be the same as the application's name,		as stored in the low-memory global CurApName. */		if (err)		return err;		/*	Add an input port */	err = OMSAddPort(appSignature, inPortID, omsPortTypeInput, (OMSReadHook2UPP)readHook, 		(long)SetCurrentA5()/*LMGetCurrentA5()*/, &gInputPortRefNum);	if (err) goto errexit;		/*	Add an output port */	err = OMSAddPort(appSignature, outPortID, omsPortTypeOutput, NULL, 0L,		 &gOutputPortRefNum);	if (err) goto errexit;			return noErr;errexit:		OMSSignOut(appSignature);		return err;}/* ------------------------------------- User interface ---------------------------- */void	InitToolbox(void);void	InitToolbox(void){	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents( everyEvent, 0 );	InitWindows();	InitMenus();	TEInit();	InitDialogs(0L);	InitCursor();}void	BuildWindow(void);void	BuildWindow(void){	WindowPtr win;	Rect menuRect;		win = GetNewWindow(126, NULL, (WindowPtr)-1L);	SetPort(win);	/* NewOMSDeviceMenu attaches window to current port */		SetRect(&menuRect, 10,10, 150,26);	gInputMenu = NewOMSDeviceMenu(NULL, odmFrameBox, &menuRect, 		omsIncludeInputs + omsIncludeReal + omsIncludeVirtual, NULL);	SetRect(&menuRect, 10,40, 150,56);	gOutputMenu = NewOMSDeviceMenu(NULL, odmFrameBox, &menuRect, 		omsIncludeOutputs + omsIncludeReal + omsIncludeVirtual, NULL);}void	DoQuit(void);void	DoQuit(void){	WindowPtr pWindow = FrontWindow();	DisposeWindow(pWindow);	if (gSignedInToMIDIMgr)		SignOutFromMIDIMgr();	OMSSignOut(MySignature);	return; }void	EventLoop(void);void	EventLoop(void){	EventRecord theEvent;	short winPart;	WindowPtr whichWin;	Point pt;	Boolean alldone = false;	while (!alldone) {		/*	Use this deferral mechanism of dealing with MIDI Manager in response			to null events.  The appHook may be called at a level where the application's			resources are not available.  But now the resources are available. */		CheckSignInOrOutOfMIDIManager();		if (gNodesChanged) {			gNodesChanged = FALSE;			RebuildOMSDeviceMenu(gInputMenu);			InputMenuSideEffects();			RebuildOMSDeviceMenu(gOutputMenu);			OutputMenuSideEffects();		}				if (WaitNextEvent(everyEvent, &theEvent, 1L, NULL)) {			switch (theEvent.what) {			case updateEvt:				whichWin = (WindowPtr)theEvent.message;				SetPort(whichWin);				BeginUpdate(whichWin);				DrawOMSDeviceMenu(gInputMenu);				DrawOMSDeviceMenu(gOutputMenu);				EndUpdate(whichWin);				break;			case mouseDown:				winPart = FindWindow(theEvent.where, &whichWin);				switch (winPart) {				case inGoAway:					if (TrackGoAway(whichWin, theEvent.where))					{						DoQuit();						alldone = true;					}					break;				case inContent:					pt = theEvent.where;					SetPort(whichWin);					GlobalToLocal(&pt);					if (TestOMSDeviceMenu(gInputMenu, pt)) {						if (ClickOMSDeviceMenu(gInputMenu)) {							InputMenuSideEffects();						}					} else if (TestOMSDeviceMenu(gOutputMenu, pt)) {						if (ClickOMSDeviceMenu(gOutputMenu)) {							OutputMenuSideEffects();						}					}					break;				}				break;			case app4Evt:				if (theEvent.message & 0x01000000) {	/* suspend/resume */					if (theEvent.message & 0x00000001) {						OMSResume(MySignature);						/* add whatever else to resume your application */					} else {						OMSSuspend(MySignature);						/* add whatever else to suspend your application */					}				}				break;			}		} else 		{			/* null event */			if (MIDIlen > 0)			{				if (Mididata[0] == 0x90)				{					SDIIPlay(theDisplayedFile,Mididata[1]);				}			//	Debugger();				/*Mididata[4];*/						}			MIDIlen = 0;		}	}}#if 0void	TestClientVirtualNodes(void);void	TestClientVirtualNodes(void){	OMSClientListH clients = OMSGetClients();	short iclient;		for (iclient = (*clients)->numClients; --iclient >= 0; ) {		OMSSignature clientID = (*clients)->client[iclient].clientID;		OMSVirtualNodeIDListH nodes = OMSGetClientVirtualNodes(clientID);		OMSDisposeHandle(nodes);	}	OMSDisposeHandle(clients);}#endifvoid	OMSmain(void);void	OMSmain(void){	if (InitOMS(MySignature, InputPortID, OutputPortID) != noErr)		/*	This sample program requires OMS and so will just			quit if it's not present or if some error prevents using OMS. */		return;	BuildWindow();	EventLoop();}