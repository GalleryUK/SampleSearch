#include "SampleSearch.h"#include "Globals.h"#include <Gestalt.h>#include <Movies.h>#include "displayPictures.h"#include <QuickTimeComponents.h>Boolean AIFFNormalPlay (FSSpec mySpec, short playFreq);extern Boolean DblBuffAudition;void SDIPlay(FSSpec mySpec, short playFreq);void SDIIPlay(FSSpec mySpec, short playFreq);extern Boolean DialogPresent;void AIFFtoSnd(FSSpec mySpec,short playFreq);void SC2InstPlay(FSSpec mySpec);extern long dblBufferSize;void checkForREX(StringPtr theName,FInfo * theFinfo);void WAVPlay(FSSpec mySpec, short playFreq);Boolean pleaseStop(void);void checkForWAV(StringPtr theName,FInfo * theFinfo);extern short keyAcrossTheTop[14];extern Fixed keyRatio[14];#include "prefs.h"void playMoviesMain(FSSpec mySpec, float startRatio);extern newPrefsRec theNewPrefs;extern Boolean autoCalcOverviews;short playRegionFromSelection(FSSpec theFile,short playFreq, Rect DisplayRect,short startHoriz, short endHoriz);#include "aifcplay.h"void outLineCell (Cell theCell, ListHandle theList);void unOutLineCell (Cell theCell, ListHandle theList);Boolean needToFixInvert = false;void KRZPlay(FSSpec mySpec, short playFreq);typedef struct listFontRec {Str255 fontName;short fontSize;} listFontRec, *listFontRecPtr;void OldSDIPlay(FSSpec mySpec);void OldSDIIPlay(FSSpec mySpec);void playMoviesMainMany(void);Boolean VgetvolName(short theVRefNum, StringPtr myString);   void checkForKRZ(StringPtr theName,FInfo * theFinfo);short AIFFplayRegionFromSelection(FSSpec theFile,short playFreq,Rect DisplayRect,short startHoriz, short endHoriz);void checkForMPG(StringPtr theName,FInfo * theFinfo);OSErr SDIISplitAudition(FSSpec theFile1, FSSpec theFile2);short countSelections(void);OSErr getFirst2Selections (FSSpec * theFile1, FSSpec * theFile2);Boolean checkFilesAreSDIISplitPartners(FSSpec theFile1, FSSpec theFile2);	OSErr sendFileToRex(FSSpec theTransferredFile);OSErr decodemain(FSSpec fs1, FSSpec fs2,short actionType);void Radar16Play(FSSpec mySpec);extern unsigned long myEventID;	//kAEOpenDocumentsextern unsigned long myEventClass;  //kCoreEventClass	void OldSDIIPlay(FSSpec mySpec);extern listFontRec  theFontRec;extern Boolean playFromList;extern Boolean waveFormSelected;extern Rect selectRect, zRect;//OSErr testCall(void);void Audition(FSSpec mySpec, short playFreq){	OSErr	myErr;	SndChannel	*mySndChan;	OSErr	iErr;	short	fRefNum;	Point	where;	Ptr	pNew;	Str255 fgh;	short kj;	FInfo	fndrInfo;	long response;	mySndChan = 0;	where.h=50;where.v=200;		keyAcrossTheTop[0] = 0x32;keyAcrossTheTop[1] = 0x12;keyAcrossTheTop[2] = 0x13;keyAcrossTheTop[3] = 0x14;keyAcrossTheTop[4] = 0x15;keyAcrossTheTop[5] = 0x17;keyAcrossTheTop[6] = 0x16;keyAcrossTheTop[7] = 0x1A;keyAcrossTheTop[8] = 0x1C;keyAcrossTheTop[9] = 0x19;keyAcrossTheTop[10] = 0x1D;keyAcrossTheTop[11] = 0x1B;keyAcrossTheTop[12] = 0x18;keyAcrossTheTop[13] = 0x33;keyRatio[0] = 0x00008000; /*รร*/keyRatio[1] = 0x00009000;keyRatio[2] = 0x0000A000;keyRatio[3] = 0x0000B000;keyRatio[4] = 0x0000C000;keyRatio[5] = 0x0000D000;keyRatio[6] = 0x0000E000;keyRatio[7] = 0x00010000; /*รร*/keyRatio[8] = 0x00011000;keyRatio[9] = 0x00012000;keyRatio[10] = 0x00013000;keyRatio[11] = 0x00014000;keyRatio[12] = 0x00015000;keyRatio[13] = 0x00016000;			/** maybe fix reference instead of refusing it **/	if (-(mySpec.vRefNum)>maxVRef)	{		genError("\pThat volume is not mounted");		/** maybe say what volume it is **/		return;	}		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr!=0)	{		genError("\pCouldn't open file to Audition");		return;	}		watchcursor(true);		switch (fndrInfo.fdType)	{		case 'Sd2f':case 'AIFF':case 'AIFC':case 'SFIL':case '.WAV':case 'bin ':case 'WAVE':case 'MooV':		break;		default: /* add the file type from name */			checkForWAV(mySpec.name,&fndrInfo);			checkForKRZ(mySpec.name,&fndrInfo);			checkForMPG(mySpec.name,&fndrInfo);		//	checkForREX(mySpec.name,&fndrInfo);		break;	}	switch (fndrInfo.fdType)	{		case 'MooV':			if (Gestalt(gestaltQuickTime, &response)) 			{				genError ("\pThis function requires QuickTime");				break;			}			playMoviesMain(mySpec,0);		break;				case 'MPEG':case '.MPG':case 'MPG ':case 'PLAY':case 'MP3 ':case '.MP3':case '.mp3':case 'Mp3 ':			if (Gestalt(gestaltQuickTime, &response)) 			{				genError ("\pThis function requires QuickTime");				break;			}			watchcursor(false);			playMoviesMain(mySpec,0);		break;		case 'SCin':case 'SCsi':case 'SCsd':case 'SCss':			SC2InstPlay(mySpec);			watchcursor(false);			return;		break;		case 'PICT':/* case 'JPEG': case 'TIFF':*/			displayFileInWindow(mySpec);			watchcursor(false);			return;		break;		case 'JFIF':			displayJPEGileInWindow(mySpec);		break;		case 'REX ':			sendFileToRex(mySpec);		break;		case 'RadR':			Radar16Play(mySpec);		break;		case 'GIFf':			importMovieToDisplayPict(mySpec);		break;	}					if (theNewPrefs.modernDblBufferAudition)	{		OSType myWAVType;				switch (fndrInfo.fdType)		{			case 'Sd2f':				if (playFromList && waveFormSelected)				{					playRegionFromSelection(mySpec, playFreq, zRect,selectRect.left, selectRect.right);					//SDIIRegionPlay(mySpec, playFreq, long startPos, long endPos)				}				else				{					if (theNewPrefs.waveFormWindow)					{						playRegionFromSelection(mySpec,playFreq, zRect,zRect.left, zRect.right);					}					else					{						SDIIPlay(mySpec, playFreq);					}				}				watchcursor(false);				return;			break;			case 'SFIL':				SDIPlay(mySpec,playFreq);				watchcursor(false);				return;			break;						case 'AIFC': /* should we also play AIFF here ? */				AIFCPlay(mySpec, playFreq);				watchcursor(false);				return;			break;						case 'AIFF':				if (playFromList && waveFormSelected)				{					AIFFplayRegionFromSelection(mySpec, playFreq, zRect,selectRect.left, selectRect.right);					//SDIIRegionPlay(mySpec, playFreq, long startPos, long endPos)				}				else				{					if (theNewPrefs.waveFormWindow)					{						AIFFplayRegionFromSelection(mySpec,playFreq, zRect,zRect.left, zRect.right);					}					else					{						AIFFtoSnd(mySpec, playFreq);					}				}				watchcursor(false);				return;			break;			case '.WAV': case '.wav': case 'WAVE': case 'bin ':				WAVPlay(mySpec, playFreq);				watchcursor(false);				return;			break;									case '.KRZ':				KRZPlay(mySpec, playFreq);				watchcursor(false);				return;			break;						default:				BlockMove(mySpec.name + (*mySpec.name) -3L,&myWAVType,4L);				if (myWAVType == '.WAV')				{					WAVPlay(mySpec, playFreq);					watchcursor(false);					return;				}			break;		}	}	else	{		switch (fndrInfo.fdType)		{			case 'Sd2f':				OldSDIIPlay(mySpec);				watchcursor(false);				return;			break;			case 'SFIL':				OldSDIPlay(mySpec);				watchcursor(false);				return;			break;			default:				if (fndrInfo.fdType != 'AIFF')				{					//SysBeep(5);					watchcursor(false);					return;				}								if (theNewPrefs.modernDblBufferAudition)				{					AIFFtoSnd(mySpec, playFreq);					watchcursor(false);					return;				}				else				{					AIFFNormalPlay (mySpec,playFreq);					watchcursor(false);					return;				}								pNew = NewPtr(kTotalSize);				iErr = MemError();				if (iErr!=0)				{					genError("\p could not allocate pNew buffer in audition");					watchcursor(false);					return;				}				/********/				PathNameFromDirID(mySpec.parID,mySpec.vRefNum,fgh);				BlockMove(mySpec.name+1,fgh+1+*fgh,64L);				kj = *fgh;				kj = *fgh + *mySpec.name;				*fgh = kj;				//iErr = FSOpen(fgh,mySpec.vRefNum,&fRefNum);				iErr = FSOpen(fgh,0,&fRefNum);								if (iErr!=0)				{					genError("\pcould not open file to audition");					DisposPtr(pNew);					watchcursor(false);					return;				}				myErr = SndNewChannel(&mySndChan,sampledSynth,initMono,0);				if (myErr!=0)				{					genError("\pCould not open sound channel");					DisposPtr(pNew);					watchcursor(false);					return;				}				watchcursor(TRUE);				iErr = SndStartFilePlay(mySndChan,fRefNum,0,kTotalSize,pNew,0,0,false);	/** make this async, with escape ability **/				if (iErr!=0)				{					genError("\pCould not play file");				//	SysBeep(5);				}				watchcursor(FALSE);				iErr = SndDisposeChannel(mySndChan,false);				DisposPtr((Ptr)mySndChan);				if (myErr!=0)				{					genError("\pCould not release sound channel");					DisposPtr(pNew);					watchcursor(false);					return;				}				iErr = FSClose(fRefNum);				DisposPtr(pNew);				watchcursor(false);			break;		}	}}void PathNameFromDirID(long dirID, short vRefNum, StringPtr fullPathName){	DirInfo	block;	Str255	directoryName,theTempComment;	OSErr	err;	fullPathName[0] = '\0';	if (-vRefNum > maxVRef) 	{		if (!VgetvolName(vRefNum, theTempComment))		{			*theTempComment = 0;		}		makeStr255("\pGhost Item",fullPathName);		concatStrings(fullPathName,theTempComment,"\p on ");		return;	}			block.ioDrParID = dirID;	*directoryName = 0;	block.ioNamePtr = directoryName;	do {		block.ioVRefNum = vRefNum;		block.ioFDirIndex = -1;		block.ioDrDirID = block.ioDrParID;		err = PBGetCatInfo((union CInfoPBRec *)&block, FALSE);		if (err!=0)		{			makeStr255("\pCannot get pathname for that file",fullPathName);			return;		}		if (haveAUX()) {				if (directoryName[1] != '/')						/* If this isn't root (i.e. "/"), append a slash ('/') */						pstrcat(directoryName, (StringPtr)"\p/");		}		else				pstrcat(directoryName, (StringPtr)"\p:");		pstrinsert(fullPathName, directoryName);	} while (block.ioDrDirID != 2);}/******************/void pstrcat(StringPtr dst, StringPtr src){	/* copy string in */	BlockMove(src + 1, dst + *dst + 1, *src);	/* adjust length byte */	*dst += *src;}void pstrinsert(StringPtr dst, StringPtr src){	/* make room for new string */	BlockMove(dst + 1, dst + *src + 1, *dst);	/* copy new string in */	BlockMove(src + 1, dst + 1, *src);	/* adjust length byte */	*dst += *src;}voidplsound(void){	SndChannelPtr	mySndChan = 0;	short	sampID = 1000;	OSErr	ery;			ery = SndNewChannel(&mySndChan,sampledSynth , initMono , 0L);		ery = SndStartFilePlay ( mySndChan , 0, 1000, 21418, 0,0,0, FALSE);		if (mySndChan != 0)		{			ery = SndDisposeChannel (mySndChan, TRUE);			DisposPtr((Ptr)mySndChan);		}}void ShowPath (FSSpec mySpec, Point myPoint){	Str255	myStr,erMess;	long lMnuAndItm;	MenuHandle	hRsrc;	short kj;			if (-(mySpec.vRefNum)>maxVRef)	{		color.red = 56797;		color.green = 56797;		color.blue = 56797;		RGBBackColor(&color);		ParamText(fvolName[-mySpec.vRefNum],0,0,0);		dAlert(2222,0);		return;	}		PathNameFromDirID(mySpec.parID, mySpec.vRefNum, myStr);	BlockMove(mySpec.name+1,myStr+1+*myStr,64L);	kj = *myStr;	kj = *myStr + *mySpec.name;	*myStr = kj;		ParamText(myStr,0,0,0);		color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	dAlert (2048,0);	/** fix pop up **/	//hRsrc = GetMenu(1024);	//hRsrc = GetResource('MENU',1024);	//	AppendMenu(hRsrc,myStr);	//InsertMenu(hRsrc,hierMenu);	//lMnuAndItm = PopUpMenuSelect(hRsrc,myPoint.v,myPoint.h,1);	//DeleteMenu(1024);	//DisposeMenu(hRsrc);}void showCommentinWin(short mode, Cell theCell);Cell theLastCell;void AuditionMany(short playFreq);Boolean globalStop = false;void AuditionMany(short playFreq){	Cell theCell;	short theindex;	FSSpec theSpec1, theSpec2;	//theLastCell = LLastClick(myList);		 globalStop = false;	if (countSelections() == 2)	{			getFirst2Selections (&theSpec1, &theSpec2);		if (checkFilesAreSDIISplitPartners(theSpec1, theSpec2))				{			SDIISplitAudition(theSpec1, theSpec2);		}				else		{			goto oldMethod;		}	}	else	{oldMethod:		SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList)  && !globalStop) 		{			theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));			if (checkReference (theindex))			{				if (autoCalcOverviews)				{					showCommentinWin(kUseCellParam,theCell);				}				showCommentinWin(kUseCellParam,theCell);				outLineCell (theCell, myList);				Audition(((*therealResults)[theindex]),playFreq);				unOutLineCell (theCell, myList);				if (theNewPrefs.deselectAsPlayed)				{					LSetSelect(false,theCell,myList);				}			}					LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */		}				LSetSelect(true,theLastCell,myList);	}}void outLineCell (Cell theCell, ListHandle theList){	Rect cellRect;	RgnHandle addReg, subReg;	Pattern thePattern;	RGBColor myColor;	GrafPtr savePort;		GetPort(&savePort);	SetPort((GrafPtr)myWindow);		addReg = NewRgn();	subReg = NewRgn();		LRect(&cellRect,theCell,theList);	/*if (theCell.h > 0)	{		cellRect.left++;	}*/	RectRgn(addReg,&cellRect);	InsetRect(&cellRect,1,1);	RectRgn(subReg,&cellRect);	DiffRgn(addReg,subReg,addReg);					GetIndPattern(&thePattern,0,7);		myColor.blue = 0;	myColor.green = 0xFFFF;	myColor.red = 0xFFFF;	RGBForeColor(&myColor);	myColor.blue = 0;	myColor.green = 0;	myColor.red = 0;	RGBBackColor(&myColor);		FillRgn(addReg,&thePattern);		myColor.red = 0;	myColor.green = 0;	myColor.blue = 0;	RGBForeColor(&myColor);	myColor.blue = 0xFFFF;	myColor.green = 0xFFFF;	myColor.red = 0xFFFF;	RGBBackColor(&myColor);		DisposeRgn(addReg);	DisposeRgn(subReg);			needToFixInvert = true;		SetPort(savePort);	return;}void unOutLineCell (Cell theCell, ListHandle theList){	RgnHandle subReg;	Rect cellRect;	GrafPtr savePort;	short fontNum;			GetPort(&savePort);	SetPort((GrafPtr)myWindow);	LRect(&cellRect,theCell,theList);	InsetRect(&cellRect,-2,-2);	subReg = NewRgn();	RectRgn(subReg,&cellRect);		GetFNum(theFontRec.fontName,&fontNum);	TextFont(fontNum);						/** font for list - chicago **/	TextSize(theFontRec.fontSize);	TextFace(0);		LUpdate(subReg,theList);	DisposeRgn(subReg);		SetPort(savePort);	return;}short countSelections(void){	Cell theCell;	short selectionCount = 0;	SetPt( &theCell, 0,0 );		/* start at top of list  */	while ( LGetSelect( TRUE, &theCell, myList) ) 	{		selectionCount++;		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}	return selectionCount;}OSErr getFirst2Selections (FSSpec * theFile1, FSSpec * theFile2){	Cell theCell;	short theindex;	SetPt( &theCell, 0,0 );		/* start at top of list  */	if ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		*theFile1 = (*therealResults)[theindex];	}	else	{		return -1;	}	LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	if ( LGetSelect( TRUE, &theCell, myList) ) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		*theFile2 = (*therealResults)[theindex];	}	else	{		return -1;	}	return noErr;}Boolean checkFilesAreSDIISplitPartners(FSSpec theFile1, FSSpec theFile2)	{	Str255 fileA, fileB;	char endA, endB;	FInfo fndrInfo;	OSErr iErr;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	if (getSDIIData (theFile1,&theRate, &theWordSize,&stereo, &theBytes))	{		return false;	}	if (theWordSize != 2 || stereo)	{		return false;	}	if (getSDIIData (theFile2,&theRate, &theWordSize,&stereo, &theBytes))	{		return false;	}	if (theWordSize != 2 || stereo)	{		return false;	}	if (*theFile1.name != *theFile2.name)	{		return false;	}	makeStr255 (theFile1.name,fileA);	makeStr255 (theFile2.name,fileB);	*fileA = (*fileA) -1;	*fileB = (*fileB) -1;	if(!EqualString(fileA,fileB,true,true)) 	{		return false;	}	endA = fileA[*fileA + 1];	endB = fileB[*fileB + 1];		switch (endA)	{		case 'r': case 'R':			if (endB != 'l' && endB != 'L')			{					return false;			}		break;		case 'l': case 'L':			if (endB != 'r' && endB != 'R')			{					return false;			}		break;		case '1':			if (endB != '2')			{					return false;			}		break;		case '2':			if (endB != '1')			{					return false;			}		break;		default:			return false;		break;	}	return true;}						OSErr PFindAProcess(OSType typeToFind, OSType creatorToFind,ProcessSerialNumberPtr processSN);OSErr sendFileToRex(FSSpec theTransferredFile){	AppleEvent	aeEvent;	/* the event to create*/	AEDesc	myAddressDesc;	/* descriptors for the */	AEDesc	aeDirDesc[1];	AEDesc	listElem;	AEDesc	fileList;		/*our list*/	FSSpec	dirSpec;	EventRecord theEvent;	short z;	AliasHandle	fileAlias[1];		/* alias of the file itself*/	AliasHandle	theAliasH[1];	ProcessSerialNumber process;	/* the finder's psn*/	OSErr		myErr;				/* duh*/	FSSpec	mySpec;	FInfo	fndrInfo;	Boolean	CreatorChanged;	OSType	preserveCreator;	//Boolean	isSample;	CInfoPBRec	pb;	StandardFileReply	reply;	short temprefNum;	OSErr	iErr;	short switchCount;	char	myChar;	long	theParID;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/	short p;	myEventID = kAEOpenDocuments;	myEventClass = kCoreEventClass;	if(PFindAProcess('APPL','rexP',&process))	{			divertSamples = true;			OpenSelection(theTransferredFile);			return;	}		myErr = AECreateDesc(typeProcessSerialNumber,(Ptr) &process,sizeof(process), &myAddressDesc);	if(myErr)		{		genError("\pAppleEvent error");		return;	}	myErr = AECreateAppleEvent (myEventClass, myEventID,&myAddressDesc, kAutoGenerateReturnID, kAnyTransactionID,&aeEvent);	if(myErr)	{		genError("\pAppleEvent error");		return;	}	if(myErr=AECreateList(nil,0,false,&fileList))	{		genError("\pAppleEvent error");		return;	}			NewAlias(nil,&theTransferredFile,&fileAlias[0]);			theAliasH[0] = fileAlias[0];				HLock((Handle)theAliasH[0]);			AECreateDesc(typeAlias, (Ptr) *theAliasH[0], GetHandleSize((Handle) theAliasH[0]), &aeDirDesc[0]);		HUnlock((Handle)theAliasH[0]);				myErr = AEPutDesc (&fileList, 1+0, &aeDirDesc[0]);			if(myErr = AEPutParamDesc(&aeEvent,keyDirectObject,&fileList))			return myErr;		myErr = AESend(&aeEvent, nil,kAENoReply+kAEAlwaysInteract+kAECanSwitchLayer,kAEHighPriority, kAEDefaultTimeout, nil, nil);	AEDisposeDesc(&aeEvent);			for (z=0;z<30;z++)	{		WaitNextEvent(everyEvent,&theEvent,0,0);	}}