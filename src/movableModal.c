//----------------------------------------------------------------------------------//	File		: movableModal.c//	Date		: April 4, 1994//	Author		: Jim Stout//	Purpose		: Implements movableModal dialogs//------------------------------------------------------------------------------------#include "movableModal.h"// following must be in your application code!!// or remove the calls from this code...pascal void movableModalDialog(ModalFilterUPP filter, short *theItem){	EventRecord theEvent;	DialogPtr	d,thisDialog;	GrafPtr		oldPort;		thisDialog = FrontWindow();	GetPort(&oldPort);	SetPort(thisDialog);		for(;;) {		WaitNextEvent(everyEvent, &theEvent, 20, 0L);		if( (*theItem = preFilterEvent(thisDialog, &theEvent)) != 0)			break;				if (!theEvent.message)		{			FindWindow(theEvent.where,(GrafPort **)&theEvent.message);		}		#ifdef powerc				if (filter != nil)			if (CallUniversalProc(filter,uppModalFilterProcInfo,thisDialog, &theEvent, theItem))				break;#else	if (filter != nil)			if (filter(thisDialog, &theEvent, theItem))				break;#endif		if (IsDialogEvent(&theEvent))			if (DialogSelect(&theEvent, &d, theItem))				break;				//doPeriodicEvent(&theEvent);	}	SetPort(oldPort);}static short preFilterEvent(DialogPtr d, EventRecord *theEvent){	short ret=0;		switch (theEvent->what) {		case mouseDown:			ret = doMouseDialog(d,theEvent); 	/* handle drag etc. of dialog		*/		break;		case diskEvt:			diskEvent(theEvent);		break;		case updateEvt:			SetPort(d);		break;	}	return (ret);}static short doMouseDialog(DialogPtr d, EventRecord *theEvent){	WindowPtr	theWindow;	short		partCode, ret=0;		switch (partCode = FindWindow(theEvent->where,&theWindow)) {		case inDrag:			if(theWindow == d) {				DragWindow(d, theEvent->where, &qd.screenBits.bounds);				theEvent->what = nullEvent;			}		break;				case inMenuBar:			//doMenuCommand(MenuSelect(theEvent->where));		break;		case inGoAway:			if (TrackBox (theWindow, theEvent->where, partCode)) {				ret = cancel;				theEvent->what = nullEvent;			}		break;		/* add code if you need to deal with these mouseDown eventsÉ	*/		case inGrow:		break;		case inZoomIn:		case inZoomOut:		break;		case inContent:		break;		default:		break;	}	return(ret);}extern void diskEvent(EventRecord *theEvent){	Point diskInitPt;	if (HiWord (theEvent->message) != noErr) {		diskInitPt.v = 120;		diskInitPt.h = 100;		DILoad ();		(void) DIBadMount (diskInitPt, theEvent->message);		DIUnload ();		theEvent->what = nullEvent;	}}