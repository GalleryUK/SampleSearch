/* now make the file selection be included in the flavbour records */#include <stdio.h>extern short	DisplayedColumns;extern Boolean dragAvailable;#include "prefs.h"extern newPrefsRec theNewPrefs;#include "SampleSearch.h"typedef struct rwfmRecord {OSType fileType;OSType creator;short	unknown; /* 00 */OSType RWM1;  /* rWm1 */} rwfmRecord;#include <Files.h>Boolean hiliteCell(short cellNumber, Boolean hilite,short top,short left);short mouseInside (Point thePoint, short top, short left);OSErr FindAProcess(OSType typeToFind, OSType creatorToFind,			ProcessSerialNumberPtr processSN);			OSErr allocateRamForFilesList (void);			#define kFinderDragType 10#define kFindFileDragType 11#define kNoHandler 0extern FSSpec * theFoundFiles;extern short lastHilite;Boolean DropLocationIsFinderTrash(AEDesc *dropLocation);#include <Drag.h>#include <Lists.h>extern ListHandle myList;Boolean addFileToList(FSSpec mySpec);extern WindowPtr	myWindow;FSSpec theFSSpecWeWant;extern FSSpec **therealResults;pascal OSErr MySendDataProc(FlavorType theType, void *refCon,ItemReference theItem, DragReference theDrag);Boolean cursorInContent = false;Boolean acceptDrag = false;HFSFlavor theFileFlavour;Boolean DropProcessIsFinder(AEDesc *dropLocation);void AddToFaveTab(FSSpec	mySpec, short index,short whichList);ProcessSerialNumber process;void setCursor(short setting);#define kWristWatch 99#define kRightCursor 1#define kLeftCursor 2#define kArrowCursor 0static pascal Size MinimumBytesForFSSpec (const FSSpec *fss);OSErr addSDIIFilesInside (FSSpec theParentObject, Boolean folderSearch);FSSpec ** theDraggedFiles;static pascal CreatePromisedFolder	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag);pascal OSErr CreatePromisedFileOrFolder	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag);		static pascal CreatePromisedFile	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag);enum{	kPromisedFlavor				= 'fssP',	kPromisedFlavorFindFile		= 'rWm1'};static pascal OSErr FSpGetDirInfo (const FSSpec *spec, CInfoPBPtr *cipbpp);pascal OSErr GetDirID (const FSSpec *spec, long *dirID);static Boolean			gQuitting;				/* set when it's time to quit */static FontInfo			gFontInfo;				/* cache for Geneva 9 info */static Rect				gIconLimitRect;			/* window portRect without text area */static Boolean			gHaveTranslucence;		/* can we call SetDragImage? */static FSSpec			gDropLocation;			/*cache where user dropped */static HFSFlavor		gHFSFlavor;				/* data dragged in, re-used when dragging out */static DragReference	gApprovedDragRef;		/* tracking handler approves, receive handler confirms */static ItemReference	gItemRef;				/* valid when gApprovedDragRef is being received */static Handle			gIconSuite;				/* cached from flavorTypeHFS dragged in */static FSSpec			gDropLocFSS;static FSSpec			gCopyTarget;pascal OSErr MyDragSendDataProc	(FlavorType flavorType, void *, ItemReference itemRef, DragReference dragRef);		pascal OSErr SetPromisedHFSFlavorData	(DragReference dragRef, ItemReference itemRef,		const PromiseHFSFlavor *phfs, const FSSpec *fss);pascal OSErr ShouldCopyToDropLoc	(DragReference dragRef, FlavorType promisedFlavor, Boolean *shouldCopy);				pascal OSErr GetDropDirectory (DragReference dragRef, FSSpecPtr fssOut);	static pascal OSErr CopyDroppedFileOrFolder	(DragReference dragRef, ItemReference itemRef, const PromiseHFSFlavor *phfs);pascal OSErr MakeHFSFlavor (short vRefNum, long dirID, ConstStr255Param path, HFSFlavor register *hfsFlavorP);		pascal OSErr MakeHFSFlavor (short vRefNum, long dirID, ConstStr255Param path, HFSFlavor register *hfsFlavorP){	OSErr err = noErr;	//	//	canonize the input parameters	//	if (!(err = FSMakeFSSpec (vRefNum,dirID,path,&(hfsFlavorP->fileSpec))))	{		//		//	get the Finder flags		//		register CInfoPBPtr cipbp = (CInfoPBPtr) NewPtrClear (sizeof (*cipbp));		if (!(err = MemError ( )))		{			cipbp->hFileInfo.ioVRefNum	= hfsFlavorP->fileSpec.vRefNum;			cipbp->hFileInfo.ioDirID	= hfsFlavorP->fileSpec.parID;			cipbp->hFileInfo.ioNamePtr	= hfsFlavorP->fileSpec.name;			if (!(err = PBGetCatInfoSync (cipbp)))			{				hfsFlavorP->fdFlags = cipbp->hFileInfo.ioFlFndrInfo.fdFlags;				//				//	now that we have the Finder flags, use them to				//	determine how to fill in the type and creator fields				//				if (hfsFlavorP->fileSpec.parID == fsRtParID)		// is it a volume?				{					hfsFlavorP->fileCreator		= 'MACS';					hfsFlavorP->fileType		= 'disk';				}				else if (cipbp->hFileInfo.ioFlAttrib & ioDirMask)	// is it a dir?				{					hfsFlavorP->fileCreator		= 'MACS';					hfsFlavorP->fileType		= 'fold';				}				else												// it must be a file				{					hfsFlavorP->fileCreator		= cipbp->hFileInfo.ioFlFndrInfo.fdCreator;					hfsFlavorP->fileType		= cipbp->hFileInfo.ioFlFndrInfo.fdType;				}			}			DisposePtr ((Ptr) cipbp);			if (!err) err = MemError ( );		}	}	return err;}static pascal OSErr RedundantMakeHFSFlavor (HFSFlavor *hfsFlavorP){		/*	We could assume that any HFSFlavor we're handed thru		our drag receive handler is valid. However:				[1] It might have become stale since we received it.				[2] We need an excuse to call MakeHFSFlavor so we			    can test it before pasting it into the Technote.			Thus, this function confirms/refreshes the HFSFlavor data;		generally we're passed a pointer to the global HFSFlavor cache,		but this code doesn't know it.*/	OSErr err = noErr;		/*	Clear some fields so we can see that MakeHFSFlavor		did its job.*/		hfsFlavorP->fileType		=	hfsFlavorP->fileCreator		=	hfsFlavorP->fdFlags			= 0;	err = MakeHFSFlavor (	hfsFlavorP->fileSpec.vRefNum,							hfsFlavorP->fileSpec.parID,							hfsFlavorP->fileSpec.name,							hfsFlavorP						);	return err;}short DragFile(EventRecord *theEvent,Cell theCell,FSSpec theSpecWeWant);short DragFile(EventRecord *theEvent,Cell theCell,FSSpec theSpecWeWant){		short				result;	RgnHandle			dragRegion, tempRgn,dRegion,fRegion;	Point				theLoc;	DragReference		theDrag;	StScrpHandle		theStyl;	AEDesc				dropLocation;	DragAttributes		attributes;	short				mouseDownModifiers, mouseUpModifiers, copyText;	Rect theRect;	Cell qCell;	short filesSoFar;	short z;	rwfmRecord myRWMRec;	Boolean finderIsTarget = false;			FInfo fndrInfo;		if (!dragAvailable)	{		return -1;	}	theFSSpecWeWant = theSpecWeWant;	//	//	Copy the hilite region into dragRegion and offset it into global coordinates.	//	/* create the hilite region */			theDraggedFiles = (FSSpec **)NewHandle(sizeof(FSSpec));	filesSoFar = 0;		dragRegion = NewRgn();	dRegion = NewRgn();	fRegion = NewRgn();	qCell.h = 0;	qCell.v = 0;		while(LGetSelect(true,&qCell,myList)) 	{		LRect(&theRect,qCell,myList);		RectRgn(dRegion,&theRect);		CopyRgn(dragRegion,fRegion);		UnionRgn(dRegion,fRegion,dragRegion);			BlockMove(&(*therealResults)[(qCell.v * DisplayedColumns) + (qCell.h * (DisplayedColumns != 1))], &(*theDraggedFiles)[filesSoFar],70L);		filesSoFar ++;		SetHandleSize((Handle)theDraggedFiles,sizeof(FSSpec) * (filesSoFar + 1));		if (MemError())		{			genError ("\pOut of Memeory");			DisposeRgn(dRegion);			DisposeRgn(fRegion);			DisposeRgn(dragRegion);			return -1;		}		LNextCell(true,true,&qCell,myList);	}		DisposeRgn(dRegion);	DisposeRgn(fRegion);/*	LRect(&theRect,theCell,myList);	RectRgn(dragRegion,&theRect);*/		SetPt(&theLoc, 0, 0);	LocalToGlobal(&theLoc);	OffsetRgn(dragRegion, theLoc.h, theLoc.v);	//	//	Wait for the mouse to move to the mouse button to be released. If the mouse button was	//	released before the mouse moves, return false. Returing false from DragText means that	//	a drag operation did not occur.	//		if(FindAProcess('FNDR','MACS',&process))	{		return;	}		NewDrag(&theDrag);	//	//	For purposes of demonstration, we insert the 'TEXT' data and promise 'styl'	//	data. If a receiver requests 'TEXT', the Drag Manager will give them the text	//	without needing us to intervene. If a receiver requests 'styl', the Drag Manager	//	will call our MySendDataProc to provide the data at drop time. The MySendDataProc	//	is specified by calling SetDragSendProc.	//	/*AddDragItemFlavor(theDrag, 1, 'TEXT', GetSelectedTextPtr(theDocument),					  GetSelectionSize(theDocument), 0);*/					for (z=0;z<filesSoFar;z++)	{		OSErr err;		 		  FSpGetFInfo(&(*theDraggedFiles)[z],&fndrInfo);		// FSpGetFInfo(&theFSSpecWeWant,&fndrInfo);					theFileFlavour.fileType = fndrInfo.fdType;					// file type		theFileFlavour.fileCreator = fndrInfo.fdCreator;				// file creator		theFileFlavour.fdFlags = fndrInfo.fdFlags;					// Finder flags				myRWMRec.fileType = fndrInfo.fdType;		myRWMRec.creator = fndrInfo.fdCreator;		myRWMRec.unknown = 0;		myRWMRec.RWM1 = 'rWm1';			theFileFlavour.fileSpec = (*theDraggedFiles)[z];			  				//theFileFlavour.fileSpec = theFSSpecWeWant;			  			/*	AddDragItemFlavor(theDrag, 1, 'hfs ', &theFileFlavour,17 + (*theFSSpecWeWant.name), 0);*/				/* these are the default values to send */		if (!isPressed(0x3B)) /* hold Ctrl to send hfs instead of phfs */		{			Str255 theStr;			AddDragItemFlavor(theDrag, z+1, 'phfs', &myRWMRec,14, 4);						AddDragItemFlavor(theDrag, z+1, 'rWm1', &(*theDraggedFiles)[z],70, 4);						makeStr255 ((*theDraggedFiles)[z].name, theStr);			*(theStr + *theStr + 1) =  '\r';			*theStr = *theStr + 1;			AddDragItemFlavor(theDrag, z+1, 'TEXT', theStr + 1,*theStr, 0); 			if (!isPressed(0x37))			{				if (!(err = RedundantMakeHFSFlavor (&theFileFlavour)))				{					err = AddDragItemFlavor(theDrag, z + 1, flavorTypeHFS, &theFileFlavour,17 + (*((*theDraggedFiles)[z].name)), 0);					if (err)					{						FlashMenuBar(0);					}				}			}		}		else		{			/*if (!(err = RedundantMakeHFSFlavor (&gHFSFlavor)))				err = AddDragItemFlavor(dragRef, 0, flavorTypeHFS, &gHFSFlavor, sizeof (gHFSFlavor), 0);*/			if (!(err = RedundantMakeHFSFlavor (&theFileFlavour)))			{				err = AddDragItemFlavor(theDrag, z, flavorTypeHFS, &theFileFlavour,17 + (*((*theDraggedFiles)[z].name)), 0);				if (err)				{					FlashMenuBar(0);				}			}			else			{							}			}							//	AddDragItemFlavor(theDrag, (filesSoFar) +1, 'hfs ', &theFileFlavour,17 + *((*theDraggedFiles)[z].name), 0);					//	AddDragItemFlavor(theDrag, z+1, 'hfs ', 0,0, 0);			//	AddDragItemFlavor(theDrag, z+1, 'TEXT', 0,0, 0);		}	//SetDragSendProc(theDrag, &MySendDataProc, (void *) (&theFileFlavour));				//SetDragSendProc(theDrag, MySendDataProc, (void *) (theDraggedFiles));	SetDragSendProc(theDrag, NewDragSendDataProc(MyDragSendDataProc), (void *) (theDraggedFiles));			//	//	Set the item's bounding rectangle in global coordinates.	//	SetDragItemBounds(theDrag, 1, &(**dragRegion).rgnBBox);	//	//	Prepare the drag region.	//	tempRgn = NewRgn();	CopyRgn(dragRegion, tempRgn);	InsetRgn(tempRgn, 1, 1);	DiffRgn(dragRegion, tempRgn, dragRegion);	DisposeRgn(tempRgn);/*#ifdef USE_CUSTOM_DRAWING	SetDragDrawingProc(theDrag, MyDrawingProc, 0L);#endif*/	//	//	Drag the text. TrackDrag will return userCanceledErr if the drop zoomed-back	//	for any reason.	//	result = TrackDrag(theDrag, theEvent, dragRegion);	if (result != noErr && result != userCanceledErr) 	{		return(true);	}	//	//	Check to see if the drop occurred in the Finder's Trash. If the drop occurred	//	in the Finder's Trash and a copy operation wasn't specified, delete the	//	source selection. Note that we can continute to get the attributes, drop location	//	modifiers, etc. of the drag until we dispose of it using DisposeDrag.	//	GetDragAttributes(theDrag, &attributes);	if (!(attributes & dragInsideSenderApplication)) 	{		GetDropLocation(theDrag, &dropLocation);		GetDragModifiers(theDrag, 0L, &mouseDownModifiers, &mouseUpModifiers);		copyText = (mouseDownModifiers | mouseUpModifiers) & optionKey;		if (DropLocationIsFinderTrash(&dropLocation))		{			/* delete the files */		}		/*if ((!copyText) && (DropLocationIsFinderTrash(&dropLocation))) 		{			TEDelete(theDocument->theTE);			theDocument->dirty = true;		}*/	if (DropProcessIsFinder(&dropLocation))	{		finderIsTarget = true;	}	else	{		finderIsTarget = false;	}				AEDisposeDesc(&dropLocation);	}	//	//	Dispose of the drag.	//	DisposeDrag(theDrag);	DisposeRgn(dragRegion);	DisposHandle ((Handle)theDraggedFiles);			if (finderIsTarget)	{		SetFrontProcess(&process);	}		return(true);}pascal OSErr MySendDataProc(FlavorType theType, void *refCon,ItemReference theItem, DragReference theDrag){		Str255 theStr;	FInfo fndrInfo;	short z;	/*	BlockMove(&theType,theStr+1,4L);	*theStr = 4;	DebugStr(theStr);*/		switch (theType) 	{		case  'hfs ':			FSpGetFInfo(&(*theDraggedFiles)[theItem],&fndrInfo);						theFileFlavour.fileType = fndrInfo.fdType;					// file type			theFileFlavour.fileCreator = fndrInfo.fdCreator;			// file creator			theFileFlavour.fdFlags = fndrInfo.fdFlags;					// Finder flags			theFileFlavour.fileSpec = (*theDraggedFiles)[theItem];				SetDragItemFlavorData(theDrag, theItem, 'hfs ', &theFileFlavour,17 + *((*theDraggedFiles)[theItem].name), 0L);		break;				case 'phfs':			FSpGetFInfo(&(*theDraggedFiles)[theItem],&fndrInfo);						theFileFlavour.fileType = fndrInfo.fdType;					// file type			theFileFlavour.fileCreator = fndrInfo.fdCreator;			// file creator			theFileFlavour.fdFlags = fndrInfo.fdFlags;					// Finder flags			theFileFlavour.fileSpec = (*theDraggedFiles)[theItem];				SetDragItemFlavorData(theDrag, theItem, 'hfs ', &theFileFlavour,17 + *((*theDraggedFiles)[theItem].name), 0L);		break;		case 'TEXT':			SetDragItemFlavorData(theDrag, theItem, 'TEXT', (*theDraggedFiles)[theItem].name + 1,*((*theDraggedFiles)[theItem].name), 0L);		break;				default:			return(badDragFlavorErr);		break;	} 		return(noErr);}/* *	MyReceiveDropHandler * *	Called by the Drag Manager when a drop occurs over one of the DragText document windows. *//* *	MyTrackingHandler * *	This is the drag tracking handler for windows in the DragText application. */GrafPtr ravePort;pascal OSErr MyTrackingHandler(short message, WindowPtr theWindow,  void *handlerRefCon, DragReference theDrag);pascal OSErr MyTrackingHandler(short message, WindowPtr theWindow,  void *handlerRefCon, DragReference theDrag){	short				result, offset;	long				theTime = TickCount();	unsigned short		count, index;	unsigned long		flavorFlags, attributes;	ItemReference		theItem;	RgnHandle			theRgn;	Point				theMouse, localMouse;	unsigned short 		numFlavors,flaver;	FlavorType theFlavType;					if (!((message == dragTrackingEnterHandler) || (acceptDrag)))		return(noErr);		GetDragAttributes(theDrag, &attributes);		switch (message) 	{		case dragTrackingEnterHandler:						/*	We get called with this message the first time that a drag enters ANY				window in our application. Check to see if all of the drag items contain				TEXT. We only accept a drag if all of the items in the drag can be accepted.*/								acceptDrag = false;						CountDragItems(theDrag, &count);			for (index = 1; index <= count; index++) 			{				GetDragItemReferenceNumber(theDrag, index, &theItem);								CountDragItemFlavors (theDrag, theItem, &numFlavors);				for (flaver = 1;flaver <= numFlavors;flaver++)				{					GetFlavorType (theDrag, theItem, flaver, &theFlavType);					switch (theFlavType)					{						case 'hfs ':							acceptDrag = true;						break;												case 'phfs':							acceptDrag = true;						break;					}								}			}			cursorInContent = false;			break;		case dragTrackingEnterWindow:										/*	We receive an EnterWindow message each time a drag enters one of our				application's windows. We initialize our global variables for tracking				the drag through the window.*/		break;		case dragTrackingInWindow:						/*	We receive InWindow messages as long as the mouse is in one of our windows				during a drag. We draw the window highlighting and blink the insertion caret				when we get these messages.*/						/*GetPort (&ravePort);			SetPort(myWindow);*/			GetDragMouse(theDrag, &theMouse, 0L);			localMouse = theMouse;			GlobalToLocal(&localMouse);						/*	Show or hide the window highlighting when the mouse enters or leaves the				TextEdit field in our window (we don't want to show the highlighting when				the mouse is over the window title bar or over the scroll bars).*/												if (!(attributes & dragInsideSenderWindow)) 			{				//printf ("mouse at : %d and %d, window at %d and %d \n",localMouse.h,localMouse.v,(*myList)->rView.right,(*myList)->rView.bottom);								if (PtInRect(localMouse, &((*myList)->rView)))				{					if (!cursorInContent) 					{						RectRgn(theRgn = NewRgn(), &((*myList)->rView));						ShowDragHilite(theDrag, theRgn, true);						DisposeRgn(theRgn);						cursorInContent = true;					}				} 				else 				{					if (cursorInContent) 					{						HideDragHilite(theDrag);					}					cursorInContent = false;				}			}			else			{				short cellSel;								cellSel = mouseInside (localMouse, 55, 0); 							if (cellSel == -1)				{					if (lastHilite >= 0)					{						hiliteCell(lastHilite, false,55,0);						lastHilite = -1;					}				}				else				{					if (lastHilite != cellSel)					{						if (lastHilite >= 0)						{							hiliteCell(lastHilite, false,55,0);							lastHilite = -1;						}						hiliteCell(cellSel, true,55,0);						lastHilite = cellSel;					}				}			}						if (localMouse.v <= 79)			{				short cellSel;								cellSel = mouseInside (localMouse, 55, 0); 							if (cellSel == -1)				{					if (lastHilite >= 0)					{						hiliteCell(lastHilite, false,55,0);						lastHilite = -1;					}				}				else				{					if (lastHilite != cellSel)					{						if (lastHilite >= 0)						{							hiliteCell(lastHilite, false,55,0);							lastHilite = -1;						}						hiliteCell(cellSel, true,55,0);						lastHilite = cellSel;					}				}									}					/*SetPort(ravePort);*/		break;		case dragTrackingLeaveWindow:						/*	Remove window highlighting, if showing.*/						if ((cursorInContent) && (attributes & dragHasLeftSenderWindow))			{				HideDragHilite(theDrag);				cursorInContent = false;			}						hiliteCell(lastHilite, false,55,0);		break;		case dragTrackingLeaveHandler:				HideDragHilite(theDrag);				cursorInContent = false;				hiliteCell(lastHilite, false,55,0);		break;	}	return(noErr);}pascal OSErr MyReceiveDropHandler(WindowPtr theWindow, unsigned long handlerRefCon, DragReference theDrag);pascal OSErr MyReceiveDropHandler(WindowPtr theWindow, unsigned long handlerRefCon, DragReference theDrag){	OSErr				result;	TEHandle			tempTE;	Rect				theRect, srcRect;	unsigned short		items, index;	ItemReference		theItem;	DragAttributes		attributes;	Ptr					textData;	StScrpHandle		stylHandle;	Size				textSize, stylSize;	short				offset, selStart, selEnd, mouseDownModifiers, mouseUpModifiers, moveText;	Point				thePoint;	FSSpec mySpec;	long specSize;	unsigned short 		numFlavors,flaver;	FlavorType theFlavType;	short handleMethod;	Str255 myData;	short cellSel;	GrafPtr savePort;	Point localMouse,theMouse;	OSErr iErr;	if (!acceptDrag)		return(dragNotAcceptedErr);	GetPort (&savePort);	SetPort(myWindow);	GetDragAttributes(theDrag, &attributes);	GetDragModifiers(theDrag, 0L, &mouseDownModifiers, &mouseUpModifiers);	//	//	Loop through all of the drag items contained in this drag and collect the text	//	into the tempTE record.	//		CountDragItems(theDrag, &items);	for (index = 1; index <= items; index++) 	{				handleMethod = kNoHandler;		GetDragItemReferenceNumber(theDrag, index, &theItem);				CountDragItemFlavors (theDrag, theItem, &numFlavors);		for (flaver = 1;flaver <= numFlavors;flaver++)		{			GetFlavorType (theDrag, theItem, flaver, &theFlavType);			switch (theFlavType)			{				case 'phfs':					handleMethod = kFindFileDragType;				break;								case 'hfs ':					handleMethod = kFinderDragType;				break;			}						}				GetDragMouse(theDrag, &theMouse, 0L);		localMouse = theMouse;		GlobalToLocal(&localMouse);										/*cellSel = mouseInside (localMouse, 55, 0); 		if (cellSel == -1)		{			if (lastHilite >= 0)			{				hiliteCell(lastHilite, false,55,0);				lastHilite = -1;			}		}		else		{			if (lastHilite != cellSel)			{				if (lastHilite >= 0)				{					hiliteCell(lastHilite, false,55,0);					lastHilite = -1;				}				hiliteCell(cellSel, true,55,0);				lastHilite = cellSel;			}		}*/								if (!(attributes & dragInsideSenderWindow))  /* came from outside into window */		{							if (localMouse.v > 79) /* dropped into list area */			{				switch (handleMethod)				{								case kFindFileDragType:						specSize = 70L;						if (!GetFlavorData(theDrag, theItem, 'rWm1', &mySpec, &specSize, 0L))						{							if (!(attributes & dragInsideSenderWindow))							{								HFileParam pb;								Boolean temp;								temp = theNewPrefs.dontAddToList;								theNewPrefs.dontAddToList = false;								pb.ioCompletion = 0;								pb.ioFVersNum = 0;								pb.ioNamePtr = mySpec.name;								pb.ioVRefNum = mySpec.vRefNum;								pb.ioFDirIndex = 0;								pb.ioDirID = mySpec.parID;								pb.ioFlAttrib = 0;								//iErr = PBGetFInfo(&pb,async);								//iErr = PBGetCatInfo(&pb,false);								iErr = PBHGetFInfo((union HParamBlockRec *)&pb,false);								if (!pb.ioFlAttrib & 0x02)  /* a folder */								{									allocateRamForFilesList ();									setCursor(kWristWatch);									addSDIIFilesInside (mySpec,true);									setCursor(kArrowCursor);									DisposPtr((Ptr)theFoundFiles);													}								else								{									addFileToList(mySpec);								}								theNewPrefs.dontAddToList = temp;							}						}						else						{							SetPort (savePort);							return dragNotAcceptedErr;						}					break;															case kFinderDragType:						specSize = 70L;						if (!GetFlavorData(theDrag, theItem, 'hfs ', (Ptr)myData, &specSize, 0L))						{							if (!(attributes & dragInsideSenderWindow))							{								Boolean temp;								HFileParam pb;																BlockMove(myData + 10L, &mySpec,70L);								temp = theNewPrefs.dontAddToList;								theNewPrefs.dontAddToList = false;								pb.ioCompletion = 0;								pb.ioFVersNum = 0;								pb.ioNamePtr = mySpec.name;								pb.ioVRefNum = mySpec.vRefNum;								pb.ioFDirIndex = 0;								pb.ioDirID = mySpec.parID;								pb.ioFlAttrib = 0;								//iErr = PBGetFInfo(&pb,async);								//iErr = PBGetCatInfo(&pb,false);								iErr = PBHGetFInfo((union HParamBlockRec *)&pb,false);								if (!pb.ioFlAttrib & 0x02) /* a folder */								{									allocateRamForFilesList ();									setCursor(kWristWatch);									addSDIIFilesInside (mySpec,true);									setCursor(kArrowCursor);									DisposPtr((Ptr)theFoundFiles);													}								else								{									addFileToList(mySpec);								}								theNewPrefs.dontAddToList = temp;							}						}						else						{							SetPort (savePort);							return dragNotAcceptedErr;						}					break;									default:						SetPort (savePort);						return dragNotAcceptedErr;					break;				}			}			else			{  /* dropped into top area or tabs */					if (lastHilite >= 0)					{						switch (handleMethod)						{												case kFindFileDragType:								specSize = 70L;								if (!GetFlavorData(theDrag, theItem, 'rWm1', &mySpec, &specSize, 0L))								{									AddToFaveTab(mySpec, 0,lastHilite);																	}								else								{									SetPort (savePort);									return dragNotAcceptedErr;								}							break;																					case kFinderDragType:								specSize = 70L;								if (!GetFlavorData(theDrag, theItem, 'hfs ', (Ptr)myData, &specSize, 0L))								{									BlockMove(myData + 10L, &mySpec,70L);									AddToFaveTab(mySpec, 0,lastHilite);																	}								else								{									SetPort (savePort);									return dragNotAcceptedErr;								}							break;													default:								SetPort (savePort);								return dragNotAcceptedErr;							break;						}						if (index == items)						{							hiliteCell(lastHilite, false,55,0);							lastHilite = -1;						}					}			}		}		else /* drag originated in this window */		{			if (localMouse.v > 79) 				break;			switch (handleMethod)			{						case kFindFileDragType:					specSize = 70L;					if (!GetFlavorData(theDrag, theItem, 'rWm1', &mySpec, &specSize, 0L))					{						AddToFaveTab(mySpec, 0,lastHilite);											}					else					{						SetPort (savePort);						return dragNotAcceptedErr;					}				break;												case kFinderDragType:					specSize = 70L;					if (!GetFlavorData(theDrag, theItem, 'hfs ', (Ptr)myData, &specSize, 0L))					{						BlockMove(myData + 10L, &mySpec,70L);						AddToFaveTab(mySpec, 0,lastHilite);											}					else					{						SetPort (savePort);						return dragNotAcceptedErr;					}				break;							default:					SetPort (savePort);					return dragNotAcceptedErr;				break;			}		}		}	SetPort (savePort);	return(noErr);}Boolean DropLocationIsFinderTrash(AEDesc *dropLocation){		OSErr			result;	AEDesc			dropSpec;	FSSpec			*theSpec;	CInfoPBRec		thePB;	short			trashVRefNum;	long			trashDirID;	//	//	Coerce the dropLocation descriptor to an FSSpec. If there's no dropLocation or	//	it can't be coerced into an FSSpec, then it couldn't have been the Trash.	//	if ((dropLocation->descriptorType != typeNull) && (AECoerceDesc(dropLocation, typeFSS, &dropSpec) == noErr)) 	{		HLock(dropSpec.dataHandle);		theSpec = (FSSpec *) *dropSpec.dataHandle;		//		//	Get the directory ID of the given dropLocation object.		//		thePB.dirInfo.ioCompletion = 0L;		thePB.dirInfo.ioNamePtr = (StringPtr) &theSpec->name;		thePB.dirInfo.ioVRefNum = theSpec->vRefNum;		thePB.dirInfo.ioFDirIndex = 0;		thePB.dirInfo.ioDrDirID = theSpec->parID;		result = PBGetCatInfo(&thePB, false);		HUnlock(dropSpec.dataHandle);		AEDisposeDesc(&dropSpec);		if (result != noErr)			return(false);		//		//	If the result is not a directory, it must not be the Trash.		//		if (!(thePB.dirInfo.ioFlAttrib & (1 << 4)))			return(false);		//		//	Get information about the Trash folder.		//		FindFolder(theSpec->vRefNum, 'trsh', true, &trashVRefNum, &trashDirID);		//		//	If the directory ID of the dropLocation object is the same as the directory ID		//	returned by FindFolder, then the drop must have occurred into the Trash.		//		if (thePB.dirInfo.ioDrDirID == trashDirID)			return(true);	}	return(false);}Boolean DropProcessIsFinder(AEDesc *dropLocation){		OSErr			result;	AEDesc			dropSpec;	FSSpec			*theSpec;	CInfoPBRec		thePB;	short			trashVRefNum;	long			trashDirID;	//	//	Coerce the dropLocation descriptor to an FSSpec. If there's no dropLocation or	//	it can't be coerced into an FSSpec, then it couldn't have been the finder.	//	if ((dropLocation->descriptorType != typeNull) && (AECoerceDesc(dropLocation, typeFSS, &dropSpec) == noErr)) 	{		return true;	}	return(false);}/************** new from here *******************/pascal OSErr MyDragSendDataProc (FlavorType flavorType, void * none, ItemReference itemRef, DragReference dragRef){	OSErr err = noErr;    PromiseHFSFlavor  phfs;    Size  mysize = sizeof (phfs);		if (!(err = GetFlavorData (dragRef,itemRef,flavorTypePromiseHFS,&phfs,&mysize,0)))	{		if (mysize != sizeof (phfs))			err = cantGetFlavorErr;		else if (flavorType == phfs.promisedFlavor)		{			Boolean shouldCopy;			if (!(err = ShouldCopyToDropLoc (dragRef,flavorType,&shouldCopy)))			{				if (shouldCopy)				{					SetCursor (*GetCursor (watchCursor));					err = CopyDroppedFileOrFolder (dragRef,itemRef,&phfs);				}				else				{					err = SetPromisedHFSFlavorData						(dragRef,itemRef,&phfs,&(theFileFlavour.fileSpec));				}			}		}	}	return err;			//	This function fulfills the promise of the promisedFlavor data.//		See comments in CopyDroppedFileOrFolder.}pascal OSErr SetPromisedHFSFlavorData	(DragReference dragRef, ItemReference itemRef,		const PromiseHFSFlavor *phfs, const FSSpec *fss){	return SetDragItemFlavorData		(dragRef,itemRef,phfs->promisedFlavor,fss,sizeof(*fss),0);}pascal OSErr ShouldCopyToDropLoc	(DragReference dragRef, FlavorType promisedFlavor, Boolean *shouldCopy){	OSErr err = noErr;	AEDesc dropLoc = { typeNull, nil };	*shouldCopy = false;	if (!(err = GetDropLocation (dragRef,&dropLoc)))	{		if (dropLoc.descriptorType == typeAlias)		{			// no hint or receiver missed it			*shouldCopy = true;		}		else if (dropLoc.descriptorType != typeNull)		{			// unknown drop location descriptor type			err = paramErr;		}		else if (promisedFlavor != kPromisedFlavorFindFile)		{			// null descriptor but no hint intended			err = dirNFErr;		}		if (dropLoc.dataHandle)		{			OSErr err2 = AEDisposeDesc (&dropLoc);			if (!err) err = err2;		}	}	return err;}static pascal OSErr CopyDroppedFileOrFolder	(DragReference dragRef, ItemReference itemRef, const PromiseHFSFlavor *phfs){		/*	Figure out where the user dropped the file or folder and create a dummy.		Then prepare to send an AppleEvent to Finder to overwrite the dummy.		Don't send the AppleEvent yet because we need to delete the dummy file		after TrackDrag completes so that Drag Manager doesn't display rejection		feedback to the user. Look at the code surrounding		AddTranslucentIconAndDrag's call to TrackDrag for more info.*/		OSErr err = noErr;	if (!(err = GetDropDirectory (dragRef,&gDropLocFSS)))	{		long dropDirID;		if (!(err = GetDirID (&gDropLocFSS,&dropDirID)))			if (!(err = FSMakeFSSpec (gDropLocFSS.vRefNum, dropDirID, gHFSFlavor.fileSpec.name, &gCopyTarget)))				err = dupFNErr;			else if (err == fnfErr)				if (!(err = CreatePromisedFileOrFolder (phfs,&gCopyTarget,smSystemScript)))					err = SetPromisedHFSFlavorData (dragRef,itemRef,phfs,&gCopyTarget);		if (err)		{			gDropLocFSS.vRefNum		= 0;			gCopyTarget.vRefNum		= 0;		}	}	return err;}pascal OSErr GetDropDirectory (DragReference dragRef, FSSpecPtr fssOut){	OSErr err = noErr;	AEDesc dropLocAlias = { typeNull, nil };	if (!(err = GetDropLocation (dragRef,&dropLocAlias)))	{		if (dropLocAlias.descriptorType != typeAlias)			err = paramErr;		else		{			AEDesc dropLocFSS = { typeNull, nil };			if (!(err = AECoerceDesc (&dropLocAlias,typeFSS,&dropLocFSS)))			{				// assume MinimumBytesForFSSpec does not move memory				FSSpecPtr fss = (FSSpecPtr) *(dropLocFSS.dataHandle);				BlockMove (fss,fssOut,MinimumBytesForFSSpec(fss));				err = AEDisposeDesc (&dropLocFSS);			}		}		if (dropLocAlias.dataHandle)		{			OSErr err2 = AEDisposeDesc (&dropLocAlias);			if (!err) err = err2;		}	}	return err;}pascal OSErr GetDirID (const FSSpec *spec, long *dirID){	OSErr err = noErr;	CInfoPBPtr cipbp;	if (!(err = FSpGetDirInfo (spec,&cipbp)))	{		*dirID = cipbp->dirInfo.ioDrDirID;		DisposePtr ((Ptr) cipbp);		if (!err) err = MemError ( );	}	return err;}static pascal CreatePromisedFile	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag){	OSErr err = noErr;	if (!(err = FSpCreate (fss,phfs->fileCreator,phfs->fileType,scriptTag)))	{		if (phfs->fdFlags)		{			FInfo finderInfo;			if (!(err = FSpGetFInfo (fss,&finderInfo)))			{				finderInfo.fdFlags = phfs->fdFlags;				err = FSpSetFInfo (fss,&finderInfo);			}		}	}	return err;}static pascal CreatePromisedFolder	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag){	OSErr err = noErr;	long newDirID; // scratch	if (!(err = FSpDirCreate (fss,scriptTag,&newDirID)))	{		if (phfs->fdFlags)		{			DInfo finderInfo;			CInfoPBRec pb;			makeStr255 ((StringPtr)fss->name,pb.dirInfo.ioNamePtr);			pb.dirInfo.ioVRefNum = fss->vRefNum;			pb.dirInfo.ioFDirIndex = 0;			pb.dirInfo.ioDrDirID = fss->parID;			if (!(err = PBGetCatInfo(&pb,0)))			{				pb.dirInfo.ioDrUsrWds.frFlags = phfs->fdFlags;				err = PBSetCatInfo(&pb,0);				//err = FSpSetDInfo (fss,&finderInfo);			}		/*	if (!(err = FSpGetDInfo (fss,&finderInfo)))			{				finderInfo.frFlags = phfs->fdFlags;				err = FSpSetDInfo (fss,&finderInfo);			}*/		}	}	return err;}pascal OSErr CreatePromisedFileOrFolder	(const PromiseHFSFlavor *phfs, const FSSpec *fss, ScriptCode scriptTag){	OSErr err = noErr;	if (phfs->promisedFlavor == kPromisedFlavorFindFile)		err = paramErr;	else if (phfs->fileType == 'fold' || phfs->fileType == 'disk')		err = CreatePromisedFolder (phfs,fss,scriptTag);	else		err = CreatePromisedFile (phfs,fss,scriptTag);	return err;}static pascal OSErr FSpGetDirInfo (const FSSpec *spec, CInfoPBPtr *cipbpp){	OSErr err = noErr;	CInfoPBPtr pbp = (CInfoPBPtr) NewPtrClear (sizeof (*pbp));	*cipbpp = nil;	if (!(err = MemError ( )))	{		pbp->dirInfo.ioVRefNum = spec->vRefNum;		pbp->dirInfo.ioDrDirID = spec->parID;		pbp->dirInfo.ioNamePtr = (StringPtr) spec->name;		err = PBGetCatInfoSync (pbp);		if (!err && !(pbp->hFileInfo.ioFlAttrib & ioDirMask))			err = dirNFErr;		if (err)			DisposePtr ((Ptr) pbp);		else			*cipbpp = pbp;	}	return err;}static pascal Size MinimumBytesForFSSpec (const FSSpec *fss){	return sizeof (*fss) - sizeof (fss->name) + *(fss->name) + 1;}