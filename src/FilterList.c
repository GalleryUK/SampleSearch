#include "SampleSearch.h"#include "Globals.h"void removeItemFromList(short index);extern Boolean DoublesFilter;extern Boolean ExcludeFilter;#include "undoStuff.h"void saveForUndo (void);extern Boolean commentSearch;extern Str255 commentSearchStr;Boolean GetSearchComment(FSSpec mySpec, Str255 theComment);short NewSearchAgain(void){	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Rect	iRect;				/** for dialog enquiry **/	short	iType;				/** for dialog enquiry **/	Str255	sAgainName;	char	*tempName;	char	*CsAgainName;	OSErr	iErr;	short	listcounter;	char	*strResult;	short	newListCounter;	short		findStrLen;	char	tempstor[255];	char	tempstor2[255];	char	tempstor3[255];	OSType	searchType;	short z;	StringHandle	hString;	FInfo	fndrInfo;	Boolean stillOK;	Str255 theFileComment;	oldFindCounter = totfindcounter;							/** preserve for undo **/	saveForUndo ();	tempName = tempstor;				CsAgainName = tempstor2;	strResult = tempstor3; 	newListCounter=0;		if (!getsearchstring(true))		{			DisableItem(GetMHandle(129),1);								/** if filter dialog cancelled **/		//	SetHandleSize((Handle)theUndoResults,70L);			fChanged = false;			return totfindcounter;		}	if (commentSearch)		PtoCstr(commentSearchStr);		fChanged = true;	BlockMove(gFileName,sAgainName,256L); 					BlockMove(sAgainName,gFileName,256L); 				/** put it into global variable gFileName **/	UprString(sAgainName,false);	findStrLen = *sAgainName;	if (findStrLen > 255)		findStrLen = 255;	PtoCstr(sAgainName);										/** ????????? **/	BlockMove(sAgainName,CsAgainName,findStrLen+1L);	typeRelevant = false;	hString = GetString(999+iCtlValue);							/** grab file type from popup from resource **/	if (!hString)		genError("\pCould not find popup resource");		BlockMove(*hString +1,&searchType,4L);	numTypesToSearch = 0;										/** one less than we need **/	BlockMove(*hString +1,&Fiyltype[0],4L);	if (searchType == 'UUUU')	{		numTypesToSearch = 2;		typeCounter = 0;		Fiyltype[0] = 'AIFF';		Fiyltype[1] = 'SFIL';		Fiyltype[2] = 'Sd2f';	}		if (searchType == 'XXXX')	{		numTypesToSearch = 1;		typeCounter = 0;		Fiyltype[0] = 'AIFF';		Fiyltype[1] = 'Sd2f';	}		if (searchType == 'IIII')	{		numTypesToSearch = 3;		typeCounter = 0;		Fiyltype[0] = 'SCin';		Fiyltype[1] = 'SCsi';		Fiyltype[2] = 'SCsd';		Fiyltype[3] = 'SCss';	}	if (searchType == 'AAAA')	{		typeRelevant = false;									/** ignore file type **/	}	else	{		typeRelevant = true;	}		if 	(!FInfolistInMem && (typeRelevant || fdFldrMask))	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)				genError("\pCould not expand FInfo in Filterlist");								checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));											for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}	if (DoublesFilter)		AlphaSort ();	for(listcounter=0;listcounter< totfindcounter;listcounter++)	{		stillOK = true;		BlockMove((*therealResults)[listcounter].name,tempName,64L);			UprString((unsigned char *)tempName,false);		PtoCstr((unsigned char *)tempName);				if(typeRelevant)			/** file type selected **/		{				BlockMove(&(*theFInfo)[listcounter],&fndrInfo,16L);			stillOK = false;			for (typeCounter = 0;typeCounter<= numTypesToSearch;typeCounter++)			{				if (fndrInfo.fdType == Fiyltype[typeCounter])		/** allow for all samples exception **/				{					stillOK = true;				}			}			if (fndrInfo.fdType == searchType)						{					stillOK = true;				}		}		if (DoublesFilter && stillOK)		{			//stillOK = false;			if (!listcounter)			{				if(!(EqualString((*therealResults)[listcounter].name,(*therealResults)[listcounter+1].name,true,true)))				{					stillOK = false;				}			}			else			{				if(!((EqualString((*therealResults)[listcounter].name,(*therealResults)[listcounter+1].name,true,true)) || (EqualString((*therealResults)[listcounter].name,(*therealResults)[listcounter-1].name,true,true))))				{					stillOK = false;				}			}		}				if (*CsAgainName)			/** string is not null **/		{			if (!strstr((const char *)tempName,(const char *)CsAgainName))			{				stillOK = false;					}		}					if (fdFldrMask)				/** fdfldr selected **/		{			if ((fndrInfo.fdFldr & fdFldrMask) != (fdFldrVal & fdFldrMask))				{					stillOK = false;				}		}				if (commentSearch && stillOK)		{			/* get comment change to C str in get search string */			if(GetSearchComment((*therealResults)[listcounter] ,theFileComment) & (*theFileComment > 0))			{				PtoCstr (theFileComment);				if (!strstr((const char *)theFileComment,(const char *)commentSearchStr))				{					stillOK = false;				}			}			else			{				stillOK = false;			}										}						if (stillOK^ExcludeFilter) 		{			//BlockMove(&(*therealResults)[listcounter],&(*gTheResults)[newListCounter],70L);			if (listcounter != newListCounter)			{				BlockMove(&(*therealResults)[listcounter],&(*therealResults)[newListCounter],70L);				BlockMove(&(*theFInfo)[listcounter],&(*theFInfo)[newListCounter],16L);			}			newListCounter++;		}			}		/*for(listcounter=0;listcounter<=newListCounter;listcounter++)	{		BlockMove(&(*gTheResults)[listcounter],&(*therealResults)[listcounter],70L);	}	*/		reFound = true;		FInfoArrayPtr = newListCounter;	return 	newListCounter;		}void PurgeList (void){	short z;	FInfo fndrInfo;	OSErr	iErr;		watchcursor(true);	saveForUndo ();	for (z=0;z<totfindcounter;z++)	{				iErr = FSpGetFInfo(&((*therealResults)[z]),&fndrInfo);		if (iErr)		{			removeItemFromList(z);				z--;		}	}	watchcursor(false);	return;}