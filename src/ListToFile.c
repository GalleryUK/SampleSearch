#include "SampleSearch.h"#include "Globals.h"#include "Packages.h"Boolean OutputListToFile(void);long getSampleCellInstSize (FSSpec mySpec);Boolean GetComment(FSSpec mySpec, short index, Str255 theComment);Boolean SetComment (FSSpec mySpec, short index, StringPtr theComment);Boolean translateFileType (OSType	theType, StringPtr theTypeText);Boolean GetSizeDate (FSSpec mySpec, short index, long* theSize, long* theDate);OSErr nameFromVRefNum (short whichVol, StringPtr volName);Boolean xOutputListToFile(void);Boolean xOutputListToFile(void){	short z;	FSSpec	theOPFileSpec;	StandardFileReply	theReply;	short refNum;	Boolean showSize;	Boolean showDate;	Boolean showType;	Boolean showCreator;	Boolean showComment;	FILE *fileList;	Str255 listText;	long theSize;	short numchars;		watchcursor (true);	fileList = fopen("SampleSearch List Output","a");	for (z=0;z<totfindcounter;z++)	{			BlockMove ((*therealResults)[z].name,listText,64L);		PtoCstr (listText);		numchars = fprintf(fileList,"%s",listText);		theSize = getSampleCellInstSize ((*therealResults)[z]);		theSize /= 1000L;		if (!theSize)			theSize = 1L;		NumToString(theSize,listText);		*(listText + *listText +1) = 'k';		(*listText) ++;		PtoCstr (listText);		numchars = fprintf(fileList,"\t%s\n",listText);	}	fclose (fileList);	watchcursor (false);		}void PathNameFromDirID(long dirID, short vRefNum, StringPtr fullPathName);Boolean OutputListToFile(void){	short z;	FSSpec	theOPFileSpec;	StandardFileReply	theReply;	short refNum;	long theSize, theDate;	Boolean showSize;	Boolean showDate;	Boolean showType;	Boolean showCreator;	Boolean showComment;	FILE *fileList;	Str255 listText,thePath;	short numchars;	Str255 theComment;		long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	StandardPutFile("\pEnter Name for output file","\pSampleSearch List Output",&theReply);	if (!theReply.sfGood)	{		return;	}	if (theReply.sfReplacing)	{		FSpDelete(&theReply.sfFile);	}	PathNameFromDirID(theReply.sfFile.parID, theReply.sfFile.vRefNum, (StringPtr) thePath);	concatStrings(thePath, theReply.sfFile.name,"\p");	P2CStr (thePath);	watchcursor (true);	fileList = fopen((Ptr)thePath,"a");		if (!DisplayComments)	{		for (z=0;z<totfindcounter;z+=4)		{					BlockMove ((*therealResults)[z].name,listText,64L);			PtoCstr (listText);			numchars = fprintf(fileList,"%s",listText);			numchars = fprintf(fileList,"\t");			if (z+1 >= totfindcounter)				break;			BlockMove ((*therealResults)[z+1].name,listText,64L);			PtoCstr (listText);			numchars = fprintf(fileList,"%s",listText);			numchars = fprintf(fileList,"\t");			if (z+2 >= totfindcounter)				break;			BlockMove ((*therealResults)[z+2].name,listText,64L);			PtoCstr (listText);			numchars = fprintf(fileList,"%s",listText);			numchars = fprintf(fileList,"\t");			if (z+3 >= totfindcounter)				break;			BlockMove ((*therealResults)[z+3].name,listText,64L);			PtoCstr (listText);			numchars = fprintf(fileList,"%s",listText);			if (isPressed(0x3A))			{				numchars = fprintf(fileList,"\t");			}			else			{				numchars = fprintf(fileList,"\n");			}		}	}	else	{		for (z=0;z<totfindcounter;z++)		{			BlockMove ((*therealResults)[z].name,listText,64L);			PtoCstr (listText);			numchars = fprintf(fileList,"%s",listText);			numchars = fprintf(fileList,"\t");						switch (DispMode)			{				case 0: /* comment */					GetComment((*therealResults)[z], z, theComment);				break;				case 1:/* vrefnum */					NumToString((*therealResults)[z].vRefNum,theComment);				break;				case 2:/* types */					translateFileType ((*theFInfo)[z].fdType, theComment);				break;				case 3:/* creator */					BlockMove (&(*theFInfo)[z].fdCreator,theComment + 1,4L);					*theComment = 4;				break;				case 4:/* path */					*theComment = 0;					PathNameFromDirID((*therealResults)[z].parID, (*therealResults)[z].vRefNum,(StringPtr)theComment);				break;				case 5:/* category */					*theComment = 0;				break;				case 6:/* date */					GetSizeDate (((*therealResults)[z]),z, &theSize, &theDate);					IUDateString(theDate,0,theComment);				break;				case 7:/* size */					GetSizeDate (((*therealResults)[z]),z, &theSize, &theDate);					theSize /= 1024;					if (theSize == 0)						theSize = 1;					NumToString(theSize,theComment);					*(theComment + (*theComment) + 1) = 'k';					*theComment = *theComment + 1;				break;								case 8:					if (getSDIIData (((*therealResults)[z]), &theRate, &theWordSize, &stereo, &theBytes))					{						/* not SDII */						makeStr255("\pNot an SDII File", theComment);					}					else					{						NumToString (theRate, theComment);						concatStrings(theComment, "\pkHz", "\p");						if (theWordSize == 2)						{							concatStrings(theComment, "\p16Bit", "\p  ");						}						else						{							concatStrings(theComment, "\p8Bit", "\p  ");						}						if (stereo)						{							concatStrings(theComment, "\pStereo", "\p  ");						}						else						{							concatStrings(theComment, "\pMono", "\p  ");						}								}				break;								default:					*theComment = 0;				break;			}			PtoCstr (theComment);			numchars = fprintf(fileList,"%s",theComment);			numchars = fprintf(fileList,"\n");		}	}	fclose (fileList);	watchcursor (false);		}OSErr generateDatabaseText(void);OSErr generateDatabaseText(void){	short z;	FSSpec	theOPFileSpec;	StandardFileReply	theReply;	short refNum;	long theSize, theDate;	Boolean showSize;	Boolean showDate;	Boolean showType;	Boolean showCreator;	Boolean showComment;	FILE *fileList;	Str255 listText,thePath;	short numchars;	Str255 theComment;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	char theTab = '\t', theCR = '\r';	OSErr iErr;	long inOutCount;	StandardPutFile("\pEnter Name for Data File","\pSampleSearch Text Data",&theReply);	if (!theReply.sfGood)	{		return;	}	if (theReply.sfReplacing)	{		FSpDelete(&theReply.sfFile);	}//	PathNameFromDirID(theReply.sfFile.parID, theReply.sfFile.vRefNum, (StringPtr) thePath);//	concatStrings(thePath, theReply.sfFile.name,"\p");//	P2CStr (thePath);	iErr = FSpCreate(&theReply.sfFile,'ttxt','TEXT',0);	if (iErr)	{		SysBeep(5);			return;	}	iErr = FSpOpenDF(&theReply.sfFile,fsWrPerm,&refNum);	if (iErr)	{		SysBeep(5);			return;	}	watchcursor (true);//	fileList = fopen((Ptr)thePath,"a");		for (z=0;z<totfindcounter;z++)	{		FInfo fndrInfo;		iErr = FSpGetFInfo(&(*therealResults)[z],&fndrInfo);		inOutCount = *(*therealResults)[z].name;		iErr = FSWrite(refNum,&inOutCount,(*therealResults)[z].name+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);		GetComment((*therealResults)[z], z, theComment);		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);			/* drivename */		nameFromVRefNum ((*therealResults)[z].vRefNum,theComment);													inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);			/* parID */		NumToString((*therealResults)[z].parID,theComment);		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);		/* types */		translateFileType (fndrInfo.fdType, theComment);		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);			/* creator */		BlockMove (&fndrInfo.fdCreator,theComment + 1,4L);		*theComment = 4;		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);			/* path */		*theComment = 0;		PathNameFromDirID((*therealResults)[z].parID, (*therealResults)[z].vRefNum,(StringPtr)theComment);		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);		/* category ??? */		/* date */		GetSizeDate (((*therealResults)[z]),z, &theSize, &theDate);		IUDateString(theDate,0,theComment);		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);			/* size */		GetSizeDate (((*therealResults)[z]),z, &theSize, &theDate);		theSize /= 1024;		if (theSize == 0)			theSize = 1;		NumToString(theSize,theComment);		*(theComment + (*theComment) + 1) = 'k';		*theComment = *theComment + 1;		inOutCount = *theComment;		iErr = FSWrite(refNum,&inOutCount,theComment+1);		inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);			if (getSDIIData (((*therealResults)[z]), &theRate, &theWordSize, &stereo, &theBytes))		{			/* not SDII */		}		else		{			NumToString (theRate, theComment);			concatStrings(theComment, "\pkHz", "\p");			if (theWordSize == 2)			{				concatStrings(theComment, "\p16Bit", "\p  ");			}			else			{				concatStrings(theComment, "\p8Bit", "\p  ");			}			if (stereo)			{				concatStrings(theComment, "\pStereo", "\p  ");			}			else			{				concatStrings(theComment, "\pMono", "\p  ");			}						inOutCount = *theComment;			iErr = FSWrite(refNum,&inOutCount,theComment+1);			inOutCount = 1;			iErr = FSWrite(refNum,&inOutCount,(Ptr)&theTab);		}			inOutCount = 1;		iErr = FSWrite(refNum,&inOutCount,(Ptr)&theCR);	}	FSClose (refNum);	watchcursor (false);	return noErr;}