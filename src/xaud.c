#include "SampleSearch.h"#include "Globals.h"#include "curs.h"#include "xSound.h"long whereLoc;#include <SoundInput.h>#define kPitchUp 1#define kPitchDown -1#define kPitchNormal 0long tempPos;#define kForward 0 #define kBackward 1#define kStationary 2extern long dblBufferSize;extern short theXWordSize;extern long presInOutCount;Boolean Reverse(Ptr theData, long howMuch, short theWordSize, Boolean stereo);void SDIIRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect);Boolean direction = kForward;void zDrawGrowIcon (WindowPtr theWindow);Boolean xgCallBackPerformed;extern Boolean regionSelected;short isPressed(unsigned short k );long kScrubSensitivity = 2L;extern Rect selectRect;extern Boolean waveFormSelected;pascal void xSampleCallBack (SndChannelPtr theChan, SndCommand theCmd);Boolean drawOverViewInWindow(FSSpec mySpec);OSErr convertBuffer24To16 (Ptr theSoundData, long *sourceLength);SndChannelPtr xmySndChan;long fileBytes;Boolean xuseTwo; /* the real buffer switch */OSErr disposeCache (void);OSErr setUpCache (void);Ptr xtempPtr;long physicalFilePos, logicalFilePos;Ptr cacheBuffer;OSErr xGetFPos (short refNum, long * filePos);long cacheBufferStart, cacheBufferLength;OSErr xSetFPos(short refNum,short posMode,long posOffset);#define kCacheSize 66000LOSErr fillerup(short refNum,long * inOutCount,short direction);OSErr setUpCache (void){	cacheBuffer = NewPtrClear(kCacheSize);	if (!cacheBuffer)	{		return -99;	}	xtempPtr = NewPtrClear(kCacheSize);	if (!xtempPtr)	{		return -99;	}	cacheBufferStart = 0;	cacheBufferLength = 0;	physicalFilePos = 0;	logicalFilePos = 0;	return 0;}short currentSpeed = 100;OSErr disposeCache (void){	DisposPtr(cacheBuffer);	DisposPtr(xtempPtr);	return 0;}long xdblBufferSize = 32766L;#include "xaud.h"OSErr xFSRead(short refNum,long * inOutCount,Ptr theData);Point scrubStart;pascal void xSampleCallBack (SndChannelPtr theChan, SndCommand theCmd){		long myA5;	// variable to hold current value of A5				myA5 = SetA5(theCmd.param2);	// set my A5				xgCallBackPerformed = TRUE;	// set a global flag which says whether the buffer is finished playing				myA5 = SetA5(myA5);	// restore the current A5}OSErr xInstallCallBack (SndChannelPtr mySndChan){	SndCommand mySndCmd;	// command record		xgCallBackPerformed = false;	mySndCmd.cmd = callBackCmd;	// install the callback command	mySndCmd.param1 = 1;	// last command for this channel	mySndCmd.param2 = SetCurrentA5();	// pass the callback the A5	return SndDoCommand (mySndChan, &mySndCmd, true);}SndChannelPtr xCreateSndChannel(Boolean Stereo){	SndChannelPtr myChan;	// pointer to a sound channel	OSErr myErr;	//xSampleCallBackX = NewSndCallBackProc(xSampleCallBack);	myChan = (SndChannelPtr)NewPtrClear(sizeof(SndChannel));	if ( myChan != nil ) 	{		myChan->qLength = stdQLength;	 //128 sound commands		myErr = SndNewChannel(&myChan, sampledSynth, initStereo,NewSndCallBackProc(xSampleCallBack));	}	return myChan;			// return SndChannelPtr}Boolean xgetSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes){	short iRefNum,fRefNum;	OSErr	iErr;	StringHandle h1,h2,h3;	long xwordsize;	Str255 the1, the2, the3;	long chans;	CInfoPBRec	cipbr;				/* local pb */	HFileInfo	*fpb = (HFileInfo *)&cipbr;	/* to pointers */	Str255 zfilename;		iRefNum = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (fRefNum == -1)	{		return true;	}	UseResFile(fRefNum);	h1 = GetString(1000);	if (!h1)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return true;	}	h2 = GetString(1001);	if (!h2)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return true;	}	h3 = GetString(1002);	if (!h3)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return true;	}		**(Byte**)h2 = 5;	BlockMove (*h1,the1,2L);	BlockMove (*h2,the2,6L);	BlockMove (*h3,the3,2L);	StringToNum(the3,&chans);	StringToNum(the2,theRate);	StringToNum(the1,&xwordsize);	CloseResFile(fRefNum);	UseResFile(iRefNum);		*theWordSize = LoWord(xwordsize);	*stereo = (chans == 2L);			BlockMove(mySpec.name,zfilename,64L);	fpb->ioVRefNum = mySpec.vRefNum;		/* default volume */	fpb->ioNamePtr = zfilename;	/* buffer to receive name */	fpb->ioDirID = mySpec.parID;	fpb->ioFDirIndex = 0;		iErr = PBGetCatInfo(&cipbr,false);		*theBytes = fpb->ioFlLgLen;	return false;}void clearOverViewInWindow (void);long dblBuffSize24Bit;void SDIIPlayScrub(FSSpec mySpec, Rect displayRect, short startHoriz){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	short displayWidth = displayRect.right - displayRect.left;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	short lastDirection = kForward;	Ptr mySndH[2];	Boolean overflowFwd;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent,myEvent;	short refNum;	long z,myFilePos;	Point oldPt,originalPt;	short varySpeed; 	long startByte;	float howFar;	Rect invRect, presInv, tempr;	Boolean invDirectionChanged = false;	short minEdit,maxEdit, selectionStart;	short lastHoriz,curHoriz;	FInfo fndrInfo;	Boolean selectionMode = false;	Boolean flipper = false,lastFlip = false;	GetMouse(&oldPt);	GetMouse(&scrubStart);	GetMouse(&originalPt);	myEvent.what = 0;	xgCallBackPerformed = false;	xuseTwo = 0;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr)	{		return;	}	switch (fndrInfo.fdType)	{		case 'Sd2f':		break;			default:			return;		break;	}	if (xgetSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes))	{		return;	}		dblBuffSize24Bit = dblBufferSize;	if (theWordSize == 3)	{		dblBuffSize24Bit = (dblBuffSize24Bit * 3) / 2;	}	dblBuffSize24Bit = dblBuffSize24Bit / 6;	dblBuffSize24Bit = dblBuffSize24Bit * 6;	/*selectRect.top = displayRect.top;	selectRect.bottom = displayRect.bottom;*/							drawOverViewInWindow(mySpec);		if (waveFormSelected)	{		tempr = selectRect;		InvertRect(&selectRect);	}	fileBytes = theBytes;	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)	{		return;	}	mySndH[0] = NewPtr(dblBuffSize24Bit << 1);	if (!mySndH[0])	{				return;	}		mySndH[1] = NewPtr(dblBuffSize24Bit << 1);	if (!mySndH[1])	{				DisposPtr(mySndH[0]);		return;	}					minEdit = displayRect.left;	maxEdit = displayRect.right;		setUpCache ();	howFar = (float)startHoriz / (float)displayWidth;	howFar = howFar * (float)theBytes;	startByte = (long)howFar;	startByte = (unsigned long)startByte >> 2;	startByte = (unsigned long)startByte << 2;	if (theWordSize == 3)	{		startByte = (startByte / 3) * 3;	}	if (theWordSize == 2)	{		startByte = startByte >> 2 << 2;	}	xSetFPos(refNum,fsFromStart,startByte);	howFar = ((float)startByte / (float)theBytes) * (float)(displayRect.right - displayRect.left);	curHoriz = howFar;	SetRect(&invRect,curHoriz,displayRect.top + 1,curHoriz + 1,displayRect.bottom);	InvertRect(&invRect);	presInv = invRect;	lastHoriz = curHoriz;	if (!isPressed(0x3B))	{		varySpeed = currentSpeed = 100;		oldPt.h = 0;		xAlterPitch(xmySndChan,varySpeed);	}		if (currentSpeed > 100)	{		inOutCount = dblBuffSize24Bit;		if (theWordSize == 3)		{			inOutCount = (inOutCount / 3) * 3;			presInOutCount = (inOutCount * 2 ) / 3;			presInOutCount = (presInOutCount / 3) * 3;		}		else		{			inOutCount = inOutCount >> 2 << 2;			presInOutCount = inOutCount;		}	}	else	{		if (currentSpeed < 100)		{			inOutCount = dblBuffSize24Bit >> 3;			if (theWordSize == 3)			{				inOutCount = (inOutCount / 3) * 3;				presInOutCount = (inOutCount * 2 ) / 3;				presInOutCount = (presInOutCount / 3) * 3;			}			else			{				inOutCount = inOutCount >> 2 << 2;				presInOutCount = inOutCount;			}		}		else		{			inOutCount = dblBuffSize24Bit;			if (theWordSize == 3)			{				presInOutCount = (inOutCount * 2 ) / 3;				presInOutCount = (presInOutCount / 3) * 3;			}			else			{				presInOutCount = inOutCount;			}		}	}				iErr = xFSRead(refNum,&inOutCount,mySndH[xuseTwo]);		if (theWordSize ==1) /* 8 bit audio */	{		for (z = (long)mySndH[xuseTwo]; z<(long)mySndH[xuseTwo]+inOutCount;z++)		{			*((Byte *)z) += 128;		}	}	theXWordSize = theWordSize;	if (theWordSize == 3)	{		presInOutCount = inOutCount;		convertBuffer24To16 (mySndH[xuseTwo], &presInOutCount);		theXWordSize = 2;	}					xmySndChan = xCreateSndChannel(stereo);		/** SDI is mono **/	    sound.samplePtr =  mySndH[xuseTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (presInOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/			setCursor(kRightCursor);		GetNextEvent(everyEvent,&theEvent);	    cmd.cmd = bufferCmd;    cmd.param2 = (long)&sound;    err = SndDoImmediate(xmySndChan,&cmd);	   // inOutCount = presInOutCount;	xgCallBackPerformed = false;	xInstallCallBack (xmySndChan);		if (iErr == eofErr)	{		while (xgCallBackPerformed == false)		{			if(!Button())  /* stop it playing with an event */			{					xgCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				if (!isPressed(0x3B))		{			if (varySpeed < 0)			{				varySpeed = -100;				currentSpeed = 100;			}			else			{				varySpeed = 100;				currentSpeed = 100;			}			oldPt.h = 0;			xAlterPitch(xmySndChan,100);		}		if (currentSpeed > 100)		{			inOutCount = dblBuffSize24Bit;			if (theWordSize == 3)			{				presInOutCount = (inOutCount * 2 ) / 3;				presInOutCount = (presInOutCount / 3) * 3;			}			else			{				presInOutCount = inOutCount;			}		}		else		{			if (currentSpeed < 100)			{				inOutCount = dblBuffSize24Bit >> 3;				if (theWordSize == 3)				{					inOutCount = (inOutCount / 3) * 3;					presInOutCount = (inOutCount * 2 ) / 3;					presInOutCount = (presInOutCount / 3) * 3;				}				else				{					inOutCount = inOutCount >> 2 << 2;					presInOutCount = inOutCount;				}			}			else			{				inOutCount = dblBuffSize24Bit;				if (theWordSize == 3)				{					presInOutCount = (inOutCount * 2 ) / 3;					presInOutCount = (presInOutCount / 3) * 3;				}				else				{					presInOutCount = inOutCount;				}			}		}		iErr = xFSRead(refNum,&inOutCount,mySndH[!xuseTwo]);			if (theWordSize ==1)		{			for (z = (long)mySndH[!xuseTwo]; z<(long)mySndH[!xuseTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}		theXWordSize = theWordSize;		if (theWordSize == 3)		{			presInOutCount = inOutCount;			convertBuffer24To16 (mySndH[!xuseTwo], &presInOutCount);			theXWordSize = 2;		}	}	while (Button())	{	    sound.samplePtr =  mySndH[!xuseTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (presInOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    err = SndDoCommand(xmySndChan,&cmd,true);	  					//inOutCount = presInOutCount;		while (xgCallBackPerformed == false && Button())		{			if(Button()) 			{					Point localPt;				GetMouse(&localPt);									if (!isPressed(0x3B))				{					if (varySpeed < 0)					{						varySpeed = -100;						currentSpeed = 100;					}					else					{						varySpeed = 100;						currentSpeed = 100;					}					oldPt.h = 0;					xAlterPitch(xmySndChan,100);				}								flipper = isPressed(0x3A);												if(GetNextEvent(keyDownMask,&theEvent)) 				{					short theQuay;					Rect blankRect;										switch (theEvent.what)					{												case keyDown:														theQuay = (theEvent.message) & keyCodeMask;							/*theChar = (theEvent.message) & charCodeMask;*/							switch (theQuay)							{								case 0x1200: case 0x5300:									if (waveFormSelected)									{										 if (invRect.left < selectRect.right)										 {											if (invRect.left < selectRect.left) /* more to the left */											{												 blankRect = selectRect;												 blankRect.left =  invRect.left;												 blankRect.right =  selectRect.left;												 InvertRect(&blankRect);												 selectRect.left = blankRect.left;											}											else											{												if (invRect.left > selectRect.left) /* more to the right */												{													 blankRect = selectRect;													 blankRect.left = selectRect.left;													 blankRect.right =  invRect.left;													 InvertRect(&blankRect);													 selectRect.left = blankRect.right;												}																				}										 }									 }									 else									 {										 selectRect.left = invRect.left;										 selectRect.right = displayRect.right;										 InvertRect(&selectRect);										 waveFormSelected = true;										 zDrawGrowIcon (myWindow);									 }								break;																case 0x1300: case 0x5400:									if ( waveFormSelected) 									{										 if (invRect.left > selectRect.left)										 {											if (invRect.left < selectRect.right) /* more to the left */											{												 blankRect = selectRect;												 blankRect.left =  invRect.left;												 blankRect.right =  selectRect.right;												 InvertRect(&blankRect);												 selectRect.right = blankRect.left;											}											else											{												if (invRect.left > selectRect.right) /* more to the right */												{													 blankRect = selectRect;													 blankRect.left = selectRect.right;													 blankRect.right =  invRect.left;													 InvertRect(&blankRect);													 selectRect.right = blankRect.right;												}																				}										 }									 }									 else									 {										 selectRect.right = invRect.right;										 selectRect.left = displayRect.left;										 InvertRect(&selectRect);										 waveFormSelected = true;										 zDrawGrowIcon (myWindow);									 }								break;																default:																break;							}						break;												default:												break;					}				}										if ((localPt.h != oldPt.h)  || (flipper != lastFlip))				{					varySpeed = (localPt.h-originalPt.h) * kScrubSensitivity;					varySpeed += 100;										lastFlip = flipper;										if (flipper)					{						varySpeed = -varySpeed;					}										if (!isPressed(0x3B))					{						if (varySpeed < 0)						{							varySpeed = -100;							currentSpeed = 100;						}						else						{							varySpeed = 100;							currentSpeed = 100;						}						xAlterPitch(xmySndChan,100);					}										if (varySpeed == 0)					{						//direction = kStationary;					}					else					{						if (varySpeed < 0)						{							if (direction == kForward)							{								setCursor(kLeftCursor);																invDirectionChanged = true;																direction = kBackward;								xGetFPos (refNum, &tempPos);								tempPos += -(inOutCount * 2);								whereLoc = tempPos;								if (theWordSize == 3)								{									whereLoc = (whereLoc / 3) * 3;								}								if (theWordSize == 2)								{									whereLoc = whereLoc >> 2 << 2;								}								iErr = xSetFPos(refNum,fsFromStart,whereLoc);								if (iErr)								{									xSetFPos(refNum,fsFromStart,0);									iErr = 0;								}																cmd.cmd = flushCmd;								cmd.param1 = 0;							    cmd.param2 = 0;							    							    err = SndDoImmediate(xmySndChan,&cmd);																xInstallCallBack (xmySndChan);																BlockMove (mySndH[xuseTwo],mySndH[!xuseTwo],presInOutCount);																Reverse(mySndH[!xuseTwo],presInOutCount,theXWordSize,stereo);																sound.samplePtr =  mySndH[!xuseTwo];           /*location of sound data*/							    sound.numChannels = stereo+1;              /*stereo sound*/							    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/							    sound.loopStart = 0;                /*there are no loop points*/							    sound.loopEnd = 0;							    sound.encode = extSH;               /*this is an extended SH*/							    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/							    sound.numFrames = (presInOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/							    sound.markerChunk = nil;            /*not used*/							    sound.instrumentChunks = nil;       /*not used*/							    sound.AESRecording = nil;           /*not used*/							    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/							    sound.futureUse1 = 0;               /*reserved*/							    sound.futureUse2 = 0;               /*reserved*/							    sound.futureUse3 = 0;               /*reserved*/							    sound.futureUse4 = 0;               /*reserved*/														    cmd.cmd = bufferCmd;							    cmd.param2 = (long)&sound;							    err = SndDoCommand(xmySndChan,&cmd,true);							}							else							{								invDirectionChanged = false;							}							direction = kBackward;														varySpeed = (originalPt.h - localPt.h) * kScrubSensitivity;							varySpeed -= 100;														if (flipper)							{								varySpeed = -varySpeed;							}						}							else						{							if (direction == kBackward)							{								setCursor(kRightCursor);																invDirectionChanged = true;																cmd.cmd = flushCmd;								cmd.param1 = 0;							    cmd.param2 = 0;							    							    err = SndDoImmediate(xmySndChan,&cmd);								direction = kForward;									xGetFPos (refNum, &tempPos);								tempPos += inOutCount * 2;								whereLoc = tempPos;								if (theWordSize == 3)								{									whereLoc = (whereLoc / 3) * 3;								}								if (theWordSize == 2)								{									whereLoc = whereLoc >> 2 << 2;								}								iErr = xSetFPos(refNum,fsFromStart,whereLoc);								xInstallCallBack (xmySndChan);																BlockMove (mySndH[xuseTwo],mySndH[!xuseTwo],presInOutCount);																Reverse(mySndH[!xuseTwo],presInOutCount,theXWordSize,stereo);																sound.samplePtr =  mySndH[!xuseTwo];           /*location of sound data*/							    sound.numChannels = stereo+1;              /*stereo sound*/							    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/							    sound.loopStart = 0;                /*there are no loop points*/							    sound.loopEnd = 0;							    sound.encode = extSH;               /*this is an extended SH*/							    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/							    sound.numFrames = (presInOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/							    sound.markerChunk = nil;            /*not used*/							    sound.instrumentChunks = nil;       /*not used*/							    sound.AESRecording = nil;           /*not used*/							    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/							    sound.futureUse1 = 0;               /*reserved*/							    sound.futureUse2 = 0;               /*reserved*/							    sound.futureUse3 = 0;               /*reserved*/							    sound.futureUse4 = 0;               /*reserved*/														    cmd.cmd = bufferCmd;							    cmd.param2 = (long)&sound;							    err = SndDoCommand(xmySndChan,&cmd,true);							}							else							{								invDirectionChanged = false;							}							direction = kForward;						}					}					if (varySpeed > 200)						varySpeed = 200;																oldPt.h = localPt.h;					if (!isPressed(0x3B))					{						if (varySpeed < 0)						{							varySpeed = -100;							currentSpeed = 100;						}						else						{							varySpeed = 100;							currentSpeed = 100;						}												oldPt.h = 0;						xAlterPitch(xmySndChan,100);					}										xAlterPitch(xmySndChan,abs(varySpeed));														}								/*if (GetNextEvent (everyEvent, &myEvent))				{					if (myEvent.what == keyDown)					{						xgCallBackPerformed = true;						stoppit = true;					}				}*/			}			else			{				xgCallBackPerformed = true;			}		}				xgCallBackPerformed = false;		if (!stoppit)			xInstallCallBack (xmySndChan);				if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{						if (currentSpeed > 100)			{				inOutCount = dblBuffSize24Bit;				if (theWordSize == 3)				{					presInOutCount = (inOutCount * 2 ) / 3;					presInOutCount = (presInOutCount / 3) * 3;				}				else				{					presInOutCount = inOutCount;				}			}			else			{				if (currentSpeed < 100)				{					//FlashMenuBar(0);					inOutCount = dblBuffSize24Bit >> 3;					if (theWordSize == 3)					{						inOutCount = (inOutCount / 3) * 3;						presInOutCount = (inOutCount * 2 ) / 3;						presInOutCount = (presInOutCount / 3) * 3;					}					else					{						inOutCount = inOutCount >> 2 << 2;						presInOutCount = inOutCount;					}				}				else				{					inOutCount = dblBuffSize24Bit;					if (theWordSize == 3)					{						presInOutCount = (inOutCount * 2 ) / 3;						presInOutCount = (presInOutCount / 3) * 3;					}					else					{						presInOutCount = inOutCount;					}				}			}			if (direction == kBackward)			{				if ((cacheBufferStart + logicalFilePos) > inOutCount /*dblBuffSize24Bit*/)				{					xGetFPos (refNum, &tempPos);					tempPos += (-(inOutCount));					whereLoc = tempPos;					if (theWordSize == 3)					{						whereLoc = (whereLoc / 3) * 3;					}					if (theWordSize == 2)					{						whereLoc = whereLoc >> 2 << 2;					}					iErr = xSetFPos(refNum,fsFromStart,whereLoc);					if (iErr)					{						xSetFPos(refNum,fsFromStart,0);						iErr = 0;					}				}				else /* within the last buffer */				{					Point localPt;										xGetFPos (refNum, &myFilePos);					if (myFilePos == 0)					{						Point loc2;						GetMouse (&localPt);						GetMouse (&loc2);						while (Button() && (localPt.h < (originalPt.h - (100 / kScrubSensitivity))))						{							GetMouse (&localPt);						}						direction = kForward;						xSetFPos(refNum,fsFromStart,0);						inOutCount = dblBuffSize24Bit >> 3;												if (theWordSize == 3)						{							inOutCount = (inOutCount / 3 ) * 3;							presInOutCount = (inOutCount * 2 ) / 3;							presInOutCount = (presInOutCount / 3) * 3;						}						else						{							inOutCount = inOutCount >> 2 << 2;							presInOutCount = inOutCount;						}						varySpeed = 0;					}					else					{						xSetFPos(refNum,fsFromStart,0);						inOutCount = myFilePos;						if (theWordSize == 3)						{							inOutCount = (inOutCount / 3 ) * 3;							presInOutCount = (inOutCount * 2 ) / 3;							presInOutCount = (presInOutCount / 3) * 3;						}						else						{							inOutCount = inOutCount >> 2 << 2;							presInOutCount = inOutCount;						}					}					//Reverse(mySndH[xuseTwo], inOutCount, theWordSize,stereo);				}				}			xGetFPos (refNum, &myFilePos);			if (direction == kBackward)			{				myFilePos += inOutCount;			}			howFar = ((float)myFilePos / (float)theBytes) * (float)(displayRect.right - displayRect.left);			curHoriz = howFar;								if (curHoriz != lastHoriz)			{				if (!isPressed(0x38) && !isPressed(0x3C))				{					if (selectionMode)					{						RGBColor myColor;						waveFormSelected = true;												selectRect.left = minEdit;						selectRect.right = maxEdit;						/*selectRect.top = displayRect.top;						selectRect.bottom = displayRect.bottom;*/						invRect.left = 0;						invRect.right = 0;											/*myColor.red = (regionSelected) ? 0x0000 : 0xFFFF;						myColor.green = (regionSelected) ? 0xFFFF : 0x0000;						myColor.blue = 0;						RGBForeColor(&myColor);						FrameRect(&selectRect);						myColor.red = 0;						myColor.green = 0;						myColor.blue = 0;						RGBForeColor(&myColor);	*/													zDrawGrowIcon (myWindow);						/* do outro */						selectionMode = false;					}					else					{						InvertRect(&invRect);					}					presInv = invRect;					SetRect(&invRect,curHoriz,displayRect.top + 1,curHoriz+1,displayRect.bottom);					lastDirection = direction;													}				else /* scrub edit */				{					if (!selectionMode)					{						selectionStart = lastHoriz;						if (waveFormSelected)						{							regionSelected = waveFormSelected = false;							invRect.left = selectionStart;							invRect.right = selectionStart;							drawOverViewInWindow(mySpec);							/* delete selection, clear screen, variables etc */						}						/* do intro */						selectionMode = true;					}					if (curHoriz > lastHoriz) /* forward */					{						short tempPt = invRect.right;						if (lastDirection == kBackward)						{							tempPt = invRect.left;						}						SetRect(&invRect,tempPt,displayRect.top + 1,curHoriz + 1,displayRect.bottom);																	lastDirection = kForward;					}					else  /* backward */					{						short tempPt = invRect.left;						if (lastDirection == kForward)						{							tempPt = invRect.right;						}						SetRect(&invRect,curHoriz,displayRect.top + 1,tempPt,displayRect.bottom);												lastDirection = kBackward;					}										if (curHoriz < selectionStart)					{						minEdit = curHoriz;						maxEdit = selectionStart;					}					else					{						minEdit = selectionStart;						maxEdit = curHoriz;					}				}				InvertRect(&invRect);				presInv = invRect;							}			else			{				//lastDirection = kStationary;			}						lastHoriz = curHoriz;								/*	if (overflowFwd && direction == kForward)			{				Point localPt;				 cmd.cmd = flushCmd;				 cmd.param2 = 0;				 err = SndDoImmediate(xmySndChan,&cmd);								GetMouse (&localPt);				while (Button() && (localPt.h >= (originalPt.h)))				{					GetMouse (&localPt);				}				direction = kBackward;				//iErr = xSetFPos(refNum,fsFromLEOF,-(inOutCount));			}*/						overflowFwd = false;			iErr = xFSRead(refNum,&inOutCount,mySndH[xuseTwo]);						if (iErr == eofErr)			{				overflowFwd = true;			}			if (theWordSize ==1)			{				for (z = (long)mySndH[xuseTwo]; z<(long)mySndH[xuseTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}						theXWordSize = theWordSize;			if (theWordSize == 3)			{				presInOutCount = inOutCount;				convertBuffer24To16 (mySndH[xuseTwo], &presInOutCount);				theXWordSize = 2;			}			if (direction == kBackward)			{				Reverse(mySndH[xuseTwo], presInOutCount, theXWordSize,stereo);					xGetFPos (refNum, &tempPos);					tempPos += (-(inOutCount));					whereLoc = tempPos;					if (theWordSize == 3)					{						whereLoc = (whereLoc / 3) * 3;					}					if (theWordSize == 2)					{						whereLoc = whereLoc >> 2 << 2;					}					iErr = xSetFPos(refNum,fsFromStart,whereLoc);				if (iErr)				{					iErr = xSetFPos(refNum,fsFromStart,0);				}			}									xuseTwo = !xuseTwo;		}	}					if (selectionMode)	{			RGBColor myColor;		waveFormSelected = true;				selectRect.left = minEdit;		selectRect.right = maxEdit;		/*selectRect.top = displayRect.top;		selectRect.bottom = displayRect.bottom;*/		invRect.left = 0;		invRect.right = 0;			/*myColor.red = (regionSelected) ? 0x0000 : 0xFFFF;		myColor.green = (regionSelected) ? 0xFFFF : 0x0000;		myColor.blue = 0;		RGBForeColor(&myColor);		FrameRect(&selectRect);		myColor.red = 0;		myColor.green = 0;		myColor.blue = 0;		RGBForeColor(&myColor);	*/					zDrawGrowIcon (myWindow);		/* do outro */		selectionMode = false;	}		   InvertRect(&invRect);	 	   presInv = invRect;	 cmd.cmd = flushCmd;	 cmd.param2 = 0;	  err = SndDoImmediate(xmySndChan,&cmd);	    	  cmd.cmd = quietCmd;	  cmd.param2 = 0;	  err = SndDoImmediate(xmySndChan,&cmd);		iErr = SndDisposeChannel(xmySndChan,true);	DisposPtr((char *)xmySndChan);	GetNextEvent(everyEvent,&theEvent);	/* maybe shut it up */	FSClose(refNum);	DisposPtr(mySndH[0]);	DisposPtr(mySndH[1]);	disposeCache ();		if (waveFormSelected)	{		RGBColor myColor;		myColor.red = 0xFFFF;		myColor.green = 0x0000;		myColor.blue = 0;		RGBForeColor(&myColor);		tempr = selectRect;		tempr.top--;		FrameRect(&selectRect);				myColor.red = 0;		myColor.green = 0;		myColor.blue = 0;		RGBForeColor(&myColor);			zDrawGrowIcon (myWindow);	}	if (myEvent.what == keyDown)	{		switch ((myEvent.message) & keyCodeMask)		{			case 0x7B00 : case 0x7C00 : case 0x7D00 : case 0x7E00 : 				/* do something special if you pressed an arrow key */			break;					default :			break;			}	}	}short lastPercent = -1;OSErr xAlterPitch(SndChannelPtr chan, short percent) { 	SndCommand cmd; 	OSErr err;	short upDown, One,Two;	long intermed;		currentSpeed = percent;		if (percent == lastPercent)	{		return noErr;	}	lastPercent = percent;		cmd.cmd = 86; 	cmd.param1 = 0; 		if (percent > 100)	{		upDown = kPitchUp;	}	if (percent < 100)	{		upDown = kPitchDown;	}	if (percent == 100)	{		upDown = kPitchNormal;	}		switch (upDown)	{		case kPitchUp:				One = percent/100;			percent = percent - (One * 100);			intermed = (long)percent * 0x00010000 / 100L;			Two = LoWord(intermed);			cmd.param2 = (((long)One) << 16) | ((long)Two & 0x0000FFFF);		break;				case kPitchDown:			One = 0x0000;			intermed = (long)percent * 0x00010000 / 100L;			Two = LoWord(intermed);			cmd.param2 = (((long)One) << 16) | ((long)Two & 0x0000FFFF);		break;				case kPitchNormal:			cmd.param2 = 0x00010000;		break;	}	err = SndDoImmediate(chan, &cmd); 				return (err); }Boolean Reverse(Ptr theData, long howMuch, short theWordSize, Boolean stereo){	Ptr theData2;	long z;			theData2 = NewPtrClear(dblBuffSize24Bit);	if (!theData2)	{		return false;	}			if (stereo)	{		if (theWordSize == 2)		{				for (z= (howMuch- 4);z>=0;z-=4L)			{				*(((short *)theData2) + (((howMuch - 4) - z) >> 1)) = *(((short *)theData) + (z >> 1));				*(((short *)theData2) + (((howMuch - 2) - z) >> 1)) = *(((short *)theData) + ((z + 2) >> 1));			}					}		else		{			for (z=(howMuch - 2);z>=0;z-=2)			{				*(((char *)theData2) + ((howMuch - 2) - z)) = *(((char *)theData) + z);				*(((char *)theData2) + ((howMuch - 1) - z)) = *(((char *)theData) + z + 1);			}			}	}	else	{		if (theWordSize == 2)		{				for (z=(howMuch - 2);z>=0;z-=2L)			{				*(((short *)theData2) + (((howMuch - 2) - z) >> 1)) = *(((short *)theData) + (z >> 1));			}					}		else		{			for (z=(howMuch - 1);z>=0;z--)			{				*(((char *)theData2) + ((howMuch - 1) - z)) = *(((char *)theData) + z);			}			}	}	BlockMove (theData2,theData,howMuch);		DisposPtr (theData2);	return true;}OSErr xFSRead(short refNum,long * inOutCount,Ptr theData){	OSErr iErr;	long inOutCopy;		inOutCopy = *inOutCount;	if (*inOutCount >  (cacheBufferLength - logicalFilePos))	{		iErr = fillerup(refNum,&inOutCopy,direction);	}			if (*inOutCount <= (cacheBufferLength - logicalFilePos))	{		/* get it from the cache */		BlockMove (cacheBuffer + logicalFilePos,theData,*inOutCount);		logicalFilePos += *inOutCount;		return noErr;	}	else	{		//FlashMenuBar(0);		*inOutCount = (cacheBufferLength - logicalFilePos);			BlockMove (cacheBuffer + logicalFilePos,theData,*inOutCount);		logicalFilePos += *inOutCount;		return eofErr;	}	return noErr;}		OSErr fillerup(short refNum,long * inOutCount,short direction){	long myCount;	long remainder;	OSErr iErr;		remainder = cacheBufferLength - logicalFilePos;			BlockMove (cacheBuffer + logicalFilePos,xtempPtr,remainder);	BlockMove (xtempPtr, cacheBuffer,remainder);			myCount = kCacheSize - remainder;		iErr = FSRead(refNum,&myCount,cacheBuffer + remainder);		//physicalFilePos += myCount; /* this is actually wrong. this should come after the next line */		cacheBufferStart = physicalFilePos - remainder;		physicalFilePos += myCount;		logicalFilePos = 0;		cacheBufferLength = myCount + remainder;	/*	cacheBufferLength	logicalFilePos	physicalFilePos	cacheBuffer	cacheBufferStart*/		return iErr;}OSErr xGetFPos (short refNum, long * filePos){	*filePos = cacheBufferStart + logicalFilePos;	return noErr;}	OSErr xSetFPos(short refNum,short posMode,long posOffset){	long wantPos,myCount,newPos;	OSErr iErr;		switch (posMode)	{		case fsFromStart:			wantPos = posOffset;		break;				case fsFromLEOF:			wantPos = fileBytes + posOffset;		break;				case fsFromMark:			wantPos = (cacheBufferStart + logicalFilePos) + posOffset;		break;	}		if (wantPos > fileBytes)	{		return eofErr;	}		if (wantPos < 0)	{		return posErr;	}			if ((wantPos >= cacheBufferStart) && (wantPos < (cacheBufferStart + cacheBufferLength)))	{		logicalFilePos = wantPos - cacheBufferStart;				/* move within the cache */	}	else	{		switch(direction)		{			case kForward:				/* really move */				iErr = SetFPos(refNum,fsFromStart,wantPos);				if (iErr)				{								}				physicalFilePos = wantPos;				cacheBufferStart = wantPos;				logicalFilePos = 0;				myCount = kCacheSize;				iErr = FSRead(refNum,&myCount,cacheBuffer);				physicalFilePos += myCount;				cacheBufferLength = myCount;			break;						case kBackward:				/* really move */				newPos = wantPos - (kCacheSize - dblBuffSize24Bit - 4L);				if (newPos < 0)				{					newPos = 0;				}				iErr = SetFPos(refNum,fsFromStart,newPos);				if (iErr)				{								}				physicalFilePos = newPos;				cacheBufferStart = newPos;				logicalFilePos = wantPos - newPos;				myCount = kCacheSize;				iErr = FSRead(refNum,&myCount,cacheBuffer);				physicalFilePos += myCount;				cacheBufferLength = myCount;			break;		}	}	return noErr;}