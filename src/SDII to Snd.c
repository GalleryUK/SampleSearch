#include "SampleSearch.h"#include "Globals.h"#include "xSound.h"#include <Resources.h>#include <FixMath.h>#include <Types.h>#include <SoundInput.h>extern Boolean DialogPresent;extern Boolean plusMode;#include "DSP.h"#define kWaitIfFull TRUE	// wait for room in queue#define kSoundComplete  1	// last command in channel;  Application definedextern long dblBufferSize;extern Boolean gCallBackPerformed;  extern Boolean autoSustain;void SDIIPlay(FSSpec,short playFreq);Boolean getSDIIData (FSSpec mySpec, long* theRate, short* theWordSize, Boolean* stereo, long* theBytes);SndChannelPtr CreateSndChannel(Boolean Stereo);void CallSndPlay(Handle);OSErr InstallCallBack(SndChannelPtr);void pitchIt(void);short isPressed(unsigned short k );void genErrorN(Str255 myText,long Errno);OSErr AlterPitch(SndChannelPtr chan, Fixed theRatio);void SDIIPlayScrub(FSSpec mySpec, Rect displayRect, short startHoriz);short keyAcrossTheTop[14];Fixed keyRatio[14];void ConvertSound(Ptr sndPtr, long datasize);long findCOMM(short localRefNum, OSType);extern float myPowers[128];OSErr playIMAWAV (FSSpec mySpec);SndChannelPtr mySndChan;OSErr convertBuffer24To16 (Ptr theSoundData, long *sourceLength);Fixed myPow(Byte keynum);short theXWordSize;short  arrowPressed;long presInOutCount;void ConvertSound(Ptr sndPtr, long datasize);short arrowKey (void);Boolean pleaseStop(void);Boolean pleaseStopII(void);void convertSplitMonoToStereo(Ptr sourceAudioA, Ptr sourceAudioB,Ptr destAudio, long monoLength);OSErr convertBuffer16To24 (Ptr theSourceData,Ptr theDestData, long *Length);OSErr SDIISplitAudition(FSSpec theFile1, FSSpec theFile2);void ConvertSound(Ptr sndPtr, long datasize);#define kLeftArrowPressed 1#define kRightArrowPressed 2	#define kDownArrowPressed 3#define kUpArrowPressed 4extern Boolean globalStop;void AIFFRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect);void ConvertSoundB(Ptr sndPtr, long datasize);void ConvertSoundB(Ptr sndPtr, long datasize){	long theCount;	for (theCount = (long)sndPtr;theCount< ((long)sndPtr + datasize);theCount+=2L)	{	     	*(short *)(theCount) = *(Byte *)(theCount) | (*(Byte *)(theCount + 1) << 8);	}}void genErrorN(Str255 myText,long Errno){	Str255 myErrorNum;	GrafPtr	savePort;		GetPort (&savePort);	if (DialogPresent)	{		SysBeep(5);		return;	}	NumToString(Errno,myErrorNum);	ParamText(myText,myErrorNum,0,0);		color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	dAlert(2200,0);	SetPort (savePort);	return;}extern Boolean mousePlay;extern Boolean playingFromWaveform;extern Boolean stopPlaying;//#define dspPlay 1void SDIIRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect);void SDIIRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	EventRecord theEvent;	SndCommand cmd;	SCStatus theStat;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	long thePlaySize, presPlaySize;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	short refNum,curHoriz = 0, lastHoriz;	long z;	Rect invRect;	float howFar;	GrafPtr savePort;	long currentFilePos = startPos, lastFilePos;	long dblBuffSize24Bit;	FInfo fndrInfo;	Boolean loopPlay = false, firstTime = true;	if (isPressed(0x3A) && isPressed(0x3B))	{		loopPlay = true;	}#ifdef dspPlay	initDSP();#endif	iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr)	{		return;	}	switch (fndrInfo.fdType)	{		case 'AIFF':			AIFFRegionPlayCursor(mySpec, playFreq, startPos, endPos, displayRect);			return;		break;		case 'Sd2f':		break;		default:			return;		break;	}	dblBuffSize24Bit = dblBufferSize / 3;	dblBuffSize24Bit = dblBuffSize24Bit * 3;	startPos = startPos / 3;	startPos = startPos * 3;	GetPort(&savePort);	SetPort((GrafPtr)myWindow);		gCallBackPerformed = false;	useTwo = 0;			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes))	{		SetPort(savePort);		return;	}	if (theWordSize == 3)	{		startPos = startPos / 3;		startPos = startPos * 3;		endPos = endPos / 3;		endPos = endPos * 3;	}	if (theWordSize == 2)	{		startPos = startPos >> 2 << 2;		endPos = endPos >> 2 << 2;		//dblBuffSize24Bit = dblBuffSize24Bit >> 2 << 2;		dblBuffSize24Bit = dblBufferSize >> 1 << 1;	}	thePlaySize = endPos - startPos;	if (thePlaySize < 0)	{		SetPort(savePort);		return;		}	presPlaySize = thePlaySize;	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)	{		SetPort(savePort);		return;	}				mySndH[0] = NewPtr(dblBuffSize24Bit);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		SetPort(savePort);		return;	}		mySndH[1] = NewPtr(dblBuffSize24Bit);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		SetPort(savePort);		return;	}				mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	useTwo = 0;	gCallBackPerformed = false;	firstTime = true;do {	howFar = ((float)startPos / (float)theBytes) * (float)(displayRect.right - displayRect.left);	lastHoriz = howFar;//	gCallBackPerformed = false;//	useTwo = 0;		curHoriz = 0;	lastFilePos = currentFilePos = startPos;	stoppit = false;	stoppitnextTime = false;	thePlaySize = presPlaySize;	iErr = SetFPos(refNum,fsFromStart,startPos);	if (iErr)	{		FSClose(refNum);		SetPort(savePort);		return;	}	if (firstTime){		inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		SetPort(savePort);		return;	}	presInOutCount = inOutCount;	currentFilePos += inOutCount;	lastFilePos = currentFilePos;		thePlaySize -= inOutCount;				howFar = ((float)startPos / (float)theBytes) * (float)(displayRect.right - displayRect.left);		curHoriz = howFar;		SetRect(&invRect,curHoriz,displayRect.top + 1,curHoriz + 1,displayRect.bottom);		InvertRect(&invRect);		lastHoriz = curHoriz;				if (theWordSize ==1)		{			for (z = (long)mySndH[useTwo]; z< (long)mySndH[useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}	theXWordSize = theWordSize;	if (theWordSize == 3)	{		presInOutCount = inOutCount;		convertBuffer24To16 (mySndH[useTwo], &inOutCount);		theXWordSize = 2;	}	#ifdef dspPlay	processDSPBuffer((short *)mySndH[useTwo],inOutCount);	if (stopPlaying)	{		stoppit = true;		gCallBackPerformed = true;	}#endif		//pitchIt();	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd );	    		inOutCount = presInOutCount;	InstallCallBack (mySndChan);			if (iErr == eofErr || (inOutCount < dblBuffSize24Bit))	{		while (gCallBackPerformed == false)		{			//pitchIt();#ifdef dspPlay#else						if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}#endif		}		stoppit = true;	}	}					if (!stoppit)	{				inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);			DisposPtr(mySndH[1]);			FSClose (refNum);			SetPort(savePort);			return;		}				presInOutCount = inOutCount;		currentFilePos += inOutCount;		thePlaySize -= inOutCount;		if (theWordSize ==1)		{			for (z = (long)mySndH[!useTwo]; z<(long)mySndH[!useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}		theXWordSize = theWordSize;		if (theWordSize == 3)		{			presInOutCount = inOutCount;			convertBuffer24To16 (mySndH[!useTwo], &inOutCount);			theXWordSize = 2;		}	}firstTime = false;	while (!stoppit)	{	#ifdef dspPlay	processDSPBuffer((short *)mySndH[!useTwo],inOutCount);	if (stopPlaying)	{		stoppit = true;		gCallBackPerformed = true;	}#endif	    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{#ifdef dspPlay#else							if(pleaseStop() || (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}#endif			if (playingFromWaveform)			{				if(isPressed(0x37)) /* command */				{					gCallBackPerformed = true;					stoppit = true;				}				if (isPressed(0x3B))				{										/*GetMouse(&localPt);					SDIIPlayScrub(mySpec, displayRect, localPt.h);*/					stoppit = true;					gCallBackPerformed = true;				}								if (isPressed(0x12) || isPressed(0x53)) /* IN POINT */				{									}				if (isPressed(0x13) || isPressed(0x54)) /*out point */				{								}			}		}				howFar = ((float)lastFilePos / (float)theBytes) * (float)(displayRect.right - displayRect.left);				curHoriz = howFar;		if (curHoriz > lastHoriz)		{			InvertRect(&invRect);			SetRect(&invRect,curHoriz,displayRect.top + 1,curHoriz + 1,displayRect.bottom);			InvertRect(&invRect);			lastHoriz = curHoriz;		}						gCallBackPerformed = false;		if (!stoppit)			iErr = InstallCallBack (mySndChan);					if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;				iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				SysBeep(5);				DisposPtr(mySndH[0]);				DisposPtr(mySndH[1]);		#ifdef dspPlay				exitDSP();		#endif				FSClose (refNum);				InvertRect(&invRect);				SetPort(savePort);				return;			}			lastFilePos = currentFilePos;			currentFilePos += inOutCount;		#ifdef dspPlay				if ((iErr == eofErr) || (inOutCount < dblBuffSize24Bit))				{					SetFPos(refNum,1,startPos);					iErr = 0;					currentFilePos = startPos;					thePlaySize = endPos - startPos;					howFar = ((float)startPos / (float)theBytes) * (float)(displayRect.right - displayRect.left);					lastHoriz = howFar;					lastFilePos = startPos;				}		#endif						thePlaySize -= inOutCount;			if (theWordSize ==1)			{				for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}#ifdef dspPlay#else			if ((iErr == eofErr) || (inOutCount < dblBuffSize24Bit))			{				stoppitnextTime = true;			}#endif			theXWordSize = theWordSize;			if (theWordSize == 3)			{				presInOutCount = inOutCount;				convertBuffer24To16 (mySndH[useTwo], &inOutCount);				theXWordSize = 2;			}			useTwo = !useTwo;		}	}	if (loopPlay && !Button())	{			useTwo = !useTwo;	}} while (loopPlay && !Button());	  	   if ((iErr != eofErr) && (inOutCount == dblBuffSize24Bit))	   {	      cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);		   inOutCount = presInOutCount;	   }	   iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	   if (mousePlay){	while (theStat.scChannelBusy && Button())	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}}else{	while (theStat.scChannelBusy && !(Button() || (arrowPressed = arrowKey())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}}			iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);		if (arrowPressed)	{		switch (arrowPressed)		{			case kUpArrowPressed:			//	PostEvent(keyDown,0x00027E1E);			//	PostEvent(keyDown,0x00023120);			break;			case kDownArrowPressed:			//	PostEvent(keyDown,0x00027D1F);			//	PostEvent(keyDown,0x00023120);			break;			case kLeftArrowPressed:			//PostEvent(keyDown,0x00027B1C);			//	PostEvent(keyDown,0x00023120);			break;			case kRightArrowPressed:			//	PostEvent(keyDown,0x00027C1D);			//	PostEvent(keyDown,0x00023120);			break;		}	}		/* maybe shut it up */	InvertRect(&invRect);	FSClose(refNum);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);#ifdef dspPlay		exitDSP();#endif		SetPort(savePort);		return;}void AIFFRegionPlayCursor(FSSpec mySpec, short playFreq, long startPos, long endPos, Rect displayRect){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	EventRecord theEvent;	SndCommand cmd;	SCStatus theStat;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	long thePlaySize;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	short refNum,curHoriz = 0, lastHoriz;	long z;	Rect invRect;	float howFar;	GrafPtr savePort;	long currentFilePos = startPos, lastFilePos;	long dblBuffSize24Bit;	short channels;	SoundComponentData sndInfo;	unsigned long curPos;	short chans;	dblBuffSize24Bit = dblBufferSize / 3;	dblBuffSize24Bit = dblBuffSize24Bit * 3;	startPos = startPos / 3;	startPos = startPos * 3;	GetPort(&savePort);	SetPort((GrafPtr)myWindow);		gCallBackPerformed = false;	useTwo = 0;			iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)		return;			iErr = ParseAIFFHeader(refNum, &sndInfo, (unsigned long*)&theBytes,  (unsigned long*)&curPos);	theWordSize = sndInfo.sampleSize >> 3;	theRate = (sndInfo.sampleRate >> 16) & 0x0000FFFF;	chans = sndInfo.numChannels;	stereo = (chans == 2);		theBytes = (theBytes << (chans - 1) << (theWordSize - 1));//	FSClose (dfRefNum);//	iErr = SetFPos(dfRefNum,fsFromStart,curPos);  /* goto start of sound data */	if (theWordSize == 3)	{		startPos = startPos / 3;		startPos = startPos * 3;		endPos = endPos / 3;		endPos = endPos * 3;	}	if (theWordSize == 2)	{		startPos = startPos >> 2 << 2;		endPos = endPos >> 2 << 2;		//dblBuffSize24Bit = dblBuffSize24Bit >> 2 << 2;		dblBuffSize24Bit = dblBufferSize >> 1 << 1;	}	thePlaySize = endPos - startPos;	if (thePlaySize < 0)	{		SetPort(savePort);		return;		}			iErr = SetFPos(refNum,fsFromStart,startPos+curPos);	if (iErr)	{		FSClose(refNum);		SetPort(savePort);		return;	}		howFar = ((float)startPos / (float)theBytes) * (float)(displayRect.right - displayRect.left);	lastHoriz = howFar;			mySndH[0] = NewPtr(dblBuffSize24Bit);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		SetPort(savePort);		return;	}		mySndH[1] = NewPtr(dblBuffSize24Bit);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		SetPort(savePort);		return;	}				inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		SetPort(savePort);		return;	}	presInOutCount = inOutCount;	currentFilePos += inOutCount;	lastFilePos = currentFilePos;		thePlaySize -= inOutCount;				howFar = ((float)startPos / (float)theBytes) * (float)(displayRect.right - displayRect.left);		curHoriz = howFar;		SetRect(&invRect,curHoriz,displayRect.top + 1,curHoriz + 1,displayRect.bottom);		InvertRect(&invRect);		lastHoriz = curHoriz;				if (theWordSize ==1)		{			for (z = (long)mySndH[useTwo]; z< (long)mySndH[useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}	theXWordSize = theWordSize;	if (theWordSize == 3)	{		presInOutCount = inOutCount;		convertBuffer24To16 (mySndH[useTwo], &inOutCount);		theXWordSize = 2;	}			mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/		//pitchIt();	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd );	    		inOutCount = presInOutCount;	gCallBackPerformed = false;	InstallCallBack (mySndChan);			if (iErr == eofErr || (inOutCount < dblBuffSize24Bit))	{		while (gCallBackPerformed == false)		{			//pitchIt();			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);			DisposPtr(mySndH[1]);			FSClose (refNum);			SetPort(savePort);			return;		}				presInOutCount = inOutCount;		currentFilePos += inOutCount;		thePlaySize -= inOutCount;		if (theWordSize ==1)		{			for (z = (long)mySndH[!useTwo]; z<(long)mySndH[!useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}		theXWordSize = theWordSize;		if (theWordSize == 3)		{			presInOutCount = inOutCount;			convertBuffer24To16 (mySndH[!useTwo], &inOutCount);			theXWordSize = 2;		}	}	while (!stoppit)	{		    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			if(pleaseStop() || (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}			if (playingFromWaveform)			{				if(isPressed(0x37)) /* command */				{					gCallBackPerformed = true;					stoppit = true;				}				if (isPressed(0x3B))				{										/*GetMouse(&localPt);					SDIIPlayScrub(mySpec, displayRect, localPt.h);*/					stoppit = true;					gCallBackPerformed = true;				}								if (isPressed(0x12) || isPressed(0x53)) /* IN POINT */				{									}				if (isPressed(0x13) || isPressed(0x54)) /*out point */				{								}			}		}				howFar = ((float)lastFilePos / (float)theBytes) * (float)(displayRect.right - displayRect.left);						curHoriz = howFar;		if (curHoriz > lastHoriz)		{			InvertRect(&invRect);			SetRect(&invRect,curHoriz,displayRect.top + 1,curHoriz + 1,displayRect.bottom);			InvertRect(&invRect);			lastHoriz = curHoriz;		}						gCallBackPerformed = false;		if (!stoppit)			iErr = InstallCallBack (mySndChan);					if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;				iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				SysBeep(5);				DisposPtr(mySndH[0]);				DisposPtr(mySndH[1]);				FSClose (refNum);				InvertRect(&invRect);				SetPort(savePort);				return;			}			lastFilePos = currentFilePos;			currentFilePos += inOutCount;			if (currentFilePos > theBytes+curPos)			{				inOutCount -= (currentFilePos - theBytes+curPos);				stoppitnextTime = true;			}			thePlaySize -= inOutCount;			if (theWordSize ==1)			{				for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}					if ((iErr == eofErr) || (inOutCount < dblBuffSize24Bit))			{				stoppitnextTime = true;			}			theXWordSize = theWordSize;			if (theWordSize == 3)			{				presInOutCount = inOutCount;				convertBuffer24To16 (mySndH[useTwo], &inOutCount);				theXWordSize = 2;			}			useTwo = !useTwo;		}	}	  	   if ((iErr != eofErr) && (inOutCount == dblBuffSize24Bit))	   {	      cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);		   inOutCount = presInOutCount;	   }	   iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	   if (mousePlay){	while (theStat.scChannelBusy && Button())	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}}else{	while (theStat.scChannelBusy && !(Button() || (arrowPressed = arrowKey())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}}			iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);		if (arrowPressed)	{		switch (arrowPressed)		{			case kUpArrowPressed:			//	PostEvent(keyDown,0x00027E1E);			//	PostEvent(keyDown,0x00023120);			break;			case kDownArrowPressed:			//	PostEvent(keyDown,0x00027D1F);			//	PostEvent(keyDown,0x00023120);			break;			case kLeftArrowPressed:			//PostEvent(keyDown,0x00027B1C);			//	PostEvent(keyDown,0x00023120);			break;			case kRightArrowPressed:			//	PostEvent(keyDown,0x00027C1D);			//	PostEvent(keyDown,0x00023120);			break;		}	}		/* maybe shut it up */	InvertRect(&invRect);	FSClose(refNum);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);#ifdef dspPlay		exitDSP();#endif		SetPort(savePort);		return;}void SDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos);void SDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	EventRecord theEvent;	SndCommand cmd;	SCStatus theStat;	long theRate;	short theWordSize;	Boolean stereo;	long theBytes;	long thePlaySize;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	short refNum;	long dblBuffSize24Bit;	long z;		gCallBackPerformed = false;	useTwo = 0;		//mousePlay = false;	while (Button())	{	}	dblBuffSize24Bit = dblBufferSize / 3;	dblBuffSize24Bit = dblBuffSize24Bit * 3;	if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes))	{		return;	}		if (theWordSize == 3)	{		startPos = startPos / 3;		startPos = startPos * 3;		endPos = endPos / 3;		endPos = endPos * 3;	}	if (theWordSize == 2)	{		startPos = startPos >> 2 << 2;		endPos = endPos >> 2 << 2;	//	dblBuffSize24Bit = dblBuffSize24Bit >> 2 << 2;		dblBuffSize24Bit = dblBufferSize >> 1 << 1;	}	thePlaySize = endPos - startPos;	if (thePlaySize < 0)	{		return;		}	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)	{		return;	}		iErr = SetFPos(refNum,fsFromStart,startPos);	if (iErr)	{		FSClose(refNum);		return;	}		mySndH[0] = NewPtr(dblBuffSize24Bit);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		return;	}		mySndH[1] = NewPtr(dblBuffSize24Bit);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		return;	}				inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}		thePlaySize -= inOutCount;		if (theWordSize ==1)	{		for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)		{			*((Byte *)z) += 128;		}	}	presInOutCount = inOutCount;	theXWordSize = theWordSize;	if (theWordSize == 3)	{		convertBuffer24To16 (mySndH[useTwo], &inOutCount);		theXWordSize = 2;	}		mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd );		inOutCount = presInOutCount;	gCallBackPerformed = false;	InstallCallBack (mySndChan);			if (iErr == eofErr || (inOutCount < dblBuffSize24Bit))	{		while (gCallBackPerformed == false)		{			if(pleaseStopII()/* ||  (arrowPressed = arrowKey ())*/) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}		thePlaySize -= inOutCount;		if (theWordSize ==1)		{			for (z = (long)mySndH[!useTwo]; z<(long)mySndH[!useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}	presInOutCount = inOutCount;		theXWordSize = theWordSize;		if (theWordSize == 3)		{			convertBuffer24To16 (mySndH[!useTwo], &inOutCount);			theXWordSize = 2;		}	}	while (!stoppit)	{		    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  					inOutCount = presInOutCount;		while (gCallBackPerformed == false)		{			if(pleaseStopII()/* || (arrowPressed = arrowKey ())*/) 			{					gCallBackPerformed = true;				stoppit = true;			}		/*	if (playingFromWaveform)			{				if(isPressed(0x37))				{					gCallBackPerformed = true;					stoppit = true;				}			}*/		}		gCallBackPerformed = false;		if (!stoppit)			iErr = InstallCallBack (mySndChan);					if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = (thePlaySize > dblBuffSize24Bit) ? dblBuffSize24Bit : thePlaySize;				iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				SysBeep(5);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}			thePlaySize -= inOutCount;			if (theWordSize ==1)			{				for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}	presInOutCount = inOutCount;		theXWordSize = theWordSize;		if (theWordSize == 3)		{			convertBuffer24To16 (mySndH[useTwo], &inOutCount);			theXWordSize = 2;		}			if ((iErr == eofErr) || (presInOutCount < dblBuffSize24Bit))			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  	   if ((iErr != eofErr) && (inOutCount == dblBuffSize24Bit))	   {	      cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	   inOutCount = presInOutCount;	   }	   iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	   	while (theStat.scChannelBusy && !(Button() || (arrowPressed = arrowKey())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}			iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);	////	if (arrowPressed)//	{//		switch (arrowPressed)//		{//			case kUpArrowPressed://				///PostEvent(keyDown,0x00027E1E);//			//	PostEvent(keyDown,0x00023120);//			break;//			case kDownArrowPressed://				//PostEvent(keyDown,0x00027D1F);//			//	PostEvent(keyDown,0x00023120);//			break;//			case kLeftArrowPressed://			//	PostEvent(keyDown,0x00027B1C);//			//	PostEvent(keyDown,0x00023120);//			break;//			case kRightArrowPressed://				//PostEvent(keyDown,0x00027C1D);//			//	PostEvent(keyDown,0x00023120);//			break;//		}//	}		/* maybe shut it up */	FSClose(refNum);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);}void xSDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos);void xSDIIRegionPlay(FSSpec mySpec, short playFreq, long startPos, long endPos){	Handle	mySndH[2];	short	fRefNum;	short	thecurfile;	Str255	sampsize;	OSErr	iErr;	OSErr myErr;	Str255	samprate;	Boolean	whichBuff;	Str255	chans;	char	mysampsize;	long	mysamprate,xx,inOutCount;	char	mychans;	Handle 	hRsrc;	long z;	Fixed	sampleRate;	short 	numChans;	short		numBits;	short	refNum,tempchans;	Boolean fileEnded,Endedfile;	SCStatus theStatus;	EventRecord theEvent;	short headerLen;	Ptr mySndPtr;	unsigned char km[16];	short keycounter;	long filePos;	Boolean autoStop;		 	thecurfile = CurResFile();	fRefNum = FSpOpenResFile(&mySpec,fsRdPerm);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError opening res file",iErr);			UseResFile(fRefNum);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError using res file",iErr);		hRsrc = Get1Resource('STR ',1000);	if (hRsrc == 0)		genErrorN("\pError getting ID1000",0);	mysampsize =*(*hRsrc+1);	*sampsize = 1;	*(sampsize+1) = mysampsize;	StringToNum(sampsize,&xx);	numBits = LoWord(xx);		hRsrc = Get1Resource('STR ',1001);	if (hRsrc == 0)		genErrorN("\pError getting ID1001",0);	BlockMove (*hRsrc,samprate,28L);	if (*(samprate + 5L) == '.')				*samprate = 4;			else				*samprate = 5;	StringToNum(samprate,&sampleRate);	sampleRate = (sampleRate * (Fixed)playFreq) /(Fixed)0x3C;	sampleRate = sampleRate * 65536L;		hRsrc = Get1Resource('STR ',1002);	if (hRsrc == 0)		genErrorN("\pError getting ID1002",0);	mychans =*(*hRsrc+1);	*chans = 1;	*(chans+1) = mychans;	StringToNum(chans,&xx);	numChans = LoWord(xx);	CloseResFile(fRefNum);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError closing res file",iErr);	UseResFile(thecurfile);	iErr = ResError();	if (iErr!=0)		genErrorN("\pError using old res file",iErr);		mySndH[0] = Get1Resource('snd ',2000);	if (!mySndH[0])	{		mySndH[0] = NewHandle(dblBufferSize);		if (!mySndH[0])			genErrorN("\pError making new handle",0);			/*	AddResource(mySndH[0],'snd ',2000,"\pmySound");		iErr = ResError();		if (iErr!=0)			genErrorN("\pError adding resource",iErr);*/	}		mySndH[1] = Get1Resource('snd ',2001);	if (!mySndH[1])	{		mySndH[1] = NewHandle(dblBufferSize);		if (!mySndH[1])			genErrorN("\pError making new handle",0);			/*	AddResource(mySndH[1],'snd ',2001,"\pmySound");		iErr = ResError();		if (iErr!=0)			genErrorN("\pError adding resource",iErr);*/	}		iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,sampleRate,numBits*8,'NONE',0x3C,0,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 1",iErr);	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr!=0)		genErrorN("\pError opening data fork",iErr);	//MoveHHi(mySndH[0]);	//MoveHHi(mySndH[1]);	//HLock(mySndH[0]);	/******************/	iErr = SetFPos(refNum,1,startPos);	if (iErr !=0 )	{		SysBeep (5);		//genError ("\p Can't position file pointer there");	}	/******************/	mySndPtr = (*mySndH[0])+headerLen;	if ((dblBufferSize-800L)>= endPos - startPos)	{		inOutCount = (endPos - startPos);		autoStop = true;	}	else	{		inOutCount = dblBufferSize-800L;		autoStop = false;	}	watchcursor(TRUE);	iErr = FSRead(refNum,&inOutCount,mySndPtr);	Endedfile = (iErr == eofErr || autoStop);	if (iErr!=0 && iErr!=-39)		genErrorN("\pError reading data fork",iErr);	iErr = SetupSndHeader((SndListResource **)mySndH[0],numChans,sampleRate,numBits*8,'NONE',0x3C,inOutCount,&headerLen);	if (iErr!=0)		genErrorN("\pError setting up snd header 2",iErr);	//HUnlock(mySndH[0]);				/** process twos's complement **/	if (numBits ==1)	{		for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)		{			*((Ptr)z) += 128;		}	}	mySndChan = CreateSndChannel(numChans == 2);		/** SDI is mono **/	whichBuff = 0;	fileEnded = autoStop;	gCallBackPerformed = false;	if ( mySndH[0] != nil ) 	{		do		{			Endedfile = fileEnded;			myErr = SndPlay (mySndChan, (SndListResource **)mySndH[whichBuff], true);			if ( myErr )				genErrorN("\pError playing sound",myErr);			iErr = InstallCallBack (mySndChan);			whichBuff = !whichBuff;			/** swap double buffers **/			mySndPtr = (*mySndH[whichBuff])+headerLen;						iErr = GetFPos(refNum,&filePos);			if (filePos + (dblBufferSize-800L) >= endPos)			{				inOutCount = (endPos - filePos);				if (inOutCount < 0L)					inOutCount = 0L;				autoStop = true;			}			else			{				inOutCount = dblBufferSize-800L;				autoStop = false;			}						iErr = FSRead(refNum,&inOutCount,mySndPtr);			fileEnded = (iErr == eofErr || autoStop);			if (iErr!=0 && iErr!=-39)				genErrorN("\pError reading data fork",iErr);			iErr = SetupSndHeader((SndListResource **)mySndH[whichBuff],numChans,sampleRate,numBits*8,'NONE',0x3C,inOutCount,&headerLen);			if (iErr!=0)				genErrorN("\pError setting up snd header 2",iErr);			//HUnlock(mySndH[whichBuff]);			if (numBits ==1)			{				for (z = (long)mySndPtr; z<(long)mySndPtr+inOutCount;z++)				{					*((Ptr)z) += 128;				}			}			if (gCallBackPerformed)			{				if (autoSustain && EventAvail(everyEvent & ~mUpMask & ~keyUpMask & ~updateMask,&theEvent))				{					Endedfile = true;					GetNextEvent(everyEvent,&theEvent);				}				if (!autoSustain && (keycounter == 0 || keycounter == 256))				{					Endedfile = true;				}			}			while (!gCallBackPerformed)			{				keycounter = 0;				GetKeys(( long*)km);				for (z=0;z<=15;z++)					keycounter += (km[z] * ((z+1)*16));									if (autoSustain && EventAvail(everyEvent & ~mUpMask & ~keyUpMask & ~updateMask,&theEvent))				{					Endedfile = true;					GetNextEvent(everyEvent,&theEvent);					gCallBackPerformed = true;					break;				}				if (!autoSustain && (keycounter == 0 || keycounter == 256))				{					Endedfile = true;					//GetNextEvent(everyEvent,&theEvent);					gCallBackPerformed = true;					break;				}			}			gCallBackPerformed = false;		}while (!Endedfile);		iErr = SndDisposeChannel(mySndChan,false);		DisposPtr((Ptr)mySndChan);	}		iErr = FSClose(refNum);	if (iErr!=0)		genErrorN("\pError closing DF",iErr);		/*	RmveResource(mySndH[0]);	myErr = ResError();	if (myErr!=0)		genErrorN("\pError removing resource 1",myErr);	RmveResource(mySndH[1]);	myErr = ResError();	if (myErr!=0)		genErrorN("\pError removing resource 2",myErr);	UpdateResFile(CurResFile());	myErr = ResError();	if (myErr!=0)		genErrorN("\pError updating res map",myErr);*/		DisposPtr((Ptr)mySndChan);		DisposHandle(mySndH[0]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle 1",myErr);	DisposHandle(mySndH[1]);	myErr = MemError();	if (myErr!=0)		genErrorN("\pError disposing Handle",myErr);			watchcursor(false);		}	short GetWAVInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);short GetKRZInfo (FSSpec mySpec,long  *theSRate, short *theWordSize,long *theDuration, Boolean *isStereo, long *length);void KRZPlay(FSSpec mySpec, short playFreq);void KRZPlay(FSSpec mySpec, short playFreq){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent;	long theDuration, length;	short refNum;	long z,filePos;	short isItIMA = 0;	gCallBackPerformed = false;	useTwo = 0;			if (!plusMode)	{		return;	}		GetKRZInfo (mySpec,&theRate, &theWordSize,&theDuration, &stereo, &length);		theWordSize = theWordSize >> 3;	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		genError ("\pCan't open file");		return;	}		iErr = SetFPos(refNum,1,length);			mySndH[0] = NewPtr(dblBufferSize);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		return;	}		mySndH[1] = NewPtr(dblBufferSize);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		return;	}				inOutCount = dblBufferSize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}			mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd);	    	gCallBackPerformed = false;	InstallCallBack (mySndChan);			if (iErr == eofErr)	{		while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = dblBufferSize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);			DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}					}	while (!stoppit)	{		    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}				gCallBackPerformed = false;		if (!stoppit)			InstallCallBack (mySndChan);				if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = dblBufferSize;			iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				iErr = SndDisposeChannel(mySndChan,true);				DisposPtr((Ptr)mySndChan);				DisposPtr(mySndH[0]);				DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}									if (iErr == eofErr)			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  	if (iErr != eofErr)	{	    cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	}		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	while (theStat.scChannelBusy && ! (pleaseStop() ||  (arrowPressed = arrowKey ())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}		iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);	GetNextEvent(everyEvent,&theEvent);	/* maybe shut it up */	FSClose(refNum);	DisposPtr(mySndH[0]);	DisposPtr(mySndH[1]);}void WAVPlay(FSSpec mySpec, short playFreq);void WAVPlay(FSSpec mySpec, short playFreq){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent;	long theDuration, length;	short refNum;	long z,filePos;	short isItIMA = 0;	unsigned long bytesRead = 0;	gCallBackPerformed = false;	useTwo = 0;			if (!plusMode)	{		return;	}					isItIMA = GetWAVInfo (mySpec,&theRate, &theWordSize,&theDuration, &stereo, &length);	if (!isItIMA)	{		return;	}		if (isItIMA == 2)	{		playIMAWAV(mySpec);			return;	}		theWordSize = theWordSize >> 3;	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		genError ("\pCan't open file");		return;	}		filePos = findCOMM(refNum,'data');	if (!filePos)	{		genError ("\pCan't find data chunk");		iErr = FSClose(refNum);		return;	}	iErr = SetFPos(refNum,1,filePos + 8L);					mySndH[0] = NewPtr(dblBufferSize);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		return;	}		mySndH[1] = NewPtr(dblBufferSize);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		return;	}				inOutCount = dblBufferSize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}	bytesRead += inOutCount;	if (theWordSize == 2)		ConvertSoundB(mySndH[useTwo], inOutCount);			mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd);	    	gCallBackPerformed = false;	InstallCallBack (mySndChan);			if (iErr == eofErr)	{		while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = dblBufferSize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);			DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}		bytesRead += inOutCount;		if (theWordSize == 2)			ConvertSoundB(mySndH[!useTwo], inOutCount);	}	while (!stoppit)	{	    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}				gCallBackPerformed = false;		if (!stoppit)			InstallCallBack (mySndChan);				if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = dblBufferSize;			if (bytesRead + inOutCount >= length)			{				inOutCount = length - bytesRead;				stoppitnextTime = true;			}			iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				iErr = SndDisposeChannel(mySndChan,true);				DisposPtr((Ptr)mySndChan);				DisposPtr(mySndH[0]);				DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}			bytesRead += inOutCount;			if (theWordSize == 2)				ConvertSoundB(mySndH[useTwo], inOutCount);			if (iErr == eofErr)			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  	if (iErr != eofErr)	{	    cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	}		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	while (theStat.scChannelBusy && ! (pleaseStop() ||  (arrowPressed = arrowKey ())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}		iErr = SndDisposeChannel(mySndChan,true);DisposPtr((Ptr)mySndChan);	GetNextEvent(everyEvent,&theEvent);	/* maybe shut it up */	FSClose(refNum);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);}void Radar16Play(FSSpec mySpec);void Radar16Play(FSSpec mySpec){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	SndCommand cmd;	long theRate = 44100L;	SCStatus theStat;	short theWordSize = 2;	Boolean stereo = false;	long theBytes;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent;	long theDuration, length;	short refNum;	long z,filePos;	short isItIMA = 0;	unsigned long bytesRead = 0;	gCallBackPerformed = false;	useTwo = 0;				theWordSize = 2;	iErr = FSpOpenDF(&mySpec,fsCurPerm,&refNum);	if (iErr!=0)	{		genError ("\pCan't open file");		return;	}		iErr = GetEOF(refNum,&length);			mySndH[0] = NewPtr(dblBufferSize);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		return;	}		mySndH[1] = NewPtr(dblBufferSize);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		return;	}			inOutCount = dblBufferSize;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}	bytesRead += inOutCount;	if (theWordSize == 2)		ConvertSoundB(mySndH[useTwo], inOutCount);			mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd);	    	gCallBackPerformed = false;	InstallCallBack (mySndChan);			if (iErr == eofErr)	{		while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = dblBufferSize;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);			DisposPtr(mySndH[0]);			DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}		bytesRead += inOutCount;		if (theWordSize == 2)			ConvertSoundB(mySndH[!useTwo], inOutCount);	}	while (!stoppit)	{	    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}				gCallBackPerformed = false;		if (!stoppit)			InstallCallBack (mySndChan);				if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = dblBufferSize;			if (bytesRead + inOutCount >= length)			{				inOutCount = length - bytesRead;				stoppitnextTime = true;			}			iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				iErr = SndDisposeChannel(mySndChan,true);				DisposPtr((Ptr)mySndChan);				DisposPtr(mySndH[0]);				DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}			bytesRead += inOutCount;			if (theWordSize == 2)				ConvertSoundB(mySndH[useTwo], inOutCount);			if (iErr == eofErr)			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  	if (iErr != eofErr)	{	    cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	}		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	while (theStat.scChannelBusy && ! (pleaseStop() ||  (arrowPressed = arrowKey ())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}		iErr = SndDisposeChannel(mySndChan,true);	DisposPtr((Ptr)mySndChan);	GetNextEvent(everyEvent,&theEvent);	/* maybe shut it up */	FSClose(refNum);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);}	void SDIIPlay(FSSpec mySpec, short playFreq){	OSErr	iErr;	ExtSoundHeader      sound;	OSErr               err;	long dblBuffSize24Bit;	SndCommand cmd;	long theRate;	SCStatus theStat;	short theWordSize;	Boolean stereo;	long theBytes;	Ptr mySndH[2];	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	long inOutCount;	EventRecord theEvent,myEvent;		short refNum;	long z;		gCallBackPerformed = false;	useTwo = 0;		dblBuffSize24Bit = dblBufferSize / 3;	dblBuffSize24Bit = dblBuffSize24Bit * 3;	if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes))	{		return;	}		if (theWordSize == 2)	{		dblBuffSize24Bit = dblBufferSize >> 1 << 1;	}	iErr = FSpOpenDF(&mySpec,fsRdPerm,&refNum);	if (iErr)	{		return;	}	mySndH[0] = NewPtr(dblBuffSize24Bit);	if (!mySndH[0])	{		genErrorN("\pError making new handle",0);		return;	}		mySndH[1] = NewPtr(dblBuffSize24Bit);	if (!mySndH[1])	{		genErrorN("\pError making new handle",0);		DisposPtr(mySndH[0]);		return;	}				inOutCount = dblBuffSize24Bit;	iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);	if (iErr != eofErr && iErr)	{		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);		FSClose (refNum);		return;	}		theXWordSize = theWordSize;	if (theWordSize ==1)	{		for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)		{			*((Byte *)z) += 128;		}	}	presInOutCount = inOutCount;	if (theWordSize == 3)	{		convertBuffer24To16 (mySndH[useTwo], &inOutCount);		theXWordSize = 2;	}			mySndChan = CreateSndChannel(stereo);		/** SDI is mono **/			/*	if (playFreq != 0x3C)		{			Fixed ratio;			ratio = myPow(playFreq);			AlterPitch(mySndChan, ratio);		}*/	   	    sound.samplePtr =  mySndH[useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/			if (!mousePlay)	{		while (Button())		{				}	}	//pitchIt();		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd);	    	gCallBackPerformed = false;	InstallCallBack (mySndChan);		if (iErr == eofErr) /* the file was only one buffer long */	{		while (gCallBackPerformed == false)		{			//pitchIt();			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}		stoppit = true;	}						if (!stoppit)	{				inOutCount = dblBuffSize24Bit;		iErr = FSRead(refNum,&inOutCount,mySndH[!useTwo]);		if  (iErr != eofErr && iErr)		{			iErr = SndDisposeChannel(mySndChan,true);			DisposPtr((Ptr)mySndChan);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);			FSClose (refNum);			return;		}		if (theWordSize ==1)		{			for (z = (long)mySndH[!useTwo]; z<(long)mySndH[!useTwo]+inOutCount;z++)			{				*((Byte *)z) += 128;			}		}		theXWordSize =theWordSize;	presInOutCount = inOutCount;		if (theWordSize == 3)		{			convertBuffer24To16 (mySndH[!useTwo], &inOutCount);			theXWordSize = 2;		}	}	while (!stoppit)	{		    sound.samplePtr =  mySndH[!useTwo];           /*location of sound data*/	    sound.numChannels = stereo+1;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = playFreq; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = (inOutCount >> stereo) / theXWordSize;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = theXWordSize * 8;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/		    cmd.cmd = bufferCmd;	   	    cmd.param2 = (long)&sound;	    err = SndDoCommand(mySndChan,&cmd,true);	  						while (gCallBackPerformed == false)		{			//pitchIt();			if(pleaseStop() ||  (arrowPressed = arrowKey ())) 			{					gCallBackPerformed = true;				stoppit = true;			}		}				gCallBackPerformed = false;		if (!stoppit)			InstallCallBack (mySndChan);				if (stoppitnextTime || stoppit)		{			stoppit = true;		}		else		{			inOutCount = dblBuffSize24Bit;			iErr = FSRead(refNum,&inOutCount,mySndH[useTwo]);			if  (iErr != eofErr && iErr)			{				iErr = SndDisposeChannel(mySndChan,true);				DisposPtr((Ptr)mySndChan);		DisposPtr(mySndH[0]);		DisposPtr(mySndH[1]);				FSClose (refNum);				return;			}			if (theWordSize ==1)			{				for (z = (long)mySndH[useTwo]; z<(long)mySndH[useTwo]+inOutCount;z++)				{					*((Byte *)z) += 128;				}			}	presInOutCount = inOutCount;		theXWordSize =theWordSize;		if (theWordSize == 3)		{			convertBuffer24To16 (mySndH[useTwo], &inOutCount);			theXWordSize = 2;		}			if (iErr == eofErr)			{				stoppitnextTime = true;			}			useTwo = !useTwo;		}	}	  	if (iErr != eofErr)	{	    cmd.cmd = flushCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	    	    cmd.cmd = quietCmd;	    cmd.param2 = 0;	    err = SndDoImmediate(mySndChan,&cmd);	}		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	while (theStat.scChannelBusy && !Button()  && !(pleaseStop() ||  (arrowPressed = arrowKey ())))	{		iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);	}		iErr = SndDisposeChannel(mySndChan,true);DisposPtr((Ptr)mySndChan);	GetNextEvent(everyEvent,&theEvent);	/* maybe shut it up */	FSClose(refNum);	DisposPtr(mySndH[0]);	DisposPtr(mySndH[1]);	if (arrowPressed)	{		switch (arrowPressed)		{			case kUpArrowPressed:			//	PostEvent(keyDown,0x00027E1E);			//	PostEvent(keyDown,0x00023120);			break;			case kDownArrowPressed:			//	PostEvent(keyDown,0x00027D1F);			//	PostEvent(keyDown,0x00023120);			break;			case kLeftArrowPressed:			//	PostEvent(keyDown,0x00027B1C);			//	PostEvent(keyDown,0x00023120);			break;			case kRightArrowPressed:			//	PostEvent(keyDown,0x00027C1D);			//	PostEvent(keyDown,0x00023120);			break;		}	}}void convertSplitMonoToStereo(Ptr sourceAudioA, Ptr sourceAudioB,Ptr destAudio, long monoLength){	long theCount;		for (theCount = 0;theCount< ( monoLength << 1);theCount+=4L)	{		*(short *)((long)destAudio + theCount)  = *(short *)((long)sourceAudioA + (theCount >> 1));		*(short *)((long)destAudio + theCount + 2L) = *(short *)((long)sourceAudioB + (theCount >> 1));	}}OSErr SDIISplitAudition(FSSpec theFile1, FSSpec theFile2){	short z;	OSErr iErr;	long theRate;	short theWordSize;	Boolean stereo,realStereo;	long theBytes;	long inOutCount;	short refNum, destRef,myshort, splitrefNum, splitdestRef;	UnsignedFixed SRateIn;	float tempFloat,leftOver;	FSSpec outSpec;	OSErr	err;	Str255 temp2Str;	float floatA,floatB,floatC;	Ptr splitBufferL, splitBufferR, bufferStereo[2];	ExtSoundHeader      sound;	SndCommand cmd;	SCStatus theStat;	Boolean useTwo;	Boolean stoppit = false,stoppitnextTime = false;	EventRecord theEvent,myEvent;	gCallBackPerformed = false;	useTwo = 0;	splitBufferL = NewPtrClear (dblBufferSize);	if (!splitBufferL)	{		genError ("\pOut of memory");		return -25;	}	splitBufferR = NewPtrClear (dblBufferSize);	if (!splitBufferR)	{		DisposPtr (	splitBufferL);		genError ("\pOut of memory");		return -25;	}	bufferStereo[0] = NewPtrClear (dblBufferSize * 2L);	if (!bufferStereo[0])	{		DisposPtr (	splitBufferR);		DisposPtr (	splitBufferL);		genError ("\pOut of memory");		return -25;	}	bufferStereo[1] = NewPtrClear (dblBufferSize * 2L);	if (!bufferStereo[1])	{		DisposPtr (	splitBufferR);		DisposPtr (	splitBufferL);		DisposPtr (	bufferStereo[0]);		genError ("\pOut of memory");		return -25;	}	if (!getSDIIData (theFile1, &theRate, &theWordSize, &stereo, &theBytes))	{		/* set up audio */		mySndChan = CreateSndChannel(true);				iErr = FSpOpenDF(&theFile1,fsRdPerm,&refNum);		iErr = FSpOpenDF(&theFile2,fsRdPerm,&splitrefNum);		inOutCount = dblBufferSize;		iErr = FSRead(refNum,&inOutCount,splitBufferL);		err = FSRead(splitrefNum,&inOutCount,splitBufferR);		convertSplitMonoToStereo((char *)splitBufferL,(char *)splitBufferR,(char *)bufferStereo[useTwo],inOutCount);		inOutCount = inOutCount << 1; /* length of stereo */	    sound.samplePtr =  bufferStereo[useTwo];           /*location of sound data*/	    sound.numChannels = 2;              /*stereo sound*/	    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/	    sound.loopStart = 0;                /*there are no loop points*/	    sound.loopEnd = 0;	    sound.encode = extSH;               /*this is an extended SH*/	    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/	    sound.numFrames = inOutCount >> 2;      /*samples, not bytes*/	    sound.markerChunk = nil;            /*not used*/	    sound.instrumentChunks = nil;       /*not used*/	    sound.AESRecording = nil;           /*not used*/	    sound.sampleSize = 16;              /*16 bit samples*/	    sound.futureUse1 = 0;               /*reserved*/	    sound.futureUse2 = 0;               /*reserved*/	    sound.futureUse3 = 0;               /*reserved*/	    sound.futureUse4 = 0;               /*reserved*/			if (!mousePlay)		{			while (Button())			{						}		}	    cmd.cmd = bufferCmd;	    cmd.param2 = (long)&sound;	    err = SndDoImmediate(mySndChan,&cmd);	    		gCallBackPerformed = false;		InstallCallBack (mySndChan);		useTwo = !useTwo;		if (iErr == eofErr || err == eofErr ) /* the file was only one buffer long */		{			while (gCallBackPerformed == false)			{				//pitchIt();				if(pleaseStop() ||  (arrowPressed = arrowKey ())) 				{						gCallBackPerformed = true;					stoppit = true;				}			}			stoppit = true;		}			if (!stoppit) /* carry on and read the next buffers */		{			inOutCount = dblBufferSize;			iErr = FSRead(refNum,&inOutCount,splitBufferL);			err = FSRead(splitrefNum,&inOutCount,splitBufferR);			convertSplitMonoToStereo((char *)splitBufferL,(char *)splitBufferR,(char *)bufferStereo[useTwo],inOutCount);			inOutCount = inOutCount << 1; /* length of stereo */		}		while (!stoppit)		{				    sound.samplePtr =  bufferStereo[useTwo];           /*location of sound data*/		    sound.numChannels = 2;              /*stereo sound*/		    sound.sampleRate = theRate << 16;       /*this is 44.1 kHz data*/		    sound.loopStart = 0;                /*there are no loop points*/		    sound.loopEnd = 0;		    sound.encode = extSH;               /*this is an extended SH*/		    sound.baseFrequency = 0x3C; /*kMiddleC; */    /*only used by freqCmd*/		    sound.numFrames = inOutCount >> 2;      /*samples, not bytes*/		    sound.markerChunk = nil;            /*not used*/		    sound.instrumentChunks = nil;       /*not used*/		    sound.AESRecording = nil;           /*not used*/		    sound.sampleSize = 16;              /*16 bit samples*/		    sound.futureUse1 = 0;               /*reserved*/		    sound.futureUse2 = 0;               /*reserved*/		    sound.futureUse3 = 0;               /*reserved*/		    sound.futureUse4 = 0;               /*reserved*/				    cmd.cmd = bufferCmd;		    cmd.param2 = (long)&sound;		    err = SndDoCommand(mySndChan,&cmd,true);		    useTwo = !useTwo;			while (gCallBackPerformed == false) /* wait for the last buffer to finish */			{				if(pleaseStop() ||  (arrowPressed = arrowKey ())) 				{						gCallBackPerformed = true;					stoppit = true;				}			}						gCallBackPerformed = false;			if (!stoppit)				InstallCallBack (mySndChan);						if (stoppitnextTime || stoppit)			{				stoppit = true;			}			else			{				inOutCount = dblBufferSize;				iErr = FSRead(refNum,&inOutCount,splitBufferL);				err = FSRead(splitrefNum,&inOutCount,splitBufferR);				convertSplitMonoToStereo((char *)splitBufferL,(char *)splitBufferR,(char *)bufferStereo[useTwo],inOutCount);				inOutCount = inOutCount << 1; /* length of stereo */				if (iErr == eofErr)				{					stoppitnextTime = true;				}			}		}		if (iErr != eofErr)		{		    cmd.cmd = flushCmd;		    cmd.param2 = 0;		    err = SndDoImmediate(mySndChan,&cmd);		    		    cmd.cmd = quietCmd;		    cmd.param2 = 0;		    err = SndDoImmediate(mySndChan,&cmd);		}				iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);		while (theStat.scChannelBusy && !Button()  && !(pleaseStop() ||  (arrowPressed = arrowKey ())))		{			iErr = SndChannelStatus(mySndChan,sizeof(SCStatus),&theStat);		}				iErr = SndDisposeChannel(mySndChan,true);		  				FSClose (refNum);		FSClose (splitrefNum);	}	DisposPtr (	splitBufferR);	DisposPtr (	splitBufferL);	DisposPtr (	bufferStereo[0]);	DisposPtr (	bufferStereo[1]);	return noErr;}Boolean pleaseStop(void){		if (isPressed (0x37) && isPressed (0x2F))	{		globalStop = true;	}	if (isPressed (0x35))	{		globalStop = true;	}	if (!autoSustain)	{		if (isPressed(0x3A))		{			if (mousePlay  )			{				return (!Button());			}			else			{				return (isPressed(0x31));			}		}		else		{			if (mousePlay)			{				return (!Button());			}			else			{				return (!isPressed(0x31));			}		}	}	else	{		return Button() || (isPressed(0x52));	}}Boolean pleaseStopII(void){		return Button();}void pitchIt(void){	unsigned char km[16];	short z;	EventRecord xEvent;		GetKeys( ( long *) km);		for (z=0;z<14;z++)	{		if (( km[keyAcrossTheTop[z]>>3] >> (keyAcrossTheTop[z] & 7) ) & 1)		{			AlterPitch(mySndChan, keyRatio[z]);			GetNextEvent(keyDownMask,&xEvent);		}	}}short arrowKey (void){	short theArrowKey;		if (isPressed(0x7B))	{			return kLeftArrowPressed;	}		if (isPressed(0x7C))	{			return kRightArrowPressed;	}		if (isPressed(0x7D))	{			return kDownArrowPressed;	}		if (isPressed(0x7E))	{			return kUpArrowPressed;	}	return 0;}OSErr AlterPitch(SndChannelPtr chan, Fixed theRatio) { 	SndCommand cmd; 	OSErr err;	short upDown, One,Two;	long intermed;		cmd.cmd = 86; 	cmd.param1 = 0; 		cmd.param2 = theRatio;			err = SndDoImmediate(chan, &cmd); 	return (err); }/*Fixed myPow(Byte keynum){	float myX = myPowers[keynum];	Fixed theFixed = X2Fix((extended)myX);	return theFixed;}*/OSErr convertBuffer24To16 (Ptr theSoundData, long *sourceLength){	long z;	long destPtr;	short thisSample;	destPtr = (long)theSoundData;	for (z=0;z<*sourceLength;z+=3)	{			thisSample = *(short *)(theSoundData + z);		*((short *)destPtr) = thisSample;		destPtr += 2L;	}	*sourceLength = (*sourceLength * 2) / 3;}typedef struct Word24BitII {	short bigBit;	Byte LSB;} Word24BitII;OSErr convertBuffer16To24 (Ptr theSourceData,Ptr theDestData, long *Length){	long z;	long destPtr;	short thisSample;	Word24BitII theWord;	destPtr = (long)theDestData;	for (z=0;z<*Length;z+=2)	{			thisSample = *(short *)(theSourceData + z);		theWord.bigBit = thisSample;		theWord.LSB = 0;		*(Word24BitII *)(destPtr) = theWord;		destPtr += 3L;	}	*Length = (*Length * 3) / 2;}