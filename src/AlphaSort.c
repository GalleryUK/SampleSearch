#include "SampleSearch.h"#include "Globals.h"#include "undoStuff.h"void saveForUndo (void);void qort(Ptr v,short left, short right);void swap(Ptr v, short i,short j);void zAlphaSort(void);void xAlphaSort(void);void xAlphaSort (void){short mylocalCounter;short	iResult;FSSpec	myTemp;FInfo	myTempInfo;Boolean	anyChanged;short myTempInt;		watchcursor(true);		do	{	anyChanged = false;			for (mylocalCounter=0;mylocalCounter<totfindcounter-1;mylocalCounter++)		{		iResult = RelString((*therealResults)[mylocalCounter].name,(*therealResults)[mylocalCounter+1].name,false,false);		if (iResult == 1)			{			myTemp=(*therealResults)[mylocalCounter];			(*therealResults)[mylocalCounter] = (*therealResults)[mylocalCounter+1];			(*therealResults)[mylocalCounter+1] = myTemp;			BlockMove(&((*theFInfo)[mylocalCounter]),&myTempInfo,16L);			BlockMove(&((*theFInfo)[mylocalCounter+1]),&((*theFInfo)[mylocalCounter]),16L);			BlockMove(&myTempInfo,&((*theFInfo)[mylocalCounter+1]),16L);						/*myTempInfo = *FInfo[mylocalCounter];			*FInfo[mylocalCounter] = *FInfo[mylocalCounter+1];			*FInfo[mylocalCounter+1] = myTempInfo;*/						anyChanged = true;			} 				} 	}while (anyChanged);	watchcursor(false);	}int compare(const void *s1, const void *s2);void AlphaSort(void){		short z;	Size theCount;	FInfo **	theoldFInfo;	short * theTablePtr;	OSErr	iErr;		watchcursor(true);		if 	(!FInfolistInMem)	{			FInfoArrayPtr = totfindcounter;			//SetHandleSize(theFInfo,totfindcounter * sizeof(FInfo));			iErr = MemError();			if (iErr!=0)				genError("\pCould not expand FInfo in alphasort");												checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));											for (z=0;z<totfindcounter;z++)				{				iErr = FSpGetFInfo(&(*therealResults)[z],(*theFInfo)+z);			}				FInfolistInMem = true;	}		theTablePtr = (short *)NewPtr((totfindcounter+5) * sizeof(short));	if (!theTablePtr)	{		genError("\pCould not assign memory");		return;	}	theCount = 70L*totfindcounter;	BlockMove((*therealResults),(*gTheResults),theCount);	/** make  copy **/							for (z=0;z<totfindcounter;z++)	{		((short *)theTablePtr)[z] = z;	}		watchcursor(true);//	SysBeep(5);			qsort (theTablePtr, (long)totfindcounter, sizeof(short), compare);	//SysBeep(5);	watchcursor(false);		theoldFInfo = (FInfo **)NewHandle((totfindcounter+5L)*sizeof(FInfo));	if (!theoldFInfo)	{		genError("\pCouldn't assign memory");		DisposPtr((Ptr)theTablePtr);		return;	}	theCount = 16L * totfindcounter;	BlockMove((*theFInfo),(*theoldFInfo),theCount);	/** make a copy **/	theCount = 70L;	/* the alphasort prob is in here */			checkHandleSize ((Handle)theFInfo,totfindcounter,sizeof(FInfo));		checkHandleSize ((Handle)therealResults,totfindcounter,sizeof(FSSpec));		for (z=0;z<totfindcounter;z++)	{		BlockMove(&(((FInfo *)(*theoldFInfo))[((short*)(theTablePtr))[z]]),&((*theFInfo)[z]),16L);				BlockMove(&((*gTheResults)[((short *)theTablePtr)[z]]),&((*therealResults)[z]),theCount);	}	/*********************************/	DisposPtr((Ptr)theTablePtr);	iErr = MemError();	if (iErr!=0)		genError("\pCouldn't release theTablePtr");	DisposHandle((Handle)theoldFInfo);	iErr = MemError();	if (iErr!=0)		genError("\pCouldn't release theoldFInfo");	lCellCoords.h = 0;	lCellCoords.v = 0;	watchcursor(false);		return;}short cResult;int compare(const void *s1, const void *s2){		cResult = RelString((*therealResults)[*((short *)s1)].name,(*therealResults)[*((short *)s2)].name,false,false);		return	cResult;		}/*void AlphaSort (void){	short z;	Handle theMem;		theMem = (short)NewHandle(totfindcounter * sizeof(short));		if (theMem == 0)	{		genError ("\pCan't allocate memory for sort");		return;	}	//MoveHHi(theMem);	for (z=0;z<totfindcounter;z++)	{		theMem[z] = z;	}	qort (theMem, 1, totfindcounter);			}*/void zAlphaSort(void){	short z;	Size theCount;	FInfo **	theoldFInfo;	short * theTablePtr;	OSErr	iErr;		if (totfindcounter > 2000)	{		genError ("\pList too big to sort");		return;	}	theTablePtr = (short *)NewPtr(totfindcounter * sizeof(short));	if (!theTablePtr)	{		genError("\pCould not assign memory");		return;	}	theCount = 70L*totfindcounter;	saveForUndo ();		watchcursor(true);		for (z=0;z<totfindcounter;z++)	{		theTablePtr[z] = z;	}	qort ((Ptr)theTablePtr, 0, totfindcounter-1);			theoldFInfo = (FInfo **)NewHandle((totfindcounter+5L)*sizeof(FInfo));	if (!theoldFInfo)	{		genError("\pCouldn't assign memory");		DisposPtr((Ptr)theTablePtr);		watchcursor(false);		return;	}	//MoveHHi(theoldFInfo);	theCount = 16L * totfindcounter;	BlockMove((*theFInfo),(*theoldFInfo),theCount);	/** make undo copy **/	theCount = 70L;	for (z=0;z<totfindcounter;z++)	{		BlockMove(&(((FInfo *)(*theoldFInfo))[theTablePtr[z]]),&((*theFInfo)[z]),16L);		BlockMove(&((*gTheResults)[theTablePtr[z]]),&((*therealResults)[z]),theCount);	}	DisposPtr((Ptr)theTablePtr);	iErr = MemError();	if (iErr!=0)		genError("\pCouldn't release theTablePtr");	DisposHandle((Handle)theoldFInfo);	iErr = MemError();	if (iErr!=0)		genError("\pCouldn't release theoldFInfo");	watchcursor(false);}short i, last, iResult;void qort(Ptr v,short left, short right){	if (left >= right)		return;			swap (v,left,(left + right)/2);	last = left;	for (i=left+1;i <= right;i ++)	{		iResult = RelString((*therealResults)[i].name,(*therealResults)[left].name,false,false);			/*if (v[i] < v[left])*/		if (iResult == -1)			swap(v, ++last, i);	}	swap(v, left, last);	qort (v,left,last-1);	qort(v,last+1,right);}short temp;void swap(Ptr v, short i, short j){	temp = v[i];	v[i] = v[j];	v[j] = temp;}