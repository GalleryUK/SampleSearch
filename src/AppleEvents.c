#include "SampleSearch.h"#include "Globals.h"#include <stdio.h>void cleanUpRes(void);#include <Gestalt.h>extern FSSpec theApplSpec;#include <AppleEvents.h>#include "prefs.h"extern newPrefsRec theNewPrefs;FSSpec AEvent (void);void RemoveVBL(void);#include "undoStuff.h"AEEventHandlerUPP xMyHandleOApp;AEEventHandlerUPP xMyHandleODoc;AEEventHandlerUPP xMyHandlePDoc;AEEventHandlerUPP xMyHandleQuit;Boolean tooManyFiles;#define kWristWatch 99#define kRightCursor 1#define kLeftCursor 2#define kArrowCursor 0#define maxFilesSupported 2475long dragPresParent;Boolean objectDragged = false;void setCursor(short setting);FSSpec * theFoundFiles;Boolean AppleEventsInstalled (void);pascal OSErr  MyHandleODoc (AppleEvent *theAppleEvent, AppleEvent* reply, long														handlerRefCon);pascal OSErr  MyHandlePDoc (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon);pascal OSErr  MyHandleOApp (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon);pascal OSErr  MyHandleQuit (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon);			OSErr addSDIIFilesInside (FSSpec theParentObject, Boolean folderSearch);											OSErr MyGotRequiredParams (AppleEvent *theAppleEvent);Boolean gDone = FALSE;FSSpec	theODOCSpec;Boolean	oneOpened;long numFilesToProcess;pascal	OSErr	PBCatSearchSyncCompat(CSParamPtr paramBlock);pascal	OSErr	IndexedSearch(CSParamPtr pb, long dirID);Boolean AppleEventsInstalled (){	OSErr err;	long  result;	err = Gestalt (gestaltAppleEventsAttr, &result);	return (!err && ((result >> gestaltAppleEventsPresent) & 0x0001));											// return TRUE if there is no											// error and the proper bit of											// result is set}void addFileToAudioWindow(FSSpec theODOCedFile);Boolean xfirstTime = true;pascal OSErr  zMyHandleODoc (AppleEvent *theAppleEvent, AppleEvent* reply, long														handlerRefCon);pascal OSErr  zMyHandleODoc (AppleEvent *theAppleEvent, AppleEvent* reply, long														handlerRefCon){	FSSpec	myFSS;	AEDescList	docList;	OSErr	err;	long	index,					itemsInList;	Size	actualSize;	AEKeyword	keywd;	DescType	returnedType;	// get the direct parameter--a descriptor list--and put it into a docList	err = AEGetParamDesc (theAppleEvent, keyDirectObject, typeAEList,			&docList);	if (err)			return err;	// check for missing parameters	err = MyGotRequiredParams (theAppleEvent);	if (err)			return err;	// count the number of descriptor records in the list	err = AECountItems (&docList, &itemsInList);	// now get each descriptor record from the list, coerce the returned	// data to an FSSpec record, and open the associated file	//printf ("Files to open:\n");	if (itemsInList >0)	{			err = AEGetNthPtr (&docList, 1, typeFSS, &keywd,&returnedType, (Ptr) &myFSS, sizeof(myFSS),&actualSize);			if (err)					return err;			BlockMove(&myFSS,&theODOCSpec,70L);			oneOpened = true;			//printf ("%s\n", PtoCstr(myFSS.name));	}	err = AEDisposeDesc (&docList);	return noErr;}Boolean listOpen = false;FSSpec theDraggedObject;OSErr allocateRamForFilesList (void);OSErr allocateRamForFilesList (void){	theFoundFiles = (FSSpec *)NewPtrClear(2475 * 70L);	if (!theFoundFiles)	{			genError ("\pNot enough memory");		return -25;	}	numFilesToProcess = 0;	return 0;}pascal OSErr  MyHandleODoc (AppleEvent *theAppleEvent, AppleEvent* reply, long														handlerRefCon){	FSSpec	myFSS;	AEDescList	docList;	OSErr	err;	long	index,itemsInList;	Size	actualSize;	AEKeyword	keywd;	DescType	returnedType;	short z;	Str255 numFilesStr;	//savedItems = numFilesToConvert;		// get the direct parameter--a descriptor list--and put it into a docList	err = AEGetParamDesc (theAppleEvent, keyDirectObject, typeAEList,			&docList);	if (err)			return err;	// check for missing parameters	err = MyGotRequiredParams (theAppleEvent);	if (err)		return err;	// count the number of descriptor records in the list	err = AECountItems (&docList, &itemsInList);	// now get each descriptor record from the list, coerce the returned	// data to an FSSpec record, and open the associated file	//printf ("Files to open:\n");	if (allocateRamForFilesList ())	{		return;	}	if (itemsInList >0)	{		FInfo fndrInfo;		OSErr iErr;		CInfoPBRec pb;		for (z=0;z<itemsInList && z<maxFilesSupported;z++)		{			err = AEGetNthPtr (&docList, z+1, typeFSS, &keywd,&returnedType, (Ptr) &myFSS, sizeof(myFSS),&actualSize);			if (err)			{				DisposPtr((Ptr)theFoundFiles);							return err;			}			if (myFSS.parID == 1)			{				/* it is a drive */				if (!xfirstTime)				{					if (listOpen)					{						setCursor(kWristWatch);						addSDIIFilesInside(myFSS,false);						setCursor(kArrowCursor);						}				}			}			else			{				pb.hFileInfo.ioCompletion = 0;				pb.hFileInfo.ioNamePtr = myFSS.name;				pb.hFileInfo.ioVRefNum = myFSS.vRefNum;				pb.hFileInfo.ioFDirIndex = 0;				pb.hFileInfo.ioDirID = myFSS.parID;				iErr = PBGetCatInfo(&pb,false);								if (pb.dirInfo.ioFlAttrib & 0x10) /* a folder */				{					theDraggedObject = myFSS;					dragPresParent = theDraggedObject.parID;					theDraggedObject.parID = pb.dirInfo.ioDrDirID; /* the actual directory, not the parent */							objectDragged = true;									if (listOpen & !xfirstTime)					{						/* it is a directory */						setCursor(kWristWatch);						addSDIIFilesInside(myFSS,true);						setCursor(kArrowCursor);						//directoryScanIntoList(myFSS);					}				}				else				{					iErr = FSpGetFInfo(&myFSS,&fndrInfo);					switch(fndrInfo.fdType)					{						case 'SFlf':							/* open the list, then abort */							BlockMove(&myFSS,&theODOCSpec,70L);							oneOpened = true;							DisposPtr((Ptr)theFoundFiles);											return;						break;						default: /* all the other wierd ones */							if (listOpen & !xfirstTime)								addFileToAudioWindow(myFSS);  /* here is the function to actually put the files into your window */						break;					}					}			}		}	}		err = AEDisposeDesc (&docList);	//	NumToString((long)numFilesToProcess, numFilesStr);//	genError(numFilesStr);	DisposPtr((Ptr)theFoundFiles);					return noErr;}pascal OSErr  MyHandlePDoc (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon){	FSSpec	myFSS;	AEDescList	docList;	OSErr	err = 0;	long	index,itemsInList;	Size	actualSize;	AEKeyword	keywd;	DescType	returnedType;	return err;	// get the direct parameter--a descriptor list--and put it into a docList	err = AEGetParamDesc (theAppleEvent, keyDirectObject, typeAEList,									&docList);	if (err)			return err;	// check for missing parameters	err = MyGotRequiredParams (theAppleEvent);	if (err)			return err;	// count the number of descriptor records in the list	err = AECountItems (&docList, &itemsInList);	// now get each descriptor record from the list, coerce the returned	// data to an FSSpec record, and open the associated file	printf ("Files to print:\n");	for (index = 1; index <= itemsInList; index++) {			err = AEGetNthPtr (&docList, index, typeFSS, &keywd,							&returnedType, (Ptr) &myFSS, sizeof(myFSS), 				&actualSize);			if (err)					return err;			printf ("%s\n", PtoCstr(myFSS.name));	}	err = AEDisposeDesc (&docList);	return noErr;}pascal OSErr  MyHandleOApp (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon){	return 0;	printf ("No files to print or open\n");}void saveNewPrefs (void);void SaveAsTabFave(short whichList);pascal OSErr  MyHandleQuit (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon){	FSSpec theBackUpSpec;	FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempUndoFile",&theBackUpSpec);	FSpDelete(&theBackUpSpec);	FSMakeFSSpec(theApplSpec.vRefNum,theApplSpec.parID,"\pSFTempBackupFile",&theBackUpSpec);	FSpDelete(&theBackUpSpec);	cleanUpRes();	//RemoveVBL();	saveNewPrefs ();	if (!theNewPrefs.tabLocked[theNewPrefs.whichTab])		SaveAsTabFave(theNewPrefs.whichTab);	ExitToShell();}OSErr MyGotRequiredParams (AppleEvent *theAppleEvent){	DescType	returnedType;	Size	actualSize;	OSErr	err;	err = AEGetAttributePtr (theAppleEvent, keyMissedKeywordAttr,									typeWildCard, &returnedType, nil, 0,									&actualSize);	if (err == errAEDescNotFound)	// you got all the required parameters			return noErr;	else if (!err)			// you missed a required parameter			return errAEEventNotHandled;	else					// the call to AEGetAttributePtr failed			return err;}FSSpec AEvent (void){	Boolean		aEvents;	short 		doWhat;	short 		fileCnt;	short		i;	EventRecord	theEvent;	OSErr		err;	short	x;	xMyHandleODoc = NewAEEventHandlerProc(MyHandleODoc);		xMyHandleOApp = NewAEEventHandlerProc(MyHandleOApp);		xMyHandlePDoc = NewAEEventHandlerProc(MyHandlePDoc);		xMyHandleQuit = NewAEEventHandlerProc(MyHandleQuit);			oneOpened = false;	aEvents = AppleEventsInstalled();	if (aEvents) 	{		err = AEInstallEventHandler (kCoreEventClass, kAEOpenDocuments,												xMyHandleODoc,0, FALSE);		err = AEInstallEventHandler (kCoreEventClass, kAEOpenApplication,												xMyHandleOApp,0, FALSE);		err = AEInstallEventHandler (kCoreEventClass, kAEPrintDocuments,												xMyHandlePDoc,0, FALSE);		err = AEInstallEventHandler (kCoreEventClass, kAEQuitApplication,												xMyHandleQuit,0, FALSE);		for (x=0;x<=1;x++)		 {			if ( WaitNextEvent ( everyEvent & ~keyDownMask, &theEvent, 0, nil ) ) 			{				switch (theEvent.what) 				{					case kHighLevelEvent:						err = AEProcessAppleEvent (&theEvent);					break;				}			}		}	}	if (oneOpened)	{		xfirstTime = false;		return theODOCSpec;	}	else	{		xfirstTime = false;		theODOCSpec.vRefNum = -999;		return theODOCSpec;	}}Boolean FindFilesOn(Str31	myFileName, FSSpec * theResolveSpec, short * maxMatches, SFTypeList ftypelist, short fTypes, short driveNumber, long thedirID, Boolean searchFolder);Boolean translateParentToChildFolder(FSSpec *mySpec);OSErr addSDIIFilesInside (FSSpec theParentObject, Boolean folderSearch){	//OSErr	IndexedSearch(CSParamPtr pb,	//						  long dirID);	short maxMatches,z;	SFTypeList ftypelist;	ftypelist[0] = 'Sd2f';	maxMatches = maxFilesSupported-(numFilesToProcess + 1);	translateParentToChildFolder(&theParentObject);	FindFilesOn("\p", &theFoundFiles[numFilesToProcess], &maxMatches, ftypelist, 0, theParentObject.vRefNum, theParentObject.parID, folderSearch);	for (z=0;z<maxMatches;z++)	{		addFileToAudioWindow(theFoundFiles[numFilesToProcess+z]);	}	numFilesToProcess += maxMatches;	return noErr;}/* need to provide a ptr to an FSSpec array  */Boolean FindFilesOn(Str31	myFileName, FSSpec * theResolveSpec, short * maxMatches, SFTypeList ftypelist, short fTypes, short driveNumber, long thedirID, Boolean searchFolder){//	HParamBlockRec RPb; 				/** parameter block for PBCatSearch **/	CSParam RPb;  	short z;	CInfoPBRec gSpec1; 					/** search criteria, part 1 **/ 	CInfoPBRec gSpec2; 	OSErr	gErr,iErr;	short q;	FInfo fndrInfo;	char *occur;	Str255 Cstring,substring;	long numsofar;	Ptr	gBuffer;	GrafPtr savePort;	Str255 driveName = "\p";	Boolean nameSearch;	GetPort(&savePort);			numsofar = 0;			gogetvolref();		gBuffer = NewPtr(32768L);			/** search cache  **/	if (!gBuffer)	{		genError("\pCannot allocate memory for gBuffer");		return false;	}		if (*myFileName)	{		nameSearch = true;	}	else	{		nameSearch = false;	}	if (driveNumber != 0)	{		volumearrayptr = 1;		volumes[1] = driveNumber;	}		q=0;	do		{		for (z=1;z<=volumearrayptr;z++)			/*** set up loop to go through all registered drives **/		{		//	Spincursor(1);			if (true)			{				memset(&gSpec1,0,sizeof(CInfoPBRec));				memset(&gSpec2,0,sizeof(CInfoPBRec));								RPb.ioVRefNum = volumes[z];		/** select relevant volume **/								RPb.ioCompletion = nil;  				/** no completion routine **/				RPb.ioNamePtr = driveName;   			 		/** no volume name;  use vRefNum **/				RPb.ioMatchPtr = theResolveSpec+numsofar;  			/** points to results buffer **/				RPb.ioReqMatchCount = (*maxMatches)-numsofar;   	/** number of matches **/														/** search for name + file or directory + file TYPE  **/														RPb.ioSearchBits = ((nameSearch) ? fsSBPartialName : 0) /*+ fsSBFlAttrib*/ + fsSBFlFndrInfo;														RPb.ioSearchInfo1 = &gSpec1;   			/** points to first criteria set **/				RPb.ioSearchInfo2 = &gSpec2;  			/** points to second criteria set **/				RPb.ioSearchTime = 0;              	/** don't time out on searches **/				RPb.ioCatPosition.initialize = 0;   	/** set catalog position hint to 0  **/				RPb.ioOptBuffer = gBuffer;    			/** point to search cache  **/				RPb.ioOptBufSize  = 32768L;		/** size of search cache **/							RPb.ioSearchInfo1->hFileInfo.ioNamePtr = myFileName;   		/** point to string to find **/				RPb.ioSearchInfo1->hFileInfo.ioFlAttrib = 0x00;      		/** clear bit 4 to ask for files **/					if (fTypes > 0)					RPb.ioSearchInfo1->hFileInfo.ioFlFndrInfo.fdType = ftypelist[q] ; //searchType;	/** just find ???? files **/				else					RPb.ioSearchInfo1->hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;									RPb.ioSearchInfo1->hFileInfo.ioFlFndrInfo.fdCreator = 0;								RPb.ioSearchInfo2->hFileInfo.ioNamePtr = nil;   			/** check for mask set to nil **/				RPb.ioSearchInfo2->hFileInfo.ioFlAttrib  = 0x10;  			 /** set mask for bit 4 **/				if (fTypes > 0)					RPb.ioSearchInfo2->hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF;   //searchMask;  				else					RPb.ioSearchInfo2->hFileInfo.ioFlFndrInfo.fdType = 0;   //searchMask;  							RPb.ioSearchInfo2->hFileInfo.ioFlFndrInfo.fdCreator = 0;															if (true) /* dont find aliases */				{					RPb.ioSearchInfo1->hFileInfo.ioFlFndrInfo.fdFlags = 0;					RPb.ioSearchInfo2->hFileInfo.ioFlFndrInfo.fdFlags = 0x8000;						}				else				{					RPb.ioSearchInfo2->hFileInfo.ioFlFndrInfo.fdFlags = 0x0000;					}					RPb.ioSearchInfo2->hFileInfo.ioFlFndrInfo.fdFldr = 0;								do				{					if (searchFolder)					{						gErr = IndexedSearch((CSParam *)&RPb, thedirID);					}					else					{						gErr = PBCatSearchSyncCompat((CSParam *)&RPb);	/** get some files returns error 0 (noErr) if it returns without finishing **/					}				} while (gErr == 0);				numsofar += RPb.ioActMatchCount;			}		}		q++;	} while  (q<fTypes);herey:		if ( numsofar == 0)	{		*maxMatches = 0;		DisposPtr((Ptr)gBuffer);		return -1;	}	else	{			*maxMatches = numsofar;	}	DisposPtr((Ptr)gBuffer);	return noErr;}Boolean addFileToList(FSSpec mySpec);void addFileToAudioWindow(FSSpec theODOCedFile){	addFileToList(theODOCedFile);}