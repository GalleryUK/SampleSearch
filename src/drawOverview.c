#include "SampleSearch.h"#include "Globals.h"#include "drawOverView.h"#include "prefs.h"#include <ToolUtils.h>extern newPrefsRec theNewPrefs;extern WindowPtr myWindow;short nextRegionToHilite;void zDrawGrowIcon (WindowPtr theWindow);short theValues,tempplusLevel,tempminusLevel;void	drawColourIcon4(short left,short top,short cicnResID);extern Rect selectRect, zRect;extern Boolean autoCalcOverviews;void drawSDIIToolBar(FSSpec mySpec);Boolean regionSelected = false;Boolean createSDIIOverview(FSSpec mySpec, long decimation);extern Boolean waveFormSelected;Boolean restoreSelection (Rect theOverView, long frameStart, long frameEnd, long frameSync, FSSpec theFile);typedef struct RegionRec {long	RegionID;long	StartFrame;long	StopFrame;long	SynchFrame;long 	TimeStampMS;long 	TimeStampLS;Str31	RegionName;} RegionRec, *RegionRecPtr;void showCommentinWin(short mode, Cell theCell);typedef struct ddRLHeader {short	VersionNumber;long	HeaderSize;long	RegionSize;long	ResourceDate;long 	NextID;} ddRLHeader;extern Rect selectRect;Boolean chooseName (Str255 prompt, StringPtr reply);short countSDIIRegions(FSSpec mySpec);OSErr copyUserTimeToOrigTime (FSSpec mySpec);short theCurrentSDIIRegion = -99;OSErr exchangeUserTimeAndOrigTime (FSSpec mySpec);void concatStrings(StringPtr sourceA,StringPtr sourceB,Str255 theSeperator);FSSpec theDisplayedFile;short getSDIIRegions(FSSpec mySpec, RegionRec * mySDIIRegions);void clearOverViewInWindow (void){	GrafPtr savePort;	static short waveformH, waveFormV;	short iRefNum, rfRefNum;	Handle theOverViewHandle;	Rect 	eraseRect;	Boolean overViewPresent;	long overviewSize;	short theUp;	Byte plusLevel, minusLevel;	long z;	RGBColor myColor;		if (!theNewPrefs.waveFormWindow)		return ;	GetPort (&savePort);	SetPort (myWindow);		waveformH = myWindow->portRect.right;	waveFormV = theNewPrefs.theWaveFormHeight;			SetRect(&eraseRect,0,myWindow->portRect.bottom - waveFormV + 1,waveformH,myWindow->portRect.bottom);	RGBBackColor(&theNewPrefs.theWaveFormBackGround);		EraseRect(&eraseRect);		myColor.red = 0xFFFF;	myColor.green = 0xFFFF;	myColor.blue = 0xFFFF;	RGBBackColor(&myColor);		zDrawGrowIcon ((WindowPtr) myWindow);		theDisplayedFile.vRefNum = -999;			SetPort (savePort);	return ;}void clearRegionTools(void){	Rect eraseRect;	GrafPtr savePort;	RGBColor myColor;			if (!theNewPrefs.SDIIToolBar)		return;			GetPort (&savePort);	SetPort (myWindow);			RGBBackColor(&theNewPrefs.theWaveFormBackGround);	SetRect(&eraseRect,0,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight - theNewPrefs.toolsHeight + 1,myWindow->portRect.right,myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight + 1);	EraseRect(&eraseRect);	myColor.red = 0xFFFF;	myColor.green = 0xFFFF;	myColor.blue = 0xFFFF;	RGBBackColor(&myColor);	SetPort (savePort);}Boolean getAIFFDataII (FSSpec mySpec, long* theRate, short* theWordSize, short* chans, long* theBytes);Boolean drawOverViewInWindow(FSSpec mySpec){	GrafPtr savePort;	static short waveformH, waveFormV;	short iRefNum, rfRefNum;	Handle theOverViewHandle;	Rect 	eraseRect;	Boolean overViewPresent;	long overviewSize;	short theUp;	Byte plusLevel, minusLevel;	long z;	RGBColor myColor;	long theRate; 	short theWordSize; 	Boolean stereo;	long theBytes;		FInfo fndrInfo;	OSErr iErr;	short channels;	Boolean realSDII = false;	if (!theNewPrefs.waveFormWindow)		return false;	GetPort (&savePort);	SetPort (myWindow);		waveformH = myWindow->portRect.right;	waveFormV = theNewPrefs.theWaveFormHeight;				SetRect(&eraseRect,0,myWindow->portRect.bottom - waveFormV + 2,waveformH,myWindow->portRect.bottom);		/*myColor.red = 0xF000;	myColor.green = 0xF000;	myColor.blue = 0xFFFF;*/	RGBBackColor(&theNewPrefs.theWaveFormBackGround);		EraseRect(&eraseRect);		myColor.red = 0xFFFF;	myColor.green = 0xFFFF;	myColor.blue = 0xFFFF;	RGBBackColor(&myColor);		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr)	{		return false;	}	switch (fndrInfo.fdType)	{		case 'Sd2f':			if  (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes))			{				SetPort(savePort);				return false;			}			realSDII = true;		break;			case 'AIFF':			if  (getAIFFDataII (mySpec, &theRate, &theWordSize, &channels, &theBytes))			{				SetPort(savePort);				return false;			}			stereo = (channels == 2);		break;		case 'MPEG':case '.MPG':case 'MPG ':case 'PLAY':case 'MP3 ':case '.MP3':case '.mp3':case 'Mp3 ':		//	if (getAIFFDataII (mySpec, &theRate, &theWordSize, &channels, &theBytes))		///	{		//		SetPort(savePort);		////		return false;		//	}		//	stereo = (channels == 2);		break;		default:				SetPort(savePort);				return false;		break;	}				iRefNum = CurResFile();	rfRefNum = FSpOpenResFile(&mySpec,fsRdPerm);	if (rfRefNum == -1)	{		SetPort (savePort);		overViewPresent = false;		return;	}			UseResFile(rfRefNum);	theOverViewHandle = 0;	theOverViewHandle = Get1Resource('ddOV',1000);	if (!theOverViewHandle)	{		/* there is no overview */		overViewPresent = false;	}	else	{		overViewPresent = true; 	}	theUp = waveFormV;		if (overViewPresent)	{		/* plot the waveform */		overviewSize = (SizeResource(theOverViewHandle) - 14) >> 1;					/*	myColor.red = 0;		myColor.green = 0x4000;		myColor.blue = 0xAFFF;*/		RGBForeColor(&theNewPrefs.theWaveFormColor);							for (z=0;z<waveformH;z++) /* z is the H pixel */		{ 			theValues = (*(short **)(theOverViewHandle))[((z * overviewSize) / waveformH)+7];						if (((unsigned short)theValues & 0xFF00) > 0x7F00)			{				theValues = (unsigned short)theValues & 0x00FF;			}						if (((unsigned short)theValues & 0x00FF) < 0x0080)			{				theValues = (unsigned short)theValues & 0xFF00;				theValues = (unsigned short)theValues | 0x00FF;			}						if (theValues)			{				tempplusLevel = ((theValues & 0xFF00) >> 8);				tempplusLevel = (tempplusLevel * theUp) / 256;				plusLevel = tempplusLevel;								tempminusLevel = -(256 - (theValues & 0x00FF));				tempminusLevel = (tempminusLevel * theUp) / 256;				minusLevel = tempminusLevel;			}			else			{				tempplusLevel = 0;				tempminusLevel = 0;			}						if (stereo)			{				tempplusLevel = tempplusLevel * 2;				tempminusLevel = tempminusLevel * 2;			}						if (tempplusLevel > (waveFormV >> 1))			{				tempplusLevel =  (waveFormV >> 1);						}									MoveTo(z,myWindow->portRect.bottom - (waveFormV >> 1) - tempplusLevel);			LineTo(z,myWindow->portRect.bottom - (waveFormV >> 1) - tempminusLevel);						tempminusLevel = tempminusLevel;		}		myColor.red = 0xFFFF;		myColor.green = 0xFFFF;		myColor.blue = 0xFFFF;		RGBForeColor(&myColor);	}	else	{					/* plot a line */				}	CloseResFile(rfRefNum);	UseResFile(iRefNum);		if (!overViewPresent)	{		if (autoCalcOverviews)		{			createSDIIOverview(mySpec,0x00000100);			InvalRect(&myWindow->portRect);		}	}			zDrawGrowIcon ((WindowPtr) myWindow);							theDisplayedFile = mySpec;		SetPort (savePort);	if (!waveFormSelected)	{		if (realSDII)			drawSDIIToolBar(theDisplayedFile);	}	return true;}void zDrawGrowIcon (WindowPtr theWindow){	OSErr	iErr;	Rect theRect;		CIconHandle hCIcon;	GrafPtr savePort;		GetPort(&savePort);	SetPort(theWindow);		theRect.top = theWindow->portRect.bottom-15;	theRect.left = theWindow->portRect.right-15;	theRect.bottom = theWindow->portRect.bottom;	theRect.right = theWindow->portRect.right;		hCIcon = GetCIcon(2010);		PlotCIcon(&theRect,hCIcon);		DisposCIcon(hCIcon);		theRect.top = theWindow->portRect.bottom-15 - theNewPrefs.theWaveFormHeight + 1 - ((theNewPrefs.SDIIToolBar) ? theNewPrefs.toolsHeight : 0);	theRect.left = theWindow->portRect.right-15;	theRect.bottom = theWindow->portRect.bottom - theNewPrefs.theWaveFormHeight+1 - ((theNewPrefs.SDIIToolBar) ?  theNewPrefs.toolsHeight : 0);	theRect.right = theWindow->portRect.right;		if (autoCalcOverviews)	{		hCIcon = GetCIcon(2001);	}	else	{		hCIcon = GetCIcon(2000);	}	PlotCIcon(&theRect,hCIcon);		DisposCIcon(hCIcon);			/*iErr = PlotIconID(&theRect,0,0,cicnResID);*/	SetPort(savePort);}	void drawSDIIToolBar(FSSpec mySpec){	Rect theRect;	GrafPtr savePort;	RGBColor qColor;	Rect myWaveToolsRect,regionsPopUpRect;	CIconHandle hCIcon;	Str255 theString = "\p";	short numSDIIRegions;	RegionRec * mySDIIRegions;	FInfo fndrInfo;	OSErr iErr;	iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr!=0)	{		return;	}	if (!theNewPrefs.SDIIToolBar)		return;					GetPort(&savePort);	SetPort(myWindow);		theRect.top = myWindow->portRect.bottom -  theNewPrefs.toolsHeight - theNewPrefs.theWaveFormHeight + 1;	theRect.left = 0;	theRect.bottom = myWindow->portRect.bottom - theNewPrefs.theWaveFormHeight + 1;	theRect.right = myWindow->portRect.right;	switch (fndrInfo.fdType)	{		case 'Sd2f':		break;		default:				qColor.red = 56797;				qColor.green = 56797;				qColor.blue = 56797;				RGBBackColor(&qColor);				EraseRect(&theRect);				qColor.red = 0xFFFF;				qColor.green = 0xFFFF;				qColor.blue = 0xFFFF;				RGBBackColor(&qColor);					qColor.red = 0;				qColor.green = 0;				qColor.blue = 0;				RGBForeColor(&qColor);				MoveTo(0,theRect.bottom);				LineTo(theRect.right,theRect.bottom);				qColor.red = 0;				qColor.green = 0;				qColor.blue = 0;				RGBForeColor(&qColor);				SetPort(savePort);			/* drawblank bar */			return;		break;	}	qColor.red = 56797;	qColor.green = 56797;	qColor.blue = 56797;	RGBBackColor(&qColor);	EraseRect(&theRect);	qColor.red = 0xFFFF;	qColor.green = 0xFFFF;	qColor.blue = 0xFFFF;	RGBBackColor(&qColor);			qColor.red = 0;	qColor.green = 0;	qColor.blue = 0;	RGBForeColor(&qColor);	MoveTo(0,theRect.bottom);	LineTo(theRect.right,theRect.bottom);	qColor.red = 0;	qColor.green = 0;	qColor.blue = 0;	RGBForeColor(&qColor);		numSDIIRegions = countSDIIRegions(mySpec);		mySDIIRegions = (RegionRec *)NewPtrClear((numSDIIRegions  + 2) * sizeof(RegionRec));	if (!mySDIIRegions)	{		SysBeep(5);		SetPort (savePort);		return;	}		numSDIIRegions = getSDIIRegions(mySpec, mySDIIRegions);		if (theCurrentSDIIRegion > numSDIIRegions)	{		theCurrentSDIIRegion = -99;	}		SetRect(&myWaveToolsRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 1,(*myWindow).portRect.right,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 1);	SetRect(&regionsPopUpRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 1,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 1); 	 	hCIcon = GetCIcon(601);		PlotCIcon(&regionsPopUpRect,hCIcon);		DisposCIcon(hCIcon);		regionsPopUpRect.left += 1;	regionsPopUpRect.top += 1;	regionsPopUpRect.right -= 20;	regionsPopUpRect.bottom -= 1;		qColor.red = 53012;	qColor.green = 53012;	qColor.blue = 53012;	RGBBackColor(&qColor);			TextFont(geneva);	TextSize(9);	if (numSDIIRegions < 1)	{		makeStr255("\pNo SDII Regions",theString);		TextFace(2);	}	else	{				if (theCurrentSDIIRegion < 0)		{			NumToString((long)numSDIIRegions,theString);			concatStrings(theString,"\pSDII Regions","\p ");			TextFace(0);		}		else		{			makeStr255(mySDIIRegions[theCurrentSDIIRegion].RegionName,theString);			TextFace(1);		}	}		TextBox(theString+1,*theString,&regionsPopUpRect,1);	/*TextFont(0);	TextSize(12);*/	TextFace(0);	qColor.red = 0xFFFF;	qColor.green = 0xFFFF;	qColor.blue = 0xFFFF;	RGBBackColor(&qColor);			/****************/	SetRect(&regionsPopUpRect,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 1,256,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 1); 	 	hCIcon = GetCIcon(601);		PlotCIcon(&regionsPopUpRect,hCIcon);		DisposCIcon(hCIcon);		regionsPopUpRect.left += 1;	regionsPopUpRect.top += 1;	regionsPopUpRect.right -= 20;	regionsPopUpRect.bottom -= 1;		qColor.red = 53012;	qColor.green = 53012;	qColor.blue = 53012;	RGBBackColor(&qColor);			TextFont(geneva);	TextSize(9);		makeStr255("\pSelection Action",theString);		TextFace((waveFormSelected) ? 1 : 2);		TextBox(theString+1,*theString,&regionsPopUpRect,1);	/*TextFont(0);	TextSize(12);*/	TextFace(0);	qColor.red = 0xFFFF;	qColor.green = 0xFFFF;	qColor.blue = 0xFFFF;	RGBBackColor(&qColor);	/*******************/			SetPort(savePort);	DisposPtr ((Ptr)mySDIIRegions);}short handleRegionPopUpClick (FSSpec mySpec, short currentSDIIRegion, Boolean noMenu){	Point myMouse;	long lMnuAndItm;	short numSDIIRegions;	RegionRec * mySDIIRegions;	MenuHandle sdRegMenu;	short z;	Rect regionsPopUpRect;	Point globalPt;	GrafPtr savePort;			GetPort (&savePort);	SetPort(myWindow);			numSDIIRegions = countSDIIRegions(mySpec);			SetRect(&regionsPopUpRect,0,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 1,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 1); 	sdRegMenu = GetMenu(600);	if (!sdRegMenu)	{		SetPort(savePort);		return 0;	}		mySDIIRegions = (RegionRec *)NewPtrClear((numSDIIRegions  + 2) * sizeof(RegionRec));	if (!mySDIIRegions)	{		SysBeep(5);		SetPort(savePort);		return 0;	}		numSDIIRegions = getSDIIRegions(mySpec, mySDIIRegions);		if (theCurrentSDIIRegion > numSDIIRegions)	{		theCurrentSDIIRegion = -99;	}	InsertMenu(sdRegMenu,-1);	for (z = 0; z< numSDIIRegions;z++)	{		AppendMenu(sdRegMenu,mySDIIRegions[z].RegionName);	}		globalPt.h = regionsPopUpRect.left;	globalPt.v = regionsPopUpRect.top;	LocalToGlobal(&globalPt);	if (!noMenu)	{		lMnuAndItm = PopUpMenuSelect(sdRegMenu,globalPt.v,globalPt.h,theCurrentSDIIRegion);		DeleteMenu(600);		ReleaseResource((Handle)sdRegMenu);		zRect.top ++;		restoreSelection (zRect, mySDIIRegions[LoWord(lMnuAndItm) - 4].StartFrame, mySDIIRegions[LoWord(lMnuAndItm) - 4].StopFrame,  mySDIIRegions[LoWord(lMnuAndItm) - 4].SynchFrame, mySpec);	}	else	{		DeleteMenu(600);		ReleaseResource((Handle)sdRegMenu);		restoreSelection (zRect, mySDIIRegions[theCurrentSDIIRegion].StartFrame, mySDIIRegions[theCurrentSDIIRegion].StopFrame,  mySDIIRegions[theCurrentSDIIRegion].SynchFrame, mySpec);	}	regionSelected = true;	DisposPtr ((Ptr)mySDIIRegions);	SetPort(savePort);	return LoWord(lMnuAndItm);}	long handleSelectionPopUpClick (FSSpec mySpec){	Point myMouse;	long lMnuAndItm;	short numSDIIRegions;	RegionRec * mySDIIRegions;	MenuHandle sdRegMenu,zsdRegMenu;	short z;	Rect regionsPopUpRect;	Point globalPt;	GrafPtr savePort;			GetPort (&savePort);	SetPort(myWindow);		numSDIIRegions = countSDIIRegions(mySpec);			SetRect(&regionsPopUpRect,128,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) -  theNewPrefs.toolsHeight + 1,256,(*myWindow).portRect.bottom - ((theNewPrefs.waveFormWindow) ? theNewPrefs.theWaveFormHeight : 0) + 1); 	mySDIIRegions = (RegionRec *)NewPtrClear((numSDIIRegions  + 2) * sizeof(RegionRec));	if (!mySDIIRegions)	{		SetPort(savePort);		SysBeep(5);		return 0;	}		numSDIIRegions = getSDIIRegions(mySpec, mySDIIRegions);		if (theCurrentSDIIRegion > numSDIIRegions)	{		theCurrentSDIIRegion = -99;	}			sdRegMenu = GetMenu(602);	if (!sdRegMenu)	{		SetPort(savePort);		return 0;	}	InsertMenu(sdRegMenu,-1);			zsdRegMenu = GetMenu(15);	if (!zsdRegMenu)	{		SetPort(savePort);		return 0;	}	InsertMenu(zsdRegMenu,-1);	for (z = 0; z< numSDIIRegions;z++)	{		AppendMenu(zsdRegMenu,mySDIIRegions[z].RegionName);	}			globalPt.h = regionsPopUpRect.left;	globalPt.v = regionsPopUpRect.top;			LocalToGlobal(&globalPt);	lMnuAndItm = PopUpMenuSelect(sdRegMenu,globalPt.v,globalPt.h,1);	DeleteMenu(15);	DeleteMenu(602);	ReleaseResource((Handle)sdRegMenu);	ReleaseResource((Handle)zsdRegMenu);	DisposPtr ((Ptr)mySDIIRegions);		SetPort(savePort);	return lMnuAndItm;}	Boolean restoreSelection (Rect theOverView, long frameStart, long frameEnd, long frameSync, FSSpec theFile){	GrafPtr savePort;	short theWordSize;	Boolean stereo;	long theRate;	long theBytes;	float tempFloat;	short graphicStart;	short graphicEnd;	Rect theInverter;	RGBColor myColor;	short syncPosition;	GetPort (&savePort);	SetPort(myWindow);		if  (getSDIIData (theFile, &theRate, &theWordSize, &stereo, &theBytes))	{		SetPort(savePort);		return false;	}	regionSelected = waveFormSelected = false;	showCommentinWin(kFirstSelected,nullCell);	if (theWordSize == 3)	{		theBytes = (double)theBytes * 2 / 3;	}		tempFloat = (float)frameEnd / (float)((theBytes >> stereo) >> (theWordSize - 1));	tempFloat = tempFloat * (float)theOverView.right;	theInverter.right = tempFloat;		tempFloat = (float)frameStart / (float)((theBytes >> stereo) >> (theWordSize - 1));	tempFloat = tempFloat * (float)theOverView.right;	theInverter.left = tempFloat;	theInverter.top = theOverView.top;	theInverter.bottom = theOverView.bottom;		tempFloat = (float)frameSync / (float)((theBytes >> stereo) >> (theWordSize - 1));	tempFloat = tempFloat * (float)theOverView.right;	syncPosition = tempFloat;			selectRect = theInverter;	InvertRect(&theInverter);		myColor.red = 0;	myColor.green = 0xFFFF;	myColor.blue = 0;	RGBForeColor(&myColor);	waveFormSelected = true;	FrameRect(&theInverter);	myColor.red = 0xFFFF;	myColor.green = 0xFFFF;	myColor.blue = 0;	RGBForeColor(&myColor);	myColor.red = 0x8000;	myColor.green = 0x8000;	myColor.blue = 0x8000;	RGBBackColor(&myColor);if (syncPosition > theInverter.left){/* CODE EXAMPLE #1 */	Pattern	thePat;	Rect	theRect;	GetIndPattern(&thePat, sysPatListID, 7 ); 	/* system pattern */	PenPat(&thePat);	MoveTo (syncPosition,theInverter.top);	LineTo (syncPosition,theInverter.bottom);	PenPat(&qd.black);}	myColor.red = 0;	myColor.green = 0;	myColor.blue = 0;	RGBForeColor(&myColor);		myColor.red = 0xFFFF;	myColor.green = 0xFFFF;	myColor.blue = 0xFFFF;	RGBBackColor(&myColor);	zDrawGrowIcon (myWindow);	SetPort(savePort);	}	short getSDIIRegions(FSSpec mySpec, RegionRec * myRegions){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow;		RgnHandle	theRgn;	short theNumberOfRegions = 0;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}		if (fndrInfo.fdType != 'Sd2f')	{		return 0;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);		if (!theXFileRegions)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return 0;	}		lByteCnt = SizeResource(theXFileRegions);		if (lByteCnt < 74L)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return 0;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(theXFileRegions);	CloseResFile(fRefNum);	UseResFile(iRefNum);		theNumberOfRegions = regionCount;	BlockMove (*theXFileRegions+sizeof(ddRLHeader),myRegions,theNumberOfRegions * sizeof(RegionRec));		return regionCount;}short countSDIIRegions(FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow;		RgnHandle	theRgn;	short theNumberOfRegions = 0;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}		if (fndrInfo.fdType != 'Sd2f')	{		return 0;	}		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);		if (!theXFileRegions)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return 0;	}		lByteCnt = SizeResource(theXFileRegions);		if (lByteCnt < 74L)	{		CloseResFile(fRefNum);		UseResFile(iRefNum);		return 0;	}		regionCount = (lByteCnt - 18L) / 56L;	DetachResource(theXFileRegions);	CloseResFile(fRefNum);	UseResFile(iRefNum);		theNumberOfRegions = regionCount;		return theNumberOfRegions;}Boolean addSD2RegionFromOverView(FSSpec mySpec, Rect DisplayRect, long frameStart, long frameStop){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow, numRgns;	RgnHandle	theRgn;	short theNumberOfRegions = 0;	RegionRec * myRegions;	Handle myDDRLHandle;	ddRLHeader myHeader;	RegionRec newRgn;	float theRatio, theSt;		Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return 0; /* its not an SDII file */ 	} 			theRatio = ((float)frameStart / (float)DisplayRect.right); 	theSt = theRatio * (theBytes >> stereo >> (theWordSize - 1)); 		frameStart = theSt;		theRatio = ((float)frameStop / (float)DisplayRect.right); 	theSt = theRatio * (theBytes >> stereo >> (theWordSize - 1)); 		frameStop = theSt;		chooseName ("\pUntitled", newRgn.RegionName);		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (fRefNum == -1)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);	if (!theXFileRegions) /* there are none !!! */	{		theXFileRegions = NewHandle(sizeof(ddRLHeader));		AddResource(theXFileRegions,'ddRL',1000,"\p");		iErr = ResError();		WriteResource(theXFileRegions);		iErr = ResError();		ReleaseResource(theXFileRegions);		iErr = ResError();		lByteCnt = 18L;	}	else	{		lByteCnt = SizeResource(theXFileRegions);		ReleaseResource(theXFileRegions);		iErr = ResError();	}	SetResLoad(false);	theXFileRegions = Get1Resource('ddRL',1000);	iErr = ResError();	SetResourceSize(theXFileRegions,lByteCnt + sizeof(RegionRec));	iErr = ResError();	SetResLoad(true);	ReleaseResource(theXFileRegions);	iErr = ResError();			theXFileRegions = Get1Resource('ddRL',1000);		regionCount = (lByteCnt - 18L) / 56L;				newRgn.RegionID = regionCount + 1;	newRgn.StartFrame = frameStart;	newRgn.StopFrame = frameStop;	newRgn.SynchFrame = frameStart;	newRgn.TimeStampMS = 0;	newRgn.TimeStampLS = 0;		myHeader.VersionNumber = 1;	myHeader.HeaderSize = 12L;	myHeader.RegionSize = (long)sizeof(RegionRec);	myHeader.ResourceDate = 0L;	myHeader.NextID = regionCount + 2;				BlockMove (&myHeader, *theXFileRegions,sizeof(ddRLHeader));	BlockMove (&newRgn, (*theXFileRegions) + sizeof(ddRLHeader) + (regionCount * sizeof(RegionRec)),sizeof(RegionRec));		ChangedResource(theXFileRegions);	iErr = ResError();	WriteResource(theXFileRegions);	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	return 0;}Boolean editSD2RegionFromOverView(FSSpec mySpec, Rect DisplayRect, long frameStart, long frameStop,short whichRegion){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow, numRgns;	RgnHandle	theRgn;	short theNumberOfRegions = 0;	RegionRec * myRegions;	Handle myDDRLHandle;	ddRLHeader myHeader;	RegionRec newRgn;	float theRatio, theSt;		Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;			iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return 0; /* its not an SDII file */ 	} 			theRatio = ((float)frameStart / (float)DisplayRect.right); 	theSt = theRatio * (theBytes >> stereo >> (theWordSize - 1)); 		frameStart = theSt;		theRatio = ((float)frameStop / (float)DisplayRect.right); 	theSt = theRatio * (theBytes >> stereo >> (theWordSize - 1)); 		frameStop = theSt;		iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);	if (!theXFileRegions) /* there are none !!! */	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return -99;	}			lByteCnt = SizeResource(theXFileRegions);	regionCount = (lByteCnt - 18L) / 56L;		if (whichRegion >= regionCount)	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return -99;	}		newRgn.RegionID = regionCount + 1;	newRgn.StartFrame = frameStart;	newRgn.StopFrame = frameStop;	newRgn.SynchFrame = frameStart;	newRgn.TimeStampMS = 0;	newRgn.TimeStampLS = 0;		BlockMove ((*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),&newRgn, sizeof(RegionRec));	newRgn.StartFrame = frameStart;	newRgn.StopFrame = frameStop;	BlockMove (&newRgn, (*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),sizeof(RegionRec));		ChangedResource(theXFileRegions);	iErr = ResError();	WriteResource(theXFileRegions);	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	return 0;}Boolean chooseName (Str255 prompt, StringPtr reply){	OSErr		iErr;					FSSpec	mySpec;	FInfo	fndrInfo;	short z;	CInfoPBRec	pb;	short temprefNum;	Str255 newName;	short itemHit;				/** for dialog enquiry **/	DialogPtr	myDlg;			/** for dialog enquiry **/	Handle	iHndl;				/** for dialog enquiry **/	Handle  myHand;	Rect	iRect;				/** for dialog enquiry **/	Rect	myRect;	short	iType;				/** for dialog enquiry **/		myDlg = GetNewDialog(8999,0L,(WindowPtr)-1);	SetPort (myDlg);	color.red = 56797;	color.green = 56797;	color.blue = 56797;	RGBBackColor(&color);	GetDItem(myDlg,7,&iType,&iHndl,&iRect);	SetIText(iHndl,prompt);	SelIText(myDlg,7,0,32767);	ShowWindow(myDlg);	ModalDialog(xAlertFilter,&itemHit);		GetDItem(myDlg,7,&iType,&iHndl,&iRect);	GetIText(iHndl,newName);	DisposDialog(myDlg);	if (*newName > 30)	{		*newName = 30;	}	makeStr255 (newName,reply);	//BlockMove(newName,reply, 64L);	return 0;}extern Boolean bail;OSErr copyOrigTimeToUserTime (FSSpec mySpec);OSErr SDIIOrigTimesToUserTimesMany(void);OSErr SDIIOrigTimesToUserTimesMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	short myshort; 			bail = false;				watchcursor(true);	writeLogS((unsigned char *)"Starting SDII timestamp copying");	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) && !bail) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				if (!copyOrigTimeToUserTime((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);		}		else		{			writeLogS((unsigned char *)"Failed to convert timestamps :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		watchcursor(false);	if (memoryError)		genError("\pSome files could not be processed, consult the SampleSearchª Log for details");	return;}OSErr copyOrigTimeToUserTime (FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow, numRgns;	RgnHandle	theRgn;	short theNumberOfRegions = 0;	RegionRec * myRegions;	Handle myDDRLHandle;	ddRLHeader myHeader;	RegionRec newRgn;	float theRatio, theSt;		Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	short whichRegion;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return 0; /* its not an SDII file */ 	} 			iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);	if (!theXFileRegions) /* there are none !!! */	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return 0;	}			lByteCnt = SizeResource(theXFileRegions);	regionCount = (lByteCnt - 18L) / 56L;		if (!regionCount)	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return noErr;	}	for (whichRegion=0;whichRegion<	regionCount;whichRegion++)	{		BlockMove ((*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),&newRgn, sizeof(RegionRec));		newRgn.TimeStampMS = newRgn.TimeStampLS;		BlockMove (&newRgn, (*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),sizeof(RegionRec));	}		ChangedResource(theXFileRegions);	iErr = ResError();	WriteResource(theXFileRegions);	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	return 0;}OSErr SDIIUserTimesToOrigTimesMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	short myshort; 			bail = false;			watchcursor(true);	writeLogS((unsigned char *)"Starting SDII timestamp copying");	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) && !bail) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));				if (!copyUserTimeToOrigTime((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);		}		else		{			writeLogS((unsigned char *)"Failed to convert timestamps :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		watchcursor(false);	if (memoryError)		genError("\pSome files could not be processed, consult the SampleSearchª Log for details");	return;}OSErr SDIIUserTimesToOrigTimeExchangeMany(void){	Cell theCell;	short theindex;	Boolean memoryError = false;	short myshort; 			bail = false;				watchcursor(true);	writeLogS((unsigned char *)"Starting SDII timestamp copying");	SetPt( &theCell, 0,0 );		/* start at top of list  */		while ( LGetSelect( TRUE, &theCell, myList) && !bail) 	{		theindex = (theCell.v * DisplayedColumns) + (theCell.h * (DisplayedColumns != 1));		if (!exchangeUserTimeAndOrigTime((*therealResults)[theindex]))		{			writeLog((Ptr)(*therealResults)[theindex].name);		}		else		{			writeLogS((unsigned char *)"Failed to convert timestamps :");			writeLog((Ptr)(*therealResults)[theindex].name);				writeLogS((unsigned char *)"Continuing.....");			memoryError = true;		}		LNextCell( TRUE, TRUE, &theCell, myList ); 	/* advance to next */	}		watchcursor(false);	if (memoryError)		genError("\pSome files could not be processed, consult the SampleSearchª Log for details");	return;}OSErr copyUserTimeToOrigTime (FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow, numRgns;	RgnHandle	theRgn;	short theNumberOfRegions = 0;	RegionRec * myRegions;	Handle myDDRLHandle;	ddRLHeader myHeader;	RegionRec newRgn;	float theRatio, theSt;		Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	short whichRegion;		iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return 0; /* its not an SDII file */ 	} 			iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);	if (!theXFileRegions) /* there are none !!! */	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return 0;	}			lByteCnt = SizeResource(theXFileRegions);	regionCount = (lByteCnt - 18L) / 56L;		if (!regionCount)	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return noErr;	}	for (whichRegion=0;whichRegion<	regionCount;whichRegion++)	{		BlockMove ((*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),&newRgn, sizeof(RegionRec));		newRgn.TimeStampLS = newRgn.TimeStampMS;		BlockMove (&newRgn, (*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),sizeof(RegionRec));	}		ChangedResource(theXFileRegions);	iErr = ResError();	WriteResource(theXFileRegions);	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	return 0;}OSErr exchangeUserTimeAndOrigTime (FSSpec mySpec){	FInfo fndrInfo;	OSErr	iErr;	short fRefNum;	Handle theXFileRegions;	short iRefNum;	long lByteCnt;	short regionCount;	RegionRec tempRegRec;	short z;	FSSpec destFile;	Str255 theNumString;	Cell tempCell;	short iInsRow, numRgns;	RgnHandle	theRgn;	short theNumberOfRegions = 0;	RegionRec * myRegions;	Handle myDDRLHandle;	ddRLHeader myHeader;	RegionRec newRgn;	float theRatio, theSt;		Boolean stereo;	long theBytes,theSize;	long theRate;	short theWordSize;	short whichRegion;	unsigned long temp;	iErr = FSpGetFInfo(&mySpec,&fndrInfo);	if (iErr !=0)	{		return 0;	}			if (getSDIIData (mySpec, &theRate, &theWordSize, &stereo, &theBytes)) 	{		return 0; /* its not an SDII file */ 	} 			iRefNum = CurResFile();		fRefNum = FSpOpenResFile(&mySpec,fsCurPerm);	if (!fRefNum)	{		return 0;	}		UseResFile(fRefNum);		theXFileRegions = Get1Resource('ddRL',1000);	if (!theXFileRegions) /* there are none !!! */	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return 0;	}			lByteCnt = SizeResource(theXFileRegions);	regionCount = (lByteCnt - 18L) / 56L;		if (!regionCount)	{		CloseResFile(fRefNum);		iErr = ResError();		UseResFile(iRefNum);		return noErr;	}	for (whichRegion=0;whichRegion<	regionCount;whichRegion++)	{		BlockMove ((*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),&newRgn, sizeof(RegionRec));		temp = newRgn.TimeStampLS;		newRgn.TimeStampLS = newRgn.TimeStampMS;		newRgn.TimeStampMS = temp;		BlockMove (&newRgn, (*theXFileRegions) + sizeof(ddRLHeader) + (whichRegion * sizeof(RegionRec)),sizeof(RegionRec));	}		ChangedResource(theXFileRegions);	iErr = ResError();	WriteResource(theXFileRegions);	iErr = ResError();	CloseResFile(fRefNum);	iErr = ResError();	UseResFile(iRefNum);	return 0;}